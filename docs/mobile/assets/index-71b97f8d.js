(function(){const F=document.createElement("link").relList;if(F&&F.supports&&F.supports("modulepreload"))return;for(const K of document.querySelectorAll('link[rel="modulepreload"]'))X(K);new MutationObserver(K=>{for(const Q of K)if(Q.type==="childList")for(const Y of Q.addedNodes)Y.tagName==="LINK"&&Y.rel==="modulepreload"&&X(Y)}).observe(document,{childList:!0,subtree:!0});function W(K){const Q={};return K.integrity&&(Q.integrity=K.integrity),K.referrerPolicy&&(Q.referrerPolicy=K.referrerPolicy),K.crossOrigin==="use-credentials"?Q.credentials="include":K.crossOrigin==="anonymous"?Q.credentials="omit":Q.credentials="same-origin",Q}function X(K){if(K.ep)return;K.ep=!0;const Q=W(K);fetch(K.href,Q)}})();const index="";var commonjsGlobal=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */var Reflect$1;(function(it){(function(F){var W=typeof commonjsGlobal=="object"?commonjsGlobal:typeof self=="object"?self:typeof this=="object"?this:Function("return this;")(),X=K(it);typeof W.Reflect>"u"?W.Reflect=it:X=K(W.Reflect,X),F(X);function K(Q,Y){return function(tt,et){typeof Q[tt]!="function"&&Object.defineProperty(Q,tt,{configurable:!0,writable:!0,value:et}),Y&&Y(tt,et)}}})(function(F){var W=Object.prototype.hasOwnProperty,X=typeof Symbol=="function",K=X&&typeof Symbol.toPrimitive<"u"?Symbol.toPrimitive:"@@toPrimitive",Q=X&&typeof Symbol.iterator<"u"?Symbol.iterator:"@@iterator",Y=typeof Object.create=="function",tt={__proto__:[]}instanceof Array,et=!Y&&!tt,q={create:Y?function(){return ge(Object.create(null))}:tt?function(){return ge({__proto__:null})}:function(){return ge({})},has:et?function(At,Pt){return W.call(At,Pt)}:function(At,Pt){return Pt in At},get:et?function(At,Pt){return W.call(At,Pt)?At[Pt]:void 0}:function(At,Pt){return At[Pt]}},G=Object.getPrototypeOf(Function),O=typeof process=="object"&&process.env&&process.env.REFLECT_METADATA_USE_MAP_POLYFILL==="true",b=!O&&typeof Map=="function"&&typeof Map.prototype.entries=="function"?Map:le(),j=!O&&typeof Set=="function"&&typeof Set.prototype.entries=="function"?Set:ve(),U=!O&&typeof WeakMap=="function"?WeakMap:fe(),J=new U;function nt(At,Pt,Ct,Ft){if(Mt(Ct)){if(!se(At))throw new TypeError;if(!ue(Pt))throw new TypeError;return ft(At,Pt)}else{if(!se(At))throw new TypeError;if(!Bt(Pt))throw new TypeError;if(!Bt(Ft)&&!Mt(Ft)&&!qt(Ft))throw new TypeError;return qt(Ft)&&(Ft=void 0),Ct=Wt(Ct),gt(At,Pt,Ct,Ft)}}F("decorate",nt);function rt(At,Pt){function Ct(Ft,zt){if(!Bt(Ft))throw new TypeError;if(!Mt(zt)&&!re(zt))throw new TypeError;xt(At,Pt,Ft,zt)}return Ct}F("metadata",rt);function ot(At,Pt,Ct,Ft){if(!Bt(Ct))throw new TypeError;return Mt(Ft)||(Ft=Wt(Ft)),xt(At,Pt,Ct,Ft)}F("defineMetadata",ot);function at(At,Pt,Ct){if(!Bt(Pt))throw new TypeError;return Mt(Ct)||(Ct=Wt(Ct)),wt(At,Pt,Ct)}F("hasMetadata",at);function ut(At,Pt,Ct){if(!Bt(Pt))throw new TypeError;return Mt(Ct)||(Ct=Wt(Ct)),bt(At,Pt,Ct)}F("hasOwnMetadata",ut);function st(At,Pt,Ct){if(!Bt(Pt))throw new TypeError;return Mt(Ct)||(Ct=Wt(Ct)),Ot(At,Pt,Ct)}F("getMetadata",st);function ct(At,Pt,Ct){if(!Bt(Pt))throw new TypeError;return Mt(Ct)||(Ct=Wt(Ct)),vt(At,Pt,Ct)}F("getOwnMetadata",ct);function dt(At,Pt){if(!Bt(At))throw new TypeError;return Mt(Pt)||(Pt=Wt(Pt)),Rt(At,Pt)}F("getMetadataKeys",dt);function pt(At,Pt){if(!Bt(At))throw new TypeError;return Mt(Pt)||(Pt=Wt(Pt)),kt(At,Pt)}F("getOwnMetadataKeys",pt);function lt(At,Pt,Ct){if(!Bt(Pt))throw new TypeError;Mt(Ct)||(Ct=Wt(Ct));var Ft=_t(Pt,Ct,!1);if(Mt(Ft)||!Ft.delete(At))return!1;if(Ft.size>0)return!0;var zt=J.get(Pt);return zt.delete(Ct),zt.size>0||J.delete(Pt),!0}F("deleteMetadata",lt);function ft(At,Pt){for(var Ct=At.length-1;Ct>=0;--Ct){var Ft=At[Ct],zt=Ft(Pt);if(!Mt(zt)&&!qt(zt)){if(!ue(zt))throw new TypeError;Pt=zt}}return Pt}function gt(At,Pt,Ct,Ft){for(var zt=At.length-1;zt>=0;--zt){var he=At[zt],Kt=he(Pt,Ct,Ft);if(!Mt(Kt)&&!qt(Kt)){if(!Bt(Kt))throw new TypeError;Ft=Kt}}return Ft}function _t(At,Pt,Ct){var Ft=J.get(At);if(Mt(Ft)){if(!Ct)return;Ft=new b,J.set(At,Ft)}var zt=Ft.get(Pt);if(Mt(zt)){if(!Ct)return;zt=new b,Ft.set(Pt,zt)}return zt}function wt(At,Pt,Ct){var Ft=bt(At,Pt,Ct);if(Ft)return!0;var zt=Ee(Pt);return qt(zt)?!1:wt(At,zt,Ct)}function bt(At,Pt,Ct){var Ft=_t(Pt,Ct,!1);return Mt(Ft)?!1:Yt(Ft.has(At))}function Ot(At,Pt,Ct){var Ft=bt(At,Pt,Ct);if(Ft)return vt(At,Pt,Ct);var zt=Ee(Pt);if(!qt(zt))return Ot(At,zt,Ct)}function vt(At,Pt,Ct){var Ft=_t(Pt,Ct,!1);if(!Mt(Ft))return Ft.get(At)}function xt(At,Pt,Ct,Ft){var zt=_t(Ct,Ft,!0);zt.set(At,Pt)}function Rt(At,Pt){var Ct=kt(At,Pt),Ft=Ee(At);if(Ft===null)return Ct;var zt=Rt(Ft,Pt);if(zt.length<=0)return Ct;if(Ct.length<=0)return zt;for(var he=new j,Kt=[],Xt=0,Nt=Ct;Xt<Nt.length;Xt++){var yt=Nt[Xt],St=he.has(yt);St||(he.add(yt),Kt.push(yt))}for(var Dt=0,Lt=zt;Dt<Lt.length;Dt++){var yt=Lt[Dt],St=he.has(yt);St||(he.add(yt),Kt.push(yt))}return Kt}function kt(At,Pt){var Ct=[],Ft=_t(At,Pt,!1);if(Mt(Ft))return Ct;for(var zt=Ft.keys(),he=ye(zt),Kt=0;;){var Xt=Oe(he);if(!Xt)return Ct.length=Kt,Ct;var Nt=Ae(Xt);try{Ct[Kt]=Nt}catch(yt){try{Ie(he)}finally{throw yt}}Kt++}}function Ht(At){if(At===null)return 1;switch(typeof At){case"undefined":return 0;case"boolean":return 2;case"string":return 3;case"symbol":return 4;case"number":return 5;case"object":return At===null?1:6;default:return 6}}function Mt(At){return At===void 0}function qt(At){return At===null}function Jt(At){return typeof At=="symbol"}function Bt(At){return typeof At=="object"?At!==null:typeof At=="function"}function ee(At,Pt){switch(Ht(At)){case 0:return At;case 1:return At;case 2:return At;case 3:return At;case 4:return At;case 5:return At}var Ct=Pt===3?"string":Pt===5?"number":"default",Ft=pe(At,K);if(Ft!==void 0){var zt=Ft.call(At,Ct);if(Bt(zt))throw new TypeError;return zt}return ne(At,Ct==="default"?"number":Ct)}function ne(At,Pt){if(Pt==="string"){var Ct=At.toString;if(Zt(Ct)){var Ft=Ct.call(At);if(!Bt(Ft))return Ft}var zt=At.valueOf;if(Zt(zt)){var Ft=zt.call(At);if(!Bt(Ft))return Ft}}else{var zt=At.valueOf;if(Zt(zt)){var Ft=zt.call(At);if(!Bt(Ft))return Ft}var he=At.toString;if(Zt(he)){var Ft=he.call(At);if(!Bt(Ft))return Ft}}throw new TypeError}function Yt(At){return!!At}function ae(At){return""+At}function Wt(At){var Pt=ee(At,3);return Jt(Pt)?Pt:ae(Pt)}function se(At){return Array.isArray?Array.isArray(At):At instanceof Object?At instanceof Array:Object.prototype.toString.call(At)==="[object Array]"}function Zt(At){return typeof At=="function"}function ue(At){return typeof At=="function"}function re(At){switch(Ht(At)){case 3:return!0;case 4:return!0;default:return!1}}function pe(At,Pt){var Ct=At[Pt];if(Ct!=null){if(!Zt(Ct))throw new TypeError;return Ct}}function ye(At){var Pt=pe(At,Q);if(!Zt(Pt))throw new TypeError;var Ct=Pt.call(At);if(!Bt(Ct))throw new TypeError;return Ct}function Ae(At){return At.value}function Oe(At){var Pt=At.next();return Pt.done?!1:Pt}function Ie(At){var Pt=At.return;Pt&&Pt.call(At)}function Ee(At){var Pt=Object.getPrototypeOf(At);if(typeof At!="function"||At===G||Pt!==G)return Pt;var Ct=At.prototype,Ft=Ct&&Object.getPrototypeOf(Ct);if(Ft==null||Ft===Object.prototype)return Pt;var zt=Ft.constructor;return typeof zt!="function"||zt===At?Pt:zt}function le(){var At={},Pt=[],Ct=function(){function Kt(Xt,Nt,yt){this._index=0,this._keys=Xt,this._values=Nt,this._selector=yt}return Kt.prototype["@@iterator"]=function(){return this},Kt.prototype[Q]=function(){return this},Kt.prototype.next=function(){var Xt=this._index;if(Xt>=0&&Xt<this._keys.length){var Nt=this._selector(this._keys[Xt],this._values[Xt]);return Xt+1>=this._keys.length?(this._index=-1,this._keys=Pt,this._values=Pt):this._index++,{value:Nt,done:!1}}return{value:void 0,done:!0}},Kt.prototype.throw=function(Xt){throw this._index>=0&&(this._index=-1,this._keys=Pt,this._values=Pt),Xt},Kt.prototype.return=function(Xt){return this._index>=0&&(this._index=-1,this._keys=Pt,this._values=Pt),{value:Xt,done:!0}},Kt}();return function(){function Kt(){this._keys=[],this._values=[],this._cacheKey=At,this._cacheIndex=-2}return Object.defineProperty(Kt.prototype,"size",{get:function(){return this._keys.length},enumerable:!0,configurable:!0}),Kt.prototype.has=function(Xt){return this._find(Xt,!1)>=0},Kt.prototype.get=function(Xt){var Nt=this._find(Xt,!1);return Nt>=0?this._values[Nt]:void 0},Kt.prototype.set=function(Xt,Nt){var yt=this._find(Xt,!0);return this._values[yt]=Nt,this},Kt.prototype.delete=function(Xt){var Nt=this._find(Xt,!1);if(Nt>=0){for(var yt=this._keys.length,St=Nt+1;St<yt;St++)this._keys[St-1]=this._keys[St],this._values[St-1]=this._values[St];return this._keys.length--,this._values.length--,Xt===this._cacheKey&&(this._cacheKey=At,this._cacheIndex=-2),!0}return!1},Kt.prototype.clear=function(){this._keys.length=0,this._values.length=0,this._cacheKey=At,this._cacheIndex=-2},Kt.prototype.keys=function(){return new Ct(this._keys,this._values,Ft)},Kt.prototype.values=function(){return new Ct(this._keys,this._values,zt)},Kt.prototype.entries=function(){return new Ct(this._keys,this._values,he)},Kt.prototype["@@iterator"]=function(){return this.entries()},Kt.prototype[Q]=function(){return this.entries()},Kt.prototype._find=function(Xt,Nt){return this._cacheKey!==Xt&&(this._cacheIndex=this._keys.indexOf(this._cacheKey=Xt)),this._cacheIndex<0&&Nt&&(this._cacheIndex=this._keys.length,this._keys.push(Xt),this._values.push(void 0)),this._cacheIndex},Kt}();function Ft(Kt,Xt){return Kt}function zt(Kt,Xt){return Xt}function he(Kt,Xt){return[Kt,Xt]}}function ve(){return function(){function At(){this._map=new b}return Object.defineProperty(At.prototype,"size",{get:function(){return this._map.size},enumerable:!0,configurable:!0}),At.prototype.has=function(Pt){return this._map.has(Pt)},At.prototype.add=function(Pt){return this._map.set(Pt,Pt),this},At.prototype.delete=function(Pt){return this._map.delete(Pt)},At.prototype.clear=function(){this._map.clear()},At.prototype.keys=function(){return this._map.keys()},At.prototype.values=function(){return this._map.values()},At.prototype.entries=function(){return this._map.entries()},At.prototype["@@iterator"]=function(){return this.keys()},At.prototype[Q]=function(){return this.keys()},At}()}function fe(){var At=16,Pt=q.create(),Ct=Ft();return function(){function Nt(){this._key=Ft()}return Nt.prototype.has=function(yt){var St=zt(yt,!1);return St!==void 0?q.has(St,this._key):!1},Nt.prototype.get=function(yt){var St=zt(yt,!1);return St!==void 0?q.get(St,this._key):void 0},Nt.prototype.set=function(yt,St){var Dt=zt(yt,!0);return Dt[this._key]=St,this},Nt.prototype.delete=function(yt){var St=zt(yt,!1);return St!==void 0?delete St[this._key]:!1},Nt.prototype.clear=function(){this._key=Ft()},Nt}();function Ft(){var Nt;do Nt="@@WeakMap@@"+Xt();while(q.has(Pt,Nt));return Pt[Nt]=!0,Nt}function zt(Nt,yt){if(!W.call(Nt,Ct)){if(!yt)return;Object.defineProperty(Nt,Ct,{value:q.create()})}return Nt[Ct]}function he(Nt,yt){for(var St=0;St<yt;++St)Nt[St]=Math.random()*255|0;return Nt}function Kt(Nt){return typeof Uint8Array=="function"?typeof crypto<"u"?crypto.getRandomValues(new Uint8Array(Nt)):typeof msCrypto<"u"?msCrypto.getRandomValues(new Uint8Array(Nt)):he(new Uint8Array(Nt),Nt):he(new Array(Nt),Nt)}function Xt(){var Nt=Kt(At);Nt[6]=Nt[6]&79|64,Nt[8]=Nt[8]&191|128;for(var yt="",St=0;St<At;++St){var Dt=Nt[St];(St===4||St===6||St===8)&&(yt+="-"),Dt<16&&(yt+="0"),yt+=Dt.toString(16).toLowerCase()}return yt}}function ge(At){return At.__=void 0,delete At.__,At}})})(Reflect$1||(Reflect$1={}));/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const t$2=window,e$4=t$2.ShadowRoot&&(t$2.ShadyCSS===void 0||t$2.ShadyCSS.nativeShadow)&&"adoptedStyleSheets"in Document.prototype&&"replace"in CSSStyleSheet.prototype,s$3=Symbol(),n$5=new WeakMap;let o$4=class{constructor(F,W,X){if(this._$cssResult$=!0,X!==s$3)throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");this.cssText=F,this.t=W}get styleSheet(){let F=this.o;const W=this.t;if(e$4&&F===void 0){const X=W!==void 0&&W.length===1;X&&(F=n$5.get(W)),F===void 0&&((this.o=F=new CSSStyleSheet).replaceSync(this.cssText),X&&n$5.set(W,F))}return F}toString(){return this.cssText}};const r$2=it=>new o$4(typeof it=="string"?it:it+"",void 0,s$3),i$3=(it,...F)=>{const W=it.length===1?it[0]:F.reduce((X,K,Q)=>X+(Y=>{if(Y._$cssResult$===!0)return Y.cssText;if(typeof Y=="number")return Y;throw Error("Value passed to 'css' function must be a 'css' function result: "+Y+". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.")})(K)+it[Q+1],it[0]);return new o$4(W,it,s$3)},S$1=(it,F)=>{e$4?it.adoptedStyleSheets=F.map(W=>W instanceof CSSStyleSheet?W:W.styleSheet):F.forEach(W=>{const X=document.createElement("style"),K=t$2.litNonce;K!==void 0&&X.setAttribute("nonce",K),X.textContent=W.cssText,it.appendChild(X)})},c$1=e$4?it=>it:it=>it instanceof CSSStyleSheet?(F=>{let W="";for(const X of F.cssRules)W+=X.cssText;return r$2(W)})(it):it;/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */var s$2;const e$3=window,r$1=e$3.trustedTypes,h$1=r$1?r$1.emptyScript:"",o$3=e$3.reactiveElementPolyfillSupport,n$4={toAttribute(it,F){switch(F){case Boolean:it=it?h$1:null;break;case Object:case Array:it=it==null?it:JSON.stringify(it)}return it},fromAttribute(it,F){let W=it;switch(F){case Boolean:W=it!==null;break;case Number:W=it===null?null:Number(it);break;case Object:case Array:try{W=JSON.parse(it)}catch{W=null}}return W}},a$1=(it,F)=>F!==it&&(F==F||it==it),l$2={attribute:!0,type:String,converter:n$4,reflect:!1,hasChanged:a$1},d$1="finalized";let u$1=class extends HTMLElement{constructor(){super(),this._$Ei=new Map,this.isUpdatePending=!1,this.hasUpdated=!1,this._$El=null,this._$Eu()}static addInitializer(F){var W;this.finalize(),((W=this.h)!==null&&W!==void 0?W:this.h=[]).push(F)}static get observedAttributes(){this.finalize();const F=[];return this.elementProperties.forEach((W,X)=>{const K=this._$Ep(X,W);K!==void 0&&(this._$Ev.set(K,X),F.push(K))}),F}static createProperty(F,W=l$2){if(W.state&&(W.attribute=!1),this.finalize(),this.elementProperties.set(F,W),!W.noAccessor&&!this.prototype.hasOwnProperty(F)){const X=typeof F=="symbol"?Symbol():"__"+F,K=this.getPropertyDescriptor(F,X,W);K!==void 0&&Object.defineProperty(this.prototype,F,K)}}static getPropertyDescriptor(F,W,X){return{get(){return this[W]},set(K){const Q=this[F];this[W]=K,this.requestUpdate(F,Q,X)},configurable:!0,enumerable:!0}}static getPropertyOptions(F){return this.elementProperties.get(F)||l$2}static finalize(){if(this.hasOwnProperty(d$1))return!1;this[d$1]=!0;const F=Object.getPrototypeOf(this);if(F.finalize(),F.h!==void 0&&(this.h=[...F.h]),this.elementProperties=new Map(F.elementProperties),this._$Ev=new Map,this.hasOwnProperty("properties")){const W=this.properties,X=[...Object.getOwnPropertyNames(W),...Object.getOwnPropertySymbols(W)];for(const K of X)this.createProperty(K,W[K])}return this.elementStyles=this.finalizeStyles(this.styles),!0}static finalizeStyles(F){const W=[];if(Array.isArray(F)){const X=new Set(F.flat(1/0).reverse());for(const K of X)W.unshift(c$1(K))}else F!==void 0&&W.push(c$1(F));return W}static _$Ep(F,W){const X=W.attribute;return X===!1?void 0:typeof X=="string"?X:typeof F=="string"?F.toLowerCase():void 0}_$Eu(){var F;this._$E_=new Promise(W=>this.enableUpdating=W),this._$AL=new Map,this._$Eg(),this.requestUpdate(),(F=this.constructor.h)===null||F===void 0||F.forEach(W=>W(this))}addController(F){var W,X;((W=this._$ES)!==null&&W!==void 0?W:this._$ES=[]).push(F),this.renderRoot!==void 0&&this.isConnected&&((X=F.hostConnected)===null||X===void 0||X.call(F))}removeController(F){var W;(W=this._$ES)===null||W===void 0||W.splice(this._$ES.indexOf(F)>>>0,1)}_$Eg(){this.constructor.elementProperties.forEach((F,W)=>{this.hasOwnProperty(W)&&(this._$Ei.set(W,this[W]),delete this[W])})}createRenderRoot(){var F;const W=(F=this.shadowRoot)!==null&&F!==void 0?F:this.attachShadow(this.constructor.shadowRootOptions);return S$1(W,this.constructor.elementStyles),W}connectedCallback(){var F;this.renderRoot===void 0&&(this.renderRoot=this.createRenderRoot()),this.enableUpdating(!0),(F=this._$ES)===null||F===void 0||F.forEach(W=>{var X;return(X=W.hostConnected)===null||X===void 0?void 0:X.call(W)})}enableUpdating(F){}disconnectedCallback(){var F;(F=this._$ES)===null||F===void 0||F.forEach(W=>{var X;return(X=W.hostDisconnected)===null||X===void 0?void 0:X.call(W)})}attributeChangedCallback(F,W,X){this._$AK(F,X)}_$EO(F,W,X=l$2){var K;const Q=this.constructor._$Ep(F,X);if(Q!==void 0&&X.reflect===!0){const Y=(((K=X.converter)===null||K===void 0?void 0:K.toAttribute)!==void 0?X.converter:n$4).toAttribute(W,X.type);this._$El=F,Y==null?this.removeAttribute(Q):this.setAttribute(Q,Y),this._$El=null}}_$AK(F,W){var X;const K=this.constructor,Q=K._$Ev.get(F);if(Q!==void 0&&this._$El!==Q){const Y=K.getPropertyOptions(Q),tt=typeof Y.converter=="function"?{fromAttribute:Y.converter}:((X=Y.converter)===null||X===void 0?void 0:X.fromAttribute)!==void 0?Y.converter:n$4;this._$El=Q,this[Q]=tt.fromAttribute(W,Y.type),this._$El=null}}requestUpdate(F,W,X){let K=!0;F!==void 0&&(((X=X||this.constructor.getPropertyOptions(F)).hasChanged||a$1)(this[F],W)?(this._$AL.has(F)||this._$AL.set(F,W),X.reflect===!0&&this._$El!==F&&(this._$EC===void 0&&(this._$EC=new Map),this._$EC.set(F,X))):K=!1),!this.isUpdatePending&&K&&(this._$E_=this._$Ej())}async _$Ej(){this.isUpdatePending=!0;try{await this._$E_}catch(W){Promise.reject(W)}const F=this.scheduleUpdate();return F!=null&&await F,!this.isUpdatePending}scheduleUpdate(){return this.performUpdate()}performUpdate(){var F;if(!this.isUpdatePending)return;this.hasUpdated,this._$Ei&&(this._$Ei.forEach((K,Q)=>this[Q]=K),this._$Ei=void 0);let W=!1;const X=this._$AL;try{W=this.shouldUpdate(X),W?(this.willUpdate(X),(F=this._$ES)===null||F===void 0||F.forEach(K=>{var Q;return(Q=K.hostUpdate)===null||Q===void 0?void 0:Q.call(K)}),this.update(X)):this._$Ek()}catch(K){throw W=!1,this._$Ek(),K}W&&this._$AE(X)}willUpdate(F){}_$AE(F){var W;(W=this._$ES)===null||W===void 0||W.forEach(X=>{var K;return(K=X.hostUpdated)===null||K===void 0?void 0:K.call(X)}),this.hasUpdated||(this.hasUpdated=!0,this.firstUpdated(F)),this.updated(F)}_$Ek(){this._$AL=new Map,this.isUpdatePending=!1}get updateComplete(){return this.getUpdateComplete()}getUpdateComplete(){return this._$E_}shouldUpdate(F){return!0}update(F){this._$EC!==void 0&&(this._$EC.forEach((W,X)=>this._$EO(X,this[X],W)),this._$EC=void 0),this._$Ek()}updated(F){}firstUpdated(F){}};u$1[d$1]=!0,u$1.elementProperties=new Map,u$1.elementStyles=[],u$1.shadowRootOptions={mode:"open"},o$3==null||o$3({ReactiveElement:u$1}),((s$2=e$3.reactiveElementVersions)!==null&&s$2!==void 0?s$2:e$3.reactiveElementVersions=[]).push("1.6.3");/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */var t$1;const i$2=window,s$1=i$2.trustedTypes,e$2=s$1?s$1.createPolicy("lit-html",{createHTML:it=>it}):void 0,o$2="$lit$",n$3=`lit$${(Math.random()+"").slice(9)}$`,l$1="?"+n$3,h=`<${l$1}>`,r=document,u=()=>r.createComment(""),d=it=>it===null||typeof it!="object"&&typeof it!="function",c=Array.isArray,v=it=>c(it)||typeof(it==null?void 0:it[Symbol.iterator])=="function",a=`[ 	
\f\r]`,f=/<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,_=/-->/g,m=/>/g,p=RegExp(`>|${a}(?:([^\\s"'>=/]+)(${a}*=${a}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`,"g"),g=/'/g,$=/"/g,y=/^(?:script|style|textarea|title)$/i,w=it=>(F,...W)=>({_$litType$:it,strings:F,values:W}),x=w(1),T=Symbol.for("lit-noChange"),A=Symbol.for("lit-nothing"),E=new WeakMap,C=r.createTreeWalker(r,129,null,!1);function P(it,F){if(!Array.isArray(it)||!it.hasOwnProperty("raw"))throw Error("invalid template strings array");return e$2!==void 0?e$2.createHTML(F):F}const V=(it,F)=>{const W=it.length-1,X=[];let K,Q=F===2?"<svg>":"",Y=f;for(let tt=0;tt<W;tt++){const et=it[tt];let q,G,O=-1,b=0;for(;b<et.length&&(Y.lastIndex=b,G=Y.exec(et),G!==null);)b=Y.lastIndex,Y===f?G[1]==="!--"?Y=_:G[1]!==void 0?Y=m:G[2]!==void 0?(y.test(G[2])&&(K=RegExp("</"+G[2],"g")),Y=p):G[3]!==void 0&&(Y=p):Y===p?G[0]===">"?(Y=K??f,O=-1):G[1]===void 0?O=-2:(O=Y.lastIndex-G[2].length,q=G[1],Y=G[3]===void 0?p:G[3]==='"'?$:g):Y===$||Y===g?Y=p:Y===_||Y===m?Y=f:(Y=p,K=void 0);const j=Y===p&&it[tt+1].startsWith("/>")?" ":"";Q+=Y===f?et+h:O>=0?(X.push(q),et.slice(0,O)+o$2+et.slice(O)+n$3+j):et+n$3+(O===-2?(X.push(void 0),tt):j)}return[P(it,Q+(it[W]||"<?>")+(F===2?"</svg>":"")),X]};class N{constructor({strings:F,_$litType$:W},X){let K;this.parts=[];let Q=0,Y=0;const tt=F.length-1,et=this.parts,[q,G]=V(F,W);if(this.el=N.createElement(q,X),C.currentNode=this.el.content,W===2){const O=this.el.content,b=O.firstChild;b.remove(),O.append(...b.childNodes)}for(;(K=C.nextNode())!==null&&et.length<tt;){if(K.nodeType===1){if(K.hasAttributes()){const O=[];for(const b of K.getAttributeNames())if(b.endsWith(o$2)||b.startsWith(n$3)){const j=G[Y++];if(O.push(b),j!==void 0){const U=K.getAttribute(j.toLowerCase()+o$2).split(n$3),J=/([.?@])?(.*)/.exec(j);et.push({type:1,index:Q,name:J[2],strings:U,ctor:J[1]==="."?H:J[1]==="?"?L:J[1]==="@"?z:k})}else et.push({type:6,index:Q})}for(const b of O)K.removeAttribute(b)}if(y.test(K.tagName)){const O=K.textContent.split(n$3),b=O.length-1;if(b>0){K.textContent=s$1?s$1.emptyScript:"";for(let j=0;j<b;j++)K.append(O[j],u()),C.nextNode(),et.push({type:2,index:++Q});K.append(O[b],u())}}}else if(K.nodeType===8)if(K.data===l$1)et.push({type:2,index:Q});else{let O=-1;for(;(O=K.data.indexOf(n$3,O+1))!==-1;)et.push({type:7,index:Q}),O+=n$3.length-1}Q++}}static createElement(F,W){const X=r.createElement("template");return X.innerHTML=F,X}}function S(it,F,W=it,X){var K,Q,Y,tt;if(F===T)return F;let et=X!==void 0?(K=W._$Co)===null||K===void 0?void 0:K[X]:W._$Cl;const q=d(F)?void 0:F._$litDirective$;return(et==null?void 0:et.constructor)!==q&&((Q=et==null?void 0:et._$AO)===null||Q===void 0||Q.call(et,!1),q===void 0?et=void 0:(et=new q(it),et._$AT(it,W,X)),X!==void 0?((Y=(tt=W)._$Co)!==null&&Y!==void 0?Y:tt._$Co=[])[X]=et:W._$Cl=et),et!==void 0&&(F=S(it,et._$AS(it,F.values),et,X)),F}class M{constructor(F,W){this._$AV=[],this._$AN=void 0,this._$AD=F,this._$AM=W}get parentNode(){return this._$AM.parentNode}get _$AU(){return this._$AM._$AU}u(F){var W;const{el:{content:X},parts:K}=this._$AD,Q=((W=F==null?void 0:F.creationScope)!==null&&W!==void 0?W:r).importNode(X,!0);C.currentNode=Q;let Y=C.nextNode(),tt=0,et=0,q=K[0];for(;q!==void 0;){if(tt===q.index){let G;q.type===2?G=new R(Y,Y.nextSibling,this,F):q.type===1?G=new q.ctor(Y,q.name,q.strings,this,F):q.type===6&&(G=new Z(Y,this,F)),this._$AV.push(G),q=K[++et]}tt!==(q==null?void 0:q.index)&&(Y=C.nextNode(),tt++)}return C.currentNode=r,Q}v(F){let W=0;for(const X of this._$AV)X!==void 0&&(X.strings!==void 0?(X._$AI(F,X,W),W+=X.strings.length-2):X._$AI(F[W])),W++}}class R{constructor(F,W,X,K){var Q;this.type=2,this._$AH=A,this._$AN=void 0,this._$AA=F,this._$AB=W,this._$AM=X,this.options=K,this._$Cp=(Q=K==null?void 0:K.isConnected)===null||Q===void 0||Q}get _$AU(){var F,W;return(W=(F=this._$AM)===null||F===void 0?void 0:F._$AU)!==null&&W!==void 0?W:this._$Cp}get parentNode(){let F=this._$AA.parentNode;const W=this._$AM;return W!==void 0&&(F==null?void 0:F.nodeType)===11&&(F=W.parentNode),F}get startNode(){return this._$AA}get endNode(){return this._$AB}_$AI(F,W=this){F=S(this,F,W),d(F)?F===A||F==null||F===""?(this._$AH!==A&&this._$AR(),this._$AH=A):F!==this._$AH&&F!==T&&this._(F):F._$litType$!==void 0?this.g(F):F.nodeType!==void 0?this.$(F):v(F)?this.T(F):this._(F)}k(F){return this._$AA.parentNode.insertBefore(F,this._$AB)}$(F){this._$AH!==F&&(this._$AR(),this._$AH=this.k(F))}_(F){this._$AH!==A&&d(this._$AH)?this._$AA.nextSibling.data=F:this.$(r.createTextNode(F)),this._$AH=F}g(F){var W;const{values:X,_$litType$:K}=F,Q=typeof K=="number"?this._$AC(F):(K.el===void 0&&(K.el=N.createElement(P(K.h,K.h[0]),this.options)),K);if(((W=this._$AH)===null||W===void 0?void 0:W._$AD)===Q)this._$AH.v(X);else{const Y=new M(Q,this),tt=Y.u(this.options);Y.v(X),this.$(tt),this._$AH=Y}}_$AC(F){let W=E.get(F.strings);return W===void 0&&E.set(F.strings,W=new N(F)),W}T(F){c(this._$AH)||(this._$AH=[],this._$AR());const W=this._$AH;let X,K=0;for(const Q of F)K===W.length?W.push(X=new R(this.k(u()),this.k(u()),this,this.options)):X=W[K],X._$AI(Q),K++;K<W.length&&(this._$AR(X&&X._$AB.nextSibling,K),W.length=K)}_$AR(F=this._$AA.nextSibling,W){var X;for((X=this._$AP)===null||X===void 0||X.call(this,!1,!0,W);F&&F!==this._$AB;){const K=F.nextSibling;F.remove(),F=K}}setConnected(F){var W;this._$AM===void 0&&(this._$Cp=F,(W=this._$AP)===null||W===void 0||W.call(this,F))}}class k{constructor(F,W,X,K,Q){this.type=1,this._$AH=A,this._$AN=void 0,this.element=F,this.name=W,this._$AM=K,this.options=Q,X.length>2||X[0]!==""||X[1]!==""?(this._$AH=Array(X.length-1).fill(new String),this.strings=X):this._$AH=A}get tagName(){return this.element.tagName}get _$AU(){return this._$AM._$AU}_$AI(F,W=this,X,K){const Q=this.strings;let Y=!1;if(Q===void 0)F=S(this,F,W,0),Y=!d(F)||F!==this._$AH&&F!==T,Y&&(this._$AH=F);else{const tt=F;let et,q;for(F=Q[0],et=0;et<Q.length-1;et++)q=S(this,tt[X+et],W,et),q===T&&(q=this._$AH[et]),Y||(Y=!d(q)||q!==this._$AH[et]),q===A?F=A:F!==A&&(F+=(q??"")+Q[et+1]),this._$AH[et]=q}Y&&!K&&this.j(F)}j(F){F===A?this.element.removeAttribute(this.name):this.element.setAttribute(this.name,F??"")}}class H extends k{constructor(){super(...arguments),this.type=3}j(F){this.element[this.name]=F===A?void 0:F}}const I=s$1?s$1.emptyScript:"";class L extends k{constructor(){super(...arguments),this.type=4}j(F){F&&F!==A?this.element.setAttribute(this.name,I):this.element.removeAttribute(this.name)}}class z extends k{constructor(F,W,X,K,Q){super(F,W,X,K,Q),this.type=5}_$AI(F,W=this){var X;if((F=(X=S(this,F,W,0))!==null&&X!==void 0?X:A)===T)return;const K=this._$AH,Q=F===A&&K!==A||F.capture!==K.capture||F.once!==K.once||F.passive!==K.passive,Y=F!==A&&(K===A||Q);Q&&this.element.removeEventListener(this.name,this,K),Y&&this.element.addEventListener(this.name,this,F),this._$AH=F}handleEvent(F){var W,X;typeof this._$AH=="function"?this._$AH.call((X=(W=this.options)===null||W===void 0?void 0:W.host)!==null&&X!==void 0?X:this.element,F):this._$AH.handleEvent(F)}}class Z{constructor(F,W,X){this.element=F,this.type=6,this._$AN=void 0,this._$AM=W,this.options=X}get _$AU(){return this._$AM._$AU}_$AI(F){S(this,F)}}const B=i$2.litHtmlPolyfillSupport;B==null||B(N,R),((t$1=i$2.litHtmlVersions)!==null&&t$1!==void 0?t$1:i$2.litHtmlVersions=[]).push("2.8.0");const D=(it,F,W)=>{var X,K;const Q=(X=W==null?void 0:W.renderBefore)!==null&&X!==void 0?X:F;let Y=Q._$litPart$;if(Y===void 0){const tt=(K=W==null?void 0:W.renderBefore)!==null&&K!==void 0?K:null;Q._$litPart$=Y=new R(F.insertBefore(u(),tt),tt,void 0,W??{})}return Y._$AI(it),Y};/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */var l,o$1;class s extends u$1{constructor(){super(...arguments),this.renderOptions={host:this},this._$Do=void 0}createRenderRoot(){var F,W;const X=super.createRenderRoot();return(F=(W=this.renderOptions).renderBefore)!==null&&F!==void 0||(W.renderBefore=X.firstChild),X}update(F){const W=this.render();this.hasUpdated||(this.renderOptions.isConnected=this.isConnected),super.update(F),this._$Do=D(W,this.renderRoot,this.renderOptions)}connectedCallback(){var F;super.connectedCallback(),(F=this._$Do)===null||F===void 0||F.setConnected(!0)}disconnectedCallback(){var F;super.disconnectedCallback(),(F=this._$Do)===null||F===void 0||F.setConnected(!1)}render(){return T}}s.finalized=!0,s._$litElement$=!0,(l=globalThis.litElementHydrateSupport)===null||l===void 0||l.call(globalThis,{LitElement:s});const n$2=globalThis.litElementPolyfillSupport;n$2==null||n$2({LitElement:s});((o$1=globalThis.litElementVersions)!==null&&o$1!==void 0?o$1:globalThis.litElementVersions=[]).push("3.3.3");/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const e$1=it=>F=>typeof F=="function"?((W,X)=>(customElements.define(W,X),X))(it,F):((W,X)=>{const{kind:K,elements:Q}=X;return{kind:K,elements:Q,finisher(Y){customElements.define(W,Y)}}})(it,F);/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const i$1=(it,F)=>F.kind==="method"&&F.descriptor&&!("value"in F.descriptor)?{...F,finisher(W){W.createProperty(F.key,it)}}:{kind:"field",key:Symbol(),placement:"own",descriptor:{},originalKey:F.key,initializer(){typeof F.initializer=="function"&&(this[F.key]=F.initializer.call(this))},finisher(W){W.createProperty(F.key,it)}},e=(it,F,W)=>{F.constructor.createProperty(W,it)};function n$1(it){return(F,W)=>W!==void 0?e(it,F,W):i$1(it,F)}/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */function t(it){return n$1({...it,state:!0})}/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const o=({finisher:it,descriptor:F})=>(W,X)=>{var K;if(X===void 0){const Q=(K=W.originalKey)!==null&&K!==void 0?K:W.key,Y=F!=null?{kind:"method",placement:"prototype",key:Q,descriptor:F(W.key)}:{...W,key:Q};return it!=null&&(Y.finisher=function(tt){it(tt,Q)}),Y}{const Q=W.constructor;F!==void 0&&Object.defineProperty(W,X,F(X)),it==null||it(Q,X)}};/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */function i(it,F){return o({descriptor:W=>{const X={get(){var K,Q;return(Q=(K=this.renderRoot)===null||K===void 0?void 0:K.querySelector(it))!==null&&Q!==void 0?Q:null},enumerable:!0,configurable:!0};if(F){const K=typeof W=="symbol"?Symbol():"__"+W;X.get=function(){var Q,Y;return this[K]===void 0&&(this[K]=(Y=(Q=this.renderRoot)===null||Q===void 0?void 0:Q.querySelector(it))!==null&&Y!==void 0?Y:null),this[K]}}return X}})}/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */var n;((n=window.HTMLSlotElement)===null||n===void 0?void 0:n.prototype.assignedElements)!=null;var __defProp$j=Object.defineProperty,__getOwnPropDesc$j=Object.getOwnPropertyDescriptor,__decorateClass$j=(it,F,W,X)=>{for(var K=X>1?void 0:X?__getOwnPropDesc$j(F,W):F,Q=it.length-1,Y;Q>=0;Q--)(Y=it[Q])&&(K=(X?Y(F,W,K):Y(K))||K);return X&&K&&__defProp$j(F,W,K),K};let Avatar=class extends s{constructor(){super(...arguments),this.isMenuOpen=!1}render(){return x`
            ${this.renderIcon()}
            ${this.renderMenu()}
        `}renderIcon(){var it,F;return this.picture?x`
                <img
                    title="${this.firstName} ${this.lastName}"
                    src=${this.picture}
                    @click=${this.handleClickIcon}
                />
            `:x`
            <p
                title="${this.firstName} ${this.lastName}"
                @click=${this.handleClickIcon}
            >
                ${(it=this.firstName)==null?void 0:it.at(0)}${(F=this.lastName)==null?void 0:F.at(0)}
            </p>
        `}renderMenu(){if(this.isMenuOpen)return x`
                <div class="menu">
                    <a @click=${this.handleLogout}>
                        Logout
                    </a>
                </div>
            `}handleClickIcon(){this.isMenuOpen=!this.isMenuOpen}handleLogout(){const it=new CustomEvent("wli-logout",{bubbles:!0,composed:!0});this.dispatchEvent(it)}};Avatar.styles=i$3`
        :host {
            display: block;
            position: relative;
            width: 32px;
            height: 32px;
            border: 2px solid var(--wli-primary);
            background: var(--wli-primary);
            border-radius: 18px;
        }

        img {
            cursor: pointer;
            width: 32px;
            height: 32px;
            border-radius: 16px;
        }

        p {
            cursor: pointer;
            margin: 0;
            line-height: 32px;
            text-align: center;
            font-size: 16px;
            text-transform: uppercase;
        }

        .menu {
            position: absolute;
            color: #000000;
            background: #FFFFFF;
            right: -20px;
            top: 60px;
            width: 150px;
            border-radius: 2px;
            padding: 12px;
            box-shadow: 0px 8px 10px 1px rgba(0,0,0,.14), 0px 3px 14px 2px rgba(0,0,0,.12), 0px 5px 5px -3px rgba(0,0,0,.2);
            z-index: 1;
        }

        .menu::after {
            content: ' ';
            position: absolute;
            width: 18px;
            height: 18px;
            background: #FFFFFF;
            transform: rotate(45deg);
            top: -9px;
            right: 25px;
        }

        a {
            display: block;
            cursor: pointer;
            padding: 4px 6px;
        }

        a:hover,
        a:focus {
            background: #DEE2E6;
        }
    `;__decorateClass$j([n$1({type:String,attribute:"first-name"})],Avatar.prototype,"firstName",2);__decorateClass$j([n$1({type:String,attribute:"last-name"})],Avatar.prototype,"lastName",2);__decorateClass$j([n$1({type:String,attribute:!0})],Avatar.prototype,"picture",2);__decorateClass$j([t()],Avatar.prototype,"isMenuOpen",2);Avatar=__decorateClass$j([e$1("wli-avatar")],Avatar);var __defProp$i=Object.defineProperty,__getOwnPropDesc$i=Object.getOwnPropertyDescriptor,__decorateClass$i=(it,F,W,X)=>{for(var K=X>1?void 0:X?__getOwnPropDesc$i(F,W):F,Q=it.length-1,Y;Q>=0;Q--)(Y=it[Q])&&(K=(X?Y(F,W,K):Y(K))||K);return X&&K&&__defProp$i(F,W,K),K};let Box=class extends s{constructor(){super(...arguments),this.top=0,this.left=0,this.width=0,this.height=0}render(){return x`
            <div
                class="wrapper"
                style="top: ${this.top-24}px; left: ${this.left}px;"
            >
                <p>${this.name}</p>
                <div
                    class="box"
                    style="width: ${this.width}px; height: ${this.height}px;"
                ></div>
            </div>
        `}};Box.styles=i$3`
        .wrapper {
            position: absolute;
        }

        p {
            margin: 0;
            padding: 0 6px;
            background: white;
            width: fit-content;
        }

        .box {
            border: 2px solid white;
        }
    `;__decorateClass$i([n$1()],Box.prototype,"name",2);__decorateClass$i([n$1({type:Number})],Box.prototype,"top",2);__decorateClass$i([n$1({type:Number})],Box.prototype,"left",2);__decorateClass$i([n$1({type:Number})],Box.prototype,"width",2);__decorateClass$i([n$1({type:Number})],Box.prototype,"height",2);Box=__decorateClass$i([e$1("wli-box")],Box);var __defProp$h=Object.defineProperty,__getOwnPropDesc$h=Object.getOwnPropertyDescriptor,__decorateClass$h=(it,F,W,X)=>{for(var K=X>1?void 0:X?__getOwnPropDesc$h(F,W):F,Q=it.length-1,Y;Q>=0;Q--)(Y=it[Q])&&(K=(X?Y(F,W,K):Y(K))||K);return X&&K&&__defProp$h(F,W,K),K};let Capture=class extends s{render(){return x`
            <wli-onnx-model
                uuid=${this.uuid}
                name=${this.name}
                path=${this.path}
                .classes=${this.classes}
                width=${this.width}
                height=${this.height}
                .options=${this.options}
            >
                <wli-media-placeholder slot="media">
                </wli-media-placeholder>
            </wli-onnx-model>
        `}};Capture.styles=i$3`
        :host {
        }
    `;__decorateClass$h([n$1({type:String,attribute:!0})],Capture.prototype,"uuid",2);__decorateClass$h([n$1({type:String,attribute:!0})],Capture.prototype,"name",2);__decorateClass$h([n$1({type:String,attribute:!0})],Capture.prototype,"path",2);__decorateClass$h([n$1({type:Array})],Capture.prototype,"classes",2);__decorateClass$h([n$1({type:Number,attribute:!0})],Capture.prototype,"width",2);__decorateClass$h([n$1({type:Number,attribute:!0})],Capture.prototype,"height",2);__decorateClass$h([n$1({type:Object})],Capture.prototype,"options",2);Capture=__decorateClass$h([e$1("wli-capture")],Capture);const thyaTechLogo=""+new URL("logo-name-dark-7f755255.png",import.meta.url).href;var __defProp$g=Object.defineProperty,__getOwnPropDesc$g=Object.getOwnPropertyDescriptor,__decorateClass$g=(it,F,W,X)=>{for(var K=X>1?void 0:X?__getOwnPropDesc$g(F,W):F,Q=it.length-1,Y;Q>=0;Q--)(Y=it[Q])&&(K=(X?Y(F,W,K):Y(K))||K);return X&&K&&__defProp$g(F,W,K),K};let Header=class extends s{render(){return x`
            <img
                src="${thyaTechLogo}"
                alt="Thya Technologie Logo"
            />
            <div class="space"></div>
            ${this.renderAvatar()}
        `}renderAvatar(){if(this.credentials)return x`
                <wli-avatar
                    first-name=${this.credentials.firstName}
                    last-name=${this.credentials.lastName}
                    picture=${this.credentials.profilePicture}
                >
                </wli-avatar>
            `}};Header.styles=i$3`
        :host {
            display: flex;
            align-items: center;
            padding: 24px;
            background-color: var(--wli-secondary);
        }

        .space {
            flex: 1;
        }

        img {
            width: 150px;
        }
    `;__decorateClass$g([n$1({type:Object})],Header.prototype,"credentials",2);Header=__decorateClass$g([e$1("wli-header")],Header);var NAMED_TAG="named",NAME_TAG="name",UNMANAGED_TAG="unmanaged",OPTIONAL_TAG="optional",INJECT_TAG="inject",MULTI_INJECT_TAG="multi_inject",TAGGED="inversify:tagged",TAGGED_PROP="inversify:tagged_props",PARAM_TYPES="inversify:paramtypes",DESIGN_PARAM_TYPES="design:paramtypes",POST_CONSTRUCT="post_construct",PRE_DESTROY="pre_destroy";function getNonCustomTagKeys(){return[INJECT_TAG,MULTI_INJECT_TAG,NAME_TAG,UNMANAGED_TAG,NAMED_TAG,OPTIONAL_TAG]}var NON_CUSTOM_TAG_KEYS=getNonCustomTagKeys(),BindingScopeEnum={Request:"Request",Singleton:"Singleton",Transient:"Transient"},BindingTypeEnum={ConstantValue:"ConstantValue",Constructor:"Constructor",DynamicValue:"DynamicValue",Factory:"Factory",Function:"Function",Instance:"Instance",Invalid:"Invalid",Provider:"Provider"},TargetTypeEnum={ClassProperty:"ClassProperty",ConstructorArgument:"ConstructorArgument",Variable:"Variable"},idCounter=0;function id(){return idCounter++}var Binding=function(){function it(F,W){this.id=id(),this.activated=!1,this.serviceIdentifier=F,this.scope=W,this.type=BindingTypeEnum.Invalid,this.constraint=function(X){return!0},this.implementationType=null,this.cache=null,this.factory=null,this.provider=null,this.onActivation=null,this.onDeactivation=null,this.dynamicValue=null}return it.prototype.clone=function(){var F=new it(this.serviceIdentifier,this.scope);return F.activated=F.scope===BindingScopeEnum.Singleton?this.activated:!1,F.implementationType=this.implementationType,F.dynamicValue=this.dynamicValue,F.scope=this.scope,F.type=this.type,F.factory=this.factory,F.provider=this.provider,F.constraint=this.constraint,F.onActivation=this.onActivation,F.onDeactivation=this.onDeactivation,F.cache=this.cache,F},it}(),DUPLICATED_INJECTABLE_DECORATOR="Cannot apply @injectable decorator multiple times.",DUPLICATED_METADATA="Metadata key was used more than once in a parameter:",NULL_ARGUMENT="NULL argument",KEY_NOT_FOUND="Key Not Found",AMBIGUOUS_MATCH="Ambiguous match found for serviceIdentifier:",CANNOT_UNBIND="Could not unbind serviceIdentifier:",NOT_REGISTERED="No matching bindings found for serviceIdentifier:",MISSING_INJECTABLE_ANNOTATION="Missing required @injectable annotation in:",MISSING_INJECT_ANNOTATION="Missing required @inject or @multiInject annotation in:",UNDEFINED_INJECT_ANNOTATION=function(it){return"@inject called with undefined this could mean that the class "+it+" has a circular dependency problem. You can use a LazyServiceIdentifier to  overcome this limitation."},CIRCULAR_DEPENDENCY="Circular dependency found:",INVALID_BINDING_TYPE="Invalid binding type:",NO_MORE_SNAPSHOTS_AVAILABLE="No snapshot available to restore.",INVALID_MIDDLEWARE_RETURN="Invalid return type in middleware. Middleware must return!",INVALID_FUNCTION_BINDING="Value provided to function binding must be a function!",LAZY_IN_SYNC=function(it){return"You are attempting to construct '"+it+`' in a synchronous way
 but it has asynchronous dependencies.`},INVALID_TO_SELF_VALUE="The toSelf function can only be applied when a constructor is used as service identifier",INVALID_DECORATOR_OPERATION="The @inject @multiInject @tagged and @named decorators must be applied to the parameters of a class constructor or a class property.",ARGUMENTS_LENGTH_MISMATCH=function(){for(var it=[],F=0;F<arguments.length;F++)it[F]=arguments[F];return"The number of constructor arguments in the derived class "+(it[0]+" must be >= than the number of constructor arguments of its base class.")},CONTAINER_OPTIONS_MUST_BE_AN_OBJECT="Invalid Container constructor argument. Container options must be an object.",CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE='Invalid Container option. Default scope must be a string ("singleton" or "transient").',CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE="Invalid Container option. Auto bind injectable must be a boolean",CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK="Invalid Container option. Skip base check must be a boolean",ASYNC_UNBIND_REQUIRED="Attempting to unbind dependency with asynchronous destruction (@preDestroy or onDeactivation)",POST_CONSTRUCT_ERROR=function(it,F){return"@postConstruct error in class "+it+": "+F},PRE_DESTROY_ERROR=function(it,F){return"@preDestroy error in class "+it+": "+F},ON_DEACTIVATION_ERROR=function(it,F){return"onDeactivation() error in class "+it+": "+F},CIRCULAR_DEPENDENCY_IN_FACTORY=function(it,F){return"It looks like there is a circular dependency in one of the '"+it+"' bindings. Please investigate bindings with "+("service identifier '"+F+"'.")},STACK_OVERFLOW="Maximum call stack size exceeded",MetadataReader=function(){function it(){}return it.prototype.getConstructorMetadata=function(F){var W=Reflect.getMetadata(PARAM_TYPES,F),X=Reflect.getMetadata(TAGGED,F);return{compilerGeneratedMetadata:W,userGeneratedMetadata:X||{}}},it.prototype.getPropertiesMetadata=function(F){var W=Reflect.getMetadata(TAGGED_PROP,F)||[];return W},it}(),BindingCount={MultipleBindingsAvailable:2,NoBindingsAvailable:0,OnlyOneBindingAvailable:1};function isStackOverflowExeption(it){return it instanceof RangeError||it.message===STACK_OVERFLOW}var tryAndThrowErrorIfStackOverflow=function(it,F){try{return it()}catch(W){throw isStackOverflowExeption(W)&&(W=F()),W}};function getServiceIdentifierAsString(it){if(typeof it=="function"){var F=it;return F.name}else{if(typeof it=="symbol")return it.toString();var F=it;return F}}function listRegisteredBindingsForServiceIdentifier(it,F,W){var X="",K=W(it,F);return K.length!==0&&(X=`
Registered bindings:`,K.forEach(function(Q){var Y="Object";Q.implementationType!==null&&(Y=getFunctionName(Q.implementationType)),X=X+`
 `+Y,Q.constraint.metaData&&(X=X+" - "+Q.constraint.metaData)})),X}function alreadyDependencyChain(it,F){return it.parentRequest===null?!1:it.parentRequest.serviceIdentifier===F?!0:alreadyDependencyChain(it.parentRequest,F)}function dependencyChainToString(it){function F(X,K){K===void 0&&(K=[]);var Q=getServiceIdentifierAsString(X.serviceIdentifier);return K.push(Q),X.parentRequest!==null?F(X.parentRequest,K):K}var W=F(it);return W.reverse().join(" --> ")}function circularDependencyToException(it){it.childRequests.forEach(function(F){if(alreadyDependencyChain(F,F.serviceIdentifier)){var W=dependencyChainToString(F);throw new Error(CIRCULAR_DEPENDENCY+" "+W)}else circularDependencyToException(F)})}function listMetadataForTarget(it,F){if(F.isTagged()||F.isNamed()){var W="",X=F.getNamedTag(),K=F.getCustomTags();return X!==null&&(W+=X.toString()+`
`),K!==null&&K.forEach(function(Q){W+=Q.toString()+`
`})," "+it+`
 `+it+" - "+W}else return" "+it}function getFunctionName(it){if(it.name)return it.name;var F=it.toString(),W=F.match(/^function\s*([^\s(]+)/);return W?W[1]:"Anonymous function: "+F}function getSymbolDescription(it){return it.toString().slice(7,-1)}var Context=function(){function it(F){this.id=id(),this.container=F}return it.prototype.addPlan=function(F){this.plan=F},it.prototype.setCurrentRequest=function(F){this.currentRequest=F},it}(),Metadata=function(){function it(F,W){this.key=F,this.value=W}return it.prototype.toString=function(){return this.key===NAMED_TAG?"named: "+String(this.value).toString()+" ":"tagged: { key:"+this.key.toString()+", value: "+String(this.value)+" }"},it}(),Plan=function(){function it(F,W){this.parentContext=F,this.rootRequest=W}return it}(),LazyServiceIdentifier=function(){function it(F){this._cb=F}return it.prototype.unwrap=function(){return this._cb()},it}(),QueryableString=function(){function it(F){this.str=F}return it.prototype.startsWith=function(F){return this.str.indexOf(F)===0},it.prototype.endsWith=function(F){var W="",X=F.split("").reverse().join("");return W=this.str.split("").reverse().join(""),this.startsWith.call({str:W},X)},it.prototype.contains=function(F){return this.str.indexOf(F)!==-1},it.prototype.equals=function(F){return this.str===F},it.prototype.value=function(){return this.str},it}(),Target=function(){function it(F,W,X,K){this.id=id(),this.type=F,this.serviceIdentifier=X;var Q=typeof W=="symbol"?getSymbolDescription(W):W;this.name=new QueryableString(Q||""),this.identifier=W,this.metadata=new Array;var Y=null;typeof K=="string"?Y=new Metadata(NAMED_TAG,K):K instanceof Metadata&&(Y=K),Y!==null&&this.metadata.push(Y)}return it.prototype.hasTag=function(F){for(var W=0,X=this.metadata;W<X.length;W++){var K=X[W];if(K.key===F)return!0}return!1},it.prototype.isArray=function(){return this.hasTag(MULTI_INJECT_TAG)},it.prototype.matchesArray=function(F){return this.matchesTag(MULTI_INJECT_TAG)(F)},it.prototype.isNamed=function(){return this.hasTag(NAMED_TAG)},it.prototype.isTagged=function(){return this.metadata.some(function(F){return NON_CUSTOM_TAG_KEYS.every(function(W){return F.key!==W})})},it.prototype.isOptional=function(){return this.matchesTag(OPTIONAL_TAG)(!0)},it.prototype.getNamedTag=function(){return this.isNamed()?this.metadata.filter(function(F){return F.key===NAMED_TAG})[0]:null},it.prototype.getCustomTags=function(){return this.isTagged()?this.metadata.filter(function(F){return NON_CUSTOM_TAG_KEYS.every(function(W){return F.key!==W})}):null},it.prototype.matchesNamedTag=function(F){return this.matchesTag(NAMED_TAG)(F)},it.prototype.matchesTag=function(F){var W=this;return function(X){for(var K=0,Q=W.metadata;K<Q.length;K++){var Y=Q[K];if(Y.key===F&&Y.value===X)return!0}return!1}},it}(),__spreadArray$2=globalThis&&globalThis.__spreadArray||function(it,F,W){if(W||arguments.length===2)for(var X=0,K=F.length,Q;X<K;X++)(Q||!(X in F))&&(Q||(Q=Array.prototype.slice.call(F,0,X)),Q[X]=F[X]);return it.concat(Q||Array.prototype.slice.call(F))};function getDependencies(it,F){var W=getFunctionName(F);return getTargets(it,W,F,!1)}function getTargets(it,F,W,X){var K=it.getConstructorMetadata(W),Q=K.compilerGeneratedMetadata;if(Q===void 0){var Y=MISSING_INJECTABLE_ANNOTATION+" "+F+".";throw new Error(Y)}var tt=K.userGeneratedMetadata,et=Object.keys(tt),q=W.length===0&&et.length>0,G=et.length>W.length,O=q||G?et.length:W.length,b=getConstructorArgsAsTargets(X,F,Q,tt,O),j=getClassPropsAsTargets(it,W,F),U=__spreadArray$2(__spreadArray$2([],b,!0),j,!0);return U}function getConstructorArgsAsTarget(it,F,W,X,K){var Q=K[it.toString()]||[],Y=formatTargetMetadata(Q),tt=Y.unmanaged!==!0,et=X[it],q=Y.inject||Y.multiInject;if(et=q||et,et instanceof LazyServiceIdentifier&&(et=et.unwrap()),tt){var G=et===Object,O=et===Function,b=et===void 0,j=G||O||b;if(!F&&j){var U=MISSING_INJECT_ANNOTATION+" argument "+it+" in class "+W+".";throw new Error(U)}var J=new Target(TargetTypeEnum.ConstructorArgument,Y.targetName,et);return J.metadata=Q,J}return null}function getConstructorArgsAsTargets(it,F,W,X,K){for(var Q=[],Y=0;Y<K;Y++){var tt=Y,et=getConstructorArgsAsTarget(tt,it,F,W,X);et!==null&&Q.push(et)}return Q}function _getServiceIdentifierForProperty(it,F,W,X){var K=it||F;if(K===void 0){var Q=MISSING_INJECTABLE_ANNOTATION+" for property "+String(W)+" in class "+X+".";throw new Error(Q)}return K}function getClassPropsAsTargets(it,F,W){for(var X=it.getPropertiesMetadata(F),K=[],Q=Object.getOwnPropertySymbols(X),Y=Object.keys(X),tt=Y.concat(Q),et=0,q=tt;et<q.length;et++){var G=q[et],O=X[G],b=formatTargetMetadata(O),j=b.targetName||G,U=_getServiceIdentifierForProperty(b.inject,b.multiInject,G,W),J=new Target(TargetTypeEnum.ClassProperty,j,U);J.metadata=O,K.push(J)}var nt=Object.getPrototypeOf(F.prototype).constructor;if(nt!==Object){var rt=getClassPropsAsTargets(it,nt,W);K=__spreadArray$2(__spreadArray$2([],K,!0),rt,!0)}return K}function getBaseClassDependencyCount(it,F){var W=Object.getPrototypeOf(F.prototype).constructor;if(W!==Object){var X=getFunctionName(W),K=getTargets(it,X,W,!0),Q=K.map(function(et){return et.metadata.filter(function(q){return q.key===UNMANAGED_TAG})}),Y=[].concat.apply([],Q).length,tt=K.length-Y;return tt>0?tt:getBaseClassDependencyCount(it,W)}else return 0}function formatTargetMetadata(it){var F={};return it.forEach(function(W){F[W.key.toString()]=W.value}),{inject:F[INJECT_TAG],multiInject:F[MULTI_INJECT_TAG],targetName:F[NAME_TAG],unmanaged:F[UNMANAGED_TAG]}}var Request=function(){function it(F,W,X,K,Q){this.id=id(),this.serviceIdentifier=F,this.parentContext=W,this.parentRequest=X,this.target=Q,this.childRequests=[],this.bindings=Array.isArray(K)?K:[K],this.requestScope=X===null?new Map:null}return it.prototype.addChildRequest=function(F,W,X){var K=new it(F,this.parentContext,this,W,X);return this.childRequests.push(K),K},it}();function getBindingDictionary(it){return it._bindingDictionary}function _createTarget(it,F,W,X,K,Q){var Y=it?MULTI_INJECT_TAG:INJECT_TAG,tt=new Metadata(Y,W),et=new Target(F,X,W,tt);if(K!==void 0){var q=new Metadata(K,Q);et.metadata.push(q)}return et}function _getActiveBindings(it,F,W,X,K){var Q=getBindings(W.container,K.serviceIdentifier),Y=[];return Q.length===BindingCount.NoBindingsAvailable&&W.container.options.autoBindInjectable&&typeof K.serviceIdentifier=="function"&&it.getConstructorMetadata(K.serviceIdentifier).compilerGeneratedMetadata&&(W.container.bind(K.serviceIdentifier).toSelf(),Q=getBindings(W.container,K.serviceIdentifier)),F?Y=Q:Y=Q.filter(function(tt){var et=new Request(tt.serviceIdentifier,W,X,tt,K);return tt.constraint(et)}),_validateActiveBindingCount(K.serviceIdentifier,Y,K,W.container),Y}function _validateActiveBindingCount(it,F,W,X){switch(F.length){case BindingCount.NoBindingsAvailable:if(W.isOptional())return F;var K=getServiceIdentifierAsString(it),Q=NOT_REGISTERED;throw Q+=listMetadataForTarget(K,W),Q+=listRegisteredBindingsForServiceIdentifier(X,K,getBindings),new Error(Q);case BindingCount.OnlyOneBindingAvailable:return F;case BindingCount.MultipleBindingsAvailable:default:if(W.isArray())return F;var K=getServiceIdentifierAsString(it),Q=AMBIGUOUS_MATCH+" "+K;throw Q+=listRegisteredBindingsForServiceIdentifier(X,K,getBindings),new Error(Q)}}function _createSubRequests(it,F,W,X,K,Q){var Y,tt;if(K===null){Y=_getActiveBindings(it,F,X,null,Q),tt=new Request(W,X,null,Y,Q);var et=new Plan(X,tt);X.addPlan(et)}else Y=_getActiveBindings(it,F,X,K,Q),tt=K.addChildRequest(Q.serviceIdentifier,Y,Q);Y.forEach(function(q){var G=null;if(Q.isArray())G=tt.addChildRequest(q.serviceIdentifier,q,Q);else{if(q.cache)return;G=tt}if(q.type===BindingTypeEnum.Instance&&q.implementationType!==null){var O=getDependencies(it,q.implementationType);if(!X.container.options.skipBaseClassChecks){var b=getBaseClassDependencyCount(it,q.implementationType);if(O.length<b){var j=ARGUMENTS_LENGTH_MISMATCH(getFunctionName(q.implementationType));throw new Error(j)}}O.forEach(function(U){_createSubRequests(it,!1,U.serviceIdentifier,X,G,U)})}})}function getBindings(it,F){var W=[],X=getBindingDictionary(it);return X.hasKey(F)?W=X.get(F):it.parent!==null&&(W=getBindings(it.parent,F)),W}function plan(it,F,W,X,K,Q,Y,tt){tt===void 0&&(tt=!1);var et=new Context(F),q=_createTarget(W,X,K,"",Q,Y);try{return _createSubRequests(it,tt,K,et,null,q),et}catch(G){throw isStackOverflowExeption(G)&&circularDependencyToException(et.plan.rootRequest),G}}function createMockRequest(it,F,W,X){var K=new Target(TargetTypeEnum.Variable,"",F,new Metadata(W,X)),Q=new Context(it),Y=new Request(F,Q,null,[],K);return Y}function isPromise(it){var F=typeof it=="object"&&it!==null||typeof it=="function";return F&&typeof it.then=="function"}function isPromiseOrContainsPromise(it){return isPromise(it)?!0:Array.isArray(it)&&it.some(isPromise)}var __awaiter$3=globalThis&&globalThis.__awaiter||function(it,F,W,X){function K(Q){return Q instanceof W?Q:new W(function(Y){Y(Q)})}return new(W||(W=Promise))(function(Q,Y){function tt(G){try{q(X.next(G))}catch(O){Y(O)}}function et(G){try{q(X.throw(G))}catch(O){Y(O)}}function q(G){G.done?Q(G.value):K(G.value).then(tt,et)}q((X=X.apply(it,F||[])).next())})},__generator$3=globalThis&&globalThis.__generator||function(it,F){var W={label:0,sent:function(){if(Q[0]&1)throw Q[1];return Q[1]},trys:[],ops:[]},X,K,Q,Y;return Y={next:tt(0),throw:tt(1),return:tt(2)},typeof Symbol=="function"&&(Y[Symbol.iterator]=function(){return this}),Y;function tt(q){return function(G){return et([q,G])}}function et(q){if(X)throw new TypeError("Generator is already executing.");for(;W;)try{if(X=1,K&&(Q=q[0]&2?K.return:q[0]?K.throw||((Q=K.return)&&Q.call(K),0):K.next)&&!(Q=Q.call(K,q[1])).done)return Q;switch(K=0,Q&&(q=[q[0]&2,Q.value]),q[0]){case 0:case 1:Q=q;break;case 4:return W.label++,{value:q[1],done:!1};case 5:W.label++,K=q[1],q=[0];continue;case 7:q=W.ops.pop(),W.trys.pop();continue;default:if(Q=W.trys,!(Q=Q.length>0&&Q[Q.length-1])&&(q[0]===6||q[0]===2)){W=0;continue}if(q[0]===3&&(!Q||q[1]>Q[0]&&q[1]<Q[3])){W.label=q[1];break}if(q[0]===6&&W.label<Q[1]){W.label=Q[1],Q=q;break}if(Q&&W.label<Q[2]){W.label=Q[2],W.ops.push(q);break}Q[2]&&W.ops.pop(),W.trys.pop();continue}q=F.call(it,W)}catch(G){q=[6,G],K=0}finally{X=Q=0}if(q[0]&5)throw q[1];return{value:q[0]?q[1]:void 0,done:!0}}},tryGetFromScope=function(it,F){return F.scope===BindingScopeEnum.Singleton&&F.activated?F.cache:F.scope===BindingScopeEnum.Request&&it.has(F.id)?it.get(F.id):null},saveToScope=function(it,F,W){F.scope===BindingScopeEnum.Singleton&&_saveToSingletonScope(F,W),F.scope===BindingScopeEnum.Request&&_saveToRequestScope(it,F,W)},_saveToRequestScope=function(it,F,W){it.has(F.id)||it.set(F.id,W)},_saveToSingletonScope=function(it,F){it.cache=F,it.activated=!0,isPromise(F)&&_saveAsyncResultToSingletonScope(it,F)},_saveAsyncResultToSingletonScope=function(it,F){return __awaiter$3(void 0,void 0,void 0,function(){var W,X;return __generator$3(this,function(K){switch(K.label){case 0:return K.trys.push([0,2,,3]),[4,F];case 1:return W=K.sent(),it.cache=W,[3,3];case 2:throw X=K.sent(),it.cache=null,it.activated=!1,X;case 3:return[2]}})})},FactoryType;(function(it){it.DynamicValue="toDynamicValue",it.Factory="toFactory",it.Provider="toProvider"})(FactoryType||(FactoryType={}));var ensureFullyBound=function(it){var F=null;switch(it.type){case BindingTypeEnum.ConstantValue:case BindingTypeEnum.Function:F=it.cache;break;case BindingTypeEnum.Constructor:case BindingTypeEnum.Instance:F=it.implementationType;break;case BindingTypeEnum.DynamicValue:F=it.dynamicValue;break;case BindingTypeEnum.Provider:F=it.provider;break;case BindingTypeEnum.Factory:F=it.factory;break}if(F===null){var W=getServiceIdentifierAsString(it.serviceIdentifier);throw new Error(INVALID_BINDING_TYPE+" "+W)}},getFactoryDetails=function(it){switch(it.type){case BindingTypeEnum.Factory:return{factory:it.factory,factoryType:FactoryType.Factory};case BindingTypeEnum.Provider:return{factory:it.provider,factoryType:FactoryType.Provider};case BindingTypeEnum.DynamicValue:return{factory:it.dynamicValue,factoryType:FactoryType.DynamicValue};default:throw new Error("Unexpected factory type "+it.type)}},__assign$1=globalThis&&globalThis.__assign||function(){return __assign$1=Object.assign||function(it){for(var F,W=1,X=arguments.length;W<X;W++){F=arguments[W];for(var K in F)Object.prototype.hasOwnProperty.call(F,K)&&(it[K]=F[K])}return it},__assign$1.apply(this,arguments)},__awaiter$2=globalThis&&globalThis.__awaiter||function(it,F,W,X){function K(Q){return Q instanceof W?Q:new W(function(Y){Y(Q)})}return new(W||(W=Promise))(function(Q,Y){function tt(G){try{q(X.next(G))}catch(O){Y(O)}}function et(G){try{q(X.throw(G))}catch(O){Y(O)}}function q(G){G.done?Q(G.value):K(G.value).then(tt,et)}q((X=X.apply(it,F||[])).next())})},__generator$2=globalThis&&globalThis.__generator||function(it,F){var W={label:0,sent:function(){if(Q[0]&1)throw Q[1];return Q[1]},trys:[],ops:[]},X,K,Q,Y;return Y={next:tt(0),throw:tt(1),return:tt(2)},typeof Symbol=="function"&&(Y[Symbol.iterator]=function(){return this}),Y;function tt(q){return function(G){return et([q,G])}}function et(q){if(X)throw new TypeError("Generator is already executing.");for(;W;)try{if(X=1,K&&(Q=q[0]&2?K.return:q[0]?K.throw||((Q=K.return)&&Q.call(K),0):K.next)&&!(Q=Q.call(K,q[1])).done)return Q;switch(K=0,Q&&(q=[q[0]&2,Q.value]),q[0]){case 0:case 1:Q=q;break;case 4:return W.label++,{value:q[1],done:!1};case 5:W.label++,K=q[1],q=[0];continue;case 7:q=W.ops.pop(),W.trys.pop();continue;default:if(Q=W.trys,!(Q=Q.length>0&&Q[Q.length-1])&&(q[0]===6||q[0]===2)){W=0;continue}if(q[0]===3&&(!Q||q[1]>Q[0]&&q[1]<Q[3])){W.label=q[1];break}if(q[0]===6&&W.label<Q[1]){W.label=Q[1],Q=q;break}if(Q&&W.label<Q[2]){W.label=Q[2],W.ops.push(q);break}Q[2]&&W.ops.pop(),W.trys.pop();continue}q=F.call(it,W)}catch(G){q=[6,G],K=0}finally{X=Q=0}if(q[0]&5)throw q[1];return{value:q[0]?q[1]:void 0,done:!0}}},__spreadArray$1=globalThis&&globalThis.__spreadArray||function(it,F,W){if(W||arguments.length===2)for(var X=0,K=F.length,Q;X<K;X++)(Q||!(X in F))&&(Q||(Q=Array.prototype.slice.call(F,0,X)),Q[X]=F[X]);return it.concat(Q||Array.prototype.slice.call(F))};function _resolveRequests(it,F){return it.reduce(function(W,X){var K=F(X),Q=X.target.type;return Q===TargetTypeEnum.ConstructorArgument?W.constructorInjections.push(K):(W.propertyRequests.push(X),W.propertyInjections.push(K)),W.isAsync||(W.isAsync=isPromiseOrContainsPromise(K)),W},{constructorInjections:[],propertyInjections:[],propertyRequests:[],isAsync:!1})}function _createInstance(it,F,W){var X;if(F.length>0){var K=_resolveRequests(F,W),Q=__assign$1(__assign$1({},K),{constr:it});K.isAsync?X=createInstanceWithInjectionsAsync(Q):X=createInstanceWithInjections(Q)}else X=new it;return X}function createInstanceWithInjections(it){var F,W=new((F=it.constr).bind.apply(F,__spreadArray$1([void 0],it.constructorInjections,!1)));return it.propertyRequests.forEach(function(X,K){var Q=X.target.identifier,Y=it.propertyInjections[K];(!X.target.isOptional()||Y!==void 0)&&(W[Q]=Y)}),W}function createInstanceWithInjectionsAsync(it){return __awaiter$2(this,void 0,void 0,function(){var F,W;return __generator$2(this,function(X){switch(X.label){case 0:return[4,possiblyWaitInjections(it.constructorInjections)];case 1:return F=X.sent(),[4,possiblyWaitInjections(it.propertyInjections)];case 2:return W=X.sent(),[2,createInstanceWithInjections(__assign$1(__assign$1({},it),{constructorInjections:F,propertyInjections:W}))]}})})}function possiblyWaitInjections(it){return __awaiter$2(this,void 0,void 0,function(){var F,W,X,K;return __generator$2(this,function(Q){for(F=[],W=0,X=it;W<X.length;W++)K=X[W],Array.isArray(K)?F.push(Promise.all(K)):F.push(K);return[2,Promise.all(F)]})})}function _getInstanceAfterPostConstruct(it,F){var W=_postConstruct(it,F);return isPromise(W)?W.then(function(){return F}):F}function _postConstruct(it,F){var W,X;if(Reflect.hasMetadata(POST_CONSTRUCT,it)){var K=Reflect.getMetadata(POST_CONSTRUCT,it);try{return(X=(W=F)[K.value])===null||X===void 0?void 0:X.call(W)}catch(Q){if(Q instanceof Error)throw new Error(POST_CONSTRUCT_ERROR(it.name,Q.message))}}}function _validateInstanceResolution(it,F){it.scope!==BindingScopeEnum.Singleton&&_throwIfHandlingDeactivation(it,F)}function _throwIfHandlingDeactivation(it,F){var W="Class cannot be instantiated in "+(it.scope===BindingScopeEnum.Request?"request":"transient")+" scope.";if(typeof it.onDeactivation=="function")throw new Error(ON_DEACTIVATION_ERROR(F.name,W));if(Reflect.hasMetadata(PRE_DESTROY,F))throw new Error(PRE_DESTROY_ERROR(F.name,W))}function resolveInstance(it,F,W,X){_validateInstanceResolution(it,F);var K=_createInstance(F,W,X);return isPromise(K)?K.then(function(Q){return _getInstanceAfterPostConstruct(F,Q)}):_getInstanceAfterPostConstruct(F,K)}var __awaiter$1=globalThis&&globalThis.__awaiter||function(it,F,W,X){function K(Q){return Q instanceof W?Q:new W(function(Y){Y(Q)})}return new(W||(W=Promise))(function(Q,Y){function tt(G){try{q(X.next(G))}catch(O){Y(O)}}function et(G){try{q(X.throw(G))}catch(O){Y(O)}}function q(G){G.done?Q(G.value):K(G.value).then(tt,et)}q((X=X.apply(it,F||[])).next())})},__generator$1=globalThis&&globalThis.__generator||function(it,F){var W={label:0,sent:function(){if(Q[0]&1)throw Q[1];return Q[1]},trys:[],ops:[]},X,K,Q,Y;return Y={next:tt(0),throw:tt(1),return:tt(2)},typeof Symbol=="function"&&(Y[Symbol.iterator]=function(){return this}),Y;function tt(q){return function(G){return et([q,G])}}function et(q){if(X)throw new TypeError("Generator is already executing.");for(;W;)try{if(X=1,K&&(Q=q[0]&2?K.return:q[0]?K.throw||((Q=K.return)&&Q.call(K),0):K.next)&&!(Q=Q.call(K,q[1])).done)return Q;switch(K=0,Q&&(q=[q[0]&2,Q.value]),q[0]){case 0:case 1:Q=q;break;case 4:return W.label++,{value:q[1],done:!1};case 5:W.label++,K=q[1],q=[0];continue;case 7:q=W.ops.pop(),W.trys.pop();continue;default:if(Q=W.trys,!(Q=Q.length>0&&Q[Q.length-1])&&(q[0]===6||q[0]===2)){W=0;continue}if(q[0]===3&&(!Q||q[1]>Q[0]&&q[1]<Q[3])){W.label=q[1];break}if(q[0]===6&&W.label<Q[1]){W.label=Q[1],Q=q;break}if(Q&&W.label<Q[2]){W.label=Q[2],W.ops.push(q);break}Q[2]&&W.ops.pop(),W.trys.pop();continue}q=F.call(it,W)}catch(G){q=[6,G],K=0}finally{X=Q=0}if(q[0]&5)throw q[1];return{value:q[0]?q[1]:void 0,done:!0}}},_resolveRequest=function(it){return function(F){F.parentContext.setCurrentRequest(F);var W=F.bindings,X=F.childRequests,K=F.target&&F.target.isArray(),Q=!F.parentRequest||!F.parentRequest.target||!F.target||!F.parentRequest.target.matchesArray(F.target.serviceIdentifier);if(K&&Q)return X.map(function(tt){var et=_resolveRequest(it);return et(tt)});if(F.target.isOptional()&&W.length===0)return;var Y=W[0];return _resolveBinding(it,F,Y)}},_resolveFactoryFromBinding=function(it,F){var W=getFactoryDetails(it);return tryAndThrowErrorIfStackOverflow(function(){return W.factory.bind(it)(F)},function(){return new Error(CIRCULAR_DEPENDENCY_IN_FACTORY(W.factoryType,F.currentRequest.serviceIdentifier.toString()))})},_getResolvedFromBinding=function(it,F,W){var X,K=F.childRequests;switch(ensureFullyBound(W),W.type){case BindingTypeEnum.ConstantValue:case BindingTypeEnum.Function:X=W.cache;break;case BindingTypeEnum.Constructor:X=W.implementationType;break;case BindingTypeEnum.Instance:X=resolveInstance(W,W.implementationType,K,_resolveRequest(it));break;default:X=_resolveFactoryFromBinding(W,F.parentContext)}return X},_resolveInScope=function(it,F,W){var X=tryGetFromScope(it,F);return X!==null||(X=W(),saveToScope(it,F,X)),X},_resolveBinding=function(it,F,W){return _resolveInScope(it,W,function(){var X=_getResolvedFromBinding(it,F,W);return isPromise(X)?X=X.then(function(K){return _onActivation(F,W,K)}):X=_onActivation(F,W,X),X})};function _onActivation(it,F,W){var X=_bindingActivation(it.parentContext,F,W),K=_getContainersIterator(it.parentContext.container),Q,Y=K.next();do{Q=Y.value;var tt=it.parentContext,et=it.serviceIdentifier,q=_getContainerActivationsForService(Q,et);isPromise(X)?X=_activateContainerAsync(q,tt,X):X=_activateContainer(q,tt,X),Y=K.next()}while(Y.done!==!0&&!getBindingDictionary(Q).hasKey(it.serviceIdentifier));return X}var _bindingActivation=function(it,F,W){var X;return typeof F.onActivation=="function"?X=F.onActivation(it,W):X=W,X},_activateContainer=function(it,F,W){for(var X=it.next();!X.done;){if(W=X.value(F,W),isPromise(W))return _activateContainerAsync(it,F,W);X=it.next()}return W},_activateContainerAsync=function(it,F,W){return __awaiter$1(void 0,void 0,void 0,function(){var X,K;return __generator$1(this,function(Q){switch(Q.label){case 0:return[4,W];case 1:X=Q.sent(),K=it.next(),Q.label=2;case 2:return K.done?[3,4]:[4,K.value(F,X)];case 3:return X=Q.sent(),K=it.next(),[3,2];case 4:return[2,X]}})})},_getContainerActivationsForService=function(it,F){var W=it._activations;return W.hasKey(F)?W.get(F).values():[].values()},_getContainersIterator=function(it){for(var F=[it],W=it.parent;W!==null;)F.push(W),W=W.parent;var X=function(){var Q=F.pop();return Q!==void 0?{done:!1,value:Q}:{done:!0,value:void 0}},K={next:X};return K};function resolve(it){var F=_resolveRequest(it.plan.rootRequest.requestScope);return F(it.plan.rootRequest)}var traverseAncerstors=function(it,F){var W=it.parentRequest;return W!==null?F(W)?!0:traverseAncerstors(W,F):!1},taggedConstraint=function(it){return function(F){var W=function(X){return X!==null&&X.target!==null&&X.target.matchesTag(it)(F)};return W.metaData=new Metadata(it,F),W}},namedConstraint=taggedConstraint(NAMED_TAG),typeConstraint=function(it){return function(F){var W=null;if(F!==null)if(W=F.bindings[0],typeof it=="string"){var X=W.serviceIdentifier;return X===it}else{var K=F.bindings[0].implementationType;return it===K}return!1}},BindingWhenSyntax=function(){function it(F){this._binding=F}return it.prototype.when=function(F){return this._binding.constraint=F,new BindingOnSyntax(this._binding)},it.prototype.whenTargetNamed=function(F){return this._binding.constraint=namedConstraint(F),new BindingOnSyntax(this._binding)},it.prototype.whenTargetIsDefault=function(){return this._binding.constraint=function(F){if(F===null)return!1;var W=F.target!==null&&!F.target.isNamed()&&!F.target.isTagged();return W},new BindingOnSyntax(this._binding)},it.prototype.whenTargetTagged=function(F,W){return this._binding.constraint=taggedConstraint(F)(W),new BindingOnSyntax(this._binding)},it.prototype.whenInjectedInto=function(F){return this._binding.constraint=function(W){return W!==null&&typeConstraint(F)(W.parentRequest)},new BindingOnSyntax(this._binding)},it.prototype.whenParentNamed=function(F){return this._binding.constraint=function(W){return W!==null&&namedConstraint(F)(W.parentRequest)},new BindingOnSyntax(this._binding)},it.prototype.whenParentTagged=function(F,W){return this._binding.constraint=function(X){return X!==null&&taggedConstraint(F)(W)(X.parentRequest)},new BindingOnSyntax(this._binding)},it.prototype.whenAnyAncestorIs=function(F){return this._binding.constraint=function(W){return W!==null&&traverseAncerstors(W,typeConstraint(F))},new BindingOnSyntax(this._binding)},it.prototype.whenNoAncestorIs=function(F){return this._binding.constraint=function(W){return W!==null&&!traverseAncerstors(W,typeConstraint(F))},new BindingOnSyntax(this._binding)},it.prototype.whenAnyAncestorNamed=function(F){return this._binding.constraint=function(W){return W!==null&&traverseAncerstors(W,namedConstraint(F))},new BindingOnSyntax(this._binding)},it.prototype.whenNoAncestorNamed=function(F){return this._binding.constraint=function(W){return W!==null&&!traverseAncerstors(W,namedConstraint(F))},new BindingOnSyntax(this._binding)},it.prototype.whenAnyAncestorTagged=function(F,W){return this._binding.constraint=function(X){return X!==null&&traverseAncerstors(X,taggedConstraint(F)(W))},new BindingOnSyntax(this._binding)},it.prototype.whenNoAncestorTagged=function(F,W){return this._binding.constraint=function(X){return X!==null&&!traverseAncerstors(X,taggedConstraint(F)(W))},new BindingOnSyntax(this._binding)},it.prototype.whenAnyAncestorMatches=function(F){return this._binding.constraint=function(W){return W!==null&&traverseAncerstors(W,F)},new BindingOnSyntax(this._binding)},it.prototype.whenNoAncestorMatches=function(F){return this._binding.constraint=function(W){return W!==null&&!traverseAncerstors(W,F)},new BindingOnSyntax(this._binding)},it}(),BindingOnSyntax=function(){function it(F){this._binding=F}return it.prototype.onActivation=function(F){return this._binding.onActivation=F,new BindingWhenSyntax(this._binding)},it.prototype.onDeactivation=function(F){return this._binding.onDeactivation=F,new BindingWhenSyntax(this._binding)},it}(),BindingWhenOnSyntax=function(){function it(F){this._binding=F,this._bindingWhenSyntax=new BindingWhenSyntax(this._binding),this._bindingOnSyntax=new BindingOnSyntax(this._binding)}return it.prototype.when=function(F){return this._bindingWhenSyntax.when(F)},it.prototype.whenTargetNamed=function(F){return this._bindingWhenSyntax.whenTargetNamed(F)},it.prototype.whenTargetIsDefault=function(){return this._bindingWhenSyntax.whenTargetIsDefault()},it.prototype.whenTargetTagged=function(F,W){return this._bindingWhenSyntax.whenTargetTagged(F,W)},it.prototype.whenInjectedInto=function(F){return this._bindingWhenSyntax.whenInjectedInto(F)},it.prototype.whenParentNamed=function(F){return this._bindingWhenSyntax.whenParentNamed(F)},it.prototype.whenParentTagged=function(F,W){return this._bindingWhenSyntax.whenParentTagged(F,W)},it.prototype.whenAnyAncestorIs=function(F){return this._bindingWhenSyntax.whenAnyAncestorIs(F)},it.prototype.whenNoAncestorIs=function(F){return this._bindingWhenSyntax.whenNoAncestorIs(F)},it.prototype.whenAnyAncestorNamed=function(F){return this._bindingWhenSyntax.whenAnyAncestorNamed(F)},it.prototype.whenAnyAncestorTagged=function(F,W){return this._bindingWhenSyntax.whenAnyAncestorTagged(F,W)},it.prototype.whenNoAncestorNamed=function(F){return this._bindingWhenSyntax.whenNoAncestorNamed(F)},it.prototype.whenNoAncestorTagged=function(F,W){return this._bindingWhenSyntax.whenNoAncestorTagged(F,W)},it.prototype.whenAnyAncestorMatches=function(F){return this._bindingWhenSyntax.whenAnyAncestorMatches(F)},it.prototype.whenNoAncestorMatches=function(F){return this._bindingWhenSyntax.whenNoAncestorMatches(F)},it.prototype.onActivation=function(F){return this._bindingOnSyntax.onActivation(F)},it.prototype.onDeactivation=function(F){return this._bindingOnSyntax.onDeactivation(F)},it}(),BindingInSyntax=function(){function it(F){this._binding=F}return it.prototype.inRequestScope=function(){return this._binding.scope=BindingScopeEnum.Request,new BindingWhenOnSyntax(this._binding)},it.prototype.inSingletonScope=function(){return this._binding.scope=BindingScopeEnum.Singleton,new BindingWhenOnSyntax(this._binding)},it.prototype.inTransientScope=function(){return this._binding.scope=BindingScopeEnum.Transient,new BindingWhenOnSyntax(this._binding)},it}(),BindingInWhenOnSyntax=function(){function it(F){this._binding=F,this._bindingWhenSyntax=new BindingWhenSyntax(this._binding),this._bindingOnSyntax=new BindingOnSyntax(this._binding),this._bindingInSyntax=new BindingInSyntax(F)}return it.prototype.inRequestScope=function(){return this._bindingInSyntax.inRequestScope()},it.prototype.inSingletonScope=function(){return this._bindingInSyntax.inSingletonScope()},it.prototype.inTransientScope=function(){return this._bindingInSyntax.inTransientScope()},it.prototype.when=function(F){return this._bindingWhenSyntax.when(F)},it.prototype.whenTargetNamed=function(F){return this._bindingWhenSyntax.whenTargetNamed(F)},it.prototype.whenTargetIsDefault=function(){return this._bindingWhenSyntax.whenTargetIsDefault()},it.prototype.whenTargetTagged=function(F,W){return this._bindingWhenSyntax.whenTargetTagged(F,W)},it.prototype.whenInjectedInto=function(F){return this._bindingWhenSyntax.whenInjectedInto(F)},it.prototype.whenParentNamed=function(F){return this._bindingWhenSyntax.whenParentNamed(F)},it.prototype.whenParentTagged=function(F,W){return this._bindingWhenSyntax.whenParentTagged(F,W)},it.prototype.whenAnyAncestorIs=function(F){return this._bindingWhenSyntax.whenAnyAncestorIs(F)},it.prototype.whenNoAncestorIs=function(F){return this._bindingWhenSyntax.whenNoAncestorIs(F)},it.prototype.whenAnyAncestorNamed=function(F){return this._bindingWhenSyntax.whenAnyAncestorNamed(F)},it.prototype.whenAnyAncestorTagged=function(F,W){return this._bindingWhenSyntax.whenAnyAncestorTagged(F,W)},it.prototype.whenNoAncestorNamed=function(F){return this._bindingWhenSyntax.whenNoAncestorNamed(F)},it.prototype.whenNoAncestorTagged=function(F,W){return this._bindingWhenSyntax.whenNoAncestorTagged(F,W)},it.prototype.whenAnyAncestorMatches=function(F){return this._bindingWhenSyntax.whenAnyAncestorMatches(F)},it.prototype.whenNoAncestorMatches=function(F){return this._bindingWhenSyntax.whenNoAncestorMatches(F)},it.prototype.onActivation=function(F){return this._bindingOnSyntax.onActivation(F)},it.prototype.onDeactivation=function(F){return this._bindingOnSyntax.onDeactivation(F)},it}(),BindingToSyntax=function(){function it(F){this._binding=F}return it.prototype.to=function(F){return this._binding.type=BindingTypeEnum.Instance,this._binding.implementationType=F,new BindingInWhenOnSyntax(this._binding)},it.prototype.toSelf=function(){if(typeof this._binding.serviceIdentifier!="function")throw new Error(""+INVALID_TO_SELF_VALUE);var F=this._binding.serviceIdentifier;return this.to(F)},it.prototype.toConstantValue=function(F){return this._binding.type=BindingTypeEnum.ConstantValue,this._binding.cache=F,this._binding.dynamicValue=null,this._binding.implementationType=null,this._binding.scope=BindingScopeEnum.Singleton,new BindingWhenOnSyntax(this._binding)},it.prototype.toDynamicValue=function(F){return this._binding.type=BindingTypeEnum.DynamicValue,this._binding.cache=null,this._binding.dynamicValue=F,this._binding.implementationType=null,new BindingInWhenOnSyntax(this._binding)},it.prototype.toConstructor=function(F){return this._binding.type=BindingTypeEnum.Constructor,this._binding.implementationType=F,this._binding.scope=BindingScopeEnum.Singleton,new BindingWhenOnSyntax(this._binding)},it.prototype.toFactory=function(F){return this._binding.type=BindingTypeEnum.Factory,this._binding.factory=F,this._binding.scope=BindingScopeEnum.Singleton,new BindingWhenOnSyntax(this._binding)},it.prototype.toFunction=function(F){if(typeof F!="function")throw new Error(INVALID_FUNCTION_BINDING);var W=this.toConstantValue(F);return this._binding.type=BindingTypeEnum.Function,this._binding.scope=BindingScopeEnum.Singleton,W},it.prototype.toAutoFactory=function(F){return this._binding.type=BindingTypeEnum.Factory,this._binding.factory=function(W){var X=function(){return W.container.get(F)};return X},this._binding.scope=BindingScopeEnum.Singleton,new BindingWhenOnSyntax(this._binding)},it.prototype.toAutoNamedFactory=function(F){return this._binding.type=BindingTypeEnum.Factory,this._binding.factory=function(W){return function(X){return W.container.getNamed(F,X)}},new BindingWhenOnSyntax(this._binding)},it.prototype.toProvider=function(F){return this._binding.type=BindingTypeEnum.Provider,this._binding.provider=F,this._binding.scope=BindingScopeEnum.Singleton,new BindingWhenOnSyntax(this._binding)},it.prototype.toService=function(F){this.toDynamicValue(function(W){return W.container.get(F)})},it}(),ContainerSnapshot=function(){function it(){}return it.of=function(F,W,X,K,Q){var Y=new it;return Y.bindings=F,Y.middleware=W,Y.deactivations=K,Y.activations=X,Y.moduleActivationStore=Q,Y},it}();function isClonable(it){return typeof it=="object"&&it!==null&&"clone"in it&&typeof it.clone=="function"}var Lookup=function(){function it(){this._map=new Map}return it.prototype.getMap=function(){return this._map},it.prototype.add=function(F,W){if(F==null)throw new Error(NULL_ARGUMENT);if(W==null)throw new Error(NULL_ARGUMENT);var X=this._map.get(F);X!==void 0?X.push(W):this._map.set(F,[W])},it.prototype.get=function(F){if(F==null)throw new Error(NULL_ARGUMENT);var W=this._map.get(F);if(W!==void 0)return W;throw new Error(KEY_NOT_FOUND)},it.prototype.remove=function(F){if(F==null)throw new Error(NULL_ARGUMENT);if(!this._map.delete(F))throw new Error(KEY_NOT_FOUND)},it.prototype.removeIntersection=function(F){var W=this;this.traverse(function(X,K){var Q=F.hasKey(X)?F.get(X):void 0;if(Q!==void 0){var Y=K.filter(function(tt){return!Q.some(function(et){return tt===et})});W._setValue(X,Y)}})},it.prototype.removeByCondition=function(F){var W=this,X=[];return this._map.forEach(function(K,Q){for(var Y=[],tt=0,et=K;tt<et.length;tt++){var q=et[tt],G=F(q);G?X.push(q):Y.push(q)}W._setValue(Q,Y)}),X},it.prototype.hasKey=function(F){if(F==null)throw new Error(NULL_ARGUMENT);return this._map.has(F)},it.prototype.clone=function(){var F=new it;return this._map.forEach(function(W,X){W.forEach(function(K){return F.add(X,isClonable(K)?K.clone():K)})}),F},it.prototype.traverse=function(F){this._map.forEach(function(W,X){F(X,W)})},it.prototype._setValue=function(F,W){W.length>0?this._map.set(F,W):this._map.delete(F)},it}(),ModuleActivationStore=function(){function it(){this._map=new Map}return it.prototype.remove=function(F){if(this._map.has(F)){var W=this._map.get(F);return this._map.delete(F),W}return this._getEmptyHandlersStore()},it.prototype.addDeactivation=function(F,W,X){this._getModuleActivationHandlers(F).onDeactivations.add(W,X)},it.prototype.addActivation=function(F,W,X){this._getModuleActivationHandlers(F).onActivations.add(W,X)},it.prototype.clone=function(){var F=new it;return this._map.forEach(function(W,X){F._map.set(X,{onActivations:W.onActivations.clone(),onDeactivations:W.onDeactivations.clone()})}),F},it.prototype._getModuleActivationHandlers=function(F){var W=this._map.get(F);return W===void 0&&(W=this._getEmptyHandlersStore(),this._map.set(F,W)),W},it.prototype._getEmptyHandlersStore=function(){var F={onActivations:new Lookup,onDeactivations:new Lookup};return F},it}(),__assign=globalThis&&globalThis.__assign||function(){return __assign=Object.assign||function(it){for(var F,W=1,X=arguments.length;W<X;W++){F=arguments[W];for(var K in F)Object.prototype.hasOwnProperty.call(F,K)&&(it[K]=F[K])}return it},__assign.apply(this,arguments)},__awaiter=globalThis&&globalThis.__awaiter||function(it,F,W,X){function K(Q){return Q instanceof W?Q:new W(function(Y){Y(Q)})}return new(W||(W=Promise))(function(Q,Y){function tt(G){try{q(X.next(G))}catch(O){Y(O)}}function et(G){try{q(X.throw(G))}catch(O){Y(O)}}function q(G){G.done?Q(G.value):K(G.value).then(tt,et)}q((X=X.apply(it,F||[])).next())})},__generator=globalThis&&globalThis.__generator||function(it,F){var W={label:0,sent:function(){if(Q[0]&1)throw Q[1];return Q[1]},trys:[],ops:[]},X,K,Q,Y;return Y={next:tt(0),throw:tt(1),return:tt(2)},typeof Symbol=="function"&&(Y[Symbol.iterator]=function(){return this}),Y;function tt(q){return function(G){return et([q,G])}}function et(q){if(X)throw new TypeError("Generator is already executing.");for(;W;)try{if(X=1,K&&(Q=q[0]&2?K.return:q[0]?K.throw||((Q=K.return)&&Q.call(K),0):K.next)&&!(Q=Q.call(K,q[1])).done)return Q;switch(K=0,Q&&(q=[q[0]&2,Q.value]),q[0]){case 0:case 1:Q=q;break;case 4:return W.label++,{value:q[1],done:!1};case 5:W.label++,K=q[1],q=[0];continue;case 7:q=W.ops.pop(),W.trys.pop();continue;default:if(Q=W.trys,!(Q=Q.length>0&&Q[Q.length-1])&&(q[0]===6||q[0]===2)){W=0;continue}if(q[0]===3&&(!Q||q[1]>Q[0]&&q[1]<Q[3])){W.label=q[1];break}if(q[0]===6&&W.label<Q[1]){W.label=Q[1],Q=q;break}if(Q&&W.label<Q[2]){W.label=Q[2],W.ops.push(q);break}Q[2]&&W.ops.pop(),W.trys.pop();continue}q=F.call(it,W)}catch(G){q=[6,G],K=0}finally{X=Q=0}if(q[0]&5)throw q[1];return{value:q[0]?q[1]:void 0,done:!0}}},__spreadArray=globalThis&&globalThis.__spreadArray||function(it,F,W){if(W||arguments.length===2)for(var X=0,K=F.length,Q;X<K;X++)(Q||!(X in F))&&(Q||(Q=Array.prototype.slice.call(F,0,X)),Q[X]=F[X]);return it.concat(Q||Array.prototype.slice.call(F))},Container=function(){function it(F){var W=F||{};if(typeof W!="object")throw new Error(""+CONTAINER_OPTIONS_MUST_BE_AN_OBJECT);if(W.defaultScope===void 0)W.defaultScope=BindingScopeEnum.Transient;else if(W.defaultScope!==BindingScopeEnum.Singleton&&W.defaultScope!==BindingScopeEnum.Transient&&W.defaultScope!==BindingScopeEnum.Request)throw new Error(""+CONTAINER_OPTIONS_INVALID_DEFAULT_SCOPE);if(W.autoBindInjectable===void 0)W.autoBindInjectable=!1;else if(typeof W.autoBindInjectable!="boolean")throw new Error(""+CONTAINER_OPTIONS_INVALID_AUTO_BIND_INJECTABLE);if(W.skipBaseClassChecks===void 0)W.skipBaseClassChecks=!1;else if(typeof W.skipBaseClassChecks!="boolean")throw new Error(""+CONTAINER_OPTIONS_INVALID_SKIP_BASE_CHECK);this.options={autoBindInjectable:W.autoBindInjectable,defaultScope:W.defaultScope,skipBaseClassChecks:W.skipBaseClassChecks},this.id=id(),this._bindingDictionary=new Lookup,this._snapshots=[],this._middleware=null,this._activations=new Lookup,this._deactivations=new Lookup,this.parent=null,this._metadataReader=new MetadataReader,this._moduleActivationStore=new ModuleActivationStore}return it.merge=function(F,W){for(var X=[],K=2;K<arguments.length;K++)X[K-2]=arguments[K];var Q=new it,Y=__spreadArray([F,W],X,!0).map(function(q){return getBindingDictionary(q)}),tt=getBindingDictionary(Q);function et(q,G){q.traverse(function(O,b){b.forEach(function(j){G.add(j.serviceIdentifier,j.clone())})})}return Y.forEach(function(q){et(q,tt)}),Q},it.prototype.load=function(){for(var F=[],W=0;W<arguments.length;W++)F[W]=arguments[W];for(var X=this._getContainerModuleHelpersFactory(),K=0,Q=F;K<Q.length;K++){var Y=Q[K],tt=X(Y.id);Y.registry(tt.bindFunction,tt.unbindFunction,tt.isboundFunction,tt.rebindFunction,tt.unbindAsyncFunction,tt.onActivationFunction,tt.onDeactivationFunction)}},it.prototype.loadAsync=function(){for(var F=[],W=0;W<arguments.length;W++)F[W]=arguments[W];return __awaiter(this,void 0,void 0,function(){var X,K,Q,Y,tt;return __generator(this,function(et){switch(et.label){case 0:X=this._getContainerModuleHelpersFactory(),K=0,Q=F,et.label=1;case 1:return K<Q.length?(Y=Q[K],tt=X(Y.id),[4,Y.registry(tt.bindFunction,tt.unbindFunction,tt.isboundFunction,tt.rebindFunction,tt.unbindAsyncFunction,tt.onActivationFunction,tt.onDeactivationFunction)]):[3,4];case 2:et.sent(),et.label=3;case 3:return K++,[3,1];case 4:return[2]}})})},it.prototype.unload=function(){for(var F=this,W=[],X=0;X<arguments.length;X++)W[X]=arguments[X];W.forEach(function(K){var Q=F._removeModuleBindings(K.id);F._deactivateSingletons(Q),F._removeModuleHandlers(K.id)})},it.prototype.unloadAsync=function(){for(var F=[],W=0;W<arguments.length;W++)F[W]=arguments[W];return __awaiter(this,void 0,void 0,function(){var X,K,Q,Y;return __generator(this,function(tt){switch(tt.label){case 0:X=0,K=F,tt.label=1;case 1:return X<K.length?(Q=K[X],Y=this._removeModuleBindings(Q.id),[4,this._deactivateSingletonsAsync(Y)]):[3,4];case 2:tt.sent(),this._removeModuleHandlers(Q.id),tt.label=3;case 3:return X++,[3,1];case 4:return[2]}})})},it.prototype.bind=function(F){var W=this.options.defaultScope||BindingScopeEnum.Transient,X=new Binding(F,W);return this._bindingDictionary.add(F,X),new BindingToSyntax(X)},it.prototype.rebind=function(F){return this.unbind(F),this.bind(F)},it.prototype.rebindAsync=function(F){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(W){switch(W.label){case 0:return[4,this.unbindAsync(F)];case 1:return W.sent(),[2,this.bind(F)]}})})},it.prototype.unbind=function(F){if(this._bindingDictionary.hasKey(F)){var W=this._bindingDictionary.get(F);this._deactivateSingletons(W)}this._removeServiceFromDictionary(F)},it.prototype.unbindAsync=function(F){return __awaiter(this,void 0,void 0,function(){var W;return __generator(this,function(X){switch(X.label){case 0:return this._bindingDictionary.hasKey(F)?(W=this._bindingDictionary.get(F),[4,this._deactivateSingletonsAsync(W)]):[3,2];case 1:X.sent(),X.label=2;case 2:return this._removeServiceFromDictionary(F),[2]}})})},it.prototype.unbindAll=function(){var F=this;this._bindingDictionary.traverse(function(W,X){F._deactivateSingletons(X)}),this._bindingDictionary=new Lookup},it.prototype.unbindAllAsync=function(){return __awaiter(this,void 0,void 0,function(){var F,W=this;return __generator(this,function(X){switch(X.label){case 0:return F=[],this._bindingDictionary.traverse(function(K,Q){F.push(W._deactivateSingletonsAsync(Q))}),[4,Promise.all(F)];case 1:return X.sent(),this._bindingDictionary=new Lookup,[2]}})})},it.prototype.onActivation=function(F,W){this._activations.add(F,W)},it.prototype.onDeactivation=function(F,W){this._deactivations.add(F,W)},it.prototype.isBound=function(F){var W=this._bindingDictionary.hasKey(F);return!W&&this.parent&&(W=this.parent.isBound(F)),W},it.prototype.isCurrentBound=function(F){return this._bindingDictionary.hasKey(F)},it.prototype.isBoundNamed=function(F,W){return this.isBoundTagged(F,NAMED_TAG,W)},it.prototype.isBoundTagged=function(F,W,X){var K=!1;if(this._bindingDictionary.hasKey(F)){var Q=this._bindingDictionary.get(F),Y=createMockRequest(this,F,W,X);K=Q.some(function(tt){return tt.constraint(Y)})}return!K&&this.parent&&(K=this.parent.isBoundTagged(F,W,X)),K},it.prototype.snapshot=function(){this._snapshots.push(ContainerSnapshot.of(this._bindingDictionary.clone(),this._middleware,this._activations.clone(),this._deactivations.clone(),this._moduleActivationStore.clone()))},it.prototype.restore=function(){var F=this._snapshots.pop();if(F===void 0)throw new Error(NO_MORE_SNAPSHOTS_AVAILABLE);this._bindingDictionary=F.bindings,this._activations=F.activations,this._deactivations=F.deactivations,this._middleware=F.middleware,this._moduleActivationStore=F.moduleActivationStore},it.prototype.createChild=function(F){var W=new it(F||this.options);return W.parent=this,W},it.prototype.applyMiddleware=function(){for(var F=[],W=0;W<arguments.length;W++)F[W]=arguments[W];var X=this._middleware?this._middleware:this._planAndResolve();this._middleware=F.reduce(function(K,Q){return Q(K)},X)},it.prototype.applyCustomMetadataReader=function(F){this._metadataReader=F},it.prototype.get=function(F){var W=this._getNotAllArgs(F,!1);return this._getButThrowIfAsync(W)},it.prototype.getAsync=function(F){return __awaiter(this,void 0,void 0,function(){var W;return __generator(this,function(X){return W=this._getNotAllArgs(F,!1),[2,this._get(W)]})})},it.prototype.getTagged=function(F,W,X){var K=this._getNotAllArgs(F,!1,W,X);return this._getButThrowIfAsync(K)},it.prototype.getTaggedAsync=function(F,W,X){return __awaiter(this,void 0,void 0,function(){var K;return __generator(this,function(Q){return K=this._getNotAllArgs(F,!1,W,X),[2,this._get(K)]})})},it.prototype.getNamed=function(F,W){return this.getTagged(F,NAMED_TAG,W)},it.prototype.getNamedAsync=function(F,W){return this.getTaggedAsync(F,NAMED_TAG,W)},it.prototype.getAll=function(F){var W=this._getAllArgs(F);return this._getButThrowIfAsync(W)},it.prototype.getAllAsync=function(F){var W=this._getAllArgs(F);return this._getAll(W)},it.prototype.getAllTagged=function(F,W,X){var K=this._getNotAllArgs(F,!0,W,X);return this._getButThrowIfAsync(K)},it.prototype.getAllTaggedAsync=function(F,W,X){var K=this._getNotAllArgs(F,!0,W,X);return this._getAll(K)},it.prototype.getAllNamed=function(F,W){return this.getAllTagged(F,NAMED_TAG,W)},it.prototype.getAllNamedAsync=function(F,W){return this.getAllTaggedAsync(F,NAMED_TAG,W)},it.prototype.resolve=function(F){var W=this.isBound(F);W||this.bind(F).toSelf();var X=this.get(F);return W||this.unbind(F),X},it.prototype._preDestroy=function(F,W){var X,K;if(Reflect.hasMetadata(PRE_DESTROY,F)){var Q=Reflect.getMetadata(PRE_DESTROY,F);return(K=(X=W)[Q.value])===null||K===void 0?void 0:K.call(X)}},it.prototype._removeModuleHandlers=function(F){var W=this._moduleActivationStore.remove(F);this._activations.removeIntersection(W.onActivations),this._deactivations.removeIntersection(W.onDeactivations)},it.prototype._removeModuleBindings=function(F){return this._bindingDictionary.removeByCondition(function(W){return W.moduleId===F})},it.prototype._deactivate=function(F,W){var X=this,K=Object.getPrototypeOf(W).constructor;try{if(this._deactivations.hasKey(F.serviceIdentifier)){var Q=this._deactivateContainer(W,this._deactivations.get(F.serviceIdentifier).values());if(isPromise(Q))return this._handleDeactivationError(Q.then(function(){return X._propagateContainerDeactivationThenBindingAndPreDestroyAsync(F,W,K)}),K)}var Y=this._propagateContainerDeactivationThenBindingAndPreDestroy(F,W,K);if(isPromise(Y))return this._handleDeactivationError(Y,K)}catch(tt){if(tt instanceof Error)throw new Error(ON_DEACTIVATION_ERROR(K.name,tt.message))}},it.prototype._handleDeactivationError=function(F,W){return __awaiter(this,void 0,void 0,function(){var X;return __generator(this,function(K){switch(K.label){case 0:return K.trys.push([0,2,,3]),[4,F];case 1:return K.sent(),[3,3];case 2:if(X=K.sent(),X instanceof Error)throw new Error(ON_DEACTIVATION_ERROR(W.name,X.message));return[3,3];case 3:return[2]}})})},it.prototype._deactivateContainer=function(F,W){for(var X=this,K=W.next();K.value;){var Q=K.value(F);if(isPromise(Q))return Q.then(function(){return X._deactivateContainerAsync(F,W)});K=W.next()}},it.prototype._deactivateContainerAsync=function(F,W){return __awaiter(this,void 0,void 0,function(){var X;return __generator(this,function(K){switch(K.label){case 0:X=W.next(),K.label=1;case 1:return X.value?[4,X.value(F)]:[3,3];case 2:return K.sent(),X=W.next(),[3,1];case 3:return[2]}})})},it.prototype._getContainerModuleHelpersFactory=function(){var F=this,W=function(G,O){G._binding.moduleId=O},X=function(G){return function(O){var b=F.bind(O);return W(b,G),b}},K=function(){return function(G){return F.unbind(G)}},Q=function(){return function(G){return F.unbindAsync(G)}},Y=function(){return function(G){return F.isBound(G)}},tt=function(G){return function(O){var b=F.rebind(O);return W(b,G),b}},et=function(G){return function(O,b){F._moduleActivationStore.addActivation(G,O,b),F.onActivation(O,b)}},q=function(G){return function(O,b){F._moduleActivationStore.addDeactivation(G,O,b),F.onDeactivation(O,b)}};return function(G){return{bindFunction:X(G),isboundFunction:Y(),onActivationFunction:et(G),onDeactivationFunction:q(G),rebindFunction:tt(G),unbindFunction:K(),unbindAsyncFunction:Q()}}},it.prototype._getAll=function(F){return Promise.all(this._get(F))},it.prototype._get=function(F){var W=__assign(__assign({},F),{contextInterceptor:function(K){return K},targetType:TargetTypeEnum.Variable});if(this._middleware){var X=this._middleware(W);if(X==null)throw new Error(INVALID_MIDDLEWARE_RETURN);return X}return this._planAndResolve()(W)},it.prototype._getButThrowIfAsync=function(F){var W=this._get(F);if(isPromiseOrContainsPromise(W))throw new Error(LAZY_IN_SYNC(F.serviceIdentifier));return W},it.prototype._getAllArgs=function(F){var W={avoidConstraints:!0,isMultiInject:!0,serviceIdentifier:F};return W},it.prototype._getNotAllArgs=function(F,W,X,K){var Q={avoidConstraints:!1,isMultiInject:W,serviceIdentifier:F,key:X,value:K};return Q},it.prototype._planAndResolve=function(){var F=this;return function(W){var X=plan(F._metadataReader,F,W.isMultiInject,W.targetType,W.serviceIdentifier,W.key,W.value,W.avoidConstraints);X=W.contextInterceptor(X);var K=resolve(X);return K}},it.prototype._deactivateIfSingleton=function(F){var W=this;if(F.activated)return isPromise(F.cache)?F.cache.then(function(X){return W._deactivate(F,X)}):this._deactivate(F,F.cache)},it.prototype._deactivateSingletons=function(F){for(var W=0,X=F;W<X.length;W++){var K=X[W],Q=this._deactivateIfSingleton(K);if(isPromise(Q))throw new Error(ASYNC_UNBIND_REQUIRED)}},it.prototype._deactivateSingletonsAsync=function(F){return __awaiter(this,void 0,void 0,function(){var W=this;return __generator(this,function(X){switch(X.label){case 0:return[4,Promise.all(F.map(function(K){return W._deactivateIfSingleton(K)}))];case 1:return X.sent(),[2]}})})},it.prototype._propagateContainerDeactivationThenBindingAndPreDestroy=function(F,W,X){return this.parent?this._deactivate.bind(this.parent)(F,W):this._bindingDeactivationAndPreDestroy(F,W,X)},it.prototype._propagateContainerDeactivationThenBindingAndPreDestroyAsync=function(F,W,X){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(K){switch(K.label){case 0:return this.parent?[4,this._deactivate.bind(this.parent)(F,W)]:[3,2];case 1:return K.sent(),[3,4];case 2:return[4,this._bindingDeactivationAndPreDestroyAsync(F,W,X)];case 3:K.sent(),K.label=4;case 4:return[2]}})})},it.prototype._removeServiceFromDictionary=function(F){try{this._bindingDictionary.remove(F)}catch{throw new Error(CANNOT_UNBIND+" "+getServiceIdentifierAsString(F))}},it.prototype._bindingDeactivationAndPreDestroy=function(F,W,X){var K=this;if(typeof F.onDeactivation=="function"){var Q=F.onDeactivation(W);if(isPromise(Q))return Q.then(function(){return K._preDestroy(X,W)})}return this._preDestroy(X,W)},it.prototype._bindingDeactivationAndPreDestroyAsync=function(F,W,X){return __awaiter(this,void 0,void 0,function(){return __generator(this,function(K){switch(K.label){case 0:return typeof F.onDeactivation!="function"?[3,2]:[4,F.onDeactivation(W)];case 1:K.sent(),K.label=2;case 2:return[4,this._preDestroy(X,W)];case 3:return K.sent(),[2]}})})},it}();function getFirstArrayDuplicate(it){for(var F=new Set,W=0,X=it;W<X.length;W++){var K=X[W];if(F.has(K))return K;F.add(K)}}function targetIsConstructorFunction(it){return it.prototype!==void 0}function _throwIfMethodParameter(it){if(it!==void 0)throw new Error(INVALID_DECORATOR_OPERATION)}function tagParameter(it,F,W,X){_throwIfMethodParameter(F),_tagParameterOrProperty(TAGGED,it,W.toString(),X)}function tagProperty(it,F,W){if(targetIsConstructorFunction(it))throw new Error(INVALID_DECORATOR_OPERATION);_tagParameterOrProperty(TAGGED_PROP,it.constructor,F,W)}function _ensureNoMetadataKeyDuplicates(it){var F=[];if(Array.isArray(it)){F=it;var W=getFirstArrayDuplicate(F.map(function(X){return X.key}));if(W!==void 0)throw new Error(DUPLICATED_METADATA+" "+W.toString())}else F=[it];return F}function _tagParameterOrProperty(it,F,W,X){var K=_ensureNoMetadataKeyDuplicates(X),Q={};Reflect.hasOwnMetadata(it,F)&&(Q=Reflect.getMetadata(it,F));var Y=Q[W];if(Y===void 0)Y=[];else for(var tt=function(O){if(K.some(function(b){return b.key===O.key}))throw new Error(DUPLICATED_METADATA+" "+O.key.toString())},et=0,q=Y;et<q.length;et++){var G=q[et];tt(G)}Y.push.apply(Y,K),Q[W]=Y,Reflect.defineMetadata(it,Q,F)}function createTaggedDecorator(it){return function(F,W,X){typeof X=="number"?tagParameter(F,W,X,it):tagProperty(F,W,it)}}function injectable(){return function(it){if(Reflect.hasOwnMetadata(PARAM_TYPES,it))throw new Error(DUPLICATED_INJECTABLE_DECORATOR);var F=Reflect.getMetadata(DESIGN_PARAM_TYPES,it)||[];return Reflect.defineMetadata(PARAM_TYPES,F,it),it}}function injectBase(it){return function(F){return function(W,X,K){if(F===void 0){var Q=typeof W=="function"?W.name:W.constructor.name;throw new Error(UNDEFINED_INJECT_ANNOTATION(Q))}return createTaggedDecorator(new Metadata(it,F))(W,X,K)}}}var inject=injectBase(INJECT_TAG),INJECTION=Symbol.for("INJECTION");function _proxyGetter(it,F,W,X){function K(){return X&&!Reflect.hasMetadata(INJECTION,this,F)&&Reflect.defineMetadata(INJECTION,W(),this,F),Reflect.hasMetadata(INJECTION,this,F)?Reflect.getMetadata(INJECTION,this,F):W()}function Q(Y){Reflect.defineMetadata(INJECTION,Y,this,F)}Object.defineProperty(it,F,{configurable:!0,enumerable:!0,get:K,set:Q})}function makePropertyInjectDecorator(it,F){return function(W){return function(X,K){var Q=function(){return it.get(W)};_proxyGetter(X,K,Q,F)}}}function makePropertyInjectNamedDecorator(it,F){return function(W,X){return function(K,Q){var Y=function(){return it.getNamed(W,X)};_proxyGetter(K,Q,Y,F)}}}function makePropertyInjectTaggedDecorator(it,F){return function(W,X,K){return function(Q,Y){var tt=function(){return it.getTagged(W,X,K)};_proxyGetter(Q,Y,tt,F)}}}function makePropertyMultiInjectDecorator(it,F){return function(W){return function(X,K){var Q=function(){return it.getAll(W)};_proxyGetter(X,K,Q,F)}}}function getDecorators(it,F){F===void 0&&(F=!0);var W=makePropertyInjectDecorator(it,F),X=makePropertyInjectNamedDecorator(it,F),K=makePropertyInjectTaggedDecorator(it,F),Q=makePropertyMultiInjectDecorator(it,F);return{lazyInject:W,lazyInjectNamed:X,lazyInjectTagged:K,lazyMultiInject:Q}}const container=new Container,{lazyInject,lazyInjectNamed,lazyInjectTagged,lazyMultiInject}=getDecorators(container),classesForCoco128=["person","bicycle","car","motorcycle","airplane","bus","train","truck","boat","traffic light","fire hydrant","stop sign","parking meter","bench","bird","cat","dog","horse","sheep","cow","elephant","bear","zebra","giraffe","backpack","umbrella","handbag","tie","suitcase","frisbee","skis","snowboard","sports ball","kite","baseball bat","baseball glove","skateboard","surfboard","tennis racket","bottle","wine glass","cup","fork","knife","spoon","bowl","banana","apple","sandwich","orange","broccoli","carrot","hot dog","pizza","donut","cake","chair","couch","potted plant","bed","dining table","toilet","tv","laptop","mouse","remote","keyboard","cell phone","microwave","oven","toaster","sink","refrigerator","book","clock","vase","scissors","teddy bear","hair drier","toothbrush"],optionsForCoco128={lineWidth:3,textFillStyle:"white",textBackgroundFillStyle:"#EB622D"},classesForStriga=["radicle","seed"],optionsForStriga={lineWidth:1,textFillStyle:"#EB622D",textBackgroundFillStyle:"transparent"};var __defProp$f=Object.defineProperty,__getOwnPropDesc$f=Object.getOwnPropertyDescriptor,__decorateClass$f=(it,F,W,X)=>{for(var K=X>1?void 0:X?__getOwnPropDesc$f(F,W):F,Q=it.length-1,Y;Q>=0;Q--)(Y=it[Q])&&(K=(X?Y(F,W,K):Y(K))||K);return X&&K&&__defProp$f(F,W,K),K};const BASE_URL="./data/models.json";let AvailablePublicModelsService=class{get(){return fetch(BASE_URL).then(it=>it.json()).then(it=>it.map(F=>F.type==="striga"?{...F,classes:classesForStriga,options:optionsForStriga}:{...F,classes:classesForCoco128,options:optionsForCoco128}))}};AvailablePublicModelsService=__decorateClass$f([injectable()],AvailablePublicModelsService);const AVAILABLE_PUBLIC_MODELS_SERVICE=Symbol("AvailablePublicModelsService");var __defProp$e=Object.defineProperty,__getOwnPropDesc$e=Object.getOwnPropertyDescriptor,__decorateClass$e=(it,F,W,X)=>{for(var K=X>1?void 0:X?__getOwnPropDesc$e(F,W):F,Q=it.length-1,Y;Q>=0;Q--)(Y=it[Q])&&(K=(X?Y(F,W,K):Y(K))||K);return X&&K&&__defProp$e(F,W,K),K};let Home=class extends s{constructor(){super(...arguments),this.models=[]}firstUpdated(){this.modelsSrv.get().then(it=>this.models=it)}renderItem(it){return x`
            <wli-onnx-model-item .model=${it}>
            </wli-onnx-model-item>
        `}render(){return x`
            <input
                disabled
                placeholder="Search model"
            ></input>
            <ul>
                ${this.models.map(this.renderItem.bind(this))}
            </ul>
        `}};Home.styles=i$3`
        :host {
            display: flex;
            flex-direction: column;
            margin: 24px;
            gap: 10px;
        }

        ul {
            list-style: none;
            padding: 0;
        }
    `;__decorateClass$e([lazyInject(AVAILABLE_PUBLIC_MODELS_SERVICE)],Home.prototype,"modelsSrv",2);__decorateClass$e([t()],Home.prototype,"models",2);Home=__decorateClass$e([e$1("wli-home")],Home);function isValidHttpStatusCodes(it){return it>=200&&it<=299}var __defProp$d=Object.defineProperty,__getOwnPropDesc$d=Object.getOwnPropertyDescriptor,__decorateClass$d=(it,F,W,X)=>{for(var K=X>1?void 0:X?__getOwnPropDesc$d(F,W):F,Q=it.length-1,Y;Q>=0;Q--)(Y=it[Q])&&(K=(X?Y(F,W,K):Y(K))||K);return X&&K&&__defProp$d(F,W,K),K};let HashService=class{async digest(it){const F=new TextEncoder().encode(it),W=await crypto.subtle.digest("SHA-256",F);return Array.from(new Uint8Array(W)).map(Q=>Q.toString(16).padStart(2,"0")).join("")}};HashService=__decorateClass$d([injectable()],HashService);const HASH_SERVICE=Symbol("HashService");var __defProp$c=Object.defineProperty,__getOwnPropDesc$c=Object.getOwnPropertyDescriptor,__decorateClass$c=(it,F,W,X)=>{for(var K=X>1?void 0:X?__getOwnPropDesc$c(F,W):F,Q=it.length-1,Y;Q>=0;Q--)(Y=it[Q])&&(K=(X?Y(F,W,K):Y(K))||K);return X&&K&&__defProp$c(F,W,K),K};const LOCAL_STORAGE_KEY="last-connected-user";let ActiveSessionService=class{get(){const it=localStorage.getItem(LOCAL_STORAGE_KEY);if(!it)return null;const F=localStorage.getItem(it);return F?JSON.parse(F):null}set(it){localStorage.setItem(LOCAL_STORAGE_KEY,it)}remove(){localStorage.removeItem(LOCAL_STORAGE_KEY)}};ActiveSessionService=__decorateClass$c([injectable()],ActiveSessionService);const ACTIVE_SESSION_SERVICE=Symbol("ActiveSessionService");var __defProp$b=Object.defineProperty,__getOwnPropDesc$b=Object.getOwnPropertyDescriptor,__decorateClass$b=(it,F,W,X)=>{for(var K=X>1?void 0:X?__getOwnPropDesc$b(F,W):F,Q=it.length-1,Y;Q>=0;Q--)(Y=it[Q])&&(K=(X?Y(F,W,K):Y(K))||K);return X&&K&&__defProp$b(F,W,K),K};const URL$1="https://api-infer.thya-technology.com/api/v1/customer/auth/login";let UserAuthentificationService=class{async post(it){const F=JSON.stringify(it),W=await this.hashSrv.digest(F);let X;try{X=await fetch(URL$1,{method:"POST",headers:{"Content-Type":"application/json"},body:F})}catch{const Q=localStorage.getItem(W);if(Q)return this.activeSessionSrv.set(W),[JSON.parse(Q)]}if(X){if(isValidHttpStatusCodes(X.status)){const Q=await X.json();return localStorage.setItem(W,JSON.stringify(Q.body)),this.activeSessionSrv.set(W),[Q.body]}const{message:K}=await X.json();return[null,{messages:Array.isArray(K)?K:[K]}]}return[null,{messages:["network error"]}]}};__decorateClass$b([inject(HASH_SERVICE)],UserAuthentificationService.prototype,"hashSrv",2);__decorateClass$b([inject(ACTIVE_SESSION_SERVICE)],UserAuthentificationService.prototype,"activeSessionSrv",2);UserAuthentificationService=__decorateClass$b([injectable()],UserAuthentificationService);const USER_AUTHENTIFICATION_SERVICE=Symbol("UserAuthentificationService");var __defProp$a=Object.defineProperty,__getOwnPropDesc$a=Object.getOwnPropertyDescriptor,__decorateClass$a=(it,F,W,X)=>{for(var K=X>1?void 0:X?__getOwnPropDesc$a(F,W):F,Q=it.length-1,Y;Q>=0;Q--)(Y=it[Q])&&(K=(X?Y(F,W,K):Y(K))||K);return X&&K&&__defProp$a(F,W,K),K};let Login=class extends s{constructor(){super(...arguments),this.email="",this.password="",this.messages=[]}render(){return x`
            <h2>Welcome back</h2>
            <p class="sign-up">
                Don’t have an account?
                <a
                    href="https://www.thya-technology.com/auth/register"
                    target="_blank"
                >
                    Sign up
                </a>
            </p>
            ${this.renderMessages()}
            <input
                placeholder="Email *"
                .value=${this.email}
                @input=${this.handleEmailInput}
            ></input>
            <input
                type="password"
                placeholder="Password *"
                .value=${this.password}
                @input=${this.handlePasswordInput}
            ></input>
            <div class="row">
                <div class="space"></div>
                <a
                    class="forgot-password"
                    href="https://www.thya-technology.com/auth/forgot-password"
                    target="_blank"
                >
                    Forgot password
                </a>
            </div>
            <button @click=${this.handleClick}>Login</button>
        `}renderMessages(){if(this.messages.length)return x`
                <p class="warning">
                    <strong>⚠️  Unable to connect !</strong> We encountered <strong>errors</strong>
                    when <strong>trying to connect</strong>. Details :
                </p>
                <ul class="warning">
                    ${this.messages.map(this.renderMessage)}
                </ul>
            `}renderMessage(it){return x`
            <li>
                ${it}
            </li>
        `}handleEmailInput(it){this.email=it.currentTarget.value}handlePasswordInput(it){this.password=it.currentTarget.value}async handleClick(){this.messages=[];const[it,F]=await this.authSrv.post({email:this.email,password:this.password});if(it){const W=new CustomEvent("wli-login",{detail:it,bubbles:!0,composed:!0});this.dispatchEvent(W)}else this.messages=F.messages}};Login.styles=i$3`
        :host {
            display: flex;
            flex-direction: column;
            margin: 24px;
            gap: 12px;
        }

        h2 {
            color: #FFFFFF;
            font-size: 40px;
            margin: 0 0 16px 0;
        }

        .sign-up {
            margin: 0 0 48px 0;
        }

        .sign-up a {
            color: var(--wli-primary);
        }

        .warning {
            margin: 0;
            color: #A7001E;
        }

        ul.warning {
            margin-bottom: 24px;
        }

        .row {
            display: flex;
        }

        .space {
            flex: 1;
        }

        .forgot-password {
            color: #FFFFFF;
            font-size: 12px;
        }

        input {
            height: 45px;
            box-sizing: border-box;
            color: #FFFFFF;
            background-color: #2c2a73;
            border: 1px solid #4E5771;
            padding: 10px 20px;
            border-radius: 8px;
        }

        button {
            background-color: var(--wli-primary);
            border-radius: 30px;
            cursor: pointer;
            padding: 9px 20px;
            font-weight: 700;
            font-size: 14px;
            color: #FFFFFF;
            border: 1px solid var(--wli-primary);
            transition: all .3s ease-in-out;
            margin-top: 48px;
        }

        button:hover,
        button:focus {
            background-color: #FFFFFF;
            color: var(--wli-primary);
        }
    `;__decorateClass$a([lazyInject(USER_AUTHENTIFICATION_SERVICE)],Login.prototype,"authSrv",2);__decorateClass$a([t()],Login.prototype,"email",2);__decorateClass$a([t()],Login.prototype,"password",2);__decorateClass$a([t()],Login.prototype,"messages",2);Login=__decorateClass$a([e$1("wli-login")],Login);var __defProp$9=Object.defineProperty,__getOwnPropDesc$9=Object.getOwnPropertyDescriptor,__decorateClass$9=(it,F,W,X)=>{for(var K=X>1?void 0:X?__getOwnPropDesc$9(F,W):F,Q=it.length-1,Y;Q>=0;Q--)(Y=it[Q])&&(K=(X?Y(F,W,K):Y(K))||K);return X&&K&&__defProp$9(F,W,K),K};let MainLayout=class extends s{render(){return x`
            <slot />
        `}};MainLayout.styles=i$3`
        :host {
            display: block;
            margin: 0 auto;
            max-width: 390px;
        }
    `;MainLayout=__decorateClass$9([e$1("wli-main-layout")],MainLayout);var __defProp$8=Object.defineProperty,__getOwnPropDesc$8=Object.getOwnPropertyDescriptor,__decorateClass$8=(it,F,W,X)=>{for(var K=X>1?void 0:X?__getOwnPropDesc$8(F,W):F,Q=it.length-1,Y;Q>=0;Q--)(Y=it[Q])&&(K=(X?Y(F,W,K):Y(K))||K);return X&&K&&__defProp$8(F,W,K),K};let MediaPlaceholder=class extends s{render(){return x`
            <svg
                xmlns="http://www.w3.org/2000/svg"
                height="96px"
                width="96px"
                viewBox="0 0 24 24"
                fill="#808080"
            >
                <path
                    d="M0 0h24v24H0V0z"
                    fill="none"
                />
                <path d="M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-4.86 8.86l-3 3.87L9 13.14 6 17h12l-3.86-5.14z"/>
            </svg>
        `}};MediaPlaceholder.styles=i$3`
        :host {
            display: block;
        }

        svg {
            display: block;
        }
    `;MediaPlaceholder=__decorateClass$8([e$1("wli-media-placeholder")],MediaPlaceholder);var __defProp$7=Object.defineProperty,__getOwnPropDesc$7=Object.getOwnPropertyDescriptor,__decorateClass$7=(it,F,W,X)=>{for(var K=X>1?void 0:X?__getOwnPropDesc$7(F,W):F,Q=it.length-1,Y;Q>=0;Q--)(Y=it[Q])&&(K=(X?Y(F,W,K):Y(K))||K);return X&&K&&__defProp$7(F,W,K),K};let OnnxActions=class extends s{constructor(){super(...arguments),this.disabled=!1,this.isStarted=!1}render(){return x`
            <hr />
            <div class="actions">
                <button
                    @click=${this.handleBack}
                >
                    Back
                </button>
                <button
                    ?disabled=${this.mode==="stream"}
                    @click=${this.handleRecord}
                >
                    Record
                </button>
                <button
                    @click=${this.handleUpload}
                >
                    Upload
                </button>
                <button
                    ?disabled=${this.disabled}
                    @click=${this.handleCapture}
                >
                    ${this.isStarted?"Stop":"Capture"}
                </button>
            </div>
        `}handleCapture(){let it;this.isStarted?it=new Event("wli-onnx-actions-stop",{bubbles:!0,composed:!0}):it=new Event("wli-onnx-actions-start",{bubbles:!0,composed:!0}),this.dispatchEvent(it),this.mode==="stream"&&(this.isStarted=!this.isStarted)}handleBack(){const it=new Event("wli-onnx-actions-back",{bubbles:!0,composed:!0});this.dispatchEvent(it)}handleRecord(){const it=new Event("wli-onnx-actions-record",{bubbles:!0,composed:!0});this.dispatchEvent(it)}handleUpload(){const it=new Event("wli-onnx-actions-upload",{bubbles:!0,composed:!0});this.dispatchEvent(it)}};OnnxActions.styles=i$3`
        :host {
            display: block;
            background-color: var(--wli-secondary);
            height: 72px;
        }

        hr {
            margin: 0;
            border-color: black;
        }

        .actions {
            display: flex;
            justify-content: center;
            gap: 24px;
            margin: 24px 0;
        }
    `;__decorateClass$7([i("button")],OnnxActions.prototype,"buttonElm",2);__decorateClass$7([n$1({type:Boolean,attribute:"disabled"})],OnnxActions.prototype,"disabled",2);__decorateClass$7([n$1({type:String,attribute:"mode"})],OnnxActions.prototype,"mode",2);__decorateClass$7([t()],OnnxActions.prototype,"isStarted",2);OnnxActions=__decorateClass$7([e$1("wli-onnx-actions")],OnnxActions);var __defProp$6=Object.defineProperty,__getOwnPropDesc$6=Object.getOwnPropertyDescriptor,__decorateClass$6=(it,F,W,X)=>{for(var K=X>1?void 0:X?__getOwnPropDesc$6(F,W):F,Q=it.length-1,Y;Q>=0;Q--)(Y=it[Q])&&(K=(X?Y(F,W,K):Y(K))||K);return X&&K&&__defProp$6(F,W,K),K};const DATABASE_NAME="OnnxModels",TABLE_NAME="models";let OnnxModelsDatabaseService=class{constructor(){const it=window.indexedDB.open(DATABASE_NAME);it.onerror=this.onOpenRequestError.bind(this),it.onupgradeneeded=this.onOpenrequestUpgradeNeeded.bind(this),it.onsuccess=this.onOpenRequestSuccess.bind(this),this.promise=new Promise((F,W)=>{this.resolve=F,this.reject=W})}async set(it,F){console.log("[OnnxModelsDatabaseService] set",F,it);const Q=(await this.getDatabase()).transaction(TABLE_NAME,"readwrite").objectStore("models").add(F,it);return new Promise((Y,tt)=>{Q.onsuccess=()=>Y(),Q.onerror=()=>tt()})}async get(it){console.log("[OnnxModelsDatabaseService] get",it);const K=(await this.getDatabase()).transaction(TABLE_NAME,"readwrite").objectStore("models").get(it);return new Promise((Q,Y)=>{K.onsuccess=()=>Q(K.result),K.onerror=()=>Y()})}async has(it){return console.log("[OnnxModelsDatabaseService] has",it),this.get(it).then(F=>!!F)}getDatabase(){return this.database?Promise.resolve(this.database):this.promise}onOpenRequestError(){this.reject(new Error("[OnnxModelsDatabaseService] Error while opening the database."))}onOpenrequestUpgradeNeeded(it){it.target.result.createObjectStore("models")}onOpenRequestSuccess(it){this.database=it.target.result,this.resolve(this.database)}};OnnxModelsDatabaseService=__decorateClass$6([injectable()],OnnxModelsDatabaseService);const ONNX_MODELS_DATABASE_SERVICE=Symbol("OnnxModelsDatabaseService");var __defProp$5=Object.defineProperty,__getOwnPropDesc$5=Object.getOwnPropertyDescriptor,__decorateClass$5=(it,F,W,X)=>{for(var K=X>1?void 0:X?__getOwnPropDesc$5(F,W):F,Q=it.length-1,Y;Q>=0;Q--)(Y=it[Q])&&(K=(X?Y(F,W,K):Y(K))||K);return X&&K&&__defProp$5(F,W,K),K};let OnnxModelItem=class extends s{constructor(){super(...arguments),this.handleClick=()=>{const it=new CustomEvent("wli-home-run",{detail:this.model,bubbles:!0,composed:!0});this.dispatchEvent(it)},this.handleDownload=async()=>{const F=await(await fetch(this.model.path)).arrayBuffer();await this.onnxModelsDbSrv.set(this.model.uuid,F),this.isInDatabase=!0}}firstUpdated(){this.onnxModelsDbSrv.has(this.model.uuid).then(it=>{this.isEnabled=!0,this.isInDatabase=it})}render(){return x`
            <li>
                <p>${this.model.name}</p>
                <div class="empty"></div>
                ${this.renderActionButton()}
            </li>
        `}renderActionButton(){return this.isInDatabase?x`
                <button
                    @click=${this.handleClick}
                >
                    Run
                </button>
            `:x`
            <button
                ?disabled=${!this.isEnabled}
                @click=${this.handleDownload}
            >
                Download
            </button>
        `}};OnnxModelItem.styles=i$3`
        :host {
        }

        li {
            display: flex;
            margin-bottom: 24px;
            justify-content: space-between;
            align-items: center;
            gap: 6px;
        }

        p {
            margin: 0;
        }

        .empty {
            flex: 1;
        }
    `;__decorateClass$5([lazyInject(ONNX_MODELS_DATABASE_SERVICE)],OnnxModelItem.prototype,"onnxModelsDbSrv",2);__decorateClass$5([n$1({type:Object})],OnnxModelItem.prototype,"model",2);__decorateClass$5([t()],OnnxModelItem.prototype,"isInDatabase",2);__decorateClass$5([t()],OnnxModelItem.prototype,"isEnabled",2);OnnxModelItem=__decorateClass$5([e$1("wli-onnx-model-item")],OnnxModelItem);/**
 * MediaStream ImageCapture polyfill
 *
 * @license
 * Copyright 2018 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */let ImageCapture$1=window.ImageCapture;typeof ImageCapture$1>"u"&&(ImageCapture$1=class{constructor(it){if(it.kind!=="video")throw new DOMException("NotSupportedError");this._videoStreamTrack=it,"readyState"in this._videoStreamTrack||(this._videoStreamTrack.readyState="live"),this._previewStream=new MediaStream([it]),this.videoElement=document.createElement("video"),this.videoElementPlaying=new Promise(F=>{this.videoElement.addEventListener("playing",F)}),HTMLMediaElement?this.videoElement.srcObject=this._previewStream:this.videoElement.src=URL.createObjectURL(this._previewStream),this.videoElement.muted=!0,this.videoElement.setAttribute("playsinline",""),this.videoElement.play(),this.canvasElement=document.createElement("canvas"),this.canvas2dContext=this.canvasElement.getContext("2d")}get videoStreamTrack(){return this._videoStreamTrack}getPhotoCapabilities(){return new Promise(function(F,W){const X={current:0,min:0,max:0};F({exposureCompensation:X,exposureMode:"none",fillLightMode:"none",focusMode:"none",imageHeight:X,imageWidth:X,iso:X,redEyeReduction:!1,whiteBalanceMode:"none",zoom:X}),W(new DOMException("OperationError"))})}setOptions(it={}){return new Promise(function(W,X){})}takePhoto(){const it=this;return new Promise(function(W,X){if(it._videoStreamTrack.readyState!=="live")return X(new DOMException("InvalidStateError"));it.videoElementPlaying.then(()=>{try{it.canvasElement.width=it.videoElement.videoWidth,it.canvasElement.height=it.videoElement.videoHeight,it.canvas2dContext.drawImage(it.videoElement,0,0),it.canvasElement.toBlob(W)}catch{X(new DOMException("UnknownError"))}})})}grabFrame(){const it=this;return new Promise(function(W,X){if(it._videoStreamTrack.readyState!=="live")return X(new DOMException("InvalidStateError"));it.videoElementPlaying.then(()=>{try{it.canvasElement.width=it.videoElement.videoWidth,it.canvasElement.height=it.videoElement.videoHeight,it.canvas2dContext.drawImage(it.videoElement,0,0),W(window.createImageBitmap(it.canvasElement))}catch{X(new DOMException("UnknownError"))}})})}});window.ImageCapture=ImageCapture$1;function drawCanvas(it,F){it.width=Number(getComputedStyle(it).width.split("px")[0]),it.height=Number(getComputedStyle(it).height.split("px")[0]);let W=Math.min(it.width/F.width,it.height/F.height),X=(it.width-F.width*W)/2,K=(it.height-F.height*W)/2;it.getContext("2d").clearRect(0,0,it.width,it.height),it.getContext("2d").drawImage(F,0,0,F.width,F.height,X,K,F.width*W,F.height*W)}function preProcess({data:it}){const F=[],W=[],X=[];for(let K=0;K<it.length;K+=4)F.push(it[K]/255),W.push(it[K+1]/255),X.push(it[K+2]/255);return[...F,...W,...X]}function postProcess(it,F,W,X){const{data:K,dims:Q}=it,Y=Q[2];let tt=[];for(let q=0;q<Y;q++){const[G,O]=[...Array(X.length).keys()].map(st=>[st,K[Y*(st+4)+q]]).reduce((st,ct)=>ct[1]>st[1]?ct:st,[0,0]);if(O<.3)continue;const b=X[G],j=K[q],U=K[Y+q],J=K[2*Y+q],nt=K[3*Y+q],rt=(j-J/2)/F*F,ot=(U-nt/2)/W*W,at=(j+J/2)/F*F,ut=(U+nt/2)/W*W;tt.push([rt,ot,at,ut,b,O])}tt=tt.sort((q,G)=>G[5]-q[5]);const et=[];for(;tt.length>0;)et.push(tt[0]),tt=tt.filter(q=>iou(tt[0],q)<.7||tt[0][4]!==q[4]);return et}function iou(it,F){return intersection(it,F)/union(it,F)}function union(it,F){const[W,X,K,Q]=it,[Y,tt,et,q]=F,G=(K-W)*(Q-X),O=(et-Y)*(q-tt);return G+O-intersection(it,F)}function intersection(it,F){const[W,X,K,Q]=it,[Y,tt,et,q]=F,G=Math.max(W,Y),O=Math.max(X,tt),b=Math.min(K,et),j=Math.min(Q,q);return(b-G)*(j-O)}function drawBoxes(it,F,W){const X=it.getContext("2d");X.strokeStyle="#EB622D",X.lineWidth=W.lineWidth,X.font="18px serif",F.forEach(([K,Q,Y,tt,et,q])=>{const G=[et,q.toPrecision(2)].join(" ");X.strokeRect(K,Q,Y-K,tt-Q),X.fillStyle=W.textBackgroundFillStyle;const O=X.measureText(G).width;X.fillRect(K-2,Q-24,O+10,24),X.fillStyle=W.textFillStyle,X.fillText(G,K+1,Q-6)})}var ort_min={exports:{}};/*!
* ONNX Runtime Web v1.15.1
* Copyright (c) Microsoft Corporation. All rights reserved.
* Licensed under the MIT License.
*/(function(module,exports){(function(it,F){module.exports=F()})(self,()=>(()=>{var __webpack_modules__={8453:(it,F,W)=>{W.r(F),W.d(F,{InferenceSession:()=>j,Tensor:()=>O,env:()=>Y,registerBackend:()=>Q});const X={},K=[],Q=(U,J,nt)=>{if(!J||typeof J.init!="function"||typeof J.createSessionHandler!="function")throw new TypeError("not a valid backend");{const rt=X[U];if(rt===void 0)X[U]={backend:J,priority:nt};else{if(rt.priority>nt)return;if(rt.priority===nt&&rt.backend!==J)throw new Error(`cannot register backend "${U}" using priority ${nt}`)}if(nt>=0){const ot=K.indexOf(U);ot!==-1&&K.splice(ot,1);for(let at=0;at<K.length;at++)if(X[K[at]].priority<=nt)return void K.splice(at,0,U);K.push(U)}}},Y=new class{constructor(){this.wasm={},this.webgl={},this.webgpu={},this.logLevelInternal="warning"}set logLevel(U){if(U!==void 0){if(typeof U!="string"||["verbose","info","warning","error","fatal"].indexOf(U)===-1)throw new Error(`Unsupported logging level: ${U}`);this.logLevelInternal=U}}get logLevel(){return this.logLevelInternal}},tt=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),et=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]);let q=!1;class G{constructor(J,nt,rt){let ot,at,ut;if((()=>{if(!q){q=!0;const ct=typeof BigInt64Array<"u"&&typeof BigInt64Array.from=="function",dt=typeof BigUint64Array<"u"&&typeof BigUint64Array.from=="function";ct&&(tt.set("int64",BigInt64Array),et.set(BigInt64Array,"int64")),dt&&(tt.set("uint64",BigUint64Array),et.set(BigUint64Array,"uint64"))}})(),typeof J=="string")if(ot=J,ut=rt,J==="string"){if(!Array.isArray(nt))throw new TypeError("A string tensor's data must be a string array.");at=nt}else{const ct=tt.get(J);if(ct===void 0)throw new TypeError(`Unsupported tensor type: ${J}.`);if(Array.isArray(nt))at=ct.from(nt);else{if(!(nt instanceof ct))throw new TypeError(`A ${ot} tensor's data must be type of ${ct}`);at=nt}}else if(ut=nt,Array.isArray(J)){if(J.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");const ct=typeof J[0];if(ct==="string")ot="string",at=J;else{if(ct!=="boolean")throw new TypeError(`Invalid element type of data array: ${ct}.`);ot="bool",at=Uint8Array.from(J)}}else{const ct=et.get(J.constructor);if(ct===void 0)throw new TypeError(`Unsupported type for tensor data: ${J.constructor}.`);ot=ct,at=J}if(ut===void 0)ut=[at.length];else if(!Array.isArray(ut))throw new TypeError("A tensor's dims must be a number array");const st=(ct=>{let dt=1;for(let pt=0;pt<ct.length;pt++){const lt=ct[pt];if(typeof lt!="number"||!Number.isSafeInteger(lt))throw new TypeError(`dims[${pt}] must be an integer, got: ${lt}`);if(lt<0)throw new RangeError(`dims[${pt}] must be a non-negative integer, got: ${lt}`);dt*=lt}return dt})(ut);if(st!==at.length)throw new Error(`Tensor's size(${st}) does not match data length(${at.length}).`);this.dims=ut,this.type=ot,this.data=at,this.size=st}static bufferToTensor(J,nt){if(J===void 0)throw new Error("Image buffer must be defined");if(nt.height===void 0||nt.width===void 0)throw new Error("Image height and width must be defined");if(nt.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");const{height:rt,width:ot}=nt,at=nt.norm??{mean:255,bias:0};let ut,st;ut=typeof at.mean=="number"?[at.mean,at.mean,at.mean,at.mean]:[at.mean[0],at.mean[1],at.mean[2],at.mean[3]??255],st=typeof at.bias=="number"?[at.bias,at.bias,at.bias,at.bias]:[at.bias[0],at.bias[1],at.bias[2],at.bias[3]??0];const ct=nt.bitmapFormat!==void 0?nt.bitmapFormat:"RGBA",dt=nt.tensorFormat!==void 0&&nt.tensorFormat!==void 0?nt.tensorFormat:"RGB",pt=rt*ot,lt=dt==="RGBA"?new Float32Array(4*pt):new Float32Array(3*pt);let ft=4,gt=0,_t=1,wt=2,bt=3,Ot=0,vt=pt,xt=2*pt,Rt=-1;ct==="RGB"&&(ft=3,gt=0,_t=1,wt=2,bt=-1),dt==="RGBA"?Rt=3*pt:dt==="RBG"?(Ot=0,xt=pt,vt=2*pt):dt==="BGR"&&(xt=0,vt=pt,Ot=2*pt);for(let kt=0;kt<pt;kt++,gt+=ft,wt+=ft,_t+=ft,bt+=ft)lt[Ot++]=(J[gt]+st[0])/ut[0],lt[vt++]=(J[_t]+st[1])/ut[1],lt[xt++]=(J[wt]+st[2])/ut[2],Rt!==-1&&bt!==-1&&(lt[Rt++]=(J[bt]+st[3])/ut[3]);return new G("float32",lt,dt==="RGBA"?[1,4,rt,ot]:[1,3,rt,ot])}static async fromImage(J,nt){const rt=typeof HTMLImageElement<"u"&&J instanceof HTMLImageElement,ot=typeof ImageData<"u"&&J instanceof ImageData,at=typeof ImageBitmap<"u"&&J instanceof ImageBitmap,ut=typeof J=="string";let st,ct=nt??{};if(rt){const dt=document.createElement("canvas");dt.width=J.width,dt.height=J.height;const pt=dt.getContext("2d");if(pt==null)throw new Error("Can not access image data");{let lt=J.height,ft=J.width;if(nt!==void 0&&nt.resizedHeight!==void 0&&nt.resizedWidth!==void 0&&(lt=nt.resizedHeight,ft=nt.resizedWidth),nt!==void 0){if(ct=nt,nt.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");if(ct.tensorFormat="RGBA",nt.height!==void 0&&nt.height!==lt)throw new Error("Image input config height doesn't match HTMLImageElement height");if(ct.height=lt,nt.width!==void 0&&nt.width!==ft)throw new Error("Image input config width doesn't match HTMLImageElement width");ct.width=ft}else ct.tensorFormat="RGBA",ct.height=lt,ct.width=ft;pt.drawImage(J,0,0),st=pt.getImageData(0,0,ft,lt).data}}else{if(!ot){if(at){if(nt===void 0)throw new Error("Please provide image config with format for Imagebitmap");if(nt.bitmapFormat!==void 0)throw new Error("Image input config format must be defined for ImageBitmap");const dt=document.createElement("canvas").getContext("2d");if(dt!=null){const pt=J.height,lt=J.width;if(dt.drawImage(J,0,0,lt,pt),st=dt.getImageData(0,0,lt,pt).data,nt!==void 0){if(nt.height!==void 0&&nt.height!==pt)throw new Error("Image input config height doesn't match ImageBitmap height");if(ct.height=pt,nt.width!==void 0&&nt.width!==lt)throw new Error("Image input config width doesn't match ImageBitmap width");ct.width=lt}else ct.height=pt,ct.width=lt;return G.bufferToTensor(st,ct)}throw new Error("Can not access image data")}if(ut)return new Promise((dt,pt)=>{const lt=document.createElement("canvas"),ft=lt.getContext("2d");if(!J||!ft)return pt();const gt=new Image;gt.crossOrigin="Anonymous",gt.src=J,gt.onload=()=>{lt.width=gt.width,lt.height=gt.height,ft.drawImage(gt,0,0,lt.width,lt.height);const _t=ft.getImageData(0,0,lt.width,lt.height);if(nt!==void 0){if(nt.height!==void 0&&nt.height!==lt.height)throw new Error("Image input config height doesn't match height");if(ct.height=lt.height,nt.width!==void 0&&nt.width!==lt.width)throw new Error("Image input config width doesn't match width");ct.width=lt.width}else ct.height=lt.height,ct.width=lt.width;dt(G.bufferToTensor(_t.data,ct))}});throw new Error("Input data provided is not supported - aborted tensor creation")}{const dt="RGBA";let pt,lt;if(nt!==void 0&&nt.resizedWidth!==void 0&&nt.resizedHeight!==void 0?(pt=nt.resizedHeight,lt=nt.resizedWidth):(pt=J.height,lt=J.width),nt!==void 0){if(ct=nt,nt.bitmapFormat!==void 0&&nt.bitmapFormat!==dt)throw new Error("Image input config format must be RGBA for ImageData");ct.bitmapFormat="RGBA"}else ct.bitmapFormat="RGBA";if(ct.height=pt,ct.width=lt,nt!==void 0){const ft=document.createElement("canvas");ft.width=lt,ft.height=pt;const gt=ft.getContext("2d");if(gt==null)throw new Error("Can not access image data");gt.putImageData(J,0,0),st=gt.getImageData(0,0,lt,pt).data}else st=J.data}}if(st!==void 0)return G.bufferToTensor(st,ct);throw new Error("Input data provided is not supported - aborted tensor creation")}toDataURL(J){const nt=document.createElement("canvas");nt.width=this.dims[3],nt.height=this.dims[2];const rt=nt.getContext("2d");if(rt!=null){let ot,at;(J==null?void 0:J.tensorLayout)!==void 0&&J.tensorLayout==="NHWC"?(ot=this.dims[2],at=this.dims[3]):(ot=this.dims[3],at=this.dims[2]);const ut=(J==null?void 0:J.format)!==void 0?J.format:"RGB",st=J==null?void 0:J.norm;let ct,dt;st===void 0||st.mean===void 0?ct=[255,255,255,255]:typeof st.mean=="number"?ct=[st.mean,st.mean,st.mean,st.mean]:(ct=[st.mean[0],st.mean[1],st.mean[2],0],st.mean[3]!==void 0&&(ct[3]=st.mean[3])),st===void 0||st.bias===void 0?dt=[0,0,0,0]:typeof st.bias=="number"?dt=[st.bias,st.bias,st.bias,st.bias]:(dt=[st.bias[0],st.bias[1],st.bias[2],0],st.bias[3]!==void 0&&(dt[3]=st.bias[3]));const pt=at*ot;let lt=0,ft=pt,gt=2*pt,_t=-1;ut==="RGBA"?(lt=0,ft=pt,gt=2*pt,_t=3*pt):ut==="RGB"?(lt=0,ft=pt,gt=2*pt):ut==="RBG"&&(lt=0,gt=pt,ft=2*pt);for(let wt=0;wt<at;wt++)for(let bt=0;bt<ot;bt++){const Ot=(this.data[lt++]-dt[0])*ct[0],vt=(this.data[ft++]-dt[1])*ct[1],xt=(this.data[gt++]-dt[2])*ct[2],Rt=_t===-1?255:(this.data[_t++]-dt[3])*ct[3];rt.fillStyle="rgba("+Ot+","+vt+","+xt+","+Rt+")",rt.fillRect(bt,wt,1,1)}return nt.toDataURL()}throw new Error("Can not access image data")}toImageData(J){const nt=document.createElement("canvas").getContext("2d");let rt;if(nt==null)throw new Error("Can not access image data");{let ot,at,ut;(J==null?void 0:J.tensorLayout)!==void 0&&J.tensorLayout==="NHWC"?(ot=this.dims[2],at=this.dims[1],ut=this.dims[3]):(ot=this.dims[3],at=this.dims[2],ut=this.dims[1]);const st=J!==void 0&&J.format!==void 0?J.format:"RGB",ct=J==null?void 0:J.norm;let dt,pt;ct===void 0||ct.mean===void 0?dt=[255,255,255,255]:typeof ct.mean=="number"?dt=[ct.mean,ct.mean,ct.mean,ct.mean]:(dt=[ct.mean[0],ct.mean[1],ct.mean[2],255],ct.mean[3]!==void 0&&(dt[3]=ct.mean[3])),ct===void 0||ct.bias===void 0?pt=[0,0,0,0]:typeof ct.bias=="number"?pt=[ct.bias,ct.bias,ct.bias,ct.bias]:(pt=[ct.bias[0],ct.bias[1],ct.bias[2],0],ct.bias[3]!==void 0&&(pt[3]=ct.bias[3]));const lt=at*ot;if(J!==void 0){if(J.height!==void 0&&J.height!==at)throw new Error("Image output config height doesn't match tensor height");if(J.width!==void 0&&J.width!==ot)throw new Error("Image output config width doesn't match tensor width");if(J.format!==void 0&&ut===4&&J.format!=="RGBA"||ut===3&&J.format!=="RGB"&&J.format!=="BGR")throw new Error("Tensor format doesn't match input tensor dims")}const ft=4;let gt=0,_t=1,wt=2,bt=3,Ot=0,vt=lt,xt=2*lt,Rt=-1;st==="RGBA"?(Ot=0,vt=lt,xt=2*lt,Rt=3*lt):st==="RGB"?(Ot=0,vt=lt,xt=2*lt):st==="RBG"&&(Ot=0,xt=lt,vt=2*lt),rt=nt.createImageData(ot,at);for(let kt=0;kt<at*ot;gt+=ft,_t+=ft,wt+=ft,bt+=ft,kt++)rt.data[gt]=(this.data[Ot++]-pt[0])*dt[0],rt.data[_t]=(this.data[vt++]-pt[1])*dt[1],rt.data[wt]=(this.data[xt++]-pt[2])*dt[2],rt.data[bt]=Rt===-1?255:(this.data[Rt++]-pt[3])*dt[3]}return rt}reshape(J){return new G(this.type,this.data,J)}}const O=G;class b{constructor(J){this.handler=J}async run(J,nt,rt){const ot={};let at={};if(typeof J!="object"||J===null||J instanceof O||Array.isArray(J))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let ut=!0;if(typeof nt=="object"){if(nt===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(nt instanceof O)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(nt)){if(nt.length===0)throw new TypeError("'fetches' cannot be an empty array.");ut=!1;for(const dt of nt){if(typeof dt!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(dt)===-1)throw new RangeError(`'fetches' contains invalid output name: ${dt}.`);ot[dt]=null}if(typeof rt=="object"&&rt!==null)at=rt;else if(rt!==void 0)throw new TypeError("'options' must be an object.")}else{let dt=!1;const pt=Object.getOwnPropertyNames(nt);for(const lt of this.outputNames)if(pt.indexOf(lt)!==-1){const ft=nt[lt];(ft===null||ft instanceof O)&&(dt=!0,ut=!1,ot[lt]=ft)}if(dt){if(typeof rt=="object"&&rt!==null)at=rt;else if(rt!==void 0)throw new TypeError("'options' must be an object.")}else at=nt}}else if(nt!==void 0)throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const dt of this.inputNames)if(J[dt]===void 0)throw new Error(`input '${dt}' is missing in 'feeds'.`);if(ut)for(const dt of this.outputNames)ot[dt]=null;const st=await this.handler.run(J,ot,at),ct={};for(const dt in st)Object.hasOwnProperty.call(st,dt)&&(ct[dt]=new O(st[dt].type,st[dt].data,st[dt].dims));return ct}static async create(J,nt,rt,ot){let at,ut={};if(typeof J=="string"){if(at=J,typeof nt=="object"&&nt!==null)ut=nt;else if(nt!==void 0)throw new TypeError("'options' must be an object.")}else if(J instanceof Uint8Array){if(at=J,typeof nt=="object"&&nt!==null)ut=nt;else if(nt!==void 0)throw new TypeError("'options' must be an object.")}else{if(!(J instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&J instanceof SharedArrayBuffer))throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");{const pt=J;let lt=0,ft=J.byteLength;if(typeof nt=="object"&&nt!==null)ut=nt;else if(typeof nt=="number"){if(lt=nt,!Number.isSafeInteger(lt))throw new RangeError("'byteOffset' must be an integer.");if(lt<0||lt>=pt.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${pt.byteLength}).`);if(ft=J.byteLength-lt,typeof rt=="number"){if(ft=rt,!Number.isSafeInteger(ft))throw new RangeError("'byteLength' must be an integer.");if(ft<=0||lt+ft>pt.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${pt.byteLength-lt}].`);if(typeof ot=="object"&&ot!==null)ut=ot;else if(ot!==void 0)throw new TypeError("'options' must be an object.")}else if(rt!==void 0)throw new TypeError("'byteLength' must be a number.")}else if(nt!==void 0)throw new TypeError("'options' must be an object.");at=new Uint8Array(pt,lt,ft)}}const st=(ut.executionProviders||[]).map(pt=>typeof pt=="string"?pt:pt.name),ct=await(async pt=>{const lt=pt.length===0?K:pt,ft=[];for(const gt of lt){const _t=X[gt];if(_t){if(_t.initialized)return _t.backend;if(_t.aborted)continue;const wt=!!_t.initPromise;try{return wt||(_t.initPromise=_t.backend.init()),await _t.initPromise,_t.initialized=!0,_t.backend}catch(bt){wt||ft.push({name:gt,err:bt}),_t.aborted=!0}finally{delete _t.initPromise}}}throw new Error(`no available backend found. ERR: ${ft.map(gt=>`[${gt.name}] ${gt.err}`).join(", ")}`)})(st),dt=await ct.createSessionHandler(at,ut);return new b(dt)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}const j=b},5716:(it,F,W)=>{F.R=void 0;const X=W(6027),K=W(1723);F.R=new class{async init(){}async createSessionHandler(Q,Y){const tt=new X.Session(Y);return await tt.loadModel(Q),new K.OnnxjsSessionHandler(tt)}}},2818:(it,F,W)=>{F.c8=F.rX=void 0;const X=W(8453),K=W(5381),Q=W(9544),Y=W(6640);F.rX=()=>{if((typeof X.env.wasm.initTimeout!="number"||X.env.wasm.initTimeout<0)&&(X.env.wasm.initTimeout=0),typeof X.env.wasm.simd!="boolean"&&(X.env.wasm.simd=!0),typeof X.env.wasm.proxy!="boolean"&&(X.env.wasm.proxy=!1),typeof X.env.wasm.numThreads!="number"||!Number.isInteger(X.env.wasm.numThreads)||X.env.wasm.numThreads<=0){const tt=typeof navigator>"u"?(0,K.cpus)().length:navigator.hardwareConcurrency;X.env.wasm.numThreads=Math.min(4,Math.ceil((tt||1)/2))}},F.c8=new class{async init(){(0,F.rX)(),await(0,Q.initWasm)()}async createSessionHandler(tt,et){const q=new Y.OnnxruntimeWebAssemblySessionHandler;return await q.loadModel(tt,et),Promise.resolve(q)}}},1057:function(it,F,W){var X=this&&this.__createBinding||(Object.create?function(Y,tt,et,q){q===void 0&&(q=et);var G=Object.getOwnPropertyDescriptor(tt,et);G&&!("get"in G?!tt.__esModule:G.writable||G.configurable)||(G={enumerable:!0,get:function(){return tt[et]}}),Object.defineProperty(Y,q,G)}:function(Y,tt,et,q){q===void 0&&(q=et),Y[q]=tt[et]}),K=this&&this.__exportStar||function(Y,tt){for(var et in Y)et==="default"||Object.prototype.hasOwnProperty.call(tt,et)||X(tt,Y,et)};Object.defineProperty(F,"__esModule",{value:!0}),K(W(8453),F);const Q=W(8453);{const Y=W(5716).R;(0,Q.registerBackend)("webgl",Y,-10)}{const Y=W(2818).c8;(0,Q.registerBackend)("cpu",Y,10),(0,Q.registerBackend)("wasm",Y,10),(0,Q.registerBackend)("xnnpack",Y,9)}},4910:(it,F)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.createAttributeWithCacheKey=void 0;class W{constructor(K){Object.assign(this,K)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map(K=>`${this[K]}`).join(";")),this._cacheKey}}F.createAttributeWithCacheKey=X=>new W(X)},6874:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.Attribute=void 0;const X=W(1446),K=W(1287),Q=W(9240),Y=W(7273);var tt=K.onnxruntime.experimental.fbs;class et{constructor(G){if(this._attributes=new Map,G!=null){for(const O of G)O instanceof X.onnx.AttributeProto?this._attributes.set(O.name,[et.getValue(O),et.getType(O)]):O instanceof tt.Attribute&&this._attributes.set(O.name(),[et.getValue(O),et.getType(O)]);if(this._attributes.size<G.length)throw new Error("duplicated attribute names")}}set(G,O,b){this._attributes.set(G,[b,O])}delete(G){this._attributes.delete(G)}getFloat(G,O){return this.get(G,"float",O)}getInt(G,O){return this.get(G,"int",O)}getString(G,O){return this.get(G,"string",O)}getTensor(G,O){return this.get(G,"tensor",O)}getFloats(G,O){return this.get(G,"floats",O)}getInts(G,O){return this.get(G,"ints",O)}getStrings(G,O){return this.get(G,"strings",O)}getTensors(G,O){return this.get(G,"tensors",O)}get(G,O,b){const j=this._attributes.get(G);if(j===void 0){if(b!==void 0)return b;throw new Error(`required attribute not found: ${G}`)}if(j[1]!==O)throw new Error(`type mismatch: expected ${O} but got ${j[1]}`);return j[0]}static getType(G){const O=G instanceof X.onnx.AttributeProto?G.type:G.type();switch(O){case X.onnx.AttributeProto.AttributeType.FLOAT:return"float";case X.onnx.AttributeProto.AttributeType.INT:return"int";case X.onnx.AttributeProto.AttributeType.STRING:return"string";case X.onnx.AttributeProto.AttributeType.TENSOR:return"tensor";case X.onnx.AttributeProto.AttributeType.FLOATS:return"floats";case X.onnx.AttributeProto.AttributeType.INTS:return"ints";case X.onnx.AttributeProto.AttributeType.STRINGS:return"strings";case X.onnx.AttributeProto.AttributeType.TENSORS:return"tensors";default:throw new Error(`attribute type is not supported yet: ${X.onnx.AttributeProto.AttributeType[O]}`)}}static getValue(G){const O=G instanceof X.onnx.AttributeProto?G.type:G.type();if(O===X.onnx.AttributeProto.AttributeType.GRAPH||O===X.onnx.AttributeProto.AttributeType.GRAPHS)throw new Error("graph attribute is not supported yet");const b=this.getValueNoCheck(G);if(O===X.onnx.AttributeProto.AttributeType.INT&&Y.LongUtil.isLong(b))return Y.LongUtil.longToNumber(b);if(O===X.onnx.AttributeProto.AttributeType.INTS){const j=b,U=new Array(j.length);for(let J=0;J<j.length;J++){const nt=j[J];U[J]=Y.LongUtil.longToNumber(nt)}return U}if(O===X.onnx.AttributeProto.AttributeType.TENSOR)return G instanceof X.onnx.AttributeProto?Q.Tensor.fromProto(b):Q.Tensor.fromOrtTensor(b);if(O===X.onnx.AttributeProto.AttributeType.TENSORS){if(G instanceof X.onnx.AttributeProto)return b.map(j=>Q.Tensor.fromProto(j));if(G instanceof tt.Attribute)return b.map(j=>Q.Tensor.fromOrtTensor(j))}if(O===X.onnx.AttributeProto.AttributeType.STRING&&G instanceof X.onnx.AttributeProto){const j=b;return(0,Y.decodeUtf8String)(j)}return O===X.onnx.AttributeProto.AttributeType.STRINGS&&G instanceof X.onnx.AttributeProto?b.map(Y.decodeUtf8String):b}static getValueNoCheck(G){return G instanceof X.onnx.AttributeProto?this.getValueNoCheckFromOnnxFormat(G):this.getValueNoCheckFromOrtFormat(G)}static getValueNoCheckFromOnnxFormat(G){switch(G.type){case X.onnx.AttributeProto.AttributeType.FLOAT:return G.f;case X.onnx.AttributeProto.AttributeType.INT:return G.i;case X.onnx.AttributeProto.AttributeType.STRING:return G.s;case X.onnx.AttributeProto.AttributeType.TENSOR:return G.t;case X.onnx.AttributeProto.AttributeType.GRAPH:return G.g;case X.onnx.AttributeProto.AttributeType.FLOATS:return G.floats;case X.onnx.AttributeProto.AttributeType.INTS:return G.ints;case X.onnx.AttributeProto.AttributeType.STRINGS:return G.strings;case X.onnx.AttributeProto.AttributeType.TENSORS:return G.tensors;case X.onnx.AttributeProto.AttributeType.GRAPHS:return G.graphs;default:throw new Error(`unsupported attribute type: ${X.onnx.AttributeProto.AttributeType[G.type]}`)}}static getValueNoCheckFromOrtFormat(G){switch(G.type()){case tt.AttributeType.FLOAT:return G.f();case tt.AttributeType.INT:return G.i();case tt.AttributeType.STRING:return G.s();case tt.AttributeType.TENSOR:return G.t();case tt.AttributeType.GRAPH:return G.g();case tt.AttributeType.FLOATS:return G.floatsArray();case tt.AttributeType.INTS:{const O=[];for(let b=0;b<G.intsLength();b++)O.push(G.ints(b));return O}case tt.AttributeType.STRINGS:{const O=[];for(let b=0;b<G.stringsLength();b++)O.push(G.strings(b));return O}case tt.AttributeType.TENSORS:{const O=[];for(let b=0;b<G.tensorsLength();b++)O.push(G.tensors(b));return O}default:throw new Error(`unsupported attribute type: ${tt.AttributeType[G.type()]}`)}}}F.Attribute=et},1975:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.resolveBackend=F.backend=void 0;const X=W(4418),K=new Map;async function Q(Y){const tt=F.backend;if(tt[Y]!==void 0&&function(et){const q=et;return"initialize"in q&&typeof q.initialize=="function"&&"createSessionHandler"in q&&typeof q.createSessionHandler=="function"&&"dispose"in q&&typeof q.dispose=="function"}(tt[Y])){const et=tt[Y];let q=et.initialize();if(typeof q=="object"&&"then"in q&&(q=await q),q)return K.set(Y,et),et}}F.backend={webgl:new X.WebGLBackend},F.resolveBackend=async function Y(tt){if(!tt)return Y(["webgl"]);{const et=typeof tt=="string"?[tt]:tt;for(const q of et){const G=K.get(q);if(G)return G;const O=await Q(q);if(O)return O}}throw new Error("no available backend to use")}},4418:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.WebGLBackend=void 0;const X=W(8453),K=W(1315),Q=W(2171),Y=W(3389);F.WebGLBackend=class{get contextId(){return X.env.webgl.contextId}set contextId(tt){X.env.webgl.contextId=tt}get matmulMaxBatchSize(){return X.env.webgl.matmulMaxBatchSize}set matmulMaxBatchSize(tt){X.env.webgl.matmulMaxBatchSize=tt}get textureCacheMode(){return X.env.webgl.textureCacheMode}set textureCacheMode(tt){X.env.webgl.textureCacheMode=tt}get pack(){return X.env.webgl.pack}set pack(tt){X.env.webgl.pack=tt}get async(){return X.env.webgl.async}set async(tt){X.env.webgl.async=tt}initialize(){try{return this.glContext=(0,Y.createWebGLContext)(this.contextId),typeof this.matmulMaxBatchSize!="number"&&(this.matmulMaxBatchSize=16),typeof this.textureCacheMode!="string"&&(this.textureCacheMode="full"),typeof this.pack!="boolean"&&(this.pack=!1),typeof this.async!="boolean"&&(this.async=!1),K.Logger.setWithEnv(X.env),K.Logger.verbose("WebGLBackend",`Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`),!0}catch(tt){return K.Logger.warning("WebGLBackend",`Unable to initialize WebGLBackend. ${tt}`),!1}}createSessionHandler(tt){return new Q.WebGLSessionHandler(this,tt)}dispose(){this.glContext.dispose()}}},6859:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.CoordsGlslLib=void 0;const X=W(7273),K=W(1997),Q=W(6757),Y=W(7618),tt=W(432);class et extends K.GlslLib{constructor(G){super(G)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.offsetToCoords()),this.coordsToOffset()),this.toVec()),this.valueFrom()),this.getCommonUtilFuncs()),this.getInputsSamplingSnippets()),this.getOutputSamplingSnippet())}getCustomTypes(){return{}}offsetToCoords(){return{offsetToCoords:new K.GlslLibRoutine(`
      vec2 offsetToCoords(int offset, int width, int height) {
        int t = offset / width;
        int s = offset - t*width;
        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);
        return coords;
      }
      `)}}coordsToOffset(){return{coordsToOffset:new K.GlslLibRoutine(`
      int coordsToOffset(vec2 coords, int width, int height) {
        float s = coords.s * float(width);
        float t = coords.t * float(height);
        int offset = int(t) * width + int(s);
        return offset;
      }
      `)}}getOutputSamplingSnippet(){const G=this.context.outputTextureLayout;return G.isPacked?this.getPackedOutputSamplingSnippet(G):this.getUnpackedOutputSamplingSnippet(G)}getPackedOutputSamplingSnippet(G){const O=G.unpackedShape,b=[G.width,G.height],j={},U="getOutputCoords";switch(O.length){case 0:j[U]=this.getOutputScalarCoords();break;case 1:j[U]=this.getOutputPacked1DCoords(O,b);break;case 2:j[U]=this.getOutputPacked2DCoords(O,b);break;case 3:j[U]=this.getOutputPacked3DCoords(O,b);break;default:j[U]=this.getOutputPackedNDCoords(O,b)}const J=`
      void setOutput(vec4 val) {
        ${(0,Q.getGlsl)(this.context.glContext.version).output} = val;
      }
    `;return j.floatTextureSetRGBA=new K.GlslLibRoutine(J),j}getUnpackedOutputSamplingSnippet(G){const O=G.unpackedShape,b=[G.width,G.height],j={},U="getOutputCoords";switch(O.length){case 0:j[U]=this.getOutputScalarCoords();break;case 1:j[U]=this.getOutputUnpacked1DCoords(O,b);break;case 2:j[U]=this.getOutputUnpacked2DCoords(O,b);break;case 3:j[U]=this.getOutputUnpacked3DCoords(O,b);break;case 4:j[U]=this.getOutputUnpacked4DCoords(O,b);break;case 5:j[U]=this.getOutputUnpacked5DCoords(O,b);break;case 6:j[U]=this.getOutputUnpacked6DCoords(O,b);break;default:throw new Error(`Unsupported output dimensionality: ${O.length}`)}const J=`
        void setOutput(float val) {
          ${(0,Q.getGlsl)(this.context.glContext.version).output} = vec4(val, 0, 0, 0);
        }
    `;return j.floatTextureSetR=new K.GlslLibRoutine(J),j}getOutputScalarCoords(){return new K.GlslLibRoutine(`
      int getOutputCoords() {
        return 0;
      }
    `)}getOutputPacked1DCoords(G,O){const b=O;let j="";return b[0]===1?(j=`
          int getOutputCoords() {
            return 2 * int(TexCoords.y * ${b[1]}.0);
          }
        `,new K.GlslLibRoutine(j)):b[1]===1?(j=`
          int getOutputCoords() {
            return 2 * int(TexCoords.x * ${b[0]}.0);
          }
        `,new K.GlslLibRoutine(j)):(j=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                 vec2(${b[0]}, ${b[1]}));
          return 2 * (resTexRC.y * ${b[0]} + resTexRC.x);
        }
      `,new K.GlslLibRoutine(j))}getOutputPacked2DCoords(G,O){let b="";if(X.ArrayUtil.arraysEqual(G,O))return b=`
        ivec2 getOutputCoords() {
          return 2 * ivec2(TexCoords.xy * vec2(${O[0]}, ${O[1]}));
        }
      `,new K.GlslLibRoutine(b);const j=O,U=Math.ceil(G[1]/2);return b=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${j[0]}, ${j[1]}));

          int index = resTexRC.y * ${j[0]} + resTexRC.x;

          // reverse r and c order for packed texture
          int r = imod(index, ${U}) * 2;
          int c = 2 * (index / ${U});

          return ivec2(r, c);
        }
      `,new K.GlslLibRoutine(b)}getOutputPacked3DCoords(G,O){const b=[O[0],O[1]],j=Math.ceil(G[2]/2),U=j*Math.ceil(G[1]/2),J=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${b[0]}, ${b[1]}));
          int index = resTexRC.y * ${b[0]} + resTexRC.x;

          int b = index / ${U};
          index -= b * ${U};

          // reverse r and c order for packed texture
          int r = imod(index, ${j}) * 2;
          int c = 2 * (index / ${j});

          return ivec3(b, r, c);
        }
      `;return new K.GlslLibRoutine(J)}getOutputPackedNDCoords(G,O){const b=[O[0],O[1]],j=Math.ceil(G[G.length-1]/2),U=j*Math.ceil(G[G.length-2]/2);let J=U,nt="",rt="b, r, c";for(let at=2;at<G.length-1;at++)J*=G[G.length-at-1],nt=`
      int b${at} = index / ${J};
      index -= b${at} * ${J};
    `+nt,rt=`b${at}, `+rt;const ot=`
      ivec${G.length} getOutputCoords() {
        ivec2 resTexRC = ivec2(TexCoords.xy *
                              vec2(${b[0]}, ${b[1]}));
        int index = resTexRC.y * ${b[0]} + resTexRC.x;

        ${nt}

        int b = index / ${U};
        index -= b * ${U};

        // reverse r and c order for packed texture
        int r = imod(index, ${j}) * 2;
        int c = 2 * (index / ${j});

        return ivec${G.length}(${rt});
      }
    `;return new K.GlslLibRoutine(ot)}getOutputUnpacked1DCoords(G,O){const b=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${O[0]}, ${O[1]}));
          return resTexRC.y * ${O[0]} + resTexRC.x;
        }
      `;return new K.GlslLibRoutine(b)}getOutputUnpacked2DCoords(G,O){const b=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${O[0]}, ${O[1]}));
          int index = resTexRC.y * ${O[0]} + resTexRC.x;
          int r = index / ${G[1]};
          int c = index - r * ${G[1]};
          return ivec2(r, c);
        }
      `;return new K.GlslLibRoutine(b)}getOutputUnpacked3DCoords(G,O){let b="";const j=G.length;let U=null;j<2&&(U=[]),U=new Array(j-1),U[j-2]=G[j-1];for(let rt=j-3;rt>=0;--rt)U[rt]=U[rt+1]*G[rt+1];const J=["r","c","d"],nt=U.map((rt,ot)=>`int ${J[ot]} = index / ${rt}; ${ot===U.length-1?`int ${J[ot+1]} = index - ${J[ot]} * ${rt}`:`index -= ${J[ot]} * ${rt}`};`).join("");return b=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${O[0]}, ${O[1]}));
          int index = resTexRC.y * ${O[0]} + resTexRC.x;
          ${nt}
          return ivec3(r, c, d);
        }
      `,new K.GlslLibRoutine(b)}getOutputUnpacked4DCoords(G,O){let b="";const j=G.length;let U=null;j<2&&(U=[]),U=new Array(j-1),U[j-2]=G[j-1];for(let rt=j-3;rt>=0;--rt)U[rt]=U[rt+1]*G[rt+1];const J=["r","c","d","d2"],nt=U.map((rt,ot)=>`int ${J[ot]} = index / ${rt}; ${ot===U.length-1?`int ${J[ot+1]} = index - ${J[ot]} * ${rt}`:`index -= ${J[ot]} * ${rt}`};`).join("");return b=`
      ivec4 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${O[0]}, ${O[1]}));
          int index = resTexRC.y * ${O[0]} + resTexRC.x;
          ${nt}
          return ivec4(r, c, d, d2);
        }
      `,new K.GlslLibRoutine(b)}getOutputUnpacked5DCoords(G,O){let b="";const j=G.length;let U=null;j<2&&(U=[]),U=new Array(j-1),U[j-2]=G[j-1];for(let rt=j-3;rt>=0;--rt)U[rt]=U[rt+1]*G[rt+1];const J=["r","c","d","d2","d3"],nt=U.map((rt,ot)=>`int ${J[ot]} = index / ${rt}; ${ot===U.length-1?`int ${J[ot+1]} = index - ${J[ot]} * ${rt}`:`index -= ${J[ot]} * ${rt}`};`).join("");return b=`
      ivec5 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${O[0]}, ${O[1]}));
          int index = resTexRC.y * ${O[0]} + resTexRC.x;
          ${nt}
          return ivec5(r, c, d, d2, d3);
        }
      `,new K.GlslLibRoutine(b)}getOutputUnpacked6DCoords(G,O){let b="";const j=G.length;let U=null;j<2&&(U=[]),U=new Array(j-1),U[j-2]=G[j-1];for(let rt=j-3;rt>=0;--rt)U[rt]=U[rt+1]*G[rt+1];const J=["r","c","d","d2","d3","d4"],nt=U.map((rt,ot)=>`int ${J[ot]} = index / ${rt}; ${ot===U.length-1?`int ${J[ot+1]} = index - ${J[ot]} * ${rt}`:`index -= ${J[ot]} * ${rt}`};`).join("");return b=`
     ivec6 getOutputCoords() {
         ivec2 resTexRC = ivec2(TexCoords.xy *
                               vec2(${O[0]}, ${O[1]}));
         int index = resTexRC.y * ${O[0]} + resTexRC.x;
         ${nt}
         return ivec6(r, c, d, d2, d3, d4);
       }
     `,new K.GlslLibRoutine(b)}getCommonUtilFuncs(){const G={};let O="uvFromFlat";G[O]=new K.GlslLibRoutine(`
    vec2 uvFromFlat(int texNumR, int texNumC, int index) {
      int texC = index / texNumR;
      int texR = index - texC * texNumR;
      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to
      //       v.
      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);
    }
    `),O="packedUVfrom1D",G[O]=new K.GlslLibRoutine(`
      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
        int texelIndex = index / 2;
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),O="packedUVfrom2D",G[O]=new K.GlslLibRoutine(`
      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {
        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),O="packedUVfrom3D",G[O]=new K.GlslLibRoutine(`
      vec2 packedUVfrom3D(int texNumR, int texNumC,
          int texelsInBatch, int texelsInLogicalRow, int b,
          int row, int col) {
        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = index / texNumC;
        int texC = index - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),O="sampleTexture";const b=(0,Q.getGlsl)(this.context.glContext.version);return G[O]=new K.GlslLibRoutine(`
        float sampleTexture(sampler2D textureSampler, vec2 uv) {
            return ${b.texture2D}(textureSampler, uv).r;
        }`),G}getInputsSamplingSnippets(){const G={},O=this.context.outputTextureLayout;return this.context.programInfo.inputNames.forEach((b,j)=>{const U=this.context.inputTextureLayouts[j],J=(0,tt.generateShaderFuncNameFromInputSamplerName)(b);U.isPacked?G[J]=this.getPackedSamplerFromInput(J,b,U):G[J]=this.getUnpackedSamplerFromInput(J,b,U);const nt=(0,tt.generateShaderFuncNameFromInputSamplerNameAtOutCoords)(b);U.unpackedShape.length<=O.unpackedShape.length&&(U.isPacked?G[nt]=this.getPackedSamplerAtOutputCoords(nt,U,O,b):G[nt]=this.getUnpackedSamplerAtOutputCoords(nt,U,O,b))}),G}getPackedSamplerAtOutputCoords(G,O,b,j){const U=O.unpackedShape,J=b.unpackedShape,nt=j,rt=(0,tt.generateShaderFuncNameFromInputSamplerName)(nt),ot=U.length,at=J.length,ut=X.BroadcastUtil.getBroadcastDims(U,J),st=(0,tt.getCoordsDataType)(at),ct=at-ot;let dt;const pt=(0,tt.getGlChannels)();dt=ot===0?"":at<2&&ut.length>=1?"coords = 0;":ut.map(bt=>`coords.${pt[bt+ct]} = 0;`).join(`
`);let lt="";lt=at<2&&ot>0?"coords":U.map((bt,Ot)=>`coords.${pt[Ot+ct]}`).join(", ");let ft="return outputValue;";const gt=X.ShapeUtil.size(U)===1,_t=X.ShapeUtil.size(J)===1;if(ot!==1||gt||_t){if(gt&&!_t)ft=at===1?`
          return vec4(outputValue.x, outputValue.x, 0., 0.);
        `:`
          return vec4(outputValue.x);
        `;else if(ut.length){const bt=ot-2,Ot=ot-1;ut.indexOf(bt)>-1&&ut.indexOf(Ot)>-1?ft="return vec4(outputValue.x);":ut.indexOf(bt)>-1?ft="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":ut.indexOf(Ot)>-1&&(ft="return vec4(outputValue.xx, outputValue.zz);")}}else ft=`
        return vec4(outputValue.xy, outputValue.xy);
      `;const wt=`
      vec4 ${G}() {
        ${st} coords = getOutputCoords();
        
        int lastDim = coords.${pt[at-1]};
        coords.${pt[at-1]} = coords.${pt[at-2]};
        coords.${pt[at-2]} = lastDim;
      
        ${dt}
        vec4 outputValue = ${rt}(${lt});
        ${ft}
      }
    `;return new K.GlslLibRoutine(wt,["coordinates.getOutputCoords"])}getUnpackedSamplerAtOutputCoords(G,O,b,j){const U=[b.width,b.height],J=[O.width,O.height],nt=O.unpackedShape.length,rt=b.unpackedShape.length,ot=O.unpackedShape,at=b.unpackedShape,ut=(0,tt.generateShaderFuncNameFromInputSamplerName)(j);if(nt===rt&&X.ArrayUtil.arraysEqual(J,U)){const _t=`
          float ${G}() {
            return sampleTexture(${j}, TexCoords);
          }
        `;return new K.GlslLibRoutine(_t,["coordinates.sampleTexture"])}const st=(0,tt.getCoordsDataType)(rt),ct=X.BroadcastUtil.getBroadcastDims(ot,at),dt=rt-nt;let pt;const lt=(0,tt.getGlChannels)();pt=nt===0?"":rt<2&&ct.length>=1?"coords = 0;":ct.map(_t=>`coords.${lt[_t+dt]} = 0;`).join(`
`);let ft="";ft=rt<2&&nt>0?"coords":O.unpackedShape.map((_t,wt)=>`coords.${lt[wt+dt]}`).join(", ");const gt=`
        float ${G}() {
          ${st} coords = getOutputCoords();
          ${pt}
          return ${ut}(${ft});
        }
      `;return new K.GlslLibRoutine(gt,["coordinates.getOutputCoords"])}getPackedSamplerFromInput(G,O,b){switch(b.unpackedShape.length){case 0:return this.getPackedSamplerScalar(G,O);case 1:return this.getPackedSampler1D(G,O,b);case 2:return this.getPackedSampler2D(G,O,b);case 3:return this.getPackedSampler3D(G,O,b);default:return this.getPackedSamplerND(G,O,b)}}getUnpackedSamplerFromInput(G,O,b){const j=b.unpackedShape;switch(j.length){case 0:return this.getUnpackedSamplerScalar(G,O,b);case 1:return this.getUnpackedSampler1D(G,O,b);case 2:return this.getUnpackedSampler2D(G,O,b);case 3:return this.getUnpackedSampler3D(G,O,b);case 4:return this.getUnpackedSampler4D(G,O,b);case 5:return this.getUnpackedSampler5D(G,O,b);case 6:return this.getUnpackedSampler6D(G,O,b);default:throw new Error(`Unsupported dimension ${j.length}-D`)}}getPackedSamplerScalar(G,O){const b=`
          vec4 ${G}() {
            return ${(0,Q.getGlsl)(this.context.glContext.version).texture2D}(${O}, halfCR);
          }
        `;return new K.GlslLibRoutine(b)}getPackedSampler1D(G,O,b){const j=[b.width,b.height],U=[j[1],j[0]],J=(0,Q.getGlsl)(this.context.glContext.version),nt=`vec4 ${G}(int index) {
      vec2 uv = packedUVfrom1D(
      ${U[0]}, ${U[1]}, index);
      return ${J.texture2D}(${O}, uv);
    }`;return new K.GlslLibRoutine(nt,["coordinates.packedUVfrom1D"])}getPackedSampler2D(G,O,b){const j=b.unpackedShape,U=[b.width,b.height],J=(0,Q.getGlsl)(this.context.glContext.version),nt=U[0],rt=U[1];if(U!=null&&X.ArrayUtil.arraysEqual(j,U)){const st=`vec4 ${G}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${rt}.0, ${nt}.0);
        return ${J.texture2D}(${O}, uv);
      }`;return new K.GlslLibRoutine(st)}const ot=U,at=Math.ceil(j[1]/2),ut=`vec4 ${G}(int row, int col) {
      vec2 uv = packedUVfrom2D(${ot[1]}, ${ot[0]}, ${at}, row, col);
      return ${J.texture2D}(${O}, uv);
    }`;return new K.GlslLibRoutine(ut,["coordinates.packedUVfrom2D"])}getPackedSampler3D(G,O,b){const j=b.unpackedShape,U=[b.width,b.height],J=[U[0],U[1]],nt=(0,Q.getGlsl)(this.context.glContext.version);if(j[0]===1){const st=j.slice(1),ct=[1,2],dt=(0,tt.squeezeInputShape)(j,st),pt=["b","row","col"],lt=JSON.parse(JSON.stringify(b));lt.unpackedShape=dt;const ft=this.getPackedSamplerFromInput(G,O,lt),gt=`${ft.routineBody}
      vec4 ${G}(int b, int row, int col) {
        return ${G}(${(0,tt.getSqueezedParams)(pt,ct)});
      } `;return new K.GlslLibRoutine(gt,ft.dependencies)}const rt=J[0],ot=J[1],at=Math.ceil(j[2]/2),ut=`vec4 ${G}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${ot}, ${rt}, ${at*Math.ceil(j[1]/2)}, ${at}, b, row, col);
      return ${nt.texture2D}(${O}, uv);}`;return new K.GlslLibRoutine(ut,["coordinates.packedUVfrom3D"])}getPackedSamplerND(G,O,b){const j=b.unpackedShape,U=j.length,J=[b.width,b.height],nt=(0,Q.getGlsl)(this.context.glContext.version),rt=[J[0],J[1]],ot=rt[1],at=rt[0],ut=Math.ceil(j[U-1]/2);let st=ut*Math.ceil(j[U-2]/2),ct="int b, int row, int col",dt=`b * ${st} + (row / 2) * ${ut} + (col / 2)`;for(let lt=2;lt<U-1;lt++)ct=`int b${lt}, `+ct,st*=j[U-lt-1],dt=`b${lt} * ${st} + `+dt;const pt=`vec4 ${G}(${ct}) {
      int index = ${dt};
      int texR = index / ${at};
      int texC = index - texR * ${at};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${at}, ${ot});
      return ${nt.texture2D}(${O}, uv);
    }`;return new K.GlslLibRoutine(pt)}getUnpackedSamplerScalar(G,O,b){const[j,U]=[b.width,b.height];if(j===1&&U===1){const nt=`
          float ${G}() {
            return sampleTexture(${O}, halfCR);
          }
        `;return new K.GlslLibRoutine(nt,["coordinates.sampleTexture"])}const J=`
        float ${G}() {
          int offset_${O} = coordsToOffset(TexCoords, ${j}, ${U});
          vec2 uv = uvFromFlat(${j}, ${U}, offset_${O});
          return sampleTexture(${O}, uv);
        }
      `;return new K.GlslLibRoutine(J,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler1D(G,O,b){const j=b.width,U=b.height;if(U===1&&j===1){const nt=`
        float ${G}(int index) {
          return sampleTexture(${O}, halfCR);
        }
      `;return new K.GlslLibRoutine(nt,["coordinates.sampleTexture"])}if(U===1){const nt=`
          float ${G}(int index) {
            vec2 uv = vec2((float(index) + 0.5) / ${j}.0, 0.5);
            return sampleTexture(${O}, uv);
          }
        `;return new K.GlslLibRoutine(nt,["coordinates.sampleTexture"])}if(j===1){const nt=`
          float ${G}(int index) {
            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${U}.0);
            return sampleTexture(${O}, uv);
          }
        `;return new K.GlslLibRoutine(nt,["coordinates.sampleTexture"])}const J=`
        float ${G}(int index) {
          vec2 uv = uvFromFlat(${j}, ${U}, index);
          return sampleTexture(${O}, uv);
        }
      `;return new K.GlslLibRoutine(J,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler2D(G,O,b){const j=b.unpackedShape,U=[b.height,b.width];if(U!=null&&X.ArrayUtil.arraysEqual(j,U)){const st=`
          float ${G}(int row, int col) {
            vec2 uv = (vec2(row, col) + halfCR) / vec2(${U[1]}.0, ${U[0]}.0);
            return sampleTexture(${O}, uv);
          }
        `;return new K.GlslLibRoutine(st,["coordinates.sampleTexture"])}const{newShape:J,keptDims:nt}=(0,Y.squeezeShape)(j),rt=J;if(rt.length<j.length){const st=(0,tt.squeezeInputShape)(j,rt),ct=JSON.parse(JSON.stringify(b));ct.unpackedShape=st;const dt=["col","row"],pt=`
          ${this.getUnpackedSamplerFromInput(G,O,ct).routineBody}
          float ${G}(int row, int col) {
            return ${G}(${(0,tt.getSqueezedParams)(dt,nt)});
          }
        `;return new K.GlslLibRoutine(pt,["coordinates.sampleTexture"])}const ot=U[1],at=U[0];if(at===1){const st=`
          float ${G}(int row, int col) {
            int offset_${O} = coordsToOffset(TexCoords, ${ot}, ${at});
            float index = dot(vec3(row, col, offset_${O}), vec3(${j[1]}, 1, 1));
            vec2 uv = vec2(0.5, (index + 0.5) / ${ot}.0);
            return sampleTexture(${O}, uv);
          }
        `;return new K.GlslLibRoutine(st,["coordinates.sampleTexture","coordinates.coordsToOffset"])}if(ot===1){const st=`
          float ${G}(int row, int col) {
            int offset_${O} = coordsToOffset(TexCoords, ${ot}, ${at});
            float index = dot(vec3(row, col, offset_${O}), vec3(${j[1]}, 1, 1));
            vec2 uv = vec2((index + 0.5) / ${at}.0, 0.5);
            return sampleTexture(${O}, uv);
          }
        `;return new K.GlslLibRoutine(st,["coordinates.sampleTexture","coordinates.coordsToOffset"])}const ut=`
        float ${G}(int row, int col) {
          int index = col * ${j[1]} + row;
          vec2 uv = uvFromFlat(${ot}, ${at}, index);
          return sampleTexture(${O}, uv);
        }
      `;return new K.GlslLibRoutine(ut,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler3D(G,O,b){const j=b.unpackedShape,U=j[1]*j[2],J=j[2],{newShape:nt,keptDims:rt}=(0,Y.squeezeShape)(j),ot=nt;if(ot.length<j.length){const ut=(0,tt.squeezeInputShape)(j,ot),st=["batch","col","row"],ct=JSON.parse(JSON.stringify(b));ct.unpackedShape=ut;const dt=this.getUnpackedSamplerFromInput(G,O,ct),pt=rt.reverse(),lt=`
          ${dt.routineBody}
          float ${G}(int batch, int row, int col) {
            return ${G}(${(0,tt.getSqueezedParams)(st,pt)});
          }
        `;return new K.GlslLibRoutine(lt,dt.dependencies)}const at=`
          float ${G}(int depth, int row, int col) {
            // Explicitly use integer operations as dot() only works on floats.
            int index = depth * ${U} + col * ${J} + row;
            vec2 uv = uvFromFlat(${b.width}, ${b.height}, index);
            return sampleTexture(${O}, uv);
          }
      `;return new K.GlslLibRoutine(at,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler4D(G,O,b){const j=b.unpackedShape,U=j[3],J=j[2]*U,nt=`
        float ${G}(int row, int col, int depth, int depth2) {
          int index = row * ${j[1]*J} + col * ${J} +
              depth2 * ${U} + depth;
          vec2 uv = uvFromFlat(${b.width}, ${b.height}, index);
          return sampleTexture(${O}, uv);
        }
      `;return new K.GlslLibRoutine(nt,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler5D(G,O,b){const j=b.unpackedShape,U=j[4],J=j[3]*U,nt=j[2]*J,rt=j[1]*nt,{newShape:ot,keptDims:at}=(0,Y.squeezeShape)(j);if(ot.length<j.length){const st=(0,tt.squeezeInputShape)(j,ot),ct=["row","col","depth","depth2","depth3"],dt=JSON.parse(JSON.stringify(b));dt.unpackedShape=st;const pt=`
          ${this.getUnpackedSamplerFromInput(G,O,dt).routineBody}
          float ${G}(int row, int col, int depth, int depth2, int depth3) {
            return ${G}(${(0,tt.getSqueezedParams)(ct,at)});
          }
        `;return new K.GlslLibRoutine(pt,["coordinates.sampleTexture","coordinates.uvFromFlat"])}const ut=`
        float ${G}(int row, int col, int depth, int depth2, int depth3) {
          int index = row * ${rt} + col * ${nt} + depth * ${J} +
          depth3 * ${U} + depth2;
          vec2 uv = uvFromFlat(${b.width}, ${b.height}, index);
          return sampleTexture(${O}, uv);
        }
      `;return new K.GlslLibRoutine(ut,["coordinates.sampleTexture","coordinates.uvFromFlat"])}getUnpackedSampler6D(G,O,b){const j=b.unpackedShape,U=j[5],J=j[4]*U,nt=j[3]*J,rt=j[2]*nt,ot=j[1]*rt,{newShape:at,keptDims:ut}=(0,Y.squeezeShape)(j);if(at.length<j.length){const ct=(0,tt.squeezeInputShape)(j,at),dt=["row","col","depth","depth2","depth3","depth4"],pt=JSON.parse(JSON.stringify(b));pt.unpackedShape=ct;const lt=`
            ${this.getUnpackedSamplerFromInput(G,O,pt).routineBody}
            float ${G}(int row, int col, int depth,
              int depth2, int depth3, int depth4) {
              return ${G}(${(0,tt.getSqueezedParams)(dt,ut)});
            }
          `;return new K.GlslLibRoutine(lt,["coordinates.sampleTexture","coordinates.uvFromFlat"])}const st=`
          float ${G}(int row, int col, int depth,
            int depth2, int depth3, int depth4) {
            int index = row * ${ot} + col * ${rt} + depth * ${nt} +
            depth2 * ${J} + depth3 * ${U} + depth4;
            vec2 uv = uvFromFlat(${b.width}, ${b.height}, index);
            return sampleTexture(${O}, uv);
          }
        `;return new K.GlslLibRoutine(st,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}toVec(){const G=this.context.outputTextureLayout,O=G.shape.length,b=G.strides,j=G.width,U=G.height,J=[];for(let rt=0;rt<O-1;++rt)J.push(`
        c[${rt}] = offset / ${b[rt]};`),J.push(`
        offset -= c[${rt}] * ${b[rt]};`);J.push(`
        c[${O-1}] = offset;`);const nt=`
      void toVec(vec2 texCoords, out int c[${O}]) {
        int offset = coordsToOffset(texCoords, ${j}, ${U});
        ${J.join("")}
      }
      void toVec(int offset, out int c[${O}]) {
        ${J.join("")}
      }
    `;return{toVec:new K.GlslLibRoutine(nt,["coordinates.coordsToOffset"])}}valueFrom(){const G={};return this.context.programInfo.inputNames.forEach((O,b)=>{const j=this.context.inputTextureLayouts[b],U=(j.unpackedShape.length>0?j.unpackedShape:j.shape).length;let J=`_${O}`;G[J]=new K.GlslLibRoutine(this.getValueFromSingle(O,U,j.width,j.height,!1),[`shapeUtils.indicesToOffset${J}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"]),J+="_T",G[J]=new K.GlslLibRoutine(this.getValueFromSingle(O,U,j.width,j.height,!0),[`shapeUtils.indicesToOffset${J}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"])}),G}getValueFromSingle(G,O,b,j,U){let J=`_${G}`;return U&&(J+="_T"),`
        float ${J}(int m[${O}]) {
          int offset = indicesToOffset${J}(m);
          vec2 coords = offsetToCoords(offset, ${b}, ${j});
          float value = getColorAsFloat(${(0,Q.getGlsl)(this.context.glContext.version).texture2D}(${G}, coords));
          return value;
        }
        `}getPackedValueFrom(G,O,b,j,U){let J=`_${G}_Pack`;return U&&(J+="_T"),`
        vec4 ${J}(int m[${O}]) {
          int offset = indicesToOffset_${G}(m);
          vec2 coords = offsetToCoords(offset, ${b}, ${j});
          return ${(0,Q.getGlsl)(this.context.glContext.version).texture2D}(${G}, coords);
        }
        `}}F.CoordsGlslLib=et},1997:(it,F)=>{var W;Object.defineProperty(F,"__esModule",{value:!0}),F.TopologicalSortGlslRoutines=F.GlslLibRoutineNode=F.GlslLibRoutine=F.GlslLib=F.GlslContext=F.FunctionType=void 0,(W=F.FunctionType||(F.FunctionType={}))[W.ValueBased=0]="ValueBased",W[W.Positional=1]="Positional",F.GlslContext=class{constructor(X,K,Q,Y){this.glContext=X,this.programInfo=K,this.inputTextureLayouts=Q,this.outputTextureLayout=Y}},F.GlslLib=class{constructor(X){this.context=X}},F.GlslLibRoutine=class{constructor(X,K){this.routineBody=X,this.dependencies=K}},F.GlslLibRoutineNode=class{constructor(X,K,Q){this.name=X,this.dependencies=Q||[],K&&(this.routineBody=K)}addDependency(X){X&&this.dependencies.push(X)}},F.TopologicalSortGlslRoutines=class{static returnOrderedNodes(X){if(!X||X.length===0)return[];if(X.length===1)return X;const K=new Set,Q=new Set,Y=new Array;return this.createOrderedNodes(X,K,Q,Y),Y}static createOrderedNodes(X,K,Q,Y){for(let tt=0;tt<X.length;++tt)this.dfsTraverse(X[tt],K,Q,Y)}static dfsTraverse(X,K,Q,Y){if(!X||Q.has(X.name))return;if(K.has(X.name))throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");K.add(X.name);const tt=X.dependencies;if(tt&&tt.length>0)for(let et=0;et<tt.length;++et)this.dfsTraverse(tt[et],K,Q,Y);Y.push(X),Q.add(X.name),K.delete(X.name)}}},1371:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.EncodingGlslLib=void 0;const X=W(1997);class K extends X.GlslLib{constructor(Y){super(Y)}getFunctions(){return Object.assign(Object.assign({},this.encodeFloat32()),this.decodeFloat32())}getCustomTypes(){return{}}encodeFloat32(){return{encode:new X.GlslLibRoutine(`highp vec4 encode(highp float f) {
        return vec4(f, 0.0, 0.0, 0.0);
      }
        `)}}decodeFloat32(){return{decode:new X.GlslLibRoutine(`highp float decode(highp vec4 rgba) {
        return rgba.r;
      }
        `)}}encodeUint8(){const Y=K.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{encode:new X.GlslLibRoutine(`
      highp vec4 encode(highp float f) {
        highp float F = abs(f);
        highp float Sign = step(0.0,-f);
        highp float Exponent = floor(log2(F));
        highp float Mantissa = (exp2(- Exponent) * F);
        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));
        highp vec4 rgba;
        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));
        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);
        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));
        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));
        ${Y}
        rgba = rgba / 255.0; // values need to be normalized to [0,1]
        return rgba;
    }
        `)}}decodeUint8(){const Y=K.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{decode:new X.GlslLibRoutine(`
        highp float decode(highp vec4 rgba) {
          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]
          ${Y}
          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;
          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;
          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);
          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));
          return Result;
      }
        `)}}static isLittleEndian(){const Y=new ArrayBuffer(4),tt=new Uint32Array(Y),et=new Uint8Array(Y);if(tt[0]=3735928559,et[0]===239)return!0;if(et[0]===222)return!1;throw new Error("unknown endianness")}}F.EncodingGlslLib=K},2691:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.FragColorGlslLib=void 0;const X=W(1997),K=W(6757);class Q extends X.GlslLib{constructor(tt){super(tt)}getFunctions(){return Object.assign(Object.assign({},this.setFragColor()),this.getColorAsFloat())}getCustomTypes(){return{}}setFragColor(){const tt=(0,K.getGlsl)(this.context.glContext.version);return{setFragColor:new X.GlslLibRoutine(`
        void setFragColor(float value) {
            ${tt.output} = encode(value);
        }
        `,["encoding.encode"])}}getColorAsFloat(){return{getColorAsFloat:new X.GlslLibRoutine(`
        float getColorAsFloat(vec4 color) {
            return decode(color);
        }
        `,["encoding.decode"])}}}F.FragColorGlslLib=Q},3878:(it,F)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.replaceInlines=void 0;const W=/@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm;F.replaceInlines=function(X){const K={};let Q;for(;(Q=W.exec(X))!==null;){const Y=Q[3].split(",").map(tt=>{const et=tt.trim().split(" ");return et&&et.length===2?{type:et[0],name:et[1]}:null}).filter(tt=>tt!==null);K[Q[2]]={params:Y,body:Q[4]}}for(const Y in K){const tt="(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;".replace("__FUNC__",Y),et=new RegExp(tt,"gm");for(;(Q=et.exec(X))!==null;){const q=Q[1],G=Q[2],O=Q[3].split(","),b=q?`${q} ${G};`:"";let j=K[Y].body,U="";K[Y].params.forEach((nt,rt)=>{nt&&(U+=`${nt.type} ${nt.name} = ${O[rt]};
`)}),j=`${U}
 ${j}`,j=j.replace("return",`${G} = `);const J=`
      ${b}
      {
        ${j}
      }
      `;X=X.replace(Q[0],J)}}return X.replace(W,"")}},8897:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.GlslPreprocessor=void 0;const X=W(1997),K=W(3878),Q=W(1248),Y=W(6757);F.GlslPreprocessor=class{constructor(tt,et,q,G){this.libs={},this.glslLibRoutineDependencyGraph={},this.context=new X.GlslContext(tt,et,q,G),Object.keys(Q.glslRegistry).forEach(b=>{const j=new Q.glslRegistry[b](this.context);this.libs[b]=j});const O=this.glslLibRoutineDependencyGraph;for(const b in this.libs){const j=this.libs[b].getFunctions();for(const U in j){const J=b+"."+U;let nt;O[J]?(nt=O[J],nt.routineBody=j[U].routineBody):(nt=new X.GlslLibRoutineNode(J,j[U].routineBody),O[J]=nt);const rt=j[U].dependencies;if(rt)for(let ot=0;ot<rt.length;++ot)if(O[rt[ot]])nt.addDependency(O[rt[ot]]);else{const at=new X.GlslLibRoutineNode(rt[ot]);O[rt[ot]]=at,nt.addDependency(at)}}}}preprocess(){const tt=this.context.programInfo;let et=tt.shaderSource;return this.context.programInfo.hasMain||(et=`${et}
      ${(0,Y.getDefaultFragShaderMain)(this.context.glContext.version,this.context.outputTextureLayout.shape.length)}`),et=(0,K.replaceInlines)(et),`${(0,Y.getFragShaderPreamble)(this.context.glContext.version)}
    ${this.getUniforms(tt.inputNames,tt.variables)}
    ${this.getImports(et)}
    ${et}`}getImports(tt){const et=this.selectGlslLibRoutinesToBeIncluded(tt);if(et.length===0)return"";let q="";for(let G=0;G<et.length;++G){if(!et[G].routineBody)throw new Error(`Missing body for the Glsl Library routine: ${et[G].name}`);q+=et[G].routineBody+`
`}return q}selectGlslLibRoutinesToBeIncluded(tt){const et=[];return Object.keys(this.glslLibRoutineDependencyGraph).forEach(q=>{const G=q.split(".")[1];tt.indexOf(G)!==-1&&et.push(this.glslLibRoutineDependencyGraph[q])}),X.TopologicalSortGlslRoutines.returnOrderedNodes(et)}getUniforms(tt,et){const q=[];if(tt)for(const G of tt)q.push(`uniform sampler2D ${G};`);if(et)for(const G of et)q.push(`uniform ${G.type} ${G.name}${G.arrayLength?`[${G.arrayLength}]`:""};`);return q.join(`
`)}}},1248:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.glslRegistry=void 0;const X=W(6859),K=W(1371),Q=W(2691),Y=W(9183),tt=W(9314);F.glslRegistry={encoding:K.EncodingGlslLib,fragcolor:Q.FragColorGlslLib,vec:tt.VecGlslLib,shapeUtils:Y.ShapeUtilsGlslLib,coordinates:X.CoordsGlslLib}},9183:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.ShapeUtilsGlslLib=void 0;const X=W(1997);class K extends X.GlslLib{constructor(Y){super(Y)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.bcastIndex()),this.bcastMatmulIndex()),this.offsetToIndices()),this.indicesToOffset()),this.incrementIndices())}getCustomTypes(){return{}}bcastIndex(){const Y=this.context.outputTextureLayout.shape.length,tt={};return this.context.programInfo.inputNames.forEach((et,q)=>{const G=this.context.inputTextureLayouts[q].unpackedShape;if(G.length<=Y){const O=G.length,b=Y-O,j=`bcastIndices_${et}`;let U="";for(let nt=0;nt<O;++nt)U+=`
          realIndices[${nt}] = int( mod(float(bcastedIndices[${b+nt}]), ${G[nt]}.0) );
          `;const J=`
        void ${j} (int bcastedIndices[${Y}], out int realIndices[${O}]) {
          ${U}
        }
        `;tt[j]=new X.GlslLibRoutine(J)}}),tt}bcastMatmulIndex(){const Y=this.context.outputTextureLayout.shape.length,tt={};return this.context.programInfo.inputNames.forEach((et,q)=>{const G=this.context.inputTextureLayouts[q].shape;if(!(G.length<2||G.length>Y)){const O=G.length,b=Y-O,j=`bcastMatmulIndices_${et}`;let U="";for(let nt=0;nt<O-2;++nt)U+=`
          realIndices[${nt}] = int( mod(float(bcastedIndices[${b+nt}]), ${G[nt]}.0) );
          `;const J=`
        void ${j}(int bcastedIndices[${Y}], out int realIndices[${O}]) {
          ${U}
          realIndices[${O-1}] = bcastedIndices[${Y-1}];
          realIndices[${O-2}] = bcastedIndices[${Y-2}];
        }
        `;tt[j]=new X.GlslLibRoutine(J)}}),tt}indicesToOffset(){const Y={};return this.context.programInfo.inputNames.forEach((tt,et)=>{const q=this.context.inputTextureLayouts[et].shape,G=this.context.inputTextureLayouts[et].strides,O=q.length;let b=`indicesToOffset_${tt}`;Y[b]=new X.GlslLibRoutine(K.indexToOffsetSingle(b,O,G)),b=`indicesToOffset_${tt}_T`,Y[b]=new X.GlslLibRoutine(K.indexToOffsetSingle(b,O,G.slice().reverse()))}),Y}static indexToOffsetSingle(Y,tt,et){let q="";for(let G=tt-1;G>=0;--G)q+=`
        offset += indices[${G}] * ${et[G]};
        `;return`
      int ${Y}(int indices[${tt}]) {
        int offset = 0;
        ${q}
        return offset;
      }
      `}offsetToIndices(){const Y={};return this.context.programInfo.inputNames.forEach((tt,et)=>{const q=this.context.inputTextureLayouts[et].shape,G=this.context.inputTextureLayouts[et].strides,O=q.length;let b=`offsetToIndices_${tt}`;Y[b]=new X.GlslLibRoutine(K.offsetToIndicesSingle(b,O,G)),b=`offsetToIndices_${tt}_T`,Y[b]=new X.GlslLibRoutine(K.offsetToIndicesSingle(b,O,G.slice().reverse()))}),Y}static offsetToIndicesSingle(Y,tt,et){const q=[];for(let G=0;G<tt-1;++G)q.push(`
      indices[${G}] = offset / ${et[G]};`),q.push(`
        offset -= indices[${G}] * ${et[G]};`);return q.push(`
      indices[${tt-1}] = offset;`),`
      void ${Y}(int offset, out int indices[${tt}]) {
        ${q.join("")}
      }
      `}incrementIndices(){const Y={};return this.context.programInfo.inputNames.forEach((tt,et)=>{const q=this.context.inputTextureLayouts[et].shape,G=q.length,O=`incrementIndices_${tt}`;let b="";for(let U=0;U<G;++U)b+=`
        shape[${U}] = ${q[U]};`;const j=`
        void ${O}(int axis, out int indices[${G}]) {
          int shape[${G}];
          ${b};
          for(int i = ${G} -1 ; i >= 0; --i) {
            if(i > axis) continue;
            indices[i] += 1;
            if(indices[i] < shape[i]) {
              break;
            }
            indices[i] = 0;
          }
        }
        `;Y[O]=new X.GlslLibRoutine(j)}),Y}}F.ShapeUtilsGlslLib=K},6757:(it,F)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.getDefaultFragShaderMain=F.getFragShaderPreamble=F.getVertexShaderSource=F.getGlsl=void 0;const W={version:"",attribute:"attribute",varyingVertex:"varying",varyingFrag:"varying",texture2D:"texture2D",output:"gl_FragColor",outputDeclaration:""},X={version:"#version 300 es",attribute:"in",varyingVertex:"out",varyingFrag:"in",texture2D:"texture",output:"outputColor",outputDeclaration:"out vec4 outputColor;"};function K(Q){return Q===1?W:X}F.getGlsl=K,F.getVertexShaderSource=function(Q){const Y=K(Q);return`${Y.version}
      precision highp float;
      ${Y.attribute} vec3 position;
      ${Y.attribute} vec2 textureCoord;

      ${Y.varyingVertex} vec2 TexCoords;

      void main()
      {
          gl_Position = vec4(position, 1.0);
          TexCoords = textureCoord;
      }`},F.getFragShaderPreamble=function(Q){const Y=K(Q);return`${Y.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${Y.varyingFrag} vec2 TexCoords;
    ${Y.outputDeclaration}
    const vec2 halfCR = vec2(0.5, 0.5);

    // Custom vector types to handle higher dimenalities.
    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    `},F.getDefaultFragShaderMain=function(Q,Y){return`
  void main() {
    int indices[${Y}];
    toVec(TexCoords, indices);
    vec4 result = vec4(process(indices));
    ${K(Q).output} = result;
  }
  `}},9314:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.VecGlslLib=void 0;const X=W(1997);class K extends X.GlslLib{constructor(Y){super(Y)}getCustomTypes(){return{}}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign({},this.binaryVecFunctions()),this.copyVec()),this.setVecItem()),this.getVecItem())}binaryVecFunctions(){const Y=this.context.outputTextureLayout.shape.length,tt={add:"+=",sub:"-=",mul:"*=",div:"/="},et={};for(const q in tt){const G=`${q}Vec`;let O="";for(let j=0;j<Y;++j)O+=`
          dest[${j}] ${tt[q]} src[${j}];
          `;const b=`
        void ${G}(int src[${Y}], out int dest[${Y}]) {
          ${O}
        }
        `;et[G]=new X.GlslLibRoutine(b)}return et}copyVec(){const Y=this.context.outputTextureLayout.shape.length;let tt="";for(let q=0;q<Y;++q)tt+=`
        dest[${q}] = src[${q}];
        `;const et=`
      void copyVec(int src[${Y}], out int dest[${Y}]) {
        ${tt}
      }
      `;return{copyVec:new X.GlslLibRoutine(et)}}setVecItem(){const Y=this.context.outputTextureLayout.shape.length;let tt=`
        if(index < 0)
            index =${Y} + index;
        if (index == 0)
            m[0] = value;
        `;for(let q=1;q<Y-1;++q)tt+=`
        else if (index == ${q})
            m[${q}] = value;
            `;tt+=`
        else
            m[${Y-1}] = value;
        `;const et=`
      void setVecItem(out int m[${Y}], int index, int value) {
        ${tt}
      }
        `;return{setVecItem:new X.GlslLibRoutine(et)}}getVecItem(){const Y=this.context.outputTextureLayout.shape.length;let tt=`
        if(index < 0)
            index = ${Y} + index;
        if (index == 0)
            return m[0];
      `;for(let q=1;q<Y-1;++q)tt+=`
        else if (index == ${q})
            return m[${q}];
      `;tt+=`
        else
            return m[${Y-1}];
        `;const et=`
      int getVecItem(int m[${Y}], int index) {
        ${tt}
      }
    `;return{getVecItem:new X.GlslLibRoutine(et)}}}F.VecGlslLib=K},7860:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.WebGLInferenceHandler=void 0;const X=W(1315),K=W(9240),Q=W(7273),Y=W(9),tt=W(7379),et=W(2488),q=W(540),G=W(3314),O=W(5639);F.WebGLInferenceHandler=class{constructor(b){this.session=b,this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map}calculateTextureWidthAndHeight(b,j){return(0,G.calculateTextureWidthAndHeight)(this.session.layoutStrategy,b,j)}executeProgram(b,j){if(j.length<b.inputNames.length)throw new Error(`Input size mustn't be less than ${b.inputNames.length}.`);if(b.inputNames.length!==b.inputTypes.length)throw new Error("input names size does not match input types");const U=[];for(let ut=0;ut<b.inputNames.length;++ut)U[ut]=this.getOrCreateTextureData(j[ut],b.inputTypes[ut]);const J=((ut,st)=>{const ct=st.map(pt=>`${pt.unpackedShape.join(",")};${pt.width}x${pt.height}`).join("_");let dt=ut.name;return ut.cacheHint&&(dt+="["+ut.cacheHint+"]"),dt+=":"+ct,dt})(b,U);let nt=this.session.programManager.getArtifact(J);const rt=nt?nt.programInfo:typeof b.get=="function"?b.get():b,ot=(0,G.createTextureLayoutFromTextureType)(this.session.layoutStrategy,rt.output.dims,rt.output.textureType),at=this.createTextureData(ot,rt.output.type);return nt||(nt=this.session.programManager.build(rt,U,at),this.session.programManager.setArtifact(J,nt)),this.runProgram(nt,U,at),at}run(b,j){return this.executeProgram(b,j).tensor}runProgram(b,j,U){for(let J=0;J<j.length;++J)if(!!j[J].isPacked!=(b.programInfo.inputTypes[J]===O.TextureType.packed))throw new Error(`input[${J}] property packed inconsistent`);if(!!U.isPacked!=(b.programInfo.output.textureType===O.TextureType.packed))throw new Error("output property packed inconsistent");this.session.programManager.run(b,j,U)}getOrCreateTextureData(b,j){let U=this.getTextureData(b.dataId,j===O.TextureType.packed);if(!U&&(U=this.getTextureData(b.dataId,j!==O.TextureType.packed),U))return j===O.TextureType.packed?this.pack(U):this.unpack(U);if(!U){const J=(0,G.createTextureLayoutFromTextureType)(this.session.layoutStrategy,b.dims,j);if(j===O.TextureType.packedLastDimension){const ot=b.dims;if(ot.length===4){const at=[ot[0],Math.ceil(ot[1]*ot[2]*ot[3]/4)],ut=(0,G.createTextureLayoutFromTextureType)(this.session.layoutStrategy,at,j);let st=b.numberData;if(ot[1]*ot[2]*ot[3]%4!=0){const ct=ot[0],dt=ot[1]*ot[2]*ot[3],pt=Math.ceil(dt*1/4)*4;st=new Float32Array(ct*pt);for(let lt=0;lt<ct;++lt){const ft=lt*dt,gt=lt*pt+lt%1*dt;st.set(b.numberData.subarray(ft,ft+dt),gt)}}return this.createTextureData(ut,b.type,st,b,1)}}if(j===O.TextureType.packed){const nt=(0,G.createTextureLayoutFromShape)(this.session.layoutStrategy,b.dims,1,[],{reverseWH:!0}),rt=this.createTextureData(nt,b.type,b.numberData,b,1);U=this.pack(rt)}else U=this.createTextureData(J,b.type,b.numberData,b,1)}return U}createTextureDataFromLayoutBindTensor(b,j,U,J){return this.createTextureData(b,j,U,J,1)}createTextureData(b,j,U,J,nt){X.Logger.verbose("InferenceHandler",`Creating TextureData: layout:[${JSON.stringify(b)}]`);const rt=this.session.textureManager.createTextureFromLayout(j,b,U,nt);return this.createTextureDataFromTexture(b,j,rt,J)}reshapeUnpacked(b,j){const U=this.getOrCreateTextureData(b,O.TextureType.unpacked),J={channels:U.channels,height:U.height,width:U.width,shape:j.length!==0?j:[1],strides:Q.ShapeUtil.computeStrides(j),unpackedShape:j};return this.createTextureDataFromTexture(J,b.type,U.texture).tensor}reshapePacked(b,j){const U=this.getOrCreateTextureData(b,O.TextureType.packed);if((0,tt.isReshapeCheap)(b.dims,j)){const at={channels:U.channels,height:U.height,width:U.width,shape:j.length!==0?j:[1],strides:Q.ShapeUtil.computeStrides(j),unpackedShape:j,isPacked:!0};return this.createTextureDataFromTexture(at,b.type,U.texture).tensor}const J=(0,tt.processDims3D)(b.dims),nt=(0,tt.processDims3D)(j),rt=this.reshapePacked(b,J),ot=this.run((0,tt.createPackedReshape3DProgramInfoLoader)(this,rt,nt),[rt]);return this.reshapePacked(ot,j)}cast(b,j){const U=this.getOrCreateTextureData(b,O.TextureType.unpacked);return this.createTextureDataFromTexture(U,j,U.texture).tensor}createTextureDataFromTexture(b,j,U,J,nt){const rt=Object.assign(Object.assign({},b),{tensor:J||new K.Tensor(b.unpackedShape,j,ot=>this.readTexture(rt),async ot=>this.readTextureAsync(rt),void 0,nt),texture:U});return this.setTextureData(rt.tensor.dataId,rt,b.isPacked),rt}getTextureData(b,j=!1){return this.session.isInitializer(b)?this.session.getTextureData(b,j):j?this.packedTextureDataCache.get(b):this.unpackedTextureDataCache.get(b)}setTextureData(b,j,U=!1){this.session.isInitializer(b)?this.session.setTextureData(b,j,U):(U?this.packedTextureDataCache:this.unpackedTextureDataCache).set(b,j)}isTextureLayoutCached(b,j=!1){return!!this.getTextureData(b.dataId,j)}dispose(){this.session.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(b=>this.session.textureManager.releaseTexture(b)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(b=>this.session.textureManager.releaseTexture(b)),this.unpackedTextureDataCache=new Map}readTexture(b){return b.isPacked?this.readTexture(this.unpack(b)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTexture(b,b.tensor.type,b.channels):this.session.textureManager.readUint8TextureAsFloat((0,et.encodeAsUint8)(this,b))}async readTextureAsync(b){return b.isPacked?this.readTextureAsync(this.unpack(b)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTextureAsync(b,b.tensor.type,b.channels):this.session.textureManager.readUint8TextureAsFloat((0,et.encodeAsUint8)(this,b))}pack(b){return this.executeProgram((0,Y.createPackProgramInfoLoader)(this,b.tensor),[b.tensor])}unpack(b){return this.executeProgram((0,q.createUnpackProgramInfoLoader)(this,b.tensor),[b.tensor])}}},4110:function(it,F,W){var X=this&&this.__createBinding||(Object.create?function(Ht,Mt,qt,Jt){Jt===void 0&&(Jt=qt);var Bt=Object.getOwnPropertyDescriptor(Mt,qt);Bt&&!("get"in Bt?!Mt.__esModule:Bt.writable||Bt.configurable)||(Bt={enumerable:!0,get:function(){return Mt[qt]}}),Object.defineProperty(Ht,Jt,Bt)}:function(Ht,Mt,qt,Jt){Jt===void 0&&(Jt=qt),Ht[Jt]=Mt[qt]}),K=this&&this.__setModuleDefault||(Object.create?function(Ht,Mt){Object.defineProperty(Ht,"default",{enumerable:!0,value:Mt})}:function(Ht,Mt){Ht.default=Mt}),Q=this&&this.__importStar||function(Ht){if(Ht&&Ht.__esModule)return Ht;var Mt={};if(Ht!=null)for(var qt in Ht)qt!=="default"&&Object.prototype.hasOwnProperty.call(Ht,qt)&&X(Mt,Ht,qt);return K(Mt,Ht),Mt};Object.defineProperty(F,"__esModule",{value:!0}),F.WEBGL_OP_RESOLVE_RULES=void 0;const Y=W(8817),tt=Q(W(5194)),et=W(4752),q=W(6668),G=W(9754),O=W(5042),b=W(6742),j=W(4125),U=W(6149),J=W(5378),nt=W(6981),rt=W(7413),ot=W(7006),at=W(8276),ut=W(5565),st=W(2834),ct=W(1010),dt=W(8126),pt=W(2801),lt=W(565),ft=W(2444),gt=W(815),_t=W(564),wt=W(5416),bt=W(1240),Ot=W(5944),vt=W(5707),xt=Q(W(9087)),Rt=W(7862),kt=W(3980);F.WEBGL_OP_RESOLVE_RULES=[["Abs","","6+",xt.abs],["Acos","","7+",xt.acos],["Add","","7+",tt.add],["And","","7+",tt.and],["Asin","","7+",xt.asin],["Atan","","7+",xt.atan],["AveragePool","","7+",st.averagePool,st.parseAveragePoolAttributes],["BatchNormalization","","7+",Y.batchNormalization,Y.parseBatchNormalizationAttributes],["Cast","","6+",et.cast,et.parseCastAttributes],["Ceil","","6+",xt.ceil],["Clip","","6-10",xt.clip,xt.parseClipAttributes],["Clip","","11+",xt.clipV11],["Concat","","4+",q.concat,q.parseConcatAttributes],["Conv","","1+",G.conv,G.parseConvAttributes],["ConvTranspose","","1+",O.convTranspose,O.parseConvTransposeAttributes],["Cos","","7+",xt.cos],["Div","","7+",tt.div],["Dropout","","7+",xt.identity],["DepthToSpace","","1+",b.depthToSpace,b.parseDepthToSpaceAttributes],["Equal","","7+",tt.equal],["Elu","","6+",xt.elu,xt.parseEluAttributes],["Exp","","6+",xt.exp],["Flatten","","1+",j.flatten,j.parseFlattenAttributes],["Floor","","6+",xt.floor],["FusedConv","com.microsoft","1+",G.conv,G.parseConvAttributes],["Gather","","1+",U.gather,U.parseGatherAttributes],["Gemm","","7-10",J.gemm,J.parseGemmAttributesV7],["Gemm","","11+",J.gemm,J.parseGemmAttributesV11],["GlobalAveragePool","","1+",st.globalAveragePool,st.parseGlobalAveragePoolAttributes],["GlobalMaxPool","","1+",st.globalMaxPool],["Greater","","7+",tt.greater],["Identity","","1+",xt.identity],["ImageScaler","","1+",nt.imageScaler,nt.parseImageScalerAttributes],["InstanceNormalization","","6+",rt.instanceNormalization,rt.parseInstanceNormalizationAttributes],["LeakyRelu","","6+",xt.leakyRelu,xt.parseLeakyReluAttributes],["Less","","7+",tt.less],["LRN","","1+",ot.lrn,ot.parseLrnAttributes],["Log","","6+",xt.log],["MatMul","","1+",at.matMul,at.parseMatMulAttributes],["MaxPool","","1+",st.maxPool,st.parseMaxPoolAttributes],["Mul","","7+",tt.mul],["Neg","","6+",xt.neg],["Not","","1+",xt.not],["Or","","7+",tt.or],["Pad","","2-10",ut.padV2,ut.parsePadAttributesV2],["Pad","","11+",ut.padV11,ut.parsePadAttributesV11],["Pow","","7+",tt.pow],["PRelu","","7+",tt.pRelu],["ReduceLogSum","","1+",ct.reduceLogSum,ct.parseReduceAttributes],["ReduceMax","","1+",ct.reduceMax,ct.parseReduceAttributes],["ReduceMean","","1+",ct.reduceMean,ct.parseReduceAttributes],["ReduceMin","","1+",ct.reduceMin,ct.parseReduceAttributes],["ReduceProd","","1+",ct.reduceProd,ct.parseReduceAttributes],["ReduceSum","","1-12",ct.reduceSum,ct.parseReduceAttributes],["ReduceSumSquare","","1+",ct.reduceLogSumSquare,ct.parseReduceAttributes],["Relu","","6+",xt.relu],["Reshape","","5+",dt.reshape],["Resize","","10",pt.resize,pt.parseResizeAttributesV10],["Resize","","11+",pt.resize,pt.parseResizeAttributesV11],["Shape","","1+",lt.shape],["Sigmoid","","6+",xt.sigmoid],["Sin","","7+",xt.sin],["Slice","","10+",ft.sliceV10],["Slice","","1-9",ft.slice,ft.parseSliceAttributes],["Softmax","","1-12",gt.softmax,gt.parseSoftmaxAttributes],["Softmax","","13+",gt.softmaxV13,gt.parseSoftmaxAttributesV13],["Split","","2-12",_t.split,_t.parseSplitAttributes],["Sqrt","","6+",xt.sqrt],["Squeeze","","1-12",wt.squeeze,wt.parseSqueezeAttributes],["Squeeze","","13+",wt.squeezeV13],["Sub","","7+",tt.sub],["Sum","","6+",bt.sum],["Tan","","7+",xt.tan],["Tanh","","6+",xt.tanh],["Tile","","6+",Ot.tile],["Transpose","","1+",vt.transpose,vt.parseTransposeAttributes],["Upsample","","7-8",kt.upsample,kt.parseUpsampleAttributesV7],["Upsample","","9",kt.upsample,kt.parseUpsampleAttributesV9],["Unsqueeze","","1-12",Rt.unsqueeze,Rt.parseUnsqueezeAttributes],["Unsqueeze","","13+",Rt.unsqueezeV13],["Xor","","7+",tt.xor]]},8817:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.parseBatchNormalizationAttributes=F.batchNormalization=void 0;const X=W(4910),K=W(6757),Q=W(5639),Y={name:"BatchNormalization",inputNames:["A","Scale","B","Mean","Variance"],inputTypes:[Q.TextureType.unpacked,Q.TextureType.unpacked,Q.TextureType.unpacked,Q.TextureType.unpacked,Q.TextureType.unpacked]};F.batchNormalization=(q,G,O)=>(et(G),[q.run(Object.assign(Object.assign({},Y),{cacheHint:O.cacheKey,get:()=>tt(q,G,O)}),G)]),F.parseBatchNormalizationAttributes=q=>{const G=q.attributes.getFloat("epsilon",1e-5),O=q.attributes.getFloat("momentum",.9),b=q.attributes.getInt("spatial",1);return(0,X.createAttributeWithCacheKey)({epsilon:G,momentum:O,spatial:b})};const tt=(q,G,O)=>{const b=(0,K.getGlsl)(q.session.backend.glContext.version),j=G[0].dims.length,[U,J]=q.calculateTextureWidthAndHeight(G[1].dims,Q.TextureType.unpacked),nt=`
  float process(int[${j}] indices) {
    vec2 position = offsetToCoords(indices[1], ${U}, ${J});
    float scale = getColorAsFloat(${b.texture2D}(Scale, position));
    float mean = getColorAsFloat(${b.texture2D}(Mean, position));
    float variance = getColorAsFloat(${b.texture2D}(Variance, position));
    float b = getColorAsFloat(${b.texture2D}(B, position));

    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${O.epsilon})) ) + b;
  }`;return Object.assign(Object.assign({},Y),{output:{dims:G[0].dims,type:G[0].type,textureType:Q.TextureType.unpacked},shaderSource:nt})},et=q=>{if(!q||q.length!==5)throw new Error("BatchNormalization requires 5 inputs.");const G=q[0],O=q[1],b=q[2],j=q[3],U=q[4];if(G.dims.length<3||O.dims.length!==1||b.dims.length!==1||j.dims.length!==1||U.dims.length!==1)throw new Error("invalid input shape.");if(O.dims[0]!==G.dims[1]||b.dims[0]!==G.dims[1]||j.dims[0]!==G.dims[1]||U.dims[0]!==G.dims[1])throw new Error("invalid input shape.");if(G.type!=="float32"&&G.type!=="float64"||O.type!=="float32"&&O.type!=="float64"||b.type!=="float32"&&b.type!=="float64"||j.type!=="float32"&&j.type!=="float64"||U.type!=="float32"&&U.type!=="float64")throw new Error("invalid input tensor types.")}},5194:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.xor=F.sub=F.pRelu=F.pow=F.or=F.mul=F.less=F.greater=F.equal=F.div=F.and=F.add=F.glslPRelu=F.glslPow=F.glslXor=F.glslOr=F.glslAnd=F.glslLess=F.glslGreater=F.glslEqual=F.glslSub=F.glslMul=F.glslDiv=F.glslAdd=void 0;const X=W(7273),K=W(1997),Q=W(6757),Y=W(5639);function tt(){const st="add_";return{body:`
  float ${st}(float a, float b) {
    return a + b;
  }
  vec4 ${st}(vec4 v1, vec4 v2) {
    return v1 + v2;
  }
  `,name:st,type:K.FunctionType.ValueBased}}function et(){const st="div_";return{body:`
  float ${st}(float a, float b) {
    return a / b;
  }
  vec4 ${st}(vec4 v1, vec4 v2) {
    return v1 / v2;
  }
  `,name:st,type:K.FunctionType.ValueBased}}function q(){const st="mul_";return{body:`
  float ${st}(float a, float b) {
    return a * b;
  }
  vec4 ${st}(vec4 v1, vec4 v2) {
    return v1 * v2;
  }
  `,name:st,type:K.FunctionType.ValueBased}}function G(){const st="sub_";return{body:`
  float ${st}(float a, float b) {
    return a - b;
  }
  vec4 ${st}(vec4 v1, vec4 v2) {
    return v1 - v2;
  }
  `,name:st,type:K.FunctionType.ValueBased}}function O(){const st="equal_";return{body:`
  float ${st}(float a, float b) {
    return float(a == b);
  }
  vec4 ${st}(vec4 v1, vec4 v2) {
    return vec4(equal(v1, v2));
  }
  `,name:st,type:K.FunctionType.ValueBased}}function b(){const st="greater_";return{body:`
  float ${st}(float a, float b) {
    return float(a > b);
  }
  vec4 ${st}(vec4 v1, vec4 v2) {
    return vec4( v1.r > v2.r ,
      v1.g > v2.g,
      v1.b > v2.b,
      v1.a > v2.a );
  }
  `,name:st,type:K.FunctionType.ValueBased}}function j(){const st="less_";return{body:`
  float ${st}(float a, float b) {
    return float(a < b);
  }
  vec4 ${st}(vec4 v1, vec4 v2) {
    return vec4( v1.r < v2.r ,
                v1.g < v2.g,
                v1.b < v2.b,
                v1.a < v2.a );
  }
  `,name:st,type:K.FunctionType.ValueBased}}function U(){const st="and_";return{body:`
  float ${st}(float a, float b) {
    return float( bool(a) && bool(b) );
  }
  vec4 ${st}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r && b2.r ,
                b1.g && b2.g,
                b1.b && b2.b,
                b1.a && b2.a );
  }
  `,name:st,type:K.FunctionType.ValueBased}}function J(){const st="or_";return{body:`
  float ${st}(float a, float b) {
    return float( bool(a) || bool(b) );
  }
  vec4 ${st}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r || b2.r ,
                b1.g || b2.g,
                b1.b || b2.b,
                b1.a || b2.a );
  }
  `,name:st,type:K.FunctionType.ValueBased}}function nt(){const st="xor_";return{body:`
  float ${st}(float a, float b) {
    return float( bool(a) ^^ bool(b) );
  }
  vec4 ${st}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r ^^ b2.r ,
                b1.g ^^ b2.g,
                b1.b ^^ b2.b,
                b1.a ^^ b2.a );
  }
  `,name:st,type:K.FunctionType.ValueBased}}function rt(){return function(st){const ct=`${st}_`;return{body:`
  float ${ct}(float a, float b) {
    return ${st}(a, b);
  }
  vec4 ${ct}(vec4 v1, vec4 v2) {
    return ${st}(v1, v2);
  }
  `,name:ct,type:K.FunctionType.ValueBased}}("pow")}function ot(){const st="prelu_";return{body:`
  float ${st}(float a, float b) {
    return a < 0.0 ? a * b: a;
  }
  vec4 ${st}(vec4 v1, vec4 v2) {
    return vec4(
      v1.r < 0.0 ? v1.r * v2.r: v1.r,
      v1.g < 0.0 ? v1.g * v2.g: v1.g,
      v1.b < 0.0 ? v1.b * v2.b: v1.b,
      v1.a < 0.0 ? v1.a * v2.a: v1.a
      );
  }
  `,name:st,type:K.FunctionType.ValueBased}}F.glslAdd=tt,F.glslDiv=et,F.glslMul=q,F.glslSub=G,F.glslEqual=O,F.glslGreater=b,F.glslLess=j,F.glslAnd=U,F.glslOr=J,F.glslXor=nt,F.glslPow=rt,F.glslPRelu=ot;const at=(st,ct,dt,pt=ct[0].type,lt)=>{const ft=st.session.pack?Y.TextureType.packed:Y.TextureType.unpacked;return{name:dt.name,inputNames:["A","B"],inputTypes:[ft,ft],cacheHint:lt,get:()=>ut(st,ct,dt,pt)}},ut=(st,ct,dt,pt=ct[0].type)=>{const lt=st.session.pack?Y.TextureType.packed:Y.TextureType.unpacked,ft=!X.ShapeUtil.areEqual(ct[0].dims,ct[1].dims);let gt=ct[0].dims;const _t=st.session.pack;if(ft){const Ot=X.BroadcastUtil.calcShape(ct[0].dims,ct[1].dims,!1);if(!Ot)throw new Error("Can't perform binary op on the given tensors");gt=Ot;const vt=gt.length,xt=ct[0].dims.length!==0?ct[0].dims.length:1,Rt=ct[1].dims.length!==0?ct[1].dims.length:1,kt=ct[0].dims.length!==0?"bcastIndices_A(indices, aindices);":"aindices[0] = 0;",Ht=ct[1].dims.length!==0?"bcastIndices_B(indices, bindices);":"bindices[0] = 0;",Mt=(0,Q.getGlsl)(st.session.backend.glContext.version),qt=_t?`
      ${dt.body}
      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();
        vec4 result = ${dt.name}(a, b);
        ${Mt.output} = result;
      }`:`
      ${dt.body}
      float process(int indices[${vt}]) {
        int aindices[${xt}];
        int bindices[${Rt}];
        ${kt}
        ${Ht}
        return ${dt.name}(_A(aindices), _B(bindices));
      }`;return{name:dt.name,inputNames:["A","B"],inputTypes:[lt,lt],output:{dims:gt,type:pt,textureType:lt},shaderSource:qt,hasMain:_t}}const wt=(0,Q.getGlsl)(st.session.backend.glContext.version),bt=`
    ${dt.body}
    void main() {
      vec4 v1 = ${wt.texture2D}(A, TexCoords);
      vec4 v2 = ${wt.texture2D}(B, TexCoords);
      vec4 result = ${dt.name}(v1, v2);
      ${wt.output} = result;
    }
    `;return{name:dt.name,inputNames:["A","B"],inputTypes:[lt,lt],output:{dims:ct[0].dims,type:pt,textureType:lt},shaderSource:bt,hasMain:!0}};F.add=(st,ct)=>[st.run(at(st,ct,tt()),ct)],F.and=(st,ct)=>[st.run(at(st,ct,U(),"bool"),ct)],F.div=(st,ct)=>[st.run(at(st,ct,et()),ct)],F.equal=(st,ct)=>[st.run(at(st,ct,O(),"bool"),ct)],F.greater=(st,ct)=>[st.run(at(st,ct,b(),"bool"),ct)],F.less=(st,ct)=>[st.run(at(st,ct,j(),"bool"),ct)],F.mul=(st,ct)=>[st.run(at(st,ct,q()),ct)],F.or=(st,ct)=>[st.run(at(st,ct,J(),"bool"),ct)],F.pow=(st,ct)=>[st.run(at(st,ct,rt()),ct)],F.pRelu=(st,ct)=>[st.run(at(st,ct,ot()),ct)],F.sub=(st,ct)=>[st.run(at(st,ct,G()),ct)],F.xor=(st,ct)=>[st.run(at(st,ct,nt(),"bool"),ct)]},4752:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.parseCastAttributes=F.cast=void 0;const X=W(7273);F.cast=(Q,Y,tt)=>(K(Y),[Q.cast(Y[0],tt)]),F.parseCastAttributes=Q=>X.ProtoUtil.tensorDataTypeFromProto(Q.attributes.getInt("to"));const K=Q=>{if(!Q||Q.length!==1)throw new Error("Cast requires 1 input.");if(Q[0].type==="string")throw new Error("Invalid input type.")}},4595:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.createPackedConcatProgramInfoLoader=void 0;const X=W(6757),K=W(5639),Q=W(432),Y=W(5614);F.createPackedConcatProgramInfoLoader=(et,q,G)=>{const O=(b=q.length,j=G.cacheKey,{name:"Concat (packed)",inputNames:Array.from({length:b},(U,J)=>`X${J}`),inputTypes:Array(b).fill(K.TextureType.packed),cacheHint:j});var b,j;return Object.assign(Object.assign({},O),{get:()=>((U,J,nt,rt)=>{const ot=nt[0].dims.slice();if(rt>=ot.length||rt<-1*ot.length)throw new Error("axis specified for concat doesn't match input dimensionality");rt<0&&(rt=ot.length+rt);const at=ot.slice(0);for(let kt=1;kt<nt.length;kt++){const Ht=nt[kt].dims.slice();for(let Mt=0;Mt<ot.length;Mt++)if(Mt===rt)at[rt]+=Ht[Mt];else if(ot[Mt]!==Ht[Mt])throw new Error("non concat dimensions must match")}const ut=at.length,st=(0,Y.getChannels)("coords",ut),ct=(0,Q.getCoordsDataType)(ut),dt=(0,Y.unpackFromChannel)(),pt=nt.map(kt=>kt.dims),lt=(0,Q.getGlChannels)(ut),ft=new Array(pt.length-1);ft[0]=pt[0][rt];for(let kt=1;kt<ft.length;kt++)ft[kt]=ft[kt-1]+pt[kt][rt];const gt=lt[rt],_t=lt.slice(-2),wt=lt.join();let bt=`if (${gt} < ${ft[0]}) {
        return getChannel(
            getX0(${wt}), vec2(${_t.join()}));
        }`;for(let kt=1;kt<ft.length;kt++){const Ht=ft[kt-1];bt+=`
            if (${gt} < ${ft[kt]}  && ${gt} >= ${ft[kt-1]}) {
              return getChannel(
                getX${kt}(${tt(lt,gt,Ht)}),
                vec2(${tt(_t,gt,Ht)}));
            }`}const Ot=ft.length,vt=ft[ft.length-1];bt+=`
            return getChannel(
              getX${Ot}(${tt(lt,gt,vt)}),
              vec2(${tt(_t,gt,vt)}));`;const xt=(0,X.getGlsl)(U.session.backend.glContext.version),Rt=`
          ${dt}
          float getValue(${lt.map(kt=>"int "+kt)}) {
            ${bt}
          }

          void main() {
            ${ct} coords = getOutputCoords();
            int lastDim = coords.${lt[ut-1]};
            coords.${lt[ut-1]} = coords.${lt[ut-2]};
            coords.${lt[ut-2]} = lastDim;

            vec4 result = vec4(getValue(${st}), 0., 0., 0.);

            ${st[ut-1]} = ${st[ut-1]} + 1;
            if (${st[ut-1]} < ${at[ut-1]}) {
              result.g = getValue(${st});
            }

            ${st[ut-2]} = ${st[ut-2]} + 1;
            if (${st[ut-2]} < ${at[ut-2]}) {
              result.a = getValue(${st});
            }

            ${st[ut-1]} = ${st[ut-1]} - 1;
            if (${st[ut-2]} < ${at[ut-2]} &&
                ${st[ut-1]} < ${at[ut-1]}) {
              result.b = getValue(${st});
            }
            ${xt.output} = result;
          }
        `;return Object.assign(Object.assign({},J),{output:{dims:at,type:nt[0].type,textureType:K.TextureType.packed},shaderSource:Rt,hasMain:!0})})(et,O,q,G.axis)})};const tt=(et,q,G)=>{const O=et.indexOf(q);return et.map((b,j)=>j===O?`${b} - ${G}`:b).join()}},6668:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.parseConcatAttributes=F.concat=void 0;const X=W(4910),K=W(5639),Q=W(4595);F.concat=(b,j,U)=>(O(j),b.session.pack&&j[0].dims.length>1?[b.run((0,Q.createPackedConcatProgramInfoLoader)(b,j,U),j)]:[b.run(Y(b,j,U),j)]);const Y=(b,j,U)=>{const J=(nt=j.length,rt=U.cacheKey,{name:"Concat",inputNames:Array.from({length:nt},(ot,at)=>`X${at}`),inputTypes:Array(nt).fill(K.TextureType.unpacked),cacheHint:rt});var nt,rt;return Object.assign(Object.assign({},J),{get:()=>((ot,at,ut,st)=>{const ct=ut[0].dims.slice();if(st>=ct.length||st<-1*ct.length)throw new Error("axis specified for concat doesn't match input dimensionality");st<0&&(st=ct.length+st);const dt=ct.slice(0);for(let wt=1;wt<ut.length;wt++){const bt=ut[wt].dims.slice();for(let Ot=0;Ot<ct.length;Ot++)if(Ot===st)dt[st]+=bt[Ot];else if(ct[Ot]!==bt[Ot])throw new Error("non concat dimensions must match")}const pt=dt.length,lt=new Array(ut.length);let ft=0;for(let wt=0;wt<lt.length;++wt)ft+=ut[wt].dims[st],lt[wt]=ft;let gt="";gt=ut.length<5?tt(lt):et(lt);const _t=`
        ${q(ut.length,pt)}
        ${G(lt)}
        ${gt}
        float process(int indices[${pt}]) {
          int textureIndex = getTextureWhereDataResides (indices[${st}]);

          if(textureIndex != 0) {
            indices[${st}] = indices[${st}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));
          }

          return fetchDataFromCorrectTexture(textureIndex, indices);
        }`;return Object.assign(Object.assign({},at),{output:{dims:dt,type:ut[0].type,textureType:K.TextureType.unpacked},shaderSource:_t})})(0,J,j,U.axis)})},tt=b=>`int getTextureWhereDataResides(int index) {
      ${b.map((j,U)=>`if(index<${j}) {return ${U};}
`).join("")}
    }`,et=b=>tt(b),q=(b,j)=>{const U=[`float fetchDataFromCorrectTexture(int textureIndex, int indices[${j}]) {`];for(let J=0;J<b;++J)J===0?U.push(`	if (textureIndex == ${J}) { return _X${J}(indices); }`):J===b-1?U.push(`	else { return _X${J}(indices); }`):U.push(`	else if (textureIndex == ${J}) { return _X${J}(indices); }`);return U.push("	}"),U.join(`
`)},G=b=>{const j=["int getSizeInConcatAxisValueFromIndex(int index) {"];for(let U=0;U<b.length;++U)U===0?j.push(`	if (index == ${U}) { return ${b[U]}; }`):U===b.length-1?j.push(`	else { return ${b[U]}; }`):j.push(`	else if (index == ${U}) { return ${b[U]}; }`);return j.push("	}"),j.join(`
`)};F.parseConcatAttributes=b=>(0,X.createAttributeWithCacheKey)({axis:b.attributes.getInt("axis")});const O=b=>{if(!b||b.length<1)throw new Error("too few inputs");const j=b[0].type,U=b[0].dims.length;if(j==="string")throw new Error("string tensor is not supported yet");for(const J of b){if(J.type!==j)throw new Error("input tensors should be one type");if(J.dims.length!==U)throw new Error("input tensors should have the same shape")}}},7825:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.createUnpackedGroupedConvProgramInfoLoader=void 0;const X=W(1315),K=W(6757),Q=W(5639),Y=W(9754),tt=W(2150);F.createUnpackedGroupedConvProgramInfoLoader=(et,q,G)=>{const O=(b=q.length>2,j=G.cacheKey,{name:"GroupedConv",inputNames:b?["X","W","Bias"]:["X","W"],inputTypes:b?[Q.TextureType.unpacked,Q.TextureType.unpacked,Q.TextureType.unpacked]:[Q.TextureType.unpacked,Q.TextureType.unpacked],cacheHint:j});var b,j;return Object.assign(Object.assign({},O),{get:()=>((U,J,nt,rt)=>{const ot=J.length>2?"value += getBias(output_channel);":"",at=J[0].dims.slice(),ut=J[1].dims.slice(),st=ut[0]/rt.group;X.Logger.verbose("GroupedConv",`autpPad:${rt.autoPad}, dilations:${rt.dilations}, group:${rt.group}, kernelShape:${rt.kernelShape}, pads:${rt.pads}, strides:${rt.strides}`);const ct=(0,Y.calculateOutputShape)(at,ut,rt.dilations,rt.pads,rt.strides),dt=(0,K.getGlsl)(U.session.backend.glContext.version),{activationFunction:pt,applyActivation:lt}=(0,tt.getActivationSnippet)(rt),ft=`
  const ivec2 strides = ivec2(${rt.strides[0]}, ${rt.strides[1]});
  const ivec2 pads = ivec2(${rt.pads[0]}, ${rt.pads[1]});
  ${pt}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;
    ivec2 xRCCorner = coords.zw * strides - pads;
    int group_id = output_channel / ${st};

    float value = 0.0;
    for (int wInChannel = 0; wInChannel < ${ut[1]}; wInChannel++) {
      int input_channel = group_id * ${ut[1]} + wInChannel;
      for (int wHeight = 0; wHeight < ${ut[2]}; wHeight++) {
        int xHeight = xRCCorner.x + wHeight * ${rt.dilations[0]};

        if (xHeight < 0 || xHeight >= ${at[2]}) {
          continue;
        }

        for (int wWidth = 0; wWidth < ${ut[3]}; wWidth++) {
          int xWidth = xRCCorner.y + wWidth * ${rt.dilations[1]};
          if (xWidth < 0 || xWidth >= ${at[3]}) {
            continue;
          }

          float xVal = getX(batch, input_channel, xWidth, xHeight);
          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);
          value += xVal*wVal;
        }
      }
    }
    ${ot}
    ${lt}
    ${dt.output} = vec4(value, .0, .0, .0);
  }
`;return Object.assign(Object.assign({},nt),{output:{dims:ct,type:J[0].type,textureType:Q.TextureType.unpacked},shaderSource:ft,hasMain:!0})})(et,q,O,G)})}},7708:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.conv2DPacked=F.conv2DPackedPointwise=void 0;const X=W(9754),K=W(5950),Q=W(5632);F.conv2DPackedPointwise=(Y,tt,et)=>{const q=tt[0].dims,G=tt[1].dims,O=(0,X.calculateOutputShape)(q,G,et.dilations,et.pads,et.strides),b=Y.reshapePacked(tt[0],[q[1],q[2]*q[3]]),j=Y.reshapePacked(tt[1],[G[0],G[1]]),U=tt.length>2?[j,b,tt[2]]:[j,b],J=Y.run((0,Q.createPackedMatmulProgramInfoLoader)(Y,U,et),U);return Y.reshapePacked(J,O)},F.conv2DPacked=(Y,tt,et)=>{const q=tt[0].dims,G=tt[1].dims,O=(0,X.calculateOutputShape)(q,G,et.dilations,et.pads,et.strides),b=Y.run((0,K.createPackedIm2ColProgramInfoLoader)(Y,tt[0],tt[1],O,et),[tt[0]]),j=Y.reshapePacked(tt[1],[G[0],G[1]*G[2]*G[3]]),U=tt.length===3?[j,b,tt[2]]:[j,b],J=Y.run((0,Q.createPackedMatmulProgramInfoLoader)(Y,U,et),U);return Y.reshapePacked(J,O)}},5042:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.parseConvTransposeAttributes=F.convTranspose=void 0;const X=W(4910),K=W(6757),Q=W(5639),Y=W(2150),tt=(j,U,J,nt,rt,ot)=>(j-1)*U+J+(nt-1)*rt+1-ot,et=(j,U,J,nt,rt)=>{const ot=Math.floor(j/2);U==="SAME_UPPER"?(J[nt]=ot,J[rt]=j-ot):U==="SAME_LOWER"&&(J[nt]=j-ot,J[rt]=ot)};F.convTranspose=(j,U,J)=>(b(U,J),q(j,U,J));const q=(j,U,J)=>{const nt=O(J,U);return[G(j,U,nt)]},G=(j,U,J)=>j.run(((nt,rt,ot)=>{const at=(ut=rt.length>2,st=ot.cacheKey,{name:"ConvTranspose",inputNames:ut?["X","W","B"]:["X","W"],inputTypes:ut?[Q.TextureType.unpacked,Q.TextureType.unpacked,Q.TextureType.unpacked]:[Q.TextureType.unpacked,Q.TextureType.unpacked],cacheHint:st});var ut,st;return Object.assign(Object.assign({},at),{get:()=>((ct,dt,pt,lt)=>{const ft=dt.length>2?"getB(output_channel)":"0.0",gt=dt[0].dims,_t=dt[1].dims,wt=_t[1],bt=_t[0]/lt.group,Ot=[dt[0].dims[0],dt[1].dims[1]*lt.group,...lt.outputShape],vt=(0,K.getGlsl)(ct.session.backend.glContext.version),{activationFunction:xt,applyActivation:Rt}=(0,Y.getActivationSnippet)(lt),kt=`
  const ivec2 strides = ivec2(${lt.strides[0]}, ${lt.strides[1]});
  const ivec2 pads = ivec2(${lt.pads[0]}, ${lt.pads[1]});
  ${xt}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;

    ivec2 loc = coords.zw + pads;

    int group_id = output_channel / ${wt};
    int wOutChannel = output_channel - group_id * ${wt};

    float value = ${ft};
    for (int inChannelOffset = 0; inChannelOffset < ${bt}; inChannelOffset++) {
      int input_channel = group_id * ${bt} + inChannelOffset;
      for (int wWOff = 0; wWOff < ${_t[2]}; wWOff++) {
        for (int wHOff = 0; wHOff < ${_t[3]}; wHOff++) {
          ivec2 wOff = ivec2(wWOff * ${lt.dilations[0]}, wHOff * ${lt.dilations[1]});
          ivec2 wLoc = loc - wOff;
          ivec2 wLocIn = wLoc / strides;
          if (
            wLocIn * strides == wLoc &&
            wLocIn.x >= 0 && wLocIn.x < ${gt[2]} &&
            wLocIn.y >= 0 && wLocIn.y < ${gt[3]}
          ) {
            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);
            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);
            value += xVal * wVal;
          }
        }
      }
    }
    ${Rt}
    ${vt.output} = vec4(value, .0, .0, .0);
  }
`;return Object.assign(Object.assign({},pt),{output:{dims:Ot,type:dt[0].type,textureType:Q.TextureType.unpacked},shaderSource:kt,hasMain:!0})})(nt,rt,at,ot)})})(j,U,J),U),O=(j,U)=>{const J=j.kernelShape.slice();if(j.kernelShape.length===0)for(let at=2;at<U[1].dims.length;++at)J.push(U[1].dims[at]);const nt=j.pads.slice(),rt=j.outputShape.slice();((at,ut,st,ct,dt,pt,lt,ft)=>{const gt=at.length-2,_t=ft.length===0;for(let wt=0;wt<gt;++wt){const bt=_t?at[wt+2]*pt[wt]:ft[wt],Ot=tt(at[wt+2],pt[wt],dt[wt],ut[wt],st[wt],bt);et(Ot,ct,dt,wt,wt+gt),_t&&ft.push(pt[wt]*(at[wt+2]-1)+lt[wt]+(ut[wt]-1)*st[wt]+1-dt[wt]-dt[wt+gt])}})(U[0].dims,J,j.dilations,j.autoPad,nt,j.strides,j.outputPadding,rt);const ot=Object.assign({},j);return Object.assign(ot,{kernelShape:J,pads:nt,outputShape:rt,cacheKey:j.cacheKey}),ot};F.parseConvTransposeAttributes=j=>{const U=j.attributes,J=(0,Y.parseInternalActivationAttributes)(U),nt=U.getString("auto_pad","NOTSET"),rt=U.getInts("dilations",[1,1]),ot=U.getInt("group",1),at=U.getInts("kernel_shape",[]),ut=U.getInts("output_padding",[0,0]),st=U.getInts("output_shape",[]),ct=U.getInts("pads",[0,0,0,0]),dt=U.getInts("strides",[1,1]);return(0,X.createAttributeWithCacheKey)(Object.assign({autoPad:nt,dilations:rt,group:ot,kernelShape:at,outputPadding:ut,outputShape:st,pads:ct,strides:dt},J))};const b=(j,U)=>{if(!j||j.length!==2&&j.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(j[0].dims.length!==4||j[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");if(j[0].dims[1]!==j[1].dims[0])throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");const J=j[1].dims[1]*U.group;if(j.length===3&&(j[2].dims.length!==1||j[2].dims[0]!==J))throw new Error("invalid bias");const nt=j[0].dims.length-2;if(U.dilations.length!==nt)throw new Error(`dilations should be ${nt}D`);if(U.strides.length!==nt)throw new Error(`strides should be ${nt}D`);if(U.pads.length!==2*nt)throw new Error(`pads should be ${2*nt}D`);if(U.outputPadding.length!==nt)throw new Error(`output_padding should be ${nt}D`);if(U.kernelShape.length!==0&&U.kernelShape.length!==j[1].dims.length-2)throw new Error("invalid kernel shape");if(U.outputShape.length!==0&&U.outputShape.length!==j[0].dims.length-2)throw new Error("invalid output shape");if(j[0].type!=="float32"||j[1].type!=="float32")throw new Error("ConvTranspose input(X,W) should be float tensor");if(j.length===3&&j[2].type!=="float32")throw new Error("ConvTranspose input(bias) should be float tensor")}},9754:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.parseConvAttributes=F.conv=F.calculateOutputShape=void 0;const X=W(4910),K=W(7273),Q=W(7825),Y=W(7708),tt=W(3281),et=W(2150),q=W(1625),G=W(8276);F.calculateOutputShape=(nt,rt,ot,at,ut)=>{const st=nt[0],ct=nt.slice(2),dt=ct.length,pt=rt[0],lt=rt.slice(2).map((gt,_t)=>gt+(gt-1)*(ot[_t]-1)),ft=ct.map((gt,_t)=>gt+at[_t]+at[_t+dt]).map((gt,_t)=>Math.floor((gt-lt[_t]+ut[_t])/ut[_t]));return[st,pt].concat(...ft)},F.conv=(nt,rt,ot)=>(J(rt,ot),O(nt,rt,ot));const O=(nt,rt,ot)=>{const at=U(ot,rt),ut=nt.session.pack,st=at.kernelShape[0]===1&&at.kernelShape[1]===1;return at.group>1?[nt.run((0,Q.createUnpackedGroupedConvProgramInfoLoader)(nt,rt,at),rt)]:st&&ut?[b(nt,rt,at)]:ut&&rt[0].dims.length===4&&rt[0].dims[0]===1&&!st?[(0,Y.conv2DPacked)(nt,rt,at)]:[j(nt,rt,at)]},b=(nt,rt,ot)=>{const at=rt[0].dims,ut=rt[1].dims,st=(0,F.calculateOutputShape)(at,ut,ot.dilations,ot.pads,ot.strides),ct=nt.reshapeUnpacked(rt[0],[at[1],at[2]*at[3]]),dt=nt.reshapeUnpacked(rt[1],[ut[0],ut[1]]),pt=rt.length>2?[dt,ct,rt[2]]:[dt,ct],lt=nt.run((0,G.createMatmulProgramInfoLoader)(pt,ot),pt);return nt.reshapeUnpacked(lt,st)},j=(nt,rt,ot)=>{const at=rt[0].dims,ut=rt[1].dims,st=(0,F.calculateOutputShape)(at,ut,ot.dilations,ot.pads,ot.strides),ct=nt.run((0,q.createIm2ColProgramInfoLoader)(nt,rt[0],rt[1],st,ot),[rt[0]]),dt=rt.length===3?[ct,rt[1],rt[2]]:[ct,rt[1]];return nt.run((0,tt.createDotProductProgramInfoLoader)(nt,rt,st,ot),dt)},U=(nt,rt)=>{const ot=nt.kernelShape.slice();if(nt.kernelShape.length===0)for(let st=2;st<rt[1].dims.length;++st)ot.push(rt[1].dims[st]);const at=nt.pads.slice();K.PoolConvUtil.adjustPadsBasedOnAutoPad(rt[0].dims,nt.strides,nt.dilations,ot,at,nt.autoPad);const ut=Object.assign({},nt);return Object.assign(ut,{kernelShape:ot,pads:at,cacheKey:nt.cacheKey}),ut};F.parseConvAttributes=nt=>{const rt=nt.attributes,ot=(0,et.parseInternalActivationAttributes)(rt),at=rt.getString("auto_pad","NOTSET"),ut=rt.getInts("dilations",[1,1]),st=rt.getInt("group",1),ct=rt.getInts("kernel_shape",[]),dt=rt.getInts("pads",[0,0,0,0]),pt=rt.getInts("strides",[1,1]);return(0,X.createAttributeWithCacheKey)(Object.assign({autoPad:at,dilations:ut,group:st,kernelShape:ct,pads:dt,strides:pt},ot))};const J=(nt,rt)=>{if(!nt||nt.length!==2&&nt.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(nt[0].dims.length!==4||nt[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");if(nt[0].dims[1]!==nt[1].dims[1]*rt.group)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(nt.length===3&&(nt[2].dims.length!==1||nt[1].dims[0]!==nt[2].dims[0]))throw new Error("invalid bias");const ot=nt[0].dims.length-2;if(rt.dilations.length!==ot)throw new Error(`dilations should be ${ot}D`);if(rt.strides.length!==ot)throw new Error(`strides should be ${ot}D`);if(rt.pads.length!==2*ot)throw new Error(`pads should be ${2*ot}D`);if(rt.kernelShape.length!==0&&rt.kernelShape.length!==nt[1].dims.length-2)throw new Error("invalid kernel shape");if(nt[0].type!=="float32"||nt[1].type!=="float32")throw new Error("Conv input(X,W) should be float tensor");if(nt.length===3&&nt[2].type!=="float32")throw new Error("Conv input(bias) should be float tensor")}},6742:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.parseDepthToSpaceAttributes=F.depthToSpace=void 0;const X=W(5707);F.depthToSpace=(Q,Y,tt)=>{K(Y);const et=tt.blocksize,q=et*et,G=tt.mode==="DCR"?[0,3,4,1,5,2]:[0,1,4,2,5,3],O=tt.mode==="DCR"?[Y[0].dims[0],et,et,Y[0].dims[1]/q,Y[0].dims[2],Y[0].dims[3]]:[Y[0].dims[0],Y[0].dims[1]/q,et,et,Y[0].dims[2],Y[0].dims[3]],b=Q.reshapeUnpacked(Y[0],O),j={perm:G,cacheKey:`${G}`},[U]=(0,X.transpose)(Q,[b],j),J=[Y[0].dims[0],Y[0].dims[1]/q,Y[0].dims[2]*et,Y[0].dims[3]*et];return[Q.reshapeUnpacked(U,J)]},F.parseDepthToSpaceAttributes=Q=>{const Y=Q.attributes.getInt("blocksize");if(Y<1)throw new Error(`blocksize must be >= 1, but got : ${Y} for DepthToSpace`);const tt=Q.attributes.getString("mode","DCR");if(tt!=="DCR"&&tt!=="CRD")throw new Error(`unrecognized mode: ${tt} for DepthToSpace`);return{mode:tt,blocksize:Y}};const K=Q=>{if(Q.length!==1)throw new Error(`DepthToSpace expect 1 inputs, but got ${Q.length}`);if(Q[0].type==="string"||Q[0].dims.length!==4)throw new TypeError("DepthToSpace input should be a 4-D numeric tensor")}},3281:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.createDotProductProgramInfoLoader=void 0;const X=W(7273),K=W(6757),Q=W(5639),Y=W(2150),tt=W(1625);F.createDotProductProgramInfoLoader=(et,q,G,O)=>{const b=((j,U)=>({name:"ConvDotProduct",inputNames:j?["Im2Col","K","B"]:["Im2Col","K"],inputTypes:j?[Q.TextureType.unpacked,Q.TextureType.packedLastDimension,Q.TextureType.unpacked]:[Q.TextureType.unpacked,Q.TextureType.packedLastDimension],cacheKey:U.activationCacheKey}))(q.length>2,O);return Object.assign(Object.assign({},b),{get:()=>((j,U,J,nt,rt)=>{const ot=J[0].dims,at=J[1].dims,ut=[at[0],Math.ceil(ot[1]*at[2]*at[3]/4)],st=(0,tt.calculateIm2ColDims)(ot,at,nt),[ct,dt]=j.calculateTextureWidthAndHeight(ut,Q.TextureType.packedLastDimension),pt=X.ShapeUtil.computeStrides(st),[lt,ft]=j.calculateTextureWidthAndHeight(st,Q.TextureType.packedLastDimension),gt=nt.length,_t=J.length<3?"0.0":"_B(b)",wt=Math.ceil(ot[1]*at[2]*at[3]/4),{activationFunction:bt,applyActivation:Ot}=(0,Y.getActivationSnippet)(rt),vt=(0,K.getGlsl)(j.session.backend.glContext.version),xt=`
${bt}
float process(int indices[${gt}]) {
  int b[1];
  b[0] = indices[1];
  int im2col[4];
  im2col[0] = indices[0];
  im2col[1] = indices[2];
  im2col[2] = indices[3];
  int im2colOffset = im2col[0] * ${pt[0]} + im2col[1] * ${pt[1]} + im2col[2] * ${pt[2]};
  int kernelOffset = indices[1] * ${ut[1]};
  float value = ${_t};
  for (int i = 0; i < ${wt}; ++i) {
    vec2 im2colCoords = offsetToCoords(im2colOffset, ${lt}, ${ft});
    vec2 kernelCoords = offsetToCoords(kernelOffset, ${ct}, ${dt});
    value += dot(${vt.texture2D}(Im2Col, im2colCoords), ${vt.texture2D}(K, kernelCoords));
    ++im2colOffset;
    ++kernelOffset;
  }
  ${Ot}
  return value;
}`;return Object.assign(Object.assign({},U),{output:{dims:nt,type:J[0].type,textureType:Q.TextureType.unpacked},shaderSource:xt})})(et,b,q,G,O)})}},4125:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.parseFlattenAttributes=F.flatten=void 0;const X=W(7273);F.flatten=(Q,Y,tt)=>{K(Y,tt);const et=X.ShapeUtil.flattenShape(Y[0].dims,tt);return[Q.reshapeUnpacked(Y[0],et)]},F.parseFlattenAttributes=Q=>Q.attributes.getInt("axis",1);const K=(Q,Y)=>{if(!Q||Q.length!==1)throw new Error("Flatten requires 1 input.");const tt=Q[0].dims.length;if(tt===0)throw new Error("scalar tensor is not supported.");if(Y<-tt||Y>tt)throw new Error("Invalid axis");if(Q[0].type==="string")throw new Error("string tensor is not supported.")}},2150:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.parseInternalActivationAttributes=F.getActivationSnippet=void 0;const X=W(7273),K=W(9087);F.getActivationSnippet=function(Q){let Y;switch(Q.activation){case"Relu":Y=(0,K.glslRelu)();break;case"Sigmoid":Y=(0,K.glslSigmoid)();break;case"Clip":Y=(0,K.glslClip)(Q.clipMin,Q.clipMax);break;default:return{activationFunction:"",applyActivation:""}}const tt=Y.name;return{activationFunction:Y.body,applyActivation:`value = ${tt}_(value);`}},F.parseInternalActivationAttributes=Q=>{const Y=Q.getString("activation","");if(Y==="Clip"){const[tt,et]=Q.getFloats("activation_params",[X.MIN_CLIP,X.MAX_CLIP]);return{activation:Y,clipMax:et,clipMin:tt,activationCacheKey:`${Y}:${tt},${et}`}}return{activation:Y,activationCacheKey:Y}}},6149:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.parseGatherAttributes=F.gather=void 0;const X=W(4910),K=W(6145),Q=W(7273),Y=W(5639);F.gather=(G,O,b)=>(q(O,b.axis),[G.run(et(G,O,b),O)]),F.parseGatherAttributes=G=>(0,X.createAttributeWithCacheKey)({axis:G.attributes.getInt("axis",0)});const tt={name:"Gather",inputNames:["A","B"],inputTypes:[Y.TextureType.unpacked,Y.TextureType.unpacked]},et=(G,O,b)=>{const j=Object.assign(Object.assign({},tt),{cacheHint:b.cacheKey});return Object.assign(Object.assign({},j),{get:()=>((U,J,nt,rt)=>{const ot=nt[0].dims.slice(),at=nt[1].dims.slice(),ut=new Array(ot.length+at.length-1);rt=Q.ShapeUtil.normalizeAxis(rt,ot.length);const st=[];for(let dt=0;dt<ut.length;dt++)dt<rt?(ut[dt]=ot[dt],st.push(`inputIdx[${dt}] = outputIdx[${dt}];`)):dt<rt+at.length?(ut[dt]=at[dt-rt],st.push(`indexDataIdx[${dt-rt}] = outputIdx[${dt}];`)):(ut[dt]=ot[dt-at.length+1],st.push(`inputIdx[${dt-at.length+1}] = outputIdx[${dt}];`));const ct=`
      float process(int outputIdx[${ut.length||1}]) {
        int inputIdx[${ot.length}];
        int indexDataIdx[${at.length||1}];
        indexDataIdx[0] = 0;
        ${st.join(`
        `)}
        int idx = int(_B(indexDataIdx));
        inputIdx[${rt}] = idx < 0 ? idx + ${ot[rt]} : idx;
        return _A(inputIdx);
      }`;return Object.assign(Object.assign({},J),{output:{dims:ut,type:nt[0].type,textureType:Y.TextureType.unpacked},shaderSource:ct})})(0,j,O,b.axis)})},q=(G,O)=>{if(!G||G.length!==2)throw new Error("Gather requires 2 inputs.");const b=G[0].dims.length;if(b<1)throw new Error("Invalid input shape.");if(O<-b||O>b-1)throw new Error("Invalid axis.");if(K.NUMBER_TYPES.indexOf(G[0].type)===-1)throw new Error("Invaid input type.");if(G[1].type!=="int32"&&G[1].type!=="int16")throw new Error("Invaid input type.")}},5378:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.parseGemmAttributesV11=F.parseGemmAttributesV7=F.gemm=void 0;const X=W(4910),K=W(7273),Q=W(5639);F.gemm=(G,O,b)=>(q(O,b),[G.run(tt(O,b),O)]);const Y=(G,O)=>{const b=G.attributes.getInt("transA",0)!==0,j=G.attributes.getInt("transB",0)!==0,U=G.attributes.getFloat("alpha",1),J=G.attributes.getFloat("beta",1);return(0,X.createAttributeWithCacheKey)({transA:b,transB:j,alpha:U,beta:J,isOptionalC:O})};F.parseGemmAttributesV7=G=>Y(G,!1),F.parseGemmAttributesV11=G=>Y(G,!0);const tt=(G,O)=>{const b={name:"Gemm",inputNames:G.length===3?["A","B","C"]:["A","B"],inputTypes:G.length===3?[Q.TextureType.unpacked,Q.TextureType.unpacked,Q.TextureType.unpacked]:[Q.TextureType.unpacked,Q.TextureType.unpacked],key:O.cacheKey};return Object.assign(Object.assign({},b),{get:()=>et(b,G,O)})},et=(G,O,b)=>{const j=O[0].dims.slice(),U=O[1].dims.slice(),[J,nt]=K.GemmUtil.getShapeOfGemmResult(j,b.transA,U,b.transB,O.length===3?O[2].dims:void 0),rt=[J,nt];if(!rt)throw new Error("Can't use gemm on the given tensors");let ot=j[j.length-1],at="";b.transA&&(ot=j[0]),b.transA&&b.transB?at="value += _A_T(a) * _B_T(b);":b.transA&&!b.transB?at="value += _A_T(a) * _B(b);":!b.transA&&b.transB?at="value += _A(a) * _B_T(b);":b.transA||b.transB||(at="value += _A(a) * _B(b);");const ut=rt.length,st=`
      float process(int indices[${ut}]) {
          int a[${ut}];
          int b[${ut}];
          ${O.length===3?`int c[${O[2].dims.length}];`:""}

          copyVec(indices, a);
          copyVec(indices, b);
          ${O.length===3?"bcastIndices_C(indices, c);":""}

          float value = 0.0;
          for (int k=0; k<${ot}; ++k) {
              a[${ut-1}] = k;
              b[${ut-2}] = k;
              ${at}
          }

          value = value * alpha;
          ${O.length===3?"value += beta * _C(c);":""}
          return value;
      }`;return Object.assign(Object.assign({},G),{output:{dims:rt,type:O[0].type,textureType:Q.TextureType.unpacked},variables:[{name:"alpha",type:"float",data:b.alpha},{name:"beta",type:"float",data:b.beta}],shaderSource:st})},q=(G,O)=>{if(!G)throw new Error("Input is missing");if(O.isOptionalC&&(G.length<2||G.length>3))throw new Error("Invaid input shape.");if(!O.isOptionalC&&G.length!==3)throw new Error("Gemm requires 3 inputs");if(G.length===3&&G[2].dims.length!==1&&G[2].dims.length!==2)throw new Error("Invalid input shape of C");if(G[0].type!=="float32"&&G[0].type!=="float64"||G[1].type!=="float32"&&G[1].type!=="float64"||G.length===3&&G[2].type!=="float32"&&G[2].type!=="float64")throw new Error("Invalid input type.");if(G[0].type!==G[1].type||G.length===3&&G[0].type!==G[2].type)throw new Error("Input types are mismatched")}},5950:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.createPackedIm2ColProgramInfoLoader=void 0;const X=W(6757),K=W(5639),Q=W(5614);F.createPackedIm2ColProgramInfoLoader=(Y,tt,et,q,G)=>{const O=(b=G.cacheKey,{name:"Im2Col (packed)",inputNames:["A"],inputTypes:[K.TextureType.packed],cacheHint:b});var b;return Object.assign(Object.assign({},O),{get:()=>((j,U,J,nt,rt,ot)=>{const at=J.dims,ut=nt.dims,st=rt.length,ct=[ut[1]*ut[2]*ut[3],rt[2]*rt[3]],dt=ut[2]*ut[3],pt=(0,Q.unpackFromChannel)(),lt=(0,X.getGlsl)(j.session.backend.glContext.version);let ft="";for(let _t=0;_t<=1;_t++)for(let wt=0;wt<=1;wt++)ft+=`
            blockIndex = rc.x + ${wt};
            pos = rc.y + ${_t};

            if(blockIndex < ${ct[1]} && pos < ${ct[0]}) {
              offsetY = int(blockIndex / (${rt[st-1]})) * ${ot.strides[0]} -
                ${ot.pads[0]};
              d0 = offsetY + ${ot.dilations[0]} * (imod(pos, ${dt}) / ${ut[2]});

              if(d0 < ${at[2]} && d0 >= 0) {
                offsetX = imod(blockIndex, ${rt[st-1]}) * ${ot.strides[1]} -
                  ${ot.pads[1]};
                d1 = offsetX + ${ot.dilations[1]} * imod(imod(pos, ${dt}), ${ut[2]});

                if(d1 < ${at[3]} && d1 >= 0) {

                  ch = int(float(pos)/ ${dt}.);
                    innerDims = vec2(d0, d1);
                    result[${2*_t+wt}] = getChannel(
                      getA(0, ch, int(innerDims.x),
                      int(innerDims.y)), innerDims);
                }
              }
            }

          `;const gt=`
      ${pt}

      void main() {
        ivec2 rc = getOutputCoords();
          vec4 result = vec4(0.0);
          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
          vec2 innerDims;
          ${ft}
          ${lt.output} = result;
      }
            `;return Object.assign(Object.assign({},U),{output:{dims:ct,type:J.type,textureType:K.TextureType.packed},shaderSource:gt,hasMain:!0})})(Y,O,tt,et,q,G)})}},1625:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.calculateIm2ColDims=F.createIm2ColProgramInfoLoader=void 0;const X=W(5639);F.createIm2ColProgramInfoLoader=(K,Q,Y,tt,et)=>{const q=(G=et.cacheKey,{name:"Im2Col",inputNames:["X"],inputTypes:[X.TextureType.unpacked],cacheHint:G});var G;return Object.assign(Object.assign({},q),{get:()=>((O,b,j,U,J,nt)=>{const rt=j.dims,ot=U.dims,at=J.length,ut=(0,F.calculateIm2ColDims)(rt,ot,J,4),st=`
        const int XC = ${rt[1]};
        const int XH = ${rt[2]};
        const int XW = ${rt[3]};
        const int KH = ${nt.kernelShape[0]};
        const int KW = ${nt.kernelShape[1]};
        const int dilationH = ${nt.dilations[0]};
        const int dilationW = ${nt.dilations[1]};
        const int strideH = ${nt.strides[0]};
        const int strideW = ${nt.strides[1]};
        const int padH = ${nt.pads[0]};
        const int padW = ${nt.pads[1]};
        const int KHKW = KH*KW;
        const int XCKHKW = XC * KHKW;
        const int outputChannels = 4;
        vec4 process(int indices[${at}]) {
          int b  = indices[0]; // batch size
          int oh = indices[1] * strideH - padH; //output height
          int ow = indices[2] * strideW - padW; //output width
          int p = indices[3] * outputChannels; //patch
          vec4 value = vec4(0.0);
          for(int i=0; i < outputChannels; ++i) {
            if(p < XCKHKW) {
              int patchC = p / KHKW;
              int patchH = (p - patchC*KHKW) / KW;
              int patchW = (p - patchC*KHKW) - patchH * KW;
              int xh2 = oh + patchH * dilationH;
              int xw2 = ow + patchW * dilationW;
              int x[${rt.length}];
              x[0] = b;
              x[1] = patchC;
              x[2] = xh2;
              x[3] = xw2;
              if(xh2 >= 0 &&
                  xh2 < XH &&
                  xw2 >= 0 &&
                  xw2 < XW) {
                value[i] = _X(x);
              }
            }
            ++p;
          }
          return value;
        }
        `;return Object.assign(Object.assign({},b),{output:{dims:ut,type:j.type,textureType:X.TextureType.packedLastDimension},shaderSource:st})})(0,q,Q,Y,tt,et)})},F.calculateIm2ColDims=(K,Q,Y,tt=4)=>[Y[0],Y[2],Y[3],Math.ceil(K[1]*Q[2]*Q[3]/tt)]},6981:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.parseImageScalerAttributes=F.imageScaler=void 0;const X=W(4910),K=W(5639);F.imageScaler=(q,G,O)=>(et(G),[q.run(Y(q,G,O),G)]),F.parseImageScalerAttributes=q=>{const G=q.attributes.getFloat("scale"),O=q.attributes.getFloats("bias");return(0,X.createAttributeWithCacheKey)({scale:G,bias:O})};const Q={name:"ImageScaler",inputNames:["X"],inputTypes:[K.TextureType.unpacked]},Y=(q,G,O)=>{const b=Object.assign(Object.assign({},Q),{cacheHint:O.cacheKey});return Object.assign(Object.assign({},b),{get:()=>((j,U,J,nt)=>{const rt=J[0].dims.slice(),ot=rt.length,at=`
      ${tt(nt.bias.length)}
      float process(int indices[${ot}]) {
        return _X(indices) * scale + getBias(bias, indices[1]);
      }`;return Object.assign(Object.assign({},U),{output:{dims:rt,type:J[0].type,textureType:K.TextureType.unpacked},variables:[{name:"bias",type:"float",arrayLength:nt.bias.length,data:nt.bias},{name:"scale",type:"float",data:nt.scale}],shaderSource:at})})(0,b,G,O)})},tt=q=>{const G=[`float getBias(float bias[${q}], int channel) {`];for(let O=0;O<q;++O)O===0?G.push(`	if (channel == ${O}) { return bias[${O}]; }`):O===q-1?G.push(`	else { return bias[${O}]; }`):G.push(`	else if (channel == ${O}) { return bias[${O}]; }`);return G.push("	}"),G.join(`
`)},et=q=>{if(!q||q.length!==1)throw new Error("ImageScaler requires 1 input.");if(q[0].dims.length!==4)throw new Error("Invalid input shape.");if(q[0].type!=="float32"&&q[0].type!=="float64")throw new Error("Invalid input type.")}},7413:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.parseInstanceNormalizationAttributes=F.instanceNormalization=void 0;const X=W(6757),K=W(5639);F.instanceNormalization=(G,O,b)=>{q(O);const j=G.run(Y(O[0]),O);return[G.run(et(G,O[0],b,j.dims),[O[0],j,O[1],O[2]])]},F.parseInstanceNormalizationAttributes=G=>G.attributes.getFloat("epsilon",1e-5);const Q={name:"InstanceNormalization_MeanAndVariance",inputNames:["X"],inputTypes:[K.TextureType.unpacked]},Y=G=>Object.assign(Object.assign({},Q),{get:()=>((O,b)=>{const j=b.dims.slice(),U=j[1],J=j[2]*j[3],nt=[j[0],U],rt=`
      vec4 process(int[2] indices) {
        vec4 v = vec4(0.0);
        int a[4];
        a[0] = indices[0];
        a[1] = indices[1];
        float temp = 0.0;
        for(int a2=0; a2<${j[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${j[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += x;
          }
        }
        float mean = temp / float(${J});
        temp = 0.0;
        for(int a2=0; a2<${j[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${j[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += (x - mean) * (x - mean);
          }
        }
        v.r = mean;
        v.g = temp / float(${J});

        return v;
      }`;return Object.assign(Object.assign({},O),{output:{dims:nt,type:b.type,textureType:K.TextureType.packedLastDimension},shaderSource:rt})})(Q,G)}),tt={name:"InstanceNormalization_ComputeOutput",inputNames:["X","MeanAndVariance","Scale","B"],inputTypes:[K.TextureType.unpacked,K.TextureType.packedLastDimension,K.TextureType.unpacked,K.TextureType.unpacked]},et=(G,O,b,j)=>{const U=Object.assign(Object.assign({},tt),{cacheHint:`${b}`});return Object.assign(Object.assign({},U),{get:()=>((J,nt,rt,ot,at)=>{const ut=(0,X.getGlsl)(J.session.backend.glContext.version),[st,ct]=J.calculateTextureWidthAndHeight(at,K.TextureType.packedLastDimension),[dt,pt]=[st/4,ct],lt=`
      vec4 get_MeanAndVariance(int[2] mv) {
        int offset = indicesToOffset_MeanAndVariance(mv);
        vec2 coords = offsetToCoords(offset, ${dt}, ${pt});
        return ${ut.texture2D}(MeanAndVariance, coords);
      }

      float process(int[4] indices) {
        int mv[2];
        mv[0] = indices[0];
        mv[1] = indices[1];
        vec4 mean_and_variance = get_MeanAndVariance(mv);
        float mean = mean_and_variance.r;
        float variance = mean_and_variance.g;

        int sb[1];
        sb[0] = indices[1];
        float scale = _Scale(sb);
        float b = _B(sb);

        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;
      }`;return Object.assign(Object.assign({},nt),{output:{dims:rt.dims,type:rt.type,textureType:K.TextureType.unpacked},variables:[{name:"epsilon",type:"float",data:ot}],shaderSource:lt})})(G,U,O,b,j)})},q=G=>{if(!G||G.length!==3)throw new Error("InstanceNormalization requires 3 inputs.");const O=G[0],b=G[1],j=G[2];if(O.dims.length<3||b.dims.length!==1||j.dims.length!==1)throw new Error("Invalid input shape.");if(b.dims[0]!==O.dims[1]||j.dims[0]!==O.dims[1])throw new Error("Input shapes are mismatched.");if(O.type!=="float32"&&O.type!=="float64"||b.type!=="float32"&&b.type!=="float64"||j.type!=="float32"&&j.type!=="float64")throw new Error("Invalid input type.");if(G[0].dims.length!==4)throw new Error("Only support 4-D input shape.")}},7006:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.createLrnProgramInfoLoader=F.parseLrnAttributes=F.lrn=void 0;const X=W(4910),K=W(5639);F.lrn=(et,q,G)=>(tt(q),[et.run(Y(q,G),q)]),F.parseLrnAttributes=et=>{const q=et.attributes.getFloat("alpha",1e-4),G=et.attributes.getFloat("beta",.75),O=et.attributes.getFloat("bias",1),b=et.attributes.getInt("size");return(0,X.createAttributeWithCacheKey)({alpha:q,beta:G,bias:O,size:b})};const Q={name:"LRN",inputNames:["X"],inputTypes:[K.TextureType.unpacked]};function Y(et,q){return Object.assign(Object.assign({},Q),{cacheHint:q.cacheKey,get:()=>function(G,O){const b=G[0].dims[1],j=G[0].dims.length,U=-Math.floor((O.size-1)/2),J=Math.ceil((O.size-1)/2),nt=`float(${O.alpha}) / float(${O.size})`,rt=`
    float process(int indices[${j}]) {
        int c = indices[1];
        float x = _X(indices);
        float square_sum = 0.0;

        for (int i = ${U}; i <= ${J}; i++) {
          int idx = c + i;
          if (c >= 0 && c < ${b}) {
            indices[1] = idx;
            float j = _X(indices);
            square_sum += j * j;
          }
        }
        return x / pow(float(${O.bias}) + ${nt} * square_sum, float(${O.beta}));
    }`;return Object.assign(Object.assign({},Q),{cacheHint:O.cacheKey,output:{dims:G[0].dims,type:G[0].type,textureType:K.TextureType.unpacked},shaderSource:rt})}(et,q)})}F.createLrnProgramInfoLoader=Y;const tt=et=>{if(!et||et.length!==1)throw new Error("LRN requires 1 input.");if(et[0].dims.length!==4)throw new Error('currently only support LRN for input with "NCHW" format');if(et[0].type!=="float32")throw new Error("input should be float type")}},5632:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.createPackedMatmulProgramInfoLoader=void 0;const X=W(7273),K=W(6757),Q=W(5639),Y=W(432),tt=W(2150),et=W(8276);F.createPackedMatmulProgramInfoLoader=(q,G,O)=>{const b=(j=G.length>2,U=O.activationCacheKey,{name:"MatMul (packed)",inputNames:j?["A","B","Bias"]:["A","B"],inputTypes:j?[Q.TextureType.packed,Q.TextureType.packed,Q.TextureType.packed]:[Q.TextureType.packed,Q.TextureType.packed],cacheHint:U});var j,U;return Object.assign(Object.assign({},b),{get:()=>((J,nt,rt,ot)=>{const at=rt.length>2,ut=at?"value += getBiasForMatmul();":"",st=rt[0].dims,ct=rt[1].dims,dt=X.BroadcastUtil.calcShape(st,ct,!0),pt=!X.ShapeUtil.areEqual(rt[0].dims,rt[1].dims);if(!dt)throw new Error("Can't use matmul on the given tensors");const lt=st[st.length-1],ft=Math.ceil(lt/2),gt=st.length,_t=ct.length,wt=(0,K.getGlsl)(J.session.backend.glContext.version),bt=(0,Y.getCoordsDataType)(dt.length),Ot=dt.length,vt=(0,Y.getGlChannels)(),{activationFunction:xt,applyActivation:Rt}=(0,tt.getActivationSnippet)(ot),kt=at?`${(0,et.getBiasForMatmul)(bt,vt,rt[2].dims,dt,!0)}`:"",Ht=pt?`${function(Bt,ee,ne,Yt){let ae=[],Wt=[];const se=ne[0].dims,Zt=ne[1].dims,ue=se.length,re=Zt.length,pe=Yt.length,ye=pe-ue,Ae=pe-re;ae=se.map((fe,ge)=>`coords.${ee[ge+ye]}`),ae[ue-1]="i*2",ae.join(", "),Wt=Zt.map((fe,ge)=>`coords.${ee[ge+Ae]}`),Wt[re-2]="i*2",Wt.join(", ");const Oe=X.BroadcastUtil.getBroadcastDims(se,Yt),Ie=X.BroadcastUtil.getBroadcastDims(Zt,Yt),Ee=Oe.map(fe=>`coords.${ee[fe+ye]} = 0;`).join(`
`),le=Ie.map(fe=>`coords.${ee[fe+Ae]} = 0;`).join(`
`),ve=`int lastDim = coords.${ee[pe-1]};
  coords.${ee[pe-1]} = coords.${ee[pe-2]};
  coords.${ee[pe-2]} = lastDim;`;return`
vec4 getAAtOutCoordsMatmul(int i) {
  ${Bt} coords = getOutputCoords();
  ${ve}
  ${Ee}
  vec4 outputValue = getA(${ae});
  return outputValue;
}

vec4 getBAtOutCoordsMatmul(int i) {
  ${Bt} coords = getOutputCoords();
  ${ve}
  ${le}
  vec4 outputValue = getB(${Wt});
  return outputValue;
}`}(bt,vt,rt,dt)}`:"",Mt=pt?"getAAtOutCoordsMatmul(i)":`getA(${function(Bt,ee){let ne="";for(let Yt=0;Yt<ee-2;Yt++)ne+=`rc.${Bt[Yt]}, `;return ne+=`rc.${Bt[ee-2]}, i*2`,ne}(vt,gt)})`,qt=pt?"getBAtOutCoordsMatmul(i)":`getB(${function(Bt,ee){let ne="";for(let Yt=0;Yt<ee-2;Yt++)ne+=`rc.${Bt[Yt]}, `;return ne+=`i*2, rc.${Bt[ee-1]}`,ne}(vt,_t)})`,Jt=`
            ${Ht}
            ${kt}
            ${xt}
            void main() {
              ${pt?"":`${bt} rc =
          getOutputCoords(); int lastDim = rc.${vt[Ot-1]}; rc.${vt[Ot-1]} =
          rc.${vt[Ot-2]}; rc.${vt[Ot-2]} = lastDim;
      `}

              vec4 value = vec4(0);
              for (int i = 0; i < ${ft}; i++) {
                vec4 a = ${Mt};
                vec4 b = ${qt};

                value += (a.rrbb * b.rgrg);
                value += (a.ggaa * b.baba);
              }
              ${ut}
              ${Rt}
              ${wt.output} = value;
            }`;return Object.assign(Object.assign({},nt),{output:{dims:dt,type:rt[0].type,textureType:Q.TextureType.packed},shaderSource:Jt,hasMain:!0})})(q,b,G,O)})}},8276:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.getBiasForMatmul=F.createMatmulProgramInfoLoader=F.parseMatMulAttributes=F.matMul=void 0;const X=W(7273),K=W(5639),Q=W(432),Y=W(2150),tt=W(5632);F.matMul=(b,j,U)=>(G(j),b.session.pack?[b.run((0,tt.createPackedMatmulProgramInfoLoader)(b,j,U),j)]:[b.run(q(j,U),j)]),F.parseMatMulAttributes=b=>(0,Y.parseInternalActivationAttributes)(b.attributes);const et=(b,j)=>({name:"MatMul",inputNames:b?["A","B","Bias"]:["A","B"],inputTypes:b?[K.TextureType.unpacked,K.TextureType.unpacked,K.TextureType.unpacked]:[K.TextureType.unpacked,K.TextureType.unpacked],cacheHint:j});function q(b,j){const U=et(b.length>2,j.activationCacheKey);return Object.assign(Object.assign({},U),{get:()=>function(J,nt,rt){const ot=nt[0].dims,at=nt[1].dims,ut=X.BroadcastUtil.calcShape(ot,at,!0);if(!ut)throw new Error("Can't use matmul on the given tensors");const st=(0,Q.getCoordsDataType)(ut.length),ct=(0,Q.getGlChannels)(),{activationFunction:dt,applyActivation:pt}=(0,Y.getActivationSnippet)(rt),lt=nt.length>2,ft=lt?"value += getBiasForMatmul();":"",gt=lt?`${O(st,ct,nt[2].dims,ut,!1)}`:"",_t=ut.length,wt=ot.length,bt=at.length,Ot=`
    ${dt}
    ${gt}
    float process(int indices[${_t}]) {
        int a[${wt}];
        int b[${bt}];
        bcastMatmulIndices_A(indices, a);
        bcastMatmulIndices_B(indices, b);

        float value;
        for (int k=0; k<${ot[ot.length-1]}; ++k) {
            a[${wt-1}] = k;
            b[${bt-2}] = k;
            value += _A(a) * _B(b);
        }
        ${ft}
        ${pt}
        return value;
    }`;return Object.assign(Object.assign({},J),{output:{dims:ut,type:nt[0].type,textureType:K.TextureType.unpacked},shaderSource:Ot})}(U,b,j)})}F.createMatmulProgramInfoLoader=q;const G=b=>{if(!b||b.length!==2)throw new Error("MatMul requires 2 inputs.");if(b[0].dims[b[0].dims.length-1]!==b[1].dims[b[1].dims.length-2])throw new Error("shared dimension does not match.");if(b[0].type!=="float32"&&b[0].type!=="float64"||b[1].type!=="float32"&&b[1].type!=="float64")throw new Error("inputs should be float type");if(b[0].type!==b[1].type)throw new Error("inputs types should match")};function O(b,j,U,J,nt){let rt="";const ot=U.length,at=J.length,ut=at-ot;rt=at<2&&ot>0?"coords":U.map((dt,pt)=>`coords.${j[pt+ut]}`).join(", ");const st=X.BroadcastUtil.getBroadcastDims(U,J).map(dt=>`coords.${j[dt+ut]} = 0;`).join(`
`);let ct="vec4(outputValue.xx, outputValue.yy)";return X.ShapeUtil.size(U)===1&&(ct="vec4(outputValue.x)"),nt?`
vec4 getBiasForMatmul() {
  ${b} coords = getOutputCoords();
  ${st}
  vec4 outputValue = getBias(${rt});
  return ${ct};
}`:`
float getBiasForMatmul() {
  ${b} coords = getOutputCoords();
  ${st}
  return getBias(coords.x);
}`}F.getBiasForMatmul=O},9:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.createPackProgramInfoLoader=void 0;const X=W(6757),K=W(5639),Q=W(432),Y=W(5614),tt={name:"pack",inputNames:["A"],inputTypes:[K.TextureType.unpackedReversed]};F.createPackProgramInfoLoader=(et,q)=>Object.assign(Object.assign({},tt),{get:()=>((G,O)=>{const b=(0,X.getGlsl)(G.session.backend.glContext.version),j=O.dims,U=j.length,J=O.dims.length,nt=(0,Q.getCoordsDataType)(J),rt=(0,Y.getChannels)("rc",J),ot=(at=J,ut=rt,st=j[j.length-2],ct=j[j.length-1],at===0||at===1?"":`
    int r = ${ut[at-2]};
    int c = ${ut[at-1]};
    int rp1 = ${ut[at-2]} + 1;
    int cp1 = ${ut[at-1]} + 1;
    bool rEdge = rp1 >= ${ct};
    bool cEdge = cp1 >= ${st};
    `);var at,ut,st,ct;let dt;dt=U===0?[1,1]:U===1?[j[0],1]:[j[J-1],j[J-2]];const pt=function(gt,_t,wt){if(gt===0)return"false";if(gt===1)return`rc > ${_t[0]}`;let bt="";for(let Ot=gt-2;Ot<gt;Ot++)bt+=`${wt[Ot]} >= ${_t[Ot-gt+2]}`,Ot<gt-1&&(bt+="||");return bt}(J,dt,rt),lt=function(gt,_t){const wt=gt.length;if(wt===0)return"getA(), 0, 0, 0";if(wt===1)return`getA(rc),
            rc + 1 >= ${gt[0]} ? 0. : getA(rc + 1),
            0, 0`;let bt="";if(wt>2)for(let Ot=0;Ot<wt-2;++Ot)bt+=`${_t[Ot]},`;return`getA(${bt}r, c),
          rEdge ? 0. : getA(${bt}rp1, c),
          cEdge ? 0. : getA(${bt}r, cp1),
          rEdge || cEdge ? 0. : getA(${bt}rp1, cp1)`}(j,rt),ft=`
        void main() {
          ${nt} rc = getOutputCoords();

          if(${pt}) {
            ${b.output} = vec4(0);
          } else {
            ${ot}

            ${b.output} = vec4(${lt});
          }
        }
      `;return Object.assign(Object.assign({},tt),{hasMain:!0,output:{dims:O.dims,type:O.type,textureType:K.TextureType.packed},shaderSource:ft})})(et,q)})},5614:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.unpackFromChannel=F.getChannels=F.getVecChannels=void 0;const X=W(432);function K(Q,Y){return(0,X.getGlChannels)(Y).map(tt=>`${Q}.${tt}`)}F.getVecChannels=K,F.getChannels=function(Q,Y){return Y===1?[Q]:K(Q,Y)},F.unpackFromChannel=function(){return`
    float getChannel(vec4 frag, int dim) {
      int modCoord = imod(dim, 2);
      return modCoord == 0 ? frag.r : frag.g;
    }

    float getChannel(vec4 frag, vec2 innerDims) {
      vec2 modCoord = mod(innerDims, 2.);
      return modCoord.x == 0. ?
        (modCoord.y == 0. ? frag.r : frag.g) :
        (modCoord.y == 0. ? frag.b : frag.a);
    }
  `}},5565:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.parsePadAttributesV11=F.padV11=F.parsePadAttributesV2=F.padV2=void 0;const X=W(4910),K=W(7273),Q=W(6757),Y=W(5639),tt={name:"Pad",inputNames:["A"],inputTypes:[Y.TextureType.unpacked]};F.padV2=(nt,rt,ot)=>(G(rt),[nt.run(Object.assign(Object.assign({},tt),{cacheHint:ot.cacheKey,get:()=>q(nt,rt[0],ot)}),rt)]),F.parsePadAttributesV2=nt=>{const rt=nt.attributes.getString("mode","constant"),ot=nt.attributes.getFloat("value",0),at=nt.attributes.getInts("pads");return(0,X.createAttributeWithCacheKey)({mode:rt,value:ot,pads:at})},F.padV11=(nt,rt,ot)=>{O(rt);const at=et(nt,rt,ot);return(0,F.padV2)(nt,[rt[0]],at)},F.parsePadAttributesV11=nt=>nt.attributes.getString("mode","constant");const et=(nt,rt,ot)=>{if(!nt.session.isInitializer(rt[1].dataId)||rt.length>=3&&!nt.session.isInitializer(rt[2].dataId))throw new Error("dynamic pad attributes are not allowed");const at=Array.from(rt[1].integerData),ut=rt.length>=3?rt[2].floatData[0]:0;return(0,X.createAttributeWithCacheKey)({mode:ot,pads:at,value:ut})},q=(nt,rt,ot)=>{const at=K.ShapeUtil.padShape(rt.dims.slice(),ot.pads),ut=at.length,st=`
      ${b(nt,rt,ot)}
      float process(int[${ut}] indices) {
          return padA(indices);
      }`;return{name:"Pad",inputNames:["A"],inputTypes:[Y.TextureType.unpacked],output:{dims:at,type:rt.type,textureType:Y.TextureType.unpacked},shaderSource:st}},G=nt=>{if(!nt||nt.length!==1)throw new Error("Pad requires 1 input");if(nt[0].type!=="float32"&&nt[0].type!=="float64")throw new Error("Invalid input type.")},O=nt=>{if(!nt||nt.length!==2&&nt.length!==3)throw new Error("Pad requires 2 or 3 inputs");if(nt[1].type!=="int32")throw new Error("Invalid input type.");if(nt.length>=3&&nt[2].type==="string")throw new Error("Invalid input type.")},b=(nt,rt,ot)=>{const at=(0,Q.getGlsl)(nt.session.backend.glContext.version),[ut,st]=nt.calculateTextureWidthAndHeight(rt.dims,Y.TextureType.unpacked),ct=K.ShapeUtil.computeStrides(rt.dims);switch(ot.mode){case"constant":return j(at,rt.dims,ct,ut,st,ot.pads,ot.value);case"reflect":return U(at,rt.dims,ct,ut,st,ot.pads);case"edge":return J(at,rt.dims,ct,ut,st,ot.pads);default:throw new Error("Invalid mode")}},j=(nt,rt,ot,at,ut,st,ct)=>{const dt=rt.length;let pt="";for(let lt=dt-1;lt>=0;--lt)pt+=`
        k = m[${lt}] - ${st[lt]};
        if (k < 0)  return constant;
        if (k >= ${rt[lt]}) return constant;
        offset += k * ${ot[lt]};
        `;return`
      float padA(int m[${dt}]) {
        const float constant = float(${ct});
        int offset = 0;
        int k = 0;
        ${pt}
        vec2 coords = offsetToCoords(offset, ${at}, ${ut});
        float value = getColorAsFloat(${nt.texture2D}(A, coords));
        return value;
      }
      `},U=(nt,rt,ot,at,ut,st)=>{const ct=rt.length;let dt="";for(let pt=ct-1;pt>=0;--pt)dt+=`
        k = m[${pt}] - ${st[pt]};
        if (k < 0) { k = -k; }
        {
          const int _2n_1 = ${2*(rt[pt]-1)};
          k = int( mod( float(k), float(_2n_1) ) ) ;
          if(k >= ${rt[pt]}) { k = _2n_1 - k; }
        }
        offset += k * ${ot[pt]};
        `;return`
      float padA(int m[${ct}]) {
        int offset = 0;
        int k = 0;
        ${dt}
        vec2 coords = offsetToCoords(offset, ${at}, ${ut});
        float value = getColorAsFloat(${nt.texture2D}(A, coords));
        return value;
      }
      `},J=(nt,rt,ot,at,ut,st)=>{const ct=rt.length;let dt="";for(let pt=ct-1;pt>=0;--pt)dt+=`
        k = m[${pt}] - ${st[pt]};
        if (k < 0)  k = 0;
        if (k >= ${rt[pt]}) k = ${rt[pt]-1};
        offset += k * ${ot[pt]};
      `;return`
      float padA(int m[${ct}]) {
        int offset = 0;
        int k = 0;
        ${dt}
        vec2 coords = offsetToCoords(offset, ${at}, ${ut});
        float value = getColorAsFloat(${nt.texture2D}(A, coords));
        return value;
      }
      `}},2834:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.globalMaxPool=F.parseMaxPoolAttributes=F.maxPool=F.parseGlobalAveragePoolAttributes=F.globalAveragePool=F.parseAveragePoolAttributes=F.averagePool=void 0;const X=W(4910),K=W(7273),Q=W(5639);F.averagePool=(J,nt,rt)=>{O(nt);const ot={name:"AveragePool",inputNames:["X"],inputTypes:[Q.TextureType.unpacked],cacheHint:rt.cacheKey};return[J.run(Object.assign(Object.assign({},ot),{get:()=>Y(nt,ot,!1,rt)}),nt)]},F.parseAveragePoolAttributes=J=>{const nt=J.attributes.getString("auto_pad","NOTSET"),rt=J.attributes.getInt("ceil_mode",0),ot=J.attributes.getInt("count_include_pad",0)!==0,at=J.attributes.getInts("kernel_shape"),ut=J.attributes.getInts("strides",[]),st=J.attributes.getInts("pads",[]);if(rt!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return(0,X.createAttributeWithCacheKey)({autoPad:nt,ceilMode:rt,countIncludePad:ot,kernelShape:at,strides:ut,pads:st})};const Y=(J,nt,rt,ot)=>{const[at,ut]=et(J,ot,rt),st=K.ShapeUtil.size(at.kernelShape);let ct="";at.countIncludePad?ct+=`value /= float(${st});`:ct+=`value /= float(${st} - pad);`;const dt=`
        ${b(J[0].dims,at,"value += _X(x);",ct,"0.0")}
      `;return Object.assign(Object.assign({},nt),{output:{dims:ut,type:J[0].type,textureType:Q.TextureType.unpacked},shaderSource:dt})};F.globalAveragePool=(J,nt,rt)=>{O(nt);const ot={name:"GlobalAveragePool",inputNames:["X"],inputTypes:[Q.TextureType.unpacked],cacheHint:`${rt.countIncludePad}`};return[J.run(Object.assign(Object.assign({},ot),{get:()=>Y(nt,ot,!0,rt)}),nt)]},F.parseGlobalAveragePoolAttributes=J=>{const nt=J.attributes.getInt("count_include_pad",0)!==0;return(0,X.createAttributeWithCacheKey)({autoPad:"",ceilMode:0,countIncludePad:nt,kernelShape:[],strides:[],pads:[]})},F.maxPool=(J,nt,rt)=>{O(nt);const ot={name:"MaxPool",inputNames:["X"],inputTypes:[Q.TextureType.unpacked],cacheHint:rt.cacheKey};return[J.run(Object.assign(Object.assign({},ot),{get:()=>tt(nt,ot,!1,rt)}),nt)]},F.parseMaxPoolAttributes=J=>{const nt=J.attributes.getString("auto_pad","NOTSET"),rt=J.attributes.getInt("ceil_mode",0),ot=J.attributes.getInts("kernel_shape"),at=J.attributes.getInts("strides",[]),ut=J.attributes.getInts("pads",[]),st=J.attributes.getInt("storage_order",0),ct=J.attributes.getInts("dilations",[]);if(st!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(rt!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return(0,X.createAttributeWithCacheKey)({autoPad:nt,ceilMode:rt,countIncludePad:!1,kernelShape:ot,strides:at,pads:ut,storageOrder:st,dilations:ct})};const tt=(J,nt,rt,ot)=>{const[at,ut]=et(J,ot,rt),st=`
      ${b(J[0].dims,at,`
      value = max(_X(x), value);
    `,"","-1e5")}
    `;return Object.assign(Object.assign({},nt),{output:{dims:ut,type:J[0].type,textureType:Q.TextureType.unpacked},shaderSource:st})},et=(J,nt,rt)=>{const ot=J[0].dims.slice(),at=Object.hasOwnProperty.call(nt,"dilations"),ut=nt.kernelShape.slice(),st=nt.strides.slice(),ct=at?nt.dilations.slice():[],dt=nt.pads.slice();K.PoolConvUtil.adjustPoolAttributes(rt,ot,ut,st,ct,dt);const pt=K.PoolConvUtil.computePoolOutputShape(rt,ot,st,ct,ut,dt,nt.autoPad),lt=Object.assign({},nt);return at?Object.assign(lt,{kernelShape:ut,strides:st,pads:dt,dilations:ct,cacheKey:nt.cacheKey}):Object.assign(lt,{kernelShape:ut,strides:st,pads:dt,cacheKey:nt.cacheKey}),[lt,pt]},q={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},G={name:"GlobalMaxPool",inputNames:["X"],inputTypes:[Q.TextureType.unpacked]};F.globalMaxPool=(J,nt)=>(O(nt),[J.run(Object.assign(Object.assign({},G),{get:()=>tt(nt,G,!0,q)}),nt)]);const O=J=>{if(!J||J.length!==1)throw new Error("Pool ops requires 1 input.");if(J[0].type!=="float32"&&J[0].type!=="float64")throw new Error("Invalid input type.")},b=(J,nt,rt,ot,at)=>{const ut=J.length;if(nt.kernelShape.length<=2){const st=nt.kernelShape[nt.kernelShape.length-1],ct=nt.strides[nt.strides.length-1],dt=nt.pads[nt.pads.length/2-1],pt=nt.pads[nt.pads.length-1],lt=J[ut-1];let ft="",gt="",_t="";if(ft=dt+pt!==0?`
          for (int i = 0; i < ${st}; i++) {
            x[${ut} - 1] = indices[${ut} - 1] * ${ct} - ${dt} + i;
            if (x[${ut} - 1] < 0 || x[${ut} - 1] >= ${lt}) {
              pad++;
              continue;
            }
            ${rt}
          }`:`
          for (int i = 0; i < ${st}; i++) {
            x[${ut} - 1] = indices[${ut} - 1] * ${ct} - ${dt} + i;
            ${rt}
          }`,nt.kernelShape.length===2){const wt=nt.kernelShape[nt.kernelShape.length-2],bt=nt.strides[nt.strides.length-2],Ot=nt.pads[nt.pads.length/2-2],vt=nt.pads[nt.pads.length-2],xt=J[ut-2];gt=Ot+vt!==0?`
            for (int j = 0; j < ${wt}; j++) {
              x[${ut} - 2] = indices[${ut} - 2] * ${bt} - ${Ot} + j;
              if (x[${ut} - 2] < 0 || x[${ut} - 2] >= ${xt}) {
                pad+= ${st};
                continue;
              }
          `:`
            for (int j = 0; j < ${wt}; j++) {
              x[${ut} - 2] = indices[${ut} - 2] * ${bt} - ${Ot} + j;
            `,_t=`
          }
        `}return`
        float process(int indices[${ut}]) {
          int x[${ut}];
          copyVec(indices, x);

          float value = ${at};
          int pad = 0;
          ${gt}
          ${ft}
          ${_t}
          ${ot}
          return value;
        }
      `}{const st=K.ShapeUtil.size(nt.kernelShape),ct=K.ShapeUtil.computeStrides(nt.kernelShape),dt=ct.length,pt=nt.pads.length,lt=U(dt),ft=j(J,"inputDims"),gt=j(nt.pads,"pads"),_t=j(ct,"kernelStrides"),wt=j(nt.strides,"strides");let bt="";return bt=nt.pads.reduce((Ot,vt)=>Ot+vt)?`
            if (x[j] >= inputDims[j] || x[j] < 0) {
              pad++;
              isPad = true;
              break;
            }
          }
          if (!isPad) {
            ${rt}
          }`:`
          }
          ${rt}
        `,`
        ${lt}
        float process(int indices[${ut}]) {
          int x[${ut}];
          copyVec(indices, x);
          int offset[${dt}];
          int pads[${pt}];
          int inputDims[${ut}];
          int kernelStrides[${dt}];
          int strides[${dt}];
          ${gt}
          ${ft}
          ${wt}
          ${_t}

          float value = ${at};
          int pad = 0;
          bool isPad = false;
          for (int i = 0; i < ${st}; i++) {
            offsetToIndices(i, kernelStrides, offset);
            isPad = false;
            for (int j = ${ut} - ${dt}; j < ${ut}; j++) {
              x[j] = indices[j] * strides[j - ${ut} + ${dt}]
                + offset[j - ${ut} + ${dt}] - pads[j - 2];
              ${bt}
          }
          ${ot}

          return value;
        }
      `}},j=(J,nt)=>{let rt="";for(let ot=0;ot<J.length;ot++)rt+=`
      ${nt}[${ot}] = ${J[ot]};
    `;return rt},U=J=>`
  void offsetToIndices(int offset, int[${J}] strides, out int[${J}] indices) {
    if (${J} == 0) {
      return;
    }
    for (int i = 0; i < ${J} - 1; ++i) {
      indices[i] = offset / strides[i];
      offset -= indices[i] * strides[i];
    }
    indices[${J} - 1] = offset;
  }`},1010:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.reduceLogSumSquare=F.reduceLogSum=F.reduceProd=F.reduceMin=F.reduceMax=F.reduceMean=F.reduceSum=F.parseReduceAttributes=void 0;const X=W(4910),K=W(6145),Q=W(7273),Y=W(5639),tt=(G,O,b,j,U)=>{q(O);const J={name:j,inputNames:["A"],inputTypes:[Y.TextureType.unpacked]};return[G.run(Object.assign(Object.assign({},J),{cacheHint:b.cacheKey,get:()=>et(G,O,b,j,U,J)}),O)]};F.parseReduceAttributes=G=>{const O=G.attributes.getInts("axes",[]),b=G.attributes.getInt("keepdims",1)===1;return(0,X.createAttributeWithCacheKey)({axes:O,keepDims:b})};const et=(G,O,b,j,U,J)=>{const nt=[],rt=O[0].dims.length||1,ot=[],at=Q.ShapeUtil.normalizeAxes(b.axes,O[0].dims.length),ut=U(O,at);let st=ut[1];for(let dt=0;dt<O[0].dims.length;dt++)at.indexOf(dt)>=0||at.length===0?(b.keepDims&&nt.push(1),st=`
          for(int j${dt} = 0; j${dt} < ${O[0].dims[dt]}; j${dt}++) {
            inputIdx[${dt}] = j${dt};
            ${st}
          }`):(ot.push(`inputIdx[${dt}] = outputIdx[${nt.length}];`),nt.push(O[0].dims[dt]));const ct=`
      float process(int outputIdx[${nt.length||1}]) {
        float value;                 // final result
        int inputIdx[${rt}];      // addressing input data
        ${ot.join(`
`)}
        ${ut[0]}       // init ops for reduce max/min
        ${st}
        ${ut[2]}       // final computation for reduce mean
        return value;
      }`;return Object.assign(Object.assign({},J),{output:{dims:nt,type:O[0].type,textureType:Y.TextureType.unpacked},shaderSource:ct})},q=G=>{if(!G||G.length!==1)throw new Error("Reduce op requires 1 input.");if(K.NUMBER_TYPES.indexOf(G[0].type)===-1)throw new Error("Invalid input type.")};F.reduceSum=(G,O,b)=>tt(G,O,b,"ReduceSum",()=>["value = 0.0;","value += _A(inputIdx);",""]),F.reduceMean=(G,O,b)=>tt(G,O,b,"ReduceMean",(j,U)=>{let J=1;for(let nt=0;nt<j[0].dims.length;nt++)(U.indexOf(nt)>=0||U.length===0)&&(J*=j[0].dims[nt]);return["value = 0.0;","value += _A(inputIdx);",`value /= ${J}.;`]}),F.reduceMax=(G,O,b)=>tt(G,O,b,"ReduceMax",(j,U)=>{const J=[];for(let nt=0;nt<j[0].dims.length;nt++)(U.indexOf(nt)>=0||U.length===0)&&J.push(`inputIdx[${nt}] = 0;`);return[`${J.join(`
`)}
value = _A(inputIdx);`,"value = max(value, _A(inputIdx));",""]}),F.reduceMin=(G,O,b)=>tt(G,O,b,"ReduceMin",(j,U)=>{const J=[];for(let nt=0;nt<j[0].dims.length;nt++)(U.indexOf(nt)>=0||U.length===0)&&J.push(`inputIdx[${nt}] = 0;`);return[`${J.join(`
`)}
value = _A(inputIdx);`,"value = min(value, _A(inputIdx));",""]}),F.reduceProd=(G,O,b)=>tt(G,O,b,"ReduceProd",()=>["value = 1.0;","value *= _A(inputIdx);",""]),F.reduceLogSum=(G,O,b)=>tt(G,O,b,"ReduceLogSum",()=>["value = 0.0;","value += _A(inputIdx);","value = log(value);"]),F.reduceLogSumSquare=(G,O,b)=>tt(G,O,b,"ReduceLogSumSquare",()=>["float t; value = 0.0;","t = _A(inputIdx); value += t * t;",""])},7379:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.isReshapeCheap=F.processDims3D=F.createPackedReshape3DProgramInfoLoader=void 0;const X=W(7273),K=W(6757),Q=W(5639),Y=W(5614);F.createPackedReshape3DProgramInfoLoader=(tt,et,q)=>{const G=(O=>({name:"Reshape (packed)",inputTypes:[Q.TextureType.packed],inputNames:["A"],cacheHint:`${O}`}))(q);return Object.assign(Object.assign({},G),{get:()=>((O,b,j,U)=>{const J=b.dims,nt=U;let rt="";for(let ut=0;ut<4;ut++){let st="";switch(ut){case 0:st="outputCoords = rc;";break;case 1:st="outputCoords = ivec3(rc.x, rc.y+1, rc.z);";break;case 2:st="outputCoords = ivec3(rc.x, rc.y, rc.z+1);";break;case 3:st="outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";break;default:throw new Error}rt+=`
        ${st}
        ${ut>0?"if(outputCoords.y < rows && outputCoords.z < cols){":""}
          int flattenedIndex = getFlattenedIndex(outputCoords);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);
          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${ut}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);

        ${ut>0?"}":""}
      `}const ot=(0,K.getGlsl)(O.session.backend.glContext.version),at=`
      ${function(ut){const st=X.ShapeUtil.computeStrides(ut),ct=["b","r","c"],dt="index";return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${st.map((pt,lt)=>`int ${ct[lt]} = ${dt} / ${pt}; ${lt===st.length-1?`int ${ct[lt+1]} = ${dt} - ${ct[lt]} * ${pt}`:`index -= ${ct[lt]} * ${pt}`};`).join("")}
      return ivec3(b, r, c);
    }
  `}(J)}
      ${function(ut){const st=X.ShapeUtil.computeStrides(ut);return`
  int getFlattenedIndex(ivec3 coords) {
    // reverse y, z order
    return coords.x * ${st[0]} + coords.z * ${st[1]} + coords.y;
  }
`}(nt)}
      ${(0,Y.unpackFromChannel)()}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.0);

        ivec3 outputCoords;
        int rows = ${nt[2]};
        int cols = ${nt[1]};

        ${rt}
        ${ot.output} = result;
      }
    `;return Object.assign(Object.assign({},j),{output:{dims:nt,type:b.type,textureType:Q.TextureType.packed},shaderSource:at,hasMain:!0})})(tt,et,G,q)})},F.processDims3D=function(tt){if(tt.length===0)return[1,1,1];let et=1;for(let q=0;q<tt.length-2;++q)et*=tt[q];return[et,tt.length>1?tt[tt.length-2]:1,tt[tt.length-1]]},F.isReshapeCheap=function(tt,et){let q=!1;return q=tt.length===0||et.length===0||(tt.length<2||et.length<2?tt[tt.length-1]===et[et.length-1]:tt[tt.length-1]===et[et.length-1]&&tt[tt.length-2]===et[et.length-2]),q}},8126:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.reshape=void 0;const X=W(7273);F.reshape=(K,Q)=>{const Y=X.ShapeUtil.calculateReshapedDims(Q[0].dims,Q[1].integerData);return K.session.pack?[K.reshapePacked(Q[0],Y)]:[K.reshapeUnpacked(Q[0],Y)]}},2801:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.parseResizeAttributesV11=F.parseResizeAttributesV10=F.resize=void 0;const X=W(6757),K=W(5639),Q=W(432),Y=W(5614),tt=W(3980),et={name:"Resize",inputNames:["A"],inputTypes:[K.TextureType.packed]};F.resize=(j,U,J)=>((0,tt.validateInputs)(U,J),[j.run(Object.assign(Object.assign({},et),{cacheHint:J.cacheKey,get:()=>q(j,U,J)}),U)]),F.parseResizeAttributesV10=j=>(0,tt.parseUpsampleAttributes)(j,10),F.parseResizeAttributesV11=j=>(0,tt.parseUpsampleAttributes)(j,11);const q=(j,U,J)=>{const nt=(0,X.getGlsl)(j.session.backend.glContext.version),[rt,ot]=G(U,J);if(rt.every(bt=>bt===1)&&J.coordinateTransformMode!=="tf_crop_and_resize")return Object.assign(Object.assign({},et),{output:{dims:ot,type:U[0].type,textureType:K.TextureType.packed},hasMain:!0,shaderSource:`void main() {
                    vec4 v = ${nt.texture2D}(X, TexCoords);
                    ${nt.output} = v;
                }`});const at=ot.length;if(at<2)throw new Error(`output dimension should be at least 2, but got ${at}`);const ut=ot[at-2],st=ot[at-1],ct=U[0].dims;if(at!==ct.length)throw new Error(`output dimension should match input ${ct.length}, but got ${at}`);const dt=ct[at-2],pt=ct[at-1],lt=rt[at-2],ft=rt[at-1];let gt="";if(J.mode!=="linear")throw new Error(`resize (packed) does not support mode: '${J.mode}'`);switch(J.coordinateTransformMode){case"asymmetric":gt=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return vec4(coords) / scaleWHWH;
                    }
                `;break;case"half_pixel":gt=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;
                    }
                `;break;case"pytorch_half_pixel":gt=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 fcoords = vec4(coords);
                        return vec4(
                            ${st}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,
                            ${ut}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,
                            ${st}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,
                            ${ut}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0
                          );
                    }
                `;break;case"align_corners":gt=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 resized = vec4(${st}.0 - 1.0, ${ut}.0 - 1.0, ${st}.0 - 1.0,
                            ${ut}.0 - 1.0);
                        vec4 original = vec4(${pt}.0 - 1.0, ${dt}.0 - 1.0, ${pt}.0 - 1.0,
                            ${dt}.0 - 1.0);
                        vec4 new_scale = original / resized;
                        return vec4(coords) * new_scale;
                    }
                `;break;default:throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${J.coordinateTransformMode}'`)}const _t=(0,Q.getCoordsDataType)(at),wt=`
            const vec2 inputWH = vec2(${dt}.0, ${pt}.0);
            const vec4 scaleWHWH = vec4(float(${lt}), float(${ft}), float(${lt}), float(${ft}));
            ${(0,Y.unpackFromChannel)()}
            ${gt}
            float getAValue(int x10, int r, int c, int d) {
                return getChannel(getA(x10, r, c, d), vec2(c, d));
            }
            void main() {
                ${_t} rc = getOutputCoords();

                int batch = rc[0];
                int depth = rc[1];

                // retrieve the 4 coordinates that is used in the 4 packed output values.
                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);

                // calculate the source index in fraction
                vec4 sourceFrac = getSourceFracIndex(coords);

                // get the lower and upper bound of the 4 values that will be packed into one texel.
                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));
                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));
                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));
                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));

                bool hasNextRow = rc.w < ${ut-1};
                bool hasNextCol = rc.z < ${st-1};

                // pack x00, x01, x10, x11's top-left corner into one vec4 structure
                vec4 topLeft = vec4(
                    getAValue(batch, depth, x00.x, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);

                // pack x00, x01, x10, x11's top-right corner into one vec4 structure
                vec4 topRight = vec4(
                    getAValue(batch, depth, x00.x, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);

                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure
                vec4 bottomLeft = vec4(
                    getAValue(batch, depth, x00.z, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);

                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure
                vec4 bottomRight = vec4(
                    getAValue(batch, depth, x00.z, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);

                // calculate the interpolation fraction on u and v direction
                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);
                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));

                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);
                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);
                vec4 newValue = mix(top, bottom, clampFrac.xxzz);

                ${nt.output} = vec4(newValue);
            }
        `;return Object.assign(Object.assign({},et),{output:{dims:ot,type:U[0].type,textureType:K.TextureType.packed},hasMain:!0,shaderSource:wt})},G=(j,U)=>{const J=j[0].dims;let nt,rt=U.scales;if(rt.length===0){const at=j[U.scalesInputIdx];if(at&&at.size!==0){if(j[U.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");rt=O(at,U.mode,U.isResize)}else{const ut=j[U.sizesInputIdx];if(!ut||ut.size===0)throw new Error("Either scales or sizes MUST be provided as input.");nt=Array.from(ut.integerData),rt=b(nt,J,U.mode,U.isResize)}}else if(j[U.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");const ot=nt||J.map((at,ut)=>Math.floor(at*rt[ut]));return[rt,ot]},O=(j,U,J)=>{const nt=Array.from(j.floatData);return(0,tt.scalesValidation)(nt,U,J),nt},b=(j,U,J,nt)=>{const rt=U.length,ot=new Array(rt);for(let at=0,ut=rt;at<ut;at++)if(U[at]===0){if(j[at]!==0)throw new Error("Input dim is zero but required output dim is non-zero.");ot[at]=1}else ot[at]=j[at]/U[at];return(0,tt.scalesValidation)(ot,J,nt),ot}},565:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.shape=void 0;const X=W(9240);F.shape=(Q,Y)=>(K(Y),[new X.Tensor([Y[0].dims.length],"int32",void 0,void 0,new Int32Array(Y[0].dims))]);const K=Q=>{if(!Q||Q.length!==1)throw new Error("Shape requires 1 input.")}},2444:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.sliceV10=F.parseSliceAttributes=F.slice=void 0;const X=W(4910),K=W(6145),Q=W(7273),Y=W(5639),tt={name:"Slice",inputNames:["A"],inputTypes:[Y.TextureType.unpacked]};F.slice=(b,j,U)=>(q(j),[b.run(Object.assign(Object.assign({},tt),{cacheHint:U.cacheKey,get:()=>et(b,j[0],U)}),j)]),F.parseSliceAttributes=b=>{const j=b.attributes.getInts("starts"),U=b.attributes.getInts("ends"),J=b.attributes.getInts("axes",[]);return(0,X.createAttributeWithCacheKey)({starts:j,ends:U,axes:J})};const et=(b,j,U)=>{const J=U.axes.length===0?j.dims.slice(0).map((ct,dt)=>dt):U.axes,nt=Q.ShapeUtil.normalizeAxes(J,j.dims.length),rt=U.starts.map((ct,dt)=>ct>j.dims[nt[dt]]-1?j.dims[nt[dt]]:Q.ShapeUtil.normalizeAxis(ct,j.dims[nt[dt]])),ot=U.ends.map((ct,dt)=>ct>j.dims[nt[dt]]-1?j.dims[nt[dt]]:Q.ShapeUtil.normalizeAxis(ct,j.dims[nt[dt]])),at=j.dims.slice(),ut=[];for(let ct=0;ct<nt.length;ct++)at[nt[ct]]=ot[ct]-rt[ct],rt[ct]>0&&ut.push(`outputIdx[${nt[ct]}] += ${rt[ct]};`);const st=`
      float process(int outputIdx[${at.length}]) {
        ${ut.join(`
      `)}
        return _A(outputIdx);
      }`;return Object.assign(Object.assign({},tt),{output:{dims:at,type:j.type,textureType:Y.TextureType.unpacked},shaderSource:st})},q=b=>{if(!b||b.length!==1)throw new Error("Slice requires 1 input.");if(K.NUMBER_TYPES.indexOf(b[0].type)===-1)throw new Error("Invalid input type.")};F.sliceV10=(b,j)=>{O(j);const U=G(b,j);return[b.run(Object.assign(Object.assign({},tt),{cacheHint:U.cacheKey,get:()=>et(b,j[0],U)}),[j[0]])]};const G=(b,j)=>{if(!b.session.isInitializer(j[1].dataId)||!b.session.isInitializer(j[2].dataId)||j.length>=4&&!b.session.isInitializer(j[3].dataId)||j.length>=5&&!b.session.isInitializer(j[4].dataId))throw new Error("dynamic slice attributes are not allowed");if(j.length>=5&&j[4].integerData.some(rt=>rt!==1))throw new Error("currently non-1 steps is not supported for Slice");const U=Array.from(j[1].integerData),J=Array.from(j[2].integerData),nt=j.length>=4?Array.from(j[3].integerData):[];return{starts:U,ends:J,axes:nt,cacheKey:`${nt};${U};${J}`}},O=b=>{if(!b||b.length<3||b.length>5)throw new Error("Invalid input number.");if(b[1].type!=="int32"||b[1].dims.length!==1)throw new Error("Invalid input type.");if(b[2].type!=="int32"||b[2].dims.length!==1)throw new Error("Invalid input type.");if(b.length>=4&&(b[3].type!=="int32"||b[3].dims.length!==1))throw new Error("Invalid input type.");if(b.length>=5&&(b[4].type!=="int32"||b[4].dims.length!==1))throw new Error("Invalid input type.")}},815:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.softmaxV13=F.parseSoftmaxAttributesV13=F.parseSoftmaxAttributes=F.softmax=void 0;const X=W(4910),K=W(7273),Q=W(6757),Y=W(5639),tt=W(5707),et={name:"SoftmaxComputeMax",inputNames:["A"],inputTypes:[Y.TextureType.unpacked]},q={name:"SoftmaxComputeScale",inputNames:["A","Max"],inputTypes:[Y.TextureType.unpacked,Y.TextureType.unpacked]},G={name:"SoftMax",inputNames:["A","Max","Norm"],inputTypes:[Y.TextureType.unpacked,Y.TextureType.unpacked,Y.TextureType.unpacked]};F.softmax=(nt,rt,ot)=>{J(rt);const at=rt[0].dims.slice(),ut=K.ShapeUtil.normalizeAxis(ot.axis,at.length),st=K.ShapeUtil.sizeToDimension(at,ut),ct=K.ShapeUtil.sizeFromDimension(at,ut);return O(nt,rt,ot,st,ct)},F.parseSoftmaxAttributes=nt=>(0,X.createAttributeWithCacheKey)({axis:nt.attributes.getInt("axis",1)}),F.parseSoftmaxAttributesV13=nt=>(0,X.createAttributeWithCacheKey)({axis:nt.attributes.getInt("axis",-1)}),F.softmaxV13=(nt,rt,ot)=>{J(rt);const at=rt[0].dims.slice(),ut=K.ShapeUtil.normalizeAxis(ot.axis,at.length),st=at.length,ct=ut!==st-1,dt=[];let pt,lt=[],ft=[];ct&&(lt=Array.from({length:st}).map((bt,Ot)=>Ot),lt[ut]=st-1,lt[st-1]=ut,lt.map(bt=>dt.push(at[bt])),pt=(0,X.createAttributeWithCacheKey)({perm:lt}),ft=(0,tt.transpose)(nt,rt,pt));const gt=ct?K.ShapeUtil.sizeToDimension(dt,st-1):K.ShapeUtil.sizeToDimension(at,st-1),_t=ct?K.ShapeUtil.sizeFromDimension(dt,st-1):K.ShapeUtil.sizeFromDimension(at,st-1),wt=O(nt,ct?ft:rt,ot,gt,_t);return ct?(0,tt.transpose)(nt,wt,pt):wt};const O=(nt,rt,ot,at,ut)=>{const st=b(nt,rt[0],at,ut,[at]),ct=nt.run(Object.assign(Object.assign({},et),{cacheHint:ot.cacheKey,get:()=>st}),rt),dt=j(nt,rt[0],at,ut,st.output.dims,[at]),pt=nt.run(Object.assign(Object.assign({},q),{cacheHint:ot.cacheKey,get:()=>dt}),[rt[0],ct]),lt=U(nt,rt[0],at,ut,st.output.dims,dt.output.dims);return[nt.run(Object.assign(Object.assign({},G),{cacheHint:ot.cacheKey,get:()=>lt}),[rt[0],ct,pt])]},b=(nt,rt,ot,at,ut)=>{const[st,ct]=nt.calculateTextureWidthAndHeight(rt.dims,Y.TextureType.unpacked),dt=ut.length;if(ot<1||at<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(ut.length!==1)throw new Error("Dimensionality of the output should be 1");if(ut[0]!==ot)throw new Error("Shape of the output should be equal to logical row count");const pt=(0,Q.getGlsl)(nt.session.backend.glContext.version),lt=`
      float process(int[${dt}] indices) {
        int logical_row_start_offset = indices[0] * ${at};

        float max = getColorAsFloat(${pt.texture2D}(A, offsetToCoords(logical_row_start_offset, ${st},
        ${ct} )));
        for(int i=1; i<${at}; ++i)
        {
          float current = getColorAsFloat(${pt.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${st}, ${ct})));
          if(current > max)
          max = current;
        }

        return max;
      }`;return Object.assign(Object.assign({},et),{output:{dims:ut,type:rt.type,textureType:Y.TextureType.unpacked},shaderSource:lt})},j=(nt,rt,ot,at,ut,st)=>{const[ct,dt]=nt.calculateTextureWidthAndHeight(rt.dims,Y.TextureType.unpacked),pt=st.length;if(ot<1||at<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(st.length!==1)throw new Error("Dimensionality of the output should be 1");if(st[0]!==ot)throw new Error("Shape of the output should be equal to logical row count");if(ut.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(ut[0]!==ot)throw new Error("Shape of the intermediate results should be equal to logical row count");const lt=`
      float process(int[${pt}] indices) {
        int logical_row_start_offset = indices[0] * ${at};

        float norm_factor = 0.0;
        float max = _Max(indices);
        for(int i=0; i<${at}; ++i)
        {
          norm_factor += exp(getColorAsFloat(${(0,Q.getGlsl)(nt.session.backend.glContext.version).texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${ct}, ${dt}))) - max);
        }

        return norm_factor;
      }`;return Object.assign(Object.assign({},q),{output:{dims:st,type:rt.type,textureType:Y.TextureType.unpacked},shaderSource:lt})},U=(nt,rt,ot,at,ut,st)=>{const[ct,dt]=nt.calculateTextureWidthAndHeight(rt.dims,Y.TextureType.unpacked),pt=rt.dims.length;if(ot<1||at<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(ut.length!==1||st.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(ut[0]!==ot||st[0]!==ot)throw new Error("Shape of the intermediate results should be equal to logical row count");const lt=`
      float process(int[${pt}] indices) {

      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)
      int offset = coordsToOffset(TexCoords, ${ct}, ${dt});

      //determine the logical row for this index
      int logical_row_index[1];
      logical_row_index[0] = offset / ${at};

      float norm_factor = _Norm(logical_row_index);

      // avoid possible division by 0
      // if norm_facor is 0, all elements are zero
      // if so, return 0
      if(norm_factor == 0.0)
        return 0.0;

      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;
    }`;return Object.assign(Object.assign({},G),{output:{dims:rt.dims,type:rt.type,textureType:Y.TextureType.unpacked},shaderSource:lt})},J=nt=>{if(!nt||nt.length!==1)throw new Error("Softmax requires 1 input.");if(nt[0].type!=="float32"&&nt[0].type!=="float64")throw new Error("Invalid input type")}},564:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.parseSplitAttributes=F.split=void 0;const X=W(4910),K=W(7273),Q=W(5639),Y={name:"Split",inputNames:["A"],inputTypes:[Q.TextureType.unpacked]};F.split=(G,O,b)=>{q(O);const j=K.ShapeUtil.normalizeAxis(b.axis,O[0].dims.length),U=tt(G,O,j,b),J=[];for(let nt=0;nt<U;++nt)J.push(G.run(Object.assign(Object.assign({},Y),{cacheHint:`${b.cacheKey};${nt}`,get:()=>et(G,O[0],b,j,nt)}),O));return J},F.parseSplitAttributes=G=>{const O=G.attributes.getInt("axis",0),b=G.attributes.getInts("split",[]),j=G.outputs.length;return(0,X.createAttributeWithCacheKey)({axis:O,split:b,numOutputs:j})};const tt=(G,O,b,j)=>{const[,U]=K.SplitUtil.splitShape(O[0].dims,b,j.split,j.numOutputs);return U.length},et=(G,O,b,j,U)=>{const[J,nt]=K.SplitUtil.splitShape(O.dims,j,b.split,b.numOutputs),rt=nt[U],ot=J[U],at=`
      float process(int indices[${ot.length}]) {
        indices[${j}] += ${rt};
        return _A(indices);
      }
    `;return Object.assign(Object.assign({},Y),{cacheHint:`${b.cacheKey}:${U}`,output:{dims:ot,type:O.type,textureType:Q.TextureType.unpacked},shaderSource:at})},q=G=>{if(!G||G.length!==1)throw new Error("Split requires one input.");if(G[0].type!=="int8"&&G[0].type!=="uint8"&&G[0].type!=="int16"&&G[0].type!=="uint16"&&G[0].type!=="int32"&&G[0].type!=="uint32"&&G[0].type!=="float32"&&G[0].type!=="float64"&&G[0].type!=="bool")throw new Error("Invalid input type.")}},5416:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.parseSqueezeAttributes=F.squeezeV13=F.squeeze=void 0;const X=W(7273);F.squeeze=(Y,tt,et)=>{K(tt);const q=X.ShapeUtil.squeezeShape(tt[0].dims,et);return[Y.reshapeUnpacked(tt[0],q)]},F.squeezeV13=(Y,tt)=>(Q(tt),(0,F.squeeze)(Y,[tt[0]],Array.from(tt[1].integerData))),F.parseSqueezeAttributes=Y=>Y.attributes.getInts("axes");const K=Y=>{if(!Y||Y.length!==1)throw new Error("Squeeze requires 1 input.");if(Y[0].type==="string")throw new Error("invalid input tensor types.")},Q=Y=>{if(!Y||Y.length!==2)throw new Error("Squeeze requires 2 inputs.");if(Y[1].type!=="int32")throw new Error("Invalid input type.")}},1240:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.sum=void 0;const X=W(6757),K=W(5639);F.sum=(tt,et)=>{Y(et);const q={name:"Sum",inputNames:et.map((G,O)=>`X${O}`),inputTypes:new Array(et.length).fill(K.TextureType.unpacked)};return[tt.run(Object.assign(Object.assign({},q),{get:()=>Q(tt,et,q)}),et)]};const Q=(tt,et,q)=>{const G=(0,X.getGlsl)(tt.session.backend.glContext.version),O=et[0].dims.slice(),b=`
      void main() {
        vec4 result = ${et.map((j,U)=>`${G.texture2D}(X${U},TexCoords)`).join(" + ")};
        ${G.output} = result;
      }
    `;return Object.assign(Object.assign({},q),{output:{dims:O,type:et[0].type,textureType:K.TextureType.unpacked},hasMain:!0,shaderSource:b})},Y=tt=>{if(!tt||tt.length===0)throw new Error("Sum requires inputs.");const et=tt[0].dims.length;for(let q=1;q<tt.length;q++){if(et!==tt[q].dims.length)throw new Error("Input shapes are mismatched.");for(let G=0;G<et;G++)if(tt[0].dims[G]!==tt[q].dims[G])throw new Error("Input shapes are not matched.")}if(tt[0].type!=="float32"&&tt[0].type!=="float64")throw new Error("Invalid input type.");for(let q=1;q<tt.length;q++)if(tt[0].type!==tt[q].type)throw new Error("Input types are not matched.")}},5944:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.tile=void 0;const X=W(6145),K=W(5639);F.tile=(tt,et)=>{Y(et);const q={name:"Tile",inputNames:["A"],inputTypes:[K.TextureType.unpacked]};return[tt.run(Object.assign(Object.assign({},q),{get:()=>Q(tt,et,q)}),et)]};const Q=(tt,et,q)=>{const G=et[0].dims.slice(),O=new Array(G.length),b=[];for(let J=0;J<G.length;J++)O[J]=G[J]*et[1].numberData[J],b.push(`inputIdx[${J}] = int(mod(float(outputIdx[${J}]), ${G[J]}.));`);const j=O.length,U=`
      float process(int outputIdx[${j}]) {
        int inputIdx[${j}];
        ${b.join(`
`)}
        return _A(inputIdx);
      }
    `;return Object.assign(Object.assign({},q),{output:{dims:O,type:et[0].type,textureType:K.TextureType.unpacked},shaderSource:U})},Y=tt=>{if(!tt||tt.length!==2)throw new Error("Tile requires 2 input.");if(tt[1].dims.length!==1)throw new Error("The second input shape must 1 dimension.");if(tt[1].dims[0]!==tt[0].dims.length)throw new Error("Invalid input shape.");if(X.NUMBER_TYPES.indexOf(tt[0].type)===-1)throw new Error("Invalid input type.");if(tt[1].type!=="int32"&&tt[1].type!=="int16")throw new Error("Invalid repeat type.")}},5707:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.parseTransposeAttributes=F.transpose=void 0;const X=W(4910),K=W(7273),Q=W(5639),Y={name:"Transpose",inputNames:["A"],inputTypes:[Q.TextureType.unpacked]};F.transpose=(b,j,U)=>(O(j),[b.run(Object.assign(Object.assign({},Y),{cacheHint:U.cacheKey,get:()=>tt(b,j[0],U.perm)}),j)]),F.parseTransposeAttributes=b=>(0,X.createAttributeWithCacheKey)({perm:b.attributes.getInts("perm",[])});const tt=(b,j,U)=>{const J=j.dims;U=et(J,U);const nt=q(J,U),rt=J.length,ot=`
      ${G("perm",U,rt)}
      float process(int indices[${rt}]) {
        int a[${rt}];
        perm(a, indices);
        return _A(a);
      }`;return Object.assign(Object.assign({},Y),{output:{dims:nt,type:j.type,textureType:Q.TextureType.unpacked},shaderSource:ot})},et=(b,j)=>(j&&j.length!==b.length&&(j=[...b.keys()].reverse()),j),q=(b,j)=>(j=et(b,j),K.ShapeUtil.sortBasedOnPerm(b,j)),G=(b,j,U)=>{const J=[];J.push(`void ${b}(out int a[${U}], int src[${U}]) {`);for(let nt=0;nt<U;++nt)J.push(`	a[${j[nt]}]=src[${nt}];`);return J.push("	}"),J.join(`
`)},O=b=>{if(!b||b.length!==1)throw new Error("Transpose requires 1 input.");if(b[0].type!=="float32"&&b[0].type!=="float64")throw new Error("input should be float tensor")}},2488:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.encodeAsUint8=void 0;const X=W(6757),K=W(5639);F.encodeAsUint8=(Q,Y)=>{const tt=Y.shape,et=(0,X.getGlsl)(Q.session.backend.glContext.version),q=`
    const float FLOAT_MAX = 1.70141184e38;
    const float FLOAT_MIN = 1.17549435e-38;

    bool isNaN(float val) {
      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;
    }

    highp vec4 encodeAsUint8(highp float v) {
      if (isNaN(v)) {
        return vec4(255, 255, 255, 255);
      }

      highp float av = abs(v);

      if(av < FLOAT_MIN) {
        return vec4(0.0, 0.0, 0.0, 0.0);
      } else if(v > FLOAT_MAX) {
        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
      } else if(v < -FLOAT_MAX) {
        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
      }

      highp vec4 c = vec4(0,0,0,0);

      highp float e = floor(log2(av));
      highp float m = exp2(fract(log2(av))) - 1.0;

      c[2] = floor(128.0 * m);
      m -= c[2] / 128.0;
      c[1] = floor(32768.0 * m);
      m -= c[1] / 32768.0;
      c[0] = floor(8388608.0 * m);

      highp float ebias = e + 127.0;
      c[3] = floor(ebias / 2.0);
      ebias -= c[3] * 2.0;
      c[2] += floor(ebias) * 128.0;

      c[3] += 128.0 * step(0.0, -v);

      return c / 255.0;
    }

    void main() {
      float value = ${et.texture2D}(X,TexCoords).r;
      ${et.output} = encodeAsUint8(value);
    }`,G={name:"Uint8Encode",inputTypes:[K.TextureType.unpacked],inputNames:["X"],output:{dims:tt,type:Y.tensor.type,textureType:K.TextureType.downloadUint8AsFloat},shaderSource:q,hasMain:!0};return Q.executeProgram(G,[Y.tensor])}},9087:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.tanh=F.tan=F.sqrt=F.sin=F.sigmoid=F.relu=F.not=F.neg=F.log=F.parseLeakyReluAttributes=F.leakyRelu=F.identity=F.floor=F.exp=F.parseEluAttributes=F.elu=F.cos=F.ceil=F.clipV11=F.parseClipAttributes=F.clip=F.atan=F.asin=F.acos=F.abs=F.glslTanh=F.glslTan=F.glslSqrt=F.glslSigmoid=F.glslRelu=F.glslSin=F.glslNot=F.glslNeg=F.glslLog=F.glslLeakyRelu=F.glslIdentity=F.glslClip=F.glslFloor=F.glslExp=F.glslElu=F.glslCos=F.glslCeil=F.glslAtan=F.glslAsin=F.glslAcos=F.glslAbs=void 0;const X=W(4910),K=W(7273),Q=W(1997),Y=W(6757),tt=W(5639);function et(){return wt("abs")}function q(){return wt("acos")}function G(){return wt("asin")}function O(){return wt("atan")}function b(){return wt("ceil")}function j(){return wt("cos")}function U(vt){const xt="elu";return{body:`
  const float alpha = float(${vt});

  float ${xt}_(float a) {
    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;
  }
  vec4 ${xt}_(vec4 v) {
    return vec4(${xt}_(v.x), ${xt}_(v.y), ${xt}_(v.z), ${xt}_(v.w));
  }
  `,name:xt,type:Q.FunctionType.ValueBased}}function J(){return wt("exp")}function nt(){return wt("floor")}function rt(vt,xt){const Rt="clip";return{body:`
  const float min = float(${vt});
  const float max = float(${xt});

  float ${Rt}_(float a) {
    return clamp(a, min, max);
  }
  vec4 ${Rt}_(vec4 v) {
    return clamp(v, min, max);
  }
  `,name:Rt,type:Q.FunctionType.ValueBased}}function ot(){const vt="indentity";return{body:`
  float ${vt}_(float a) {
    return a;
  }
  vec4 ${vt}_(vec4 v) {
    return v;
  }
  `,name:vt,type:Q.FunctionType.ValueBased}}function at(vt){const xt="leakyRelu";return{body:`
  const float alpha = float(${vt});

  float ${xt}_(float a) {
    return a < 0.0 ? a * alpha : a;
  }
  vec4 ${xt}_(vec4 v) {
    return vec4(${xt}_(v.x), ${xt}_(v.y), ${xt}_(v.z), ${xt}_(v.w));
  }
  `,name:xt,type:Q.FunctionType.ValueBased}}function ut(){return wt("log")}function st(){const vt="neg";return{body:`
  float ${vt}_(float a) {
    return -a;
  }
  vec4 ${vt}_(vec4 v) {
    return -v;
  }
  `,name:vt,type:Q.FunctionType.ValueBased}}function ct(){const vt="not";return{body:`
  float ${vt}_(float a) {
    return float( ! bool(a) );
  }
  bool ${vt}_(bool a) {
    return !a;
  }
  vec4 ${vt}_(vec4 v) {
    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));
  }
  bvec4 ${vt}_(bvec4 v) {
    return bvec4(!v.x, !v.y, !v.z, !v.w);
  }
  `,name:vt,type:Q.FunctionType.ValueBased}}function dt(){return wt("sin")}function pt(){const vt="relu";return{body:`
  float ${vt}_(float a) {
    return max( a, 0.0 );
  }
  vec4 ${vt}_(vec4 v) {
    return max( v, 0.0 );
  }
  `,name:vt,type:Q.FunctionType.ValueBased}}function lt(){const vt="sigmoid";return{body:`
  float ${vt}_(float a) {
    return 1.0 / (1.0 + exp(-a));
  }
  vec4 ${vt}_(vec4 v) {
    return 1.0 / (1.0 + exp(-v));
  }
  `,name:vt,type:Q.FunctionType.ValueBased}}function ft(){return wt("sqrt")}function gt(){return wt("tan")}function _t(){const vt="tanh";return{body:`
  float ${vt}_(float a) {
    a = clamp(a, -10., 10.);
    a = exp(2.*a);
    return (a - 1.) / (a + 1.);
  }
  vec4 ${vt}_(vec4 v) {
    v = clamp(v, -10., 10.);
    v = exp(2.*v);
    return (v - 1.) / (v + 1.);
  }
  `,name:vt,type:Q.FunctionType.ValueBased}}function wt(vt){return{body:`
  float ${vt}_(float a) {
    return ${vt}(a);
  }
  vec4 ${vt}_(vec4 v) {
    return ${vt}(v);
  }
  `,name:vt,type:Q.FunctionType.ValueBased}}F.glslAbs=et,F.glslAcos=q,F.glslAsin=G,F.glslAtan=O,F.glslCeil=b,F.glslCos=j,F.glslElu=U,F.glslExp=J,F.glslFloor=nt,F.glslClip=rt,F.glslIdentity=ot,F.glslLeakyRelu=at,F.glslLog=ut,F.glslNeg=st,F.glslNot=ct,F.glslSin=dt,F.glslRelu=pt,F.glslSigmoid=lt,F.glslSqrt=ft,F.glslTan=gt,F.glslTanh=_t;const bt=(vt,xt,Rt,kt)=>{const Ht=vt.session.pack?tt.TextureType.packed:tt.TextureType.unpacked,Mt={name:Rt.name,inputTypes:[Ht],inputNames:["A"],cacheHint:kt};return Object.assign(Object.assign({},Mt),{get:()=>((qt,Jt,Bt,ee)=>{const ne=qt.session.pack?tt.TextureType.packed:tt.TextureType.unpacked,Yt=(0,Y.getGlsl)(qt.session.backend.glContext.version);return Object.assign(Object.assign({},Jt),{output:{dims:Bt.dims,type:Bt.type,textureType:ne},shaderSource:`
     ${ee.body}
     void main() {
       vec4 v = ${Yt.texture2D}(A, TexCoords);
       v = ${ee.name}_(v);
       ${Yt.output} = v;
     }
     `,hasMain:!0})})(vt,Mt,xt,Rt)})};F.abs=(vt,xt)=>[vt.run(bt(vt,xt[0],et()),xt)],F.acos=(vt,xt)=>[vt.run(bt(vt,xt[0],q()),xt)],F.asin=(vt,xt)=>[vt.run(bt(vt,xt[0],G()),xt)],F.atan=(vt,xt)=>[vt.run(bt(vt,xt[0],O()),xt)],F.clip=(vt,xt,Rt)=>[vt.run(bt(vt,xt[0],rt(Rt.min,Rt.max),Rt.cacheKey),xt)],F.parseClipAttributes=vt=>(0,X.createAttributeWithCacheKey)({min:vt.attributes.getFloat("min",K.MIN_CLIP),max:vt.attributes.getFloat("max",K.MAX_CLIP)}),F.clipV11=(vt,xt)=>{const Rt=Ot(vt,xt);return(0,F.clip)(vt,[xt[0]],Rt)};const Ot=(vt,xt)=>{if(xt.length>=3&&(!vt.session.isInitializer(xt[1].dataId)||!vt.session.isInitializer(xt[2].dataId)))throw new Error("dynamic clip attributes are not allowed");const Rt=xt.length>=3?xt[1].numberData[0]:K.MIN_CLIP,kt=xt.length>=3?xt[2].numberData[0]:K.MAX_CLIP;return(0,X.createAttributeWithCacheKey)({min:Rt,max:kt})};F.ceil=(vt,xt)=>[vt.run(bt(vt,xt[0],b()),xt)],F.cos=(vt,xt)=>[vt.run(bt(vt,xt[0],j()),xt)],F.elu=(vt,xt,Rt)=>[vt.run(bt(vt,xt[0],U(Rt.alpha),Rt.cacheKey),xt)],F.parseEluAttributes=vt=>(0,X.createAttributeWithCacheKey)({alpha:vt.attributes.getFloat("alpha",1)}),F.exp=(vt,xt)=>[vt.run(bt(vt,xt[0],J()),xt)],F.floor=(vt,xt)=>[vt.run(bt(vt,xt[0],nt()),xt)],F.identity=(vt,xt)=>[vt.run(bt(vt,xt[0],ot()),xt)],F.leakyRelu=(vt,xt,Rt)=>[vt.run(bt(vt,xt[0],at(Rt.alpha),Rt.cacheKey),xt)],F.parseLeakyReluAttributes=vt=>(0,X.createAttributeWithCacheKey)({alpha:vt.attributes.getFloat("alpha",.01)}),F.log=(vt,xt)=>[vt.run(bt(vt,xt[0],ut()),xt)],F.neg=(vt,xt)=>[vt.run(bt(vt,xt[0],st()),xt)],F.not=(vt,xt)=>[vt.run(bt(vt,xt[0],ct()),xt)],F.relu=(vt,xt)=>[vt.run(bt(vt,xt[0],pt()),xt)],F.sigmoid=(vt,xt)=>[vt.run(bt(vt,xt[0],lt()),xt)],F.sin=(vt,xt)=>[vt.run(bt(vt,xt[0],dt()),xt)],F.sqrt=(vt,xt)=>[vt.run(bt(vt,xt[0],ft()),xt)],F.tan=(vt,xt)=>[vt.run(bt(vt,xt[0],gt()),xt)],F.tanh=(vt,xt)=>[vt.run(bt(vt,xt[0],_t()),xt)]},540:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.createUnpackProgramInfoLoader=F.createUnpackProgramInfo=void 0;const X=W(6757),K=W(5639),Q=W(432),Y=W(5614),tt={name:"unpack",inputNames:["A"],inputTypes:[K.TextureType.packed]};F.createUnpackProgramInfo=(et,q)=>{const G=q.dims.length,O=(0,Y.getChannels)("rc",G),b=O.slice(-2),j=(0,Q.getCoordsDataType)(G),U=(0,Y.unpackFromChannel)(),J=q.dims.length===0?"":function(ot,at){if(ot===1)return"rc";let ut="";for(let st=0;st<ot;st++)ut+=at[st],st<ot-1&&(ut+=",");return ut}(G,O),nt=G<=1?"rc":`vec2(${b.join(",")})`,rt=`
    ${U}
    void main() {
      ${j} rc = getOutputCoords();

       // Sample the texture with the coords to get the rgba channel value.
       vec4 packedInput = getA(${J});

       ${(0,X.getGlsl)(et.session.backend.glContext.version).output} = vec4(getChannel(packedInput, ${nt}), 0, 0, 0);
     }
   `;return Object.assign(Object.assign({},tt),{hasMain:!0,output:{dims:q.dims,type:q.type,textureType:K.TextureType.unpacked},shaderSource:rt})},F.createUnpackProgramInfoLoader=(et,q)=>Object.assign(Object.assign({},tt),{get:()=>(0,F.createUnpackProgramInfo)(et,q)})},7862:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.parseUnsqueezeAttributes=F.unsqueezeV13=F.unsqueeze=void 0;const X=W(7273);F.unsqueeze=(Y,tt,et)=>{K(tt);const q=X.ShapeUtil.unsqueezeShape(tt[0].dims,et);return[Y.reshapeUnpacked(tt[0],q)]},F.unsqueezeV13=(Y,tt)=>(Q(tt),(0,F.unsqueeze)(Y,[tt[0]],Array.from(tt[1].integerData))),F.parseUnsqueezeAttributes=Y=>Y.attributes.getInts("axes");const K=Y=>{if(!Y||Y.length!==1)throw new Error("Unsqueeze requires 1 input.");if(Y[0].type==="string")throw new Error("invalid input tensor types.")},Q=Y=>{if(!Y||Y.length!==2)throw new Error("Unsqueeze requires 2 inputs.");if(Y[1].type!=="int32")throw new Error("Invalid input type.")}},3980:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.scalesValidation=F.validateInputs=F.parseUpsampleAttributes=F.parseUpsampleAttributesV9=F.parseUpsampleAttributesV7=F.upsample=void 0;const X=W(4910),K=W(6757),Q=W(5639),Y={name:"Upsample",inputNames:["X"],inputTypes:[Q.TextureType.unpacked]};F.upsample=(et,q,G)=>((0,F.validateInputs)(q,G),[et.run(Object.assign(Object.assign({},Y),{cacheHint:G.cacheKey,get:()=>tt(et,q,G)}),q)]),F.parseUpsampleAttributesV7=et=>(0,F.parseUpsampleAttributes)(et,7),F.parseUpsampleAttributesV9=et=>(0,F.parseUpsampleAttributes)(et,9),F.parseUpsampleAttributes=(et,q)=>{const G=q>=10,O=et.attributes.getString("mode","nearest");if(O!=="nearest"&&O!=="linear"&&(q<11||O!=="cubic"))throw new Error(`unrecognized mode: ${O}`);let b=[];q<9&&(b=et.attributes.getFloats("scales"),(0,F.scalesValidation)(b,O,G));const j=et.attributes.getFloat("extrapolation_value",0),U=q>10?et.attributes.getString("coordinate_transformation_mode","half_pixel"):"asymmetric";if(["asymmetric","pytorch_half_pixel","tf_half_pixel_for_nn","align_corners","tf_crop_and_resize","half_pixel"].indexOf(U)===-1)throw new Error(`coordinate_transform_mode '${U}' is not supported`);const J=U==="tf_crop_and_resize",nt=J,rt=O==="nearest"&&q>=11?et.attributes.getString("nearest_mode","round_prefer_floor"):"";if(["round_prefer_floor","round_prefer_ceil","floor","ceil",""].indexOf(rt)===-1)throw new Error(`nearest_mode '${rt}' is not supported`);const ot=et.attributes.getFloat("cubic_coeff_a",-.75),at=et.attributes.getInt("exclude_outside",0)!==0;if(at&&O!=="cubic")throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");const ut=q<11||O==="nearest"&&U==="asymmetric"&&rt==="floor";let st=0,ct=0,dt=0;return q>10?et.inputs.length>2?(st=1,ct=2,dt=3):(ct=1,dt=2):q===9&&(ct=1),(0,X.createAttributeWithCacheKey)({opset:q,isResize:G,mode:O,scales:b,extrapolationValue:j,coordinateTransformMode:U,useExtrapolation:nt,needRoiInput:J,nearestMode:rt,cubicCoefficientA:ot,excludeOutside:at,useNearest2xOptimization:ut,roiInputIdx:st,scalesInputIdx:ct,sizesInputIdx:dt})};const tt=(et,q,G)=>{const O=(0,K.getGlsl)(et.session.backend.glContext.version),[b,j]=et.calculateTextureWidthAndHeight(q[0].dims,Q.TextureType.unpacked),U=q[0].dims.map((dt,pt)=>Math.floor(dt*G.scales[pt])),[J,nt]=et.calculateTextureWidthAndHeight(U,Q.TextureType.unpacked),rt=U.length,ot=new Array(rt),at=new Array(rt);let ut=`
      int output_pitches[${rt}];
      int input_pitches[${rt}];
      `;for(let dt=rt-1;dt>=0;dt--)ot[dt]=dt===rt-1?1:ot[dt+1]*U[dt+1],at[dt]=dt===rt-1?1:at[dt+1]*q[0].dims[dt+1],ut+=`
        output_pitches[${dt}] = ${ot[dt]};
        input_pitches[${dt}] = ${at[dt]};
        `;const st=`
      float getInputFloat(int index) {
        vec2 coords = offsetToCoords(index, ${b}, ${j});
        float value = getColorAsFloat(${O.texture2D}(X, coords));
        return value;
      }
      `,ct=G.mode==="nearest"?`
    ${st}
    float process(int indices[${rt}]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${J}, ${nt});

      ${ut}

      int d, m;
      for (int dim = 0; dim < ${rt}; ++dim) {
        d = output_index / output_pitches[dim];
        m = output_index - d * output_pitches[dim];
        output_index = m;

        if (scales[dim] != 1 && d > 0) {
          int d2 = d / scales[dim];
          m = d - d2 * scales[dim];
          d = d2;
        }
        input_index += input_pitches[dim] * d;
      }

      return getInputFloat(input_index);
    }`:rt===4?`
    ${st}
    float process(int indices[4]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${J}, ${nt});

      ${ut}

      int m;
      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m / output_pitches[1];
      m = m - index_of_dim1 * output_pitches[1];
      index_of_dim2 = m / output_pitches[2];
      m = m - index_of_dim2 * output_pitches[2];
      index_of_dim3 = m;

      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;
      index_of_input_dim2 = index_of_dim2 / scales[2];
      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];
      index_of_input_dim3 = index_of_dim3 / scales[3];
      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];

      input_index = index_of_dim0 * input_pitches[0] +
            index_of_dim1 * input_pitches[1] +
            index_of_input_dim2 * input_pitches[2] +
            index_of_input_dim3;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim2 = false;
      if (index_of_input_dim2 == (${q[0].dims[2]} - 1)) {
        // It's the end in dimension 2
        x01 = x00;
        end_of_dim2 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[2]);
      }

      if (index_of_input_dim3 == (input_pitches[2] - 1)) {
        // It's the end in dimension 3
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);
    }`:`
    ${st}
    float process(int indices[2]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${J}, ${nt});

      ${ut}

      int m;
      int index_of_dim0, index_of_dim1;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m;

      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;
      index_of_input_dim0 = index_of_dim0 / scales[0];
      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];
      index_of_input_dim1 = index_of_dim1 / scales[1];
      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];

      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim0 = false;
      if (index_of_input_dim0 == (${q[0].dims[0]} - 1)) {
        // It's the end in dimension 0
        x01 = x00;
        end_of_dim0 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[0]);
      }

      if (index_of_input_dim1 == (input_pitches[0] - 1)) {
        // It's the end in dimension 1
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);
    }`;return Object.assign(Object.assign({},Y),{output:{dims:U,type:q[0].type,textureType:Q.TextureType.unpacked},shaderSource:ct,variables:[{name:"scales",type:"int",arrayLength:G.scales.length,data:G.scales.map(dt=>Math.ceil(dt))}]})};F.validateInputs=(et,q)=>{if(!et||q.opset<9&&et.length!==1||q.opset>=9&&q.opset<11&&et.length!==2||q.opset>=11&&et.length<2)throw new Error("invalid inputs.");if(q.scales.length>0&&et[0].dims.length!==q.scales.length)throw new Error("Invalid input shape.");if(et[0].type==="string")throw new Error("Invalid input tensor types.")},F.scalesValidation=(et,q,G)=>{if(G){for(const O of et)if(O<=0)throw new Error("Scale value should be greater than 0.")}else for(const O of et)if(O<1)throw new Error("Scale value should be greater than or equal to 1.");if(!(q!=="linear"&&q!=="cubic"||et.length===2||et.length===4&&et[0]===1&&et[1]===1))throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${G?"Resize":"Upsample"} opeartor.`)}},2757:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.ProgramManager=void 0;const X=W(8453),K=W(1315),Q=W(8897),Y=W(6757);F.ProgramManager=class{constructor(tt,et,q){this.profiler=tt,this.glContext=et,this.textureLayoutStrategy=q,this.repo=new Map,this.attributesBound=!1}getArtifact(tt){return this.repo.get(tt)}setArtifact(tt,et){this.repo.set(tt,et)}run(tt,et,q){var G;this.profiler.event("op",`ProgramManager.run ${(G=tt.programInfo.name)!==null&&G!==void 0?G:"unknown kernel"}`,()=>{var O;const b=this.glContext.gl,j=tt.program;b.useProgram(j);try{this.bindOutput(q),this.attributesBound||this.bindAttributes(tt.attribLocations),this.bindUniforms(tt.uniformLocations,(O=tt.programInfo.variables)!==null&&O!==void 0?O:[],et)}catch(U){throw K.Logger.error("ProgramManager",tt.programInfo.shaderSource),U}this.profiler.event("backend","GlContext.draw()",()=>{this.glContext.draw()})},this.glContext)}dispose(){this.vertexShader&&this.glContext.deleteShader(this.vertexShader),this.repo.forEach(tt=>this.glContext.deleteProgram(tt.program))}build(tt,et,q){return this.profiler.event("backend","ProgramManager.build",()=>{const G=new Q.GlslPreprocessor(this.glContext,tt,et,q),O=G.preprocess(),b=this.compile(O);return{programInfo:tt,program:b,uniformLocations:this.getUniformLocations(b,G.context.programInfo.inputNames,G.context.programInfo.variables),attribLocations:this.getAttribLocations(b)}})}compile(tt){if(!this.vertexShader){K.Logger.verbose("ProrgramManager","Compiling and caching Vertex shader for the first time");const G=(0,Y.getVertexShaderSource)(this.glContext.version);this.vertexShader=this.glContext.compileShader(G,this.glContext.gl.VERTEX_SHADER)}X.env.debug&&K.Logger.verbose("ProrgramManager",`FragShader:
${tt}
`);const et=this.glContext.compileShader(tt,this.glContext.gl.FRAGMENT_SHADER),q=this.glContext.createProgram(this.vertexShader,et);return this.glContext.deleteShader(et),q}bindOutput(tt){const et=tt.width,q=tt.height;K.Logger.verbose("ProrgramManager",`Binding output texture to Framebuffer: w/h=${et}/${q}, shape=${tt.shape}, type=${tt.tensor.type}`),this.glContext.attachFramebuffer(tt.texture,et,q)}bindAttributes(tt){const et=tt.position,q=tt.textureCoord;this.glContext.setVertexAttributes(et,q),this.attributesBound=!0}bindUniforms(tt,et,q){var G;const O=this.glContext.gl;let b=0;for(const{name:j,type:U,location:J,arrayLength:nt}of tt){const rt=(G=et.find(ot=>ot.name===j))===null||G===void 0?void 0:G.data;if(U!=="sampler2D"&&!rt)throw new Error(`variable '${j}' does not have data defined in program info`);switch(U){case"sampler2D":this.bindTexture(q[b],J,b),b++;break;case"float":nt?O.uniform1fv(J,rt):O.uniform1f(J,rt);break;case"int":nt?O.uniform1iv(J,rt):O.uniform1i(J,rt);break;default:throw new Error(`Uniform not implemented: ${U}`)}}}bindTexture(tt,et,q){this.glContext.bindTextureToUniform(tt.texture,q,et)}getAttribLocations(tt){return{position:this.getAttribLocation(tt,"position"),textureCoord:this.getAttribLocation(tt,"textureCoord")}}getUniformLocations(tt,et,q){const G=[];if(et)for(const O of et)G.push({name:O,type:"sampler2D",location:this.getUniformLocation(tt,O)});if(q)for(const O of q)G.push(Object.assign(Object.assign({},O),{location:this.getUniformLocation(tt,O.name)}));return G}getUniformLocation(tt,et){const q=this.glContext.gl.getUniformLocation(tt,et);if(q===null)throw new Error(`Uniform ${et} not found.`);return q}getAttribLocation(tt,et){return this.glContext.gl.getAttribLocation(tt,et)}}},2171:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.WebGLSessionHandler=void 0;const X=W(1315),K=W(5881),Q=W(7860),Y=W(4110),tt=W(2757),et=W(7618),q=W(5243);F.WebGLSessionHandler=class{constructor(G,O){this.backend=G,this.context=O,this.layoutStrategy=new et.PreferLogicalStrategy(G.glContext.maxTextureSize),this.programManager=new tt.ProgramManager(this.context.profiler,G.glContext,this.layoutStrategy),this.textureManager=new q.TextureManager(G.glContext,this.layoutStrategy,this.context.profiler,{reuseTextures:G.textureCacheMode==="full"}),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map,this.pack=G.pack,this.pack2unpackMap=new Map,this.unpack2packMap=new Map}createInferenceHandler(){return new Q.WebGLInferenceHandler(this)}onGraphInitialized(G){const O=G.getValues().filter(b=>b.from===-1&&b.tensor).map(b=>b.tensor.dataId);this.initializers=new Set(O)}isInitializer(G){return!!this.initializers&&this.initializers.has(G)}addInitializer(G){this.initializers.add(G)}getTextureData(G,O){return O?this.packedTextureDataCache.get(G):this.unpackedTextureDataCache.get(G)}setTextureData(G,O,b=!1){X.Logger.verbose("WebGLSessionHandler","Storing Texture data in cache"),b?this.packedTextureDataCache.set(G,O):this.unpackedTextureDataCache.set(G,O)}dispose(){this.programManager.dispose(),this.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(G=>this.textureManager.releaseTexture(G,!0)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(G=>this.textureManager.releaseTexture(G,!0)),this.unpackedTextureDataCache=new Map}resolve(G,O,b){const j=(0,K.resolveOperator)(G,O,Y.WEBGL_OP_RESOLVE_RULES);return{impl:j.opImpl,context:j.opInit?j.opInit(G,b):G}}}},9622:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.Uint8DataEncoder=F.RGBAFloatDataEncoder=F.RedFloat32DataEncoder=void 0;const X=W(1315);F.RedFloat32DataEncoder=class{constructor(K,Q=1){if(Q===1)this.internalFormat=K.R32F,this.format=K.RED,this.textureType=K.FLOAT,this.channelSize=Q;else{if(Q!==4)throw new Error(`Invalid number of channels: ${Q}`);this.internalFormat=K.RGBA32F,this.format=K.RGBA,this.textureType=K.FLOAT,this.channelSize=Q}}encode(K,Q){let Y,tt;return K.constructor!==Float32Array&&(X.Logger.warning("Encoder","data was not of type Float32; creating new Float32Array"),tt=new Float32Array(K)),Q*this.channelSize>K.length?(X.Logger.warning("Encoder","Source data too small. Allocating larger array"),tt=K,Y=this.allocate(Q*this.channelSize),tt.forEach((et,q)=>Y[q]=et)):(tt=K,Y=tt),Y}allocate(K){return new Float32Array(4*K)}decode(K,Q){return this.channelSize===1?K.filter((Y,tt)=>tt%4==0).subarray(0,Q):K.subarray(0,Q)}},F.RGBAFloatDataEncoder=class{constructor(K,Q=1,Y){if(Q!==1&&Q!==4)throw new Error(`Invalid number of channels: ${Q}`);this.internalFormat=K.RGBA,this.format=K.RGBA,this.channelSize=Q,this.textureType=Y||K.FLOAT}encode(K,Q){let Y=K;return this.channelSize===1&&(X.Logger.verbose("Encoder","Exploding into a larger array"),Y=this.allocate(Q),K.forEach((tt,et)=>Y[4*et]=tt)),Y}allocate(K){return new Float32Array(4*K)}decode(K,Q){return this.channelSize===1?K.filter((Y,tt)=>tt%4==0).subarray(0,Q):K.subarray(0,Q)}},F.Uint8DataEncoder=class{constructor(K,Q=1){if(this.channelSize=4,Q===1)this.internalFormat=K.ALPHA,this.format=K.ALPHA,this.textureType=K.UNSIGNED_BYTE,this.channelSize=Q;else{if(Q!==4)throw new Error(`Invalid number of channels: ${Q}`);this.internalFormat=K.RGBA,this.format=K.RGBA,this.textureType=K.UNSIGNED_BYTE,this.channelSize=Q}}encode(K,Q){return new Uint8Array(K.buffer,K.byteOffset,K.byteLength)}allocate(K){return new Uint8Array(K*this.channelSize)}decode(K,Q){if(K instanceof Uint8Array)return K.subarray(0,Q);throw new Error(`Invalid array type: ${K.constructor}`)}}},7618:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.getBatchDim=F.sizeToSquarishShape=F.getRowsCols=F.sizeFromShape=F.isInt=F.parseAxisParam=F.squeezeShape=F.PreferLogicalStrategy=F.AlwaysKeepOriginalSizeStrategy=void 0;const X=W(1315),K=W(7273);function Q(G,O){const b=[],j=[],U=O!=null&&Array.isArray(O)&&O.length===0,J=O==null||U?null:Y(O,G).sort();let nt=0;for(let rt=0;rt<G.length;++rt){if(J!=null){if(J[nt]===rt&&G[rt]!==1)throw new Error(`Can't squeeze axis ${rt} since its dim '${G[rt]}' is not 1`);(J[nt]==null||J[nt]>rt)&&G[rt]===1&&(b.push(G[rt]),j.push(rt)),J[nt]<=rt&&nt++}G[rt]!==1&&(b.push(G[rt]),j.push(rt))}return{newShape:b,keptDims:j}}function Y(G,O){const b=O.length;return G=G==null?O.map((j,U)=>U):[].concat(G),(0,K.assert)(G.every(j=>j>=-b&&j<b),()=>`All values in axis param must be in range [-${b}, ${b}) but got axis ${G}`),(0,K.assert)(G.every(tt),()=>`All values in axis param must be integers but got axis ${G}`),G.map(j=>j<0?b+j:j)}function tt(G){return G%1==0}function et(G){if(G.length===0)return 1;let O=G[0];for(let b=1;b<G.length;b++)O*=G[b];return O}function q(G){const O=Math.ceil(Math.sqrt(G));return[O,Math.ceil(G/O)]}F.AlwaysKeepOriginalSizeStrategy=class{constructor(G){this.maxTextureSize=G}computeTextureWH(G,O){if(G.length===0)return[1,1];const b=this.maxTextureSize;if(O&&O.breakAxis!==void 0){const J=O.breakAxis>=G.length?1:G.slice(O.breakAxis).reduce((rt,ot)=>rt*ot),nt=O.breakAxis<=0?1:G.slice(0,O.breakAxis).reduce((rt,ot)=>rt*ot);if(!(J>b||nt>b))return[J,nt];X.Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${G}, breakAxis:${O.breakAxis}`)}const j=G.reduce((J,nt)=>J*nt);let U=Math.floor(Math.sqrt(j));for(;U<b&&U<j&&j%U!=0;U++);if(U>=b||j%U!=0)throw new Error(`The given dimensions are outside this GPU's boundaries: ${G}`);return[U,j/U]}},F.PreferLogicalStrategy=class{constructor(G){this.maxTextureSize=G}computeTextureWH(G,O){const b=this.computeTexture(G,O);return O&&O.isPacked&&(b[0]/=2,b[1]/=2),O&&O.reverseWH?[b[1],b[0]]:b}computeTexture(G,O){const b=O&&O.isPacked;if(G.length===0)return b?[2,2]:[1,1];let j=this.maxTextureSize;if(O&&O.breakAxis!==void 0){const nt=O.breakAxis>=G.length?1:G.slice(O.breakAxis).reduce((ot,at)=>ot*at),rt=O.breakAxis<=0?1:G.slice(0,O.breakAxis).reduce((ot,at)=>ot*at);if(!(nt>j||rt>j))return[nt,rt];X.Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${G}, breakAxis:${O.breakAxis}`)}let U=G.slice(0);b&&(j*=2,U=U.map((nt,rt)=>rt>=U.length-2?U[rt]%2==0?U[rt]:U[rt]+1:U[rt]),U.length===1&&(U=[2,U[0]])),U.length!==2&&(U=Q(U).newShape);const J=et(U);return U.length<=1&&J<=j?[1,J]:U.length===2&&U[0]<=j&&U[1]<=j?U:U.length===3&&U[0]*U[1]<=j&&U[2]<=j?[U[0]*U[1],U[2]]:U.length===3&&U[0]<=j&&U[1]*U[2]<=j?[U[0],U[1]*U[2]]:U.length===4&&U[0]*U[1]*U[2]<=j&&U[3]<=j?[U[0]*U[1]*U[2],U[3]]:U.length===4&&U[0]<=j&&U[1]*U[2]*U[3]<=j?[U[0],U[1]*U[2]*U[3]]:b?q(J/4).map(nt=>2*nt):q(J)}},F.squeezeShape=Q,F.parseAxisParam=Y,F.isInt=tt,F.sizeFromShape=et,F.getRowsCols=function(G){if(G.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[G.length>1?G[G.length-2]:1,G[G.length-1]]},F.sizeToSquarishShape=q,F.getBatchDim=function(G,O=2){return et(G.slice(0,G.length-O))}},3314:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.createTextureLayoutFromShape=F.calculateTextureWidthAndHeight=F.createTextureLayoutFromTextureType=void 0;const X=W(7273),K=W(5639);F.createTextureLayoutFromTextureType=(Q,Y,tt)=>{const et=tt===K.TextureType.unpacked||tt===K.TextureType.unpackedReversed?1:4,q=tt===K.TextureType.packed,G=tt===K.TextureType.unpackedReversed||tt===K.TextureType.packed,O=tt===K.TextureType.packedLastDimension?Y.length-1:void 0,b=tt===K.TextureType.packedLastDimension?Y.map((j,U)=>U===Y.length-1?4*j:j):void 0;return(0,F.createTextureLayoutFromShape)(Q,Y,et,b,{isPacked:q,reverseWH:G,breakAxis:O})},F.calculateTextureWidthAndHeight=(Q,Y,tt)=>{const et=(0,F.createTextureLayoutFromTextureType)(Q,Y,tt);return[et.width,et.height]},F.createTextureLayoutFromShape=(Q,Y,tt=1,et,q)=>{const G=!(!q||!q.isPacked),[O,b]=Q.computeTextureWH(G&&et||Y,q),j=Y.length;let U=Y.slice(0);if(j===0&&(U=[1]),tt===1)et=Y;else if(G){if(tt!==4)throw new Error("a packed texture must be 4-channel");et=Y,j>0&&(U[j-1]=Math.ceil(U[j-1]/2)),j>1&&(U[j-2]=Math.ceil(U[j-2]/2))}else if(!et)throw new Error("Unpacked shape is needed when using channels > 1");return{width:O,height:b,channels:tt,isPacked:G,shape:U,strides:X.ShapeUtil.computeStrides(U),unpackedShape:et,reversedWH:q&&q.reverseWH}}},5243:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.TextureManager=void 0;const X=W(1315);F.TextureManager=class{constructor(K,Q,Y,tt){this.glContext=K,this.layoutStrategy=Q,this.profiler=Y,this.config=tt,this.pendingRead=new Map,tt.reuseTextures&&(this.inUseTextures=new Map,this.idleTextures=new Map,this.textureLookup=new Map)}createTextureFromLayout(K,Q,Y,tt){const et=this.toEncoderType(K),q=this.glContext.getEncoder(et,Q.channels||1,tt);if(Q.isPacked&&tt===1)throw new Error("not implemented");const G=Q.width,O=Q.height;let b,j;if(this.config.reuseTextures){b=`${G}x${O}_${q.format}_${q.internalFormat}_${q.textureType}`,j=this.inUseTextures.get(b),j||(j=[],this.inUseTextures.set(b,j));const J=this.idleTextures.get(b);if(J&&J.length>0){const nt=J.pop();return j.push(nt),tt===1&&this.glContext.updateTexture(nt,G,O,q,this.toTextureData(K,Y)),nt}}X.Logger.verbose("TextureManager",`Creating new texture of size ${Q.width}x${Q.height}`);const U=this.glContext.allocateTexture(G,O,q,this.toTextureData(K,Y));return this.config.reuseTextures&&(j.push(U),this.textureLookup.set(U,b)),U}readTexture(K,Q,Y){return Y||(Y=1),this.profiler.event("backend","TextureManager.readTexture",()=>{const tt=K.shape.reduce((q,G)=>q*G)*Y,et=this.glContext.readTexture(K.texture,K.width,K.height,tt,this.toEncoderType(Q),Y);return this.toTensorData(Q,et)})}async readTextureAsync(K,Q,Y){const tt=K.tensor.dataId;if(Y||(Y=1),this.pendingRead.has(tt)){const et=this.pendingRead.get(tt);return new Promise(q=>et==null?void 0:et.push(q))}return this.profiler.event("backend","TextureManager.readTextureAsync",async()=>{this.pendingRead.set(tt,[]);const et=K.shape.reduce((b,j)=>b*j)*Y;await this.glContext.createAndWaitForFence();const q=this.glContext.readTexture(K.texture,K.width,K.height,et,this.toEncoderType(Q),Y),G=this.toTensorData(Q,q),O=this.pendingRead.get(tt);return this.pendingRead.delete(tt),O==null||O.forEach(b=>b(G)),G})}readUint8TextureAsFloat(K){return this.profiler.event("backend","TextureManager.readUint8TextureAsFloat",()=>{const Q=K.shape.reduce((tt,et)=>tt*et),Y=this.glContext.readTexture(K.texture,K.width,K.height,4*Q,"byte",4);return new Float32Array(Y.buffer,Y.byteOffset,Q)})}releaseTexture(K,Q){let Y;if(this.config.reuseTextures&&(Y=this.textureLookup.get(K.texture),Y)){Q&&this.textureLookup.delete(Y);const tt=this.inUseTextures.get(Y);if(tt){const et=tt.indexOf(K.texture);if(et!==-1){tt.splice(et,1);let q=this.idleTextures.get(Y);q||(q=[],this.idleTextures.set(Y,q)),q.push(K.texture)}}}Y&&!Q||(X.Logger.verbose("TextureManager",`Deleting texture of size ${K.width}x${K.height}`),this.glContext.deleteTexture(K.texture))}toTensorData(K,Q){switch(K){case"int16":return Q instanceof Int16Array?Q:Int16Array.from(Q);case"int32":return Q instanceof Int32Array?Q:Int32Array.from(Q);case"int8":return Q instanceof Int8Array?Q:Int8Array.from(Q);case"uint16":return Q instanceof Uint16Array?Q:Uint16Array.from(Q);case"uint32":return Q instanceof Uint32Array?Q:Uint32Array.from(Q);case"uint8":case"bool":return Q instanceof Uint8Array?Q:Uint8Array.from(Q);case"float32":return Q instanceof Float32Array?Q:Float32Array.from(Q);case"float64":return Q instanceof Float64Array?Q:Float64Array.from(Q);default:throw new Error(`TensorData type ${K} is not supported`)}}toTextureData(K,Q){if(Q)return Q instanceof Float32Array?Q:new Float32Array(Q)}toEncoderType(K){return"float"}clearActiveTextures(){this.glContext.clearActiveTextures()}}},5639:(it,F)=>{var W;Object.defineProperty(F,"__esModule",{value:!0}),F.TextureType=void 0,(W=F.TextureType||(F.TextureType={}))[W.unpacked=0]="unpacked",W[W.unpackedReversed=1]="unpackedReversed",W[W.packed=2]="packed",W[W.downloadUint8AsFloat=3]="downloadUint8AsFloat",W[W.packedLastDimension=4]="packedLastDimension"},432:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.getGlChannels=F.getCoordsDataType=F.getSqueezedParams=F.squeezeInputShape=F.generateShaderFuncNameFromInputSamplerNameAtOutCoords=F.generateShaderFuncNameFromInputSamplerName=F.repeatedTry=F.getPackedShape=void 0;const X=W(7273);F.getPackedShape=function(K){const Q=K.length;return K.slice(0,Q-1).concat(K[Q-1]/4)},F.repeatedTry=async function(K,Q=tt=>0,Y){return new Promise((tt,et)=>{let q=0;const G=()=>{if(K())return void tt();q++;const O=Q(q);Y!=null&&q>=Y?et():setTimeout(G,O)};G()})},F.generateShaderFuncNameFromInputSamplerName=function(K){return(0,X.assert)(K!==void 0&&K.length!==0,()=>"empty string found for sampler name"),"get"+K.charAt(0).toUpperCase()+K.slice(1)},F.generateShaderFuncNameFromInputSamplerNameAtOutCoords=function(K){return(0,X.assert)(K!==void 0&&K.length!==0,()=>"empty string found for sampler name"),"get"+K.charAt(0).toUpperCase()+K.slice(1)+"AtOutCoords"},F.squeezeInputShape=function(K,Q){let Y=JSON.parse(JSON.stringify(K));return Y=Q,Y},F.getSqueezedParams=function(K,Q){return Q.map(Y=>K[Y]).join(", ")},F.getCoordsDataType=function(K){if(K<=1)return"int";if(K===2)return"ivec2";if(K===3)return"ivec3";if(K===4)return"ivec4";if(K===5)return"ivec5";if(K===6)return"ivec6";throw Error(`GPU for rank ${K} is not yet supported`)},F.getGlChannels=function(K=6){return["x","y","z","w","u","v"].slice(0,K)}},3389:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.createNewWebGLContext=F.createWebGLContext=void 0;const X=W(1315),K=W(3524),Q={};function Y(tt){const et=function(){if(typeof document>"u"){if(typeof OffscreenCanvas>"u")throw new TypeError("failed to create canvas: OffscreenCanvas is not supported");return new OffscreenCanvas(1,1)}const O=document.createElement("canvas");return O.width=1,O.height=1,O}();let q;const G={alpha:!1,depth:!1,antialias:!1,stencil:!1,preserveDrawingBuffer:!1,premultipliedAlpha:!1,failIfMajorPerformanceCaveat:!1};if((!tt||tt==="webgl2")&&(q=et.getContext("webgl2",G),q))try{return new K.WebGLContext(q,2)}catch(O){X.Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl2'. Error: ${O}`)}if((!tt||tt==="webgl")&&(q=et.getContext("webgl",G)||et.getContext("experimental-webgl",G),q))try{return new K.WebGLContext(q,1)}catch(O){X.Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${O}`)}throw new Error("WebGL is not supported")}F.createWebGLContext=function tt(et){let q;et&&et!=="webgl2"||!("webgl2"in Q)?et&&et!=="webgl"||!("webgl"in Q)||(q=Q.webgl):q=Q.webgl2,q=q||Y(et),et=et||q.version===1?"webgl":"webgl2";const G=q.gl;return Q[et]=q,G.isContextLost()?(delete Q[et],tt(et)):(G.disable(G.DEPTH_TEST),G.disable(G.STENCIL_TEST),G.disable(G.BLEND),G.disable(G.DITHER),G.disable(G.POLYGON_OFFSET_FILL),G.disable(G.SAMPLE_COVERAGE),G.enable(G.SCISSOR_TEST),G.enable(G.CULL_FACE),G.cullFace(G.BACK),q)},F.createNewWebGLContext=Y},3524:function(it,F,W){var X=this&&this.__createBinding||(Object.create?function(G,O,b,j){j===void 0&&(j=b);var U=Object.getOwnPropertyDescriptor(O,b);U&&!("get"in U?!O.__esModule:U.writable||U.configurable)||(U={enumerable:!0,get:function(){return O[b]}}),Object.defineProperty(G,j,U)}:function(G,O,b,j){j===void 0&&(j=b),G[j]=O[b]}),K=this&&this.__setModuleDefault||(Object.create?function(G,O){Object.defineProperty(G,"default",{enumerable:!0,value:O})}:function(G,O){G.default=O}),Q=this&&this.__importStar||function(G){if(G&&G.__esModule)return G;var O={};if(G!=null)for(var b in G)b!=="default"&&Object.prototype.hasOwnProperty.call(G,b)&&X(O,G,b);return K(O,G),O};Object.defineProperty(F,"__esModule",{value:!0}),F.WebGLContext=F.linearSearchLastTrue=void 0;const Y=W(8453),tt=Q(W(9622)),et=W(432);function q(G){let O=0;for(;O<G.length&&G[O]();++O);return O-1}F.linearSearchLastTrue=q,F.WebGLContext=class{constructor(G,O){this.frameBufferBound=!1,this.itemsToPoll=[],this.gl=G,this.version=O,this.getExtensions(),this.vertexbuffer=this.createVertexbuffer(),this.framebuffer=this.createFramebuffer(),this.queryVitalParameters()}allocateTexture(G,O,b,j){const U=this.gl,J=U.createTexture();U.bindTexture(U.TEXTURE_2D,J),U.texParameteri(U.TEXTURE_2D,U.TEXTURE_MIN_FILTER,U.NEAREST),U.texParameteri(U.TEXTURE_2D,U.TEXTURE_MAG_FILTER,U.NEAREST),U.texParameteri(U.TEXTURE_2D,U.TEXTURE_WRAP_S,U.CLAMP_TO_EDGE),U.texParameteri(U.TEXTURE_2D,U.TEXTURE_WRAP_T,U.CLAMP_TO_EDGE);const nt=j?b.encode(j,G*O):null;return U.texImage2D(U.TEXTURE_2D,0,b.internalFormat,G,O,0,b.format,b.textureType,nt),this.checkError(),J}updateTexture(G,O,b,j,U){const J=this.gl;J.bindTexture(J.TEXTURE_2D,G);const nt=j.encode(U,O*b);J.texSubImage2D(J.TEXTURE_2D,0,0,0,O,b,j.format,j.textureType,nt),this.checkError()}attachFramebuffer(G,O,b){const j=this.gl;j.bindTexture(j.TEXTURE_2D,G),j.bindFramebuffer(j.FRAMEBUFFER,this.framebuffer),j.framebufferTexture2D(j.FRAMEBUFFER,j.COLOR_ATTACHMENT0,j.TEXTURE_2D,G,0),this.checkError(),j.viewport(0,0,O,b),j.scissor(0,0,O,b)}readTexture(G,O,b,j,U,J){const nt=this.gl;J||(J=1),this.frameBufferBound||this.attachFramebuffer(G,O,b);const rt=this.getEncoder(U,J),ot=rt.allocate(O*b);return nt.bindTexture(nt.TEXTURE_2D,G),nt.framebufferTexture2D(nt.FRAMEBUFFER,nt.COLOR_ATTACHMENT0,nt.TEXTURE_2D,G,0),nt.readPixels(0,0,O,b,nt.RGBA,rt.textureType,ot),this.checkError(),rt.decode(ot,j)}isFramebufferReady(){return!0}getActiveTexture(){const G=this.gl;return"TEXTURE"+(G.getParameter(this.gl.ACTIVE_TEXTURE)-G.TEXTURE0)}getTextureBinding(){return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D)}getFramebufferBinding(){return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING)}setVertexAttributes(G,O){const b=this.gl;b.vertexAttribPointer(G,3,b.FLOAT,!1,20,0),b.enableVertexAttribArray(G),O!==-1&&(b.vertexAttribPointer(O,2,b.FLOAT,!1,20,12),b.enableVertexAttribArray(O)),this.checkError()}createProgram(G,O){const b=this.gl,j=b.createProgram();return b.attachShader(j,G),b.attachShader(j,O),b.linkProgram(j),j}compileShader(G,O){const b=this.gl,j=b.createShader(O);if(!j)throw new Error(`createShader() returned null with type ${O}`);if(b.shaderSource(j,G),b.compileShader(j),b.getShaderParameter(j,b.COMPILE_STATUS)===!1)throw new Error(`Failed to compile shader: ${b.getShaderInfoLog(j)}
Shader source:
${G}`);return j}deleteShader(G){this.gl.deleteShader(G)}bindTextureToUniform(G,O,b){const j=this.gl;j.activeTexture(j.TEXTURE0+O),this.checkError(),j.bindTexture(j.TEXTURE_2D,G),this.checkError(),j.uniform1i(b,O),this.checkError()}draw(){this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.checkError()}checkError(){if(Y.env.debug){const G=this.gl,O=G.getError();let b="";switch(O){case G.NO_ERROR:return;case G.INVALID_ENUM:b="INVALID_ENUM";break;case G.INVALID_VALUE:b="INVALID_VALUE";break;case G.INVALID_OPERATION:b="INVALID_OPERATION";break;case G.INVALID_FRAMEBUFFER_OPERATION:b="INVALID_FRAMEBUFFER_OPERATION";break;case G.OUT_OF_MEMORY:b="OUT_OF_MEMORY";break;case G.CONTEXT_LOST_WEBGL:b="CONTEXT_LOST_WEBGL";break;default:b=`Unknown WebGL Error: ${O.toString(16)}`}throw new Error(b)}}deleteTexture(G){this.gl.deleteTexture(G)}deleteProgram(G){this.gl.deleteProgram(G)}getEncoder(G,O,b=0){if(this.version===2)return new tt.RedFloat32DataEncoder(this.gl,O);switch(G){case"float":return b===1||this.isRenderFloat32Supported?new tt.RGBAFloatDataEncoder(this.gl,O):new tt.RGBAFloatDataEncoder(this.gl,O,this.textureHalfFloatExtension.HALF_FLOAT_OES);case"int":throw new Error("not implemented");case"byte":return new tt.Uint8DataEncoder(this.gl,O);default:throw new Error(`Invalid dataType: ${G}`)}}clearActiveTextures(){const G=this.gl;for(let O=0;O<this.maxTextureImageUnits;++O)G.activeTexture(G.TEXTURE0+O),G.bindTexture(G.TEXTURE_2D,null)}dispose(){if(this.disposed)return;const G=this.gl;G.bindFramebuffer(G.FRAMEBUFFER,null),G.deleteFramebuffer(this.framebuffer),G.bindBuffer(G.ARRAY_BUFFER,null),G.deleteBuffer(this.vertexbuffer),G.bindBuffer(G.ELEMENT_ARRAY_BUFFER,null),G.finish(),this.disposed=!0}createDefaultGeometry(){return new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0])}createVertexbuffer(){const G=this.gl,O=G.createBuffer();if(!O)throw new Error("createBuffer() returned null");const b=this.createDefaultGeometry();return G.bindBuffer(G.ARRAY_BUFFER,O),G.bufferData(G.ARRAY_BUFFER,b,G.STATIC_DRAW),this.checkError(),O}createFramebuffer(){const G=this.gl.createFramebuffer();if(!G)throw new Error("createFramebuffer returned null");return G}queryVitalParameters(){const G=this.gl;if(this.isFloatTextureAttachableToFrameBuffer=this.checkFloatTextureAttachableToFrameBuffer(),this.isRenderFloat32Supported=this.checkRenderFloat32(),this.isFloat32DownloadSupported=this.checkFloat32Download(),this.version===1&&!this.textureHalfFloatExtension&&!this.isRenderFloat32Supported)throw new Error("both float32 and float16 TextureType are not supported");this.isBlendSupported=!this.isRenderFloat32Supported||this.checkFloat32Blend(),this.maxTextureSize=G.getParameter(G.MAX_TEXTURE_SIZE),this.maxTextureImageUnits=G.getParameter(G.MAX_TEXTURE_IMAGE_UNITS),this.version}getExtensions(){this.version===2?(this.colorBufferFloatExtension=this.gl.getExtension("EXT_color_buffer_float"),this.disjointTimerQueryWebgl2Extension=this.gl.getExtension("EXT_disjoint_timer_query_webgl2")):(this.textureFloatExtension=this.gl.getExtension("OES_texture_float"),this.textureHalfFloatExtension=this.gl.getExtension("OES_texture_half_float"))}checkFloatTextureAttachableToFrameBuffer(){const G=this.gl,O=G.createTexture();G.bindTexture(G.TEXTURE_2D,O);const b=this.version===2?G.RGBA32F:G.RGBA;G.texImage2D(G.TEXTURE_2D,0,b,1,1,0,G.RGBA,G.FLOAT,null);const j=G.createFramebuffer();G.bindFramebuffer(G.FRAMEBUFFER,j),G.framebufferTexture2D(G.FRAMEBUFFER,G.COLOR_ATTACHMENT0,G.TEXTURE_2D,O,0);const U=G.checkFramebufferStatus(G.FRAMEBUFFER)===G.FRAMEBUFFER_COMPLETE;return G.bindTexture(G.TEXTURE_2D,null),G.bindFramebuffer(G.FRAMEBUFFER,null),G.deleteTexture(O),G.deleteFramebuffer(j),U}checkRenderFloat32(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension)return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Download(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension||!this.gl.getExtension("WEBGL_color_buffer_float"))return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Blend(){const G=this.gl;let O,b,j,U,J;try{O=G.createTexture(),b=G.createFramebuffer(),G.bindTexture(G.TEXTURE_2D,O);const nt=this.version===2?G.RGBA32F:G.RGBA;return G.texImage2D(G.TEXTURE_2D,0,nt,1,1,0,G.RGBA,G.FLOAT,null),G.bindFramebuffer(G.FRAMEBUFFER,b),G.framebufferTexture2D(G.FRAMEBUFFER,G.COLOR_ATTACHMENT0,G.TEXTURE_2D,O,0),G.enable(G.BLEND),j=G.createShader(G.VERTEX_SHADER),!!j&&(G.shaderSource(j,"void main(){}"),G.compileShader(j),U=G.createShader(G.FRAGMENT_SHADER),!!U&&(G.shaderSource(U,"precision highp float;void main(){gl_FragColor=vec4(0.5);}"),G.compileShader(U),J=G.createProgram(),!!J&&(G.attachShader(J,j),G.attachShader(J,U),G.linkProgram(J),G.useProgram(J),G.drawArrays(G.POINTS,0,1),G.getError()===G.NO_ERROR)))}finally{G.disable(G.BLEND),J&&G.deleteProgram(J),j&&G.deleteShader(j),U&&G.deleteShader(U),b&&(G.bindFramebuffer(G.FRAMEBUFFER,null),G.deleteFramebuffer(b)),O&&(G.bindTexture(G.TEXTURE_2D,null),G.deleteTexture(O))}}beginTimer(){if(this.version===2&&this.disjointTimerQueryWebgl2Extension){const G=this.gl,O=this.disjointTimerQueryWebgl2Extension,b=G.createQuery();return G.beginQuery(O.TIME_ELAPSED_EXT,b),b}throw new Error("WebGL1 profiling currently not supported.")}endTimer(){if(this.version!==2||!this.disjointTimerQueryWebgl2Extension)throw new Error("WebGL1 profiling currently not supported");{const G=this.gl,O=this.disjointTimerQueryWebgl2Extension;G.endQuery(O.TIME_ELAPSED_EXT)}}isTimerResultAvailable(G){let O=!1,b=!1;if(this.version!==2||!this.disjointTimerQueryWebgl2Extension)throw new Error("WebGL1 profiling currently not supported");{const j=this.gl,U=this.disjointTimerQueryWebgl2Extension;O=j.getQueryParameter(G,j.QUERY_RESULT_AVAILABLE),b=j.getParameter(U.GPU_DISJOINT_EXT)}return O&&!b}getTimerResult(G){let O=0;if(this.version!==2)throw new Error("WebGL1 profiling currently not supported");{const b=this.gl;O=b.getQueryParameter(G,b.QUERY_RESULT),b.deleteQuery(G)}return O/1e6}async waitForQueryAndGetTime(G){return await(0,et.repeatedTry)(()=>this.isTimerResultAvailable(G)),this.getTimerResult(G)}async createAndWaitForFence(){const G=this.createFence(this.gl);return this.pollFence(G)}createFence(G){let O;const b=G,j=b.fenceSync(b.SYNC_GPU_COMMANDS_COMPLETE,0);return G.flush(),O=j===null?()=>!0:()=>{const U=b.clientWaitSync(j,0,0);return U===b.ALREADY_SIGNALED||U===b.CONDITION_SATISFIED},{query:j,isFencePassed:O}}async pollFence(G){return new Promise(O=>{this.addItemToPoll(()=>G.isFencePassed(),()=>O())})}pollItems(){const G=q(this.itemsToPoll.map(O=>O.isDoneFn));for(let O=0;O<=G;++O){const{resolveFn:b}=this.itemsToPoll[O];b()}this.itemsToPoll=this.itemsToPoll.slice(G+1)}async addItemToPoll(G,O){this.itemsToPoll.push({isDoneFn:G,resolveFn:O}),this.itemsToPoll.length>1||await(0,et.repeatedTry)(()=>(this.pollItems(),this.itemsToPoll.length===0))}}},6496:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.ExecutionPlan=void 0;const X=W(1315);class K{constructor(Y,tt){this.op=Y,this.node=tt}}F.ExecutionPlan=class{constructor(Q,Y,tt){this.graph=Q,this.profiler=tt,this.initialize(Y)}initialize(Q){this.profiler.event("session","ExecutionPlan.initialize",()=>{const Y=this.graph.getNodes();if(Y.length!==Q.length)throw new Error("The size of nodes and OPs do not match.");this._ops=Q.map((tt,et)=>new K(tt,Y[et])),this.reset(),this._starter=[],this._ops.forEach((tt,et)=>{let q=!0;for(const G of tt.node.inputs)if(!this._values[G]&&this.graph.getInputIndices().indexOf(G)===-1){q=!1;break}q&&this._starter.push(et)})})}reset(){this._values=this.graph.getValues().map(Q=>Q.tensor)}async execute(Q,Y){return this.profiler.event("session","ExecutionPlan.execute",async()=>{this.reset();const tt=Q.createInferenceHandler(),et=this.graph.getInputIndices();if(Y.length!==et.length)throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${Y.length} expected: ${et.length}`);Y.forEach((U,J)=>{const nt=et[J];this._values[nt]=U});const q=this._starter.slice(0),G=this.graph.getValues(),O=this.graph.getNodes();let b=0;for(;b<q.length;){const U=q[b++],J=this._ops[U],nt=J.node.inputs.map(ut=>this._values[ut]);if(nt.indexOf(void 0)!==-1)throw new Error(`unresolved input detected: op: ${J.node}`);const rt=nt;X.Logger.verbose("ExecPlan",`Runing op:${J.node.name} (${rt.map((ut,st)=>`'${J.node.inputs[st]}': ${ut.type}[${ut.dims.join(",")}]`).join(", ")})`);const ot=await this.profiler.event("node",J.node.name,async()=>J.op.impl(tt,rt,J.op.context));if(ot.length!==J.node.outputs.length)throw new Error("the size of output does not match model definition.");ot.forEach((ut,st)=>{const ct=J.node.outputs[st];if(this._values[ct])throw new Error(`output [${ct}] already has value: op:${J.node.name}`);this._values[ct]=ut});const at=new Set;ot.forEach((ut,st)=>{const ct=J.node.outputs[st];for(const dt of G[ct].to){const pt=O[dt];let lt=!0;for(const ft of pt.inputs)if(!this._values[ft]){lt=!1;break}lt&&at.add(dt)}}),q.push(...at)}const j=[];for(let U=0;U<this.graph.getOutputIndices().length;U++){const J=this.graph.getOutputIndices()[U],nt=this._values[J];if(nt===void 0)throw new Error(`required output [${J}] does not have value`);J===0?await nt.getData():nt.data,j.push(nt)}return X.Logger.verbose("ExecPlan","disposing of inferenceHandler"),tt.dispose(),j})}}},4662:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.Graph=void 0;const X=W(1446),K=W(6874),Q=W(1287),Y=W(9240),tt=W(7273);var et=Q.onnxruntime.experimental.fbs;F.Graph={from:(b,j)=>new O(b,j)};class q{constructor(j){this._from=void 0,this._to=[],this.tensor=void 0,this.type=void 0,j&&(this.type=tt.ProtoUtil.tensorValueTypeFromProto(j.type.tensorType))}get from(){return this._from}get to(){return this._to}}class G{constructor(j,U){j instanceof X.onnx.NodeProto?(this.name=j.name,this.opType=j.opType,this.attributes=new K.Attribute(j.attribute)):j instanceof et.Node&&(this.name=U??j.name(),this.opType=j.opType(),this.attributes=new K.Attribute(tt.ProtoUtil.tensorAttributesFromORTFormat(j))),this.inputs=[],this.outputs=[],this.executeNode=!0}}class O{constructor(j,U){if(!j)throw new TypeError("graph is empty");this.buildGraph(j),this.transformGraph(U),this.checkIsAcyclic()}getInputIndices(){return this._allInputIndices}getInputNames(){return this._allInputNames}getOutputIndices(){return this._allOutputIndices}getOutputNames(){return this._allOutputNames}getValues(){return this._allData}getNodes(){return this._nodes}buildGraph(j){if(j instanceof X.onnx.GraphProto)this.buildGraphFromOnnxFormat(j);else{if(!(j instanceof et.Graph))throw new TypeError("Graph type is not supported.");this.buildGraphFromOrtFormat(j)}}buildGraphFromOnnxFormat(j){const U=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];const J=new Map;if(!j.input)throw new Error("missing information in graph: input");const nt=[];for(const rt of j.input){if(U.has(rt.name))throw new Error(`duplicated input name: ${rt.name}`);const ot=this._allData.push(new q(rt))-1;U.set(rt.name,ot),nt.push(rt.name)}if(!j.initializer)throw new Error("missing information in graph: initializer");for(const rt of j.initializer){let ot=U.get(rt.name);if(ot===void 0){const at=new q;at.type={shape:{dims:tt.ProtoUtil.tensorDimsFromProto(rt.dims)},tensorType:tt.ProtoUtil.tensorDataTypeFromProto(rt.dataType)},ot=this._allData.push(at)-1,U.set(rt.name,ot)}this._allData[ot]._from=-1,this._allData[ot].tensor=Y.Tensor.fromProto(rt)}for(let rt=0;rt<this._allData.length;rt++)this._allData[rt].tensor||(this._allInputIndices.push(rt),this._allInputNames.push(nt[rt]));if(!j.output)throw new Error("missing information in graph: output");for(const rt of j.output){if(U.has(rt.name))throw new Error(`duplicated output name: ${rt.name}`);const ot=this._allData.push(new q(rt))-1;U.set(rt.name,ot),this._allOutputIndices.push(ot),this._allOutputNames.push(rt.name)}if(!j.node)throw new Error("missing information in graph: node");for(const rt of j.node){if(!rt.name)for(let at=0;;at++){const ut=`unnamed_${rt.opType}_${at}`;if(!J.has(ut)){rt.name=ut;break}}if(J.has(rt.name))throw new Error(`duplicated node name: ${rt.name}`);const ot=this._nodes.push(new G(rt))-1;J.set(rt.name,ot)}for(let rt=0;rt<this._nodes.length;rt++){const ot=this._nodes[rt],at=j.node[rt];if(!at.output)throw new Error(`missing output for node: ${at.name}`);for(const ut of at.output){let st=U.get(ut);if(st===void 0&&(st=this._allData.push(new q)-1,U.set(ut,st)),ot.outputs.push(st),this._allData[st]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${st}`);if(this._allData[st]._from=rt,at.opType==="Constant"){if(!at.attribute||at.attribute.length!==1||!at.attribute[0].t)throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(!at.output||at.output.length!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");ot.outputs.pop(),ot.executeNode=!1,this._allData[st]._from=-1,this._allData[st].tensor=Y.Tensor.fromProto(at.attribute[0].t)}}}for(let rt=0;rt<this._nodes.length;rt++){const ot=this._nodes[rt],at=j.node[rt];if(!at.input)throw new Error(`missing input for node: ${at.name}`);for(const ut of at.input){const st=U.get(ut);if(st===void 0){if(ut===""&&at.input.length===3&&at.opType==="Resize")continue;throw new Error(`unrecognized input '${ut}' for node: ${at.name}`)}ot.inputs.push(st),this._allData[st]._to.push(rt)}}return!0}buildGraphFromOrtFormat(j){var U,J,nt;const rt=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];const ot=new Map,at=[];for(let ut=0;ut<j.inputsLength();ut++){const st=j.inputs(ut);if(rt.has(st))throw new Error(`duplicated input name: ${st}`);for(let ct=0;ct<j.nodeArgsLength();ct++)if(((U=j.nodeArgs(ct))===null||U===void 0?void 0:U.name())===st){const dt=new q;if(((nt=(J=j.nodeArgs(ct))===null||J===void 0?void 0:J.type())===null||nt===void 0?void 0:nt.valueType())!==et.TypeInfoValue.tensor_type)throw new Error("Unexpected value type for the nodeArg.");const pt=j.nodeArgs(ct).type().value(new et.TensorTypeAndShape),lt=tt.ProtoUtil.tensorDataTypeFromProto(pt.elemType()),ft=pt.shape(),gt=[];for(let wt=0;wt<ft.dimLength();wt++)gt.push(tt.LongUtil.longToNumber(ft.dim(wt).value().dimValue()));dt.type={shape:{dims:gt},tensorType:lt};const _t=this._allData.push(dt)-1;rt.set(st,_t),at.push(st)}}for(let ut=0;ut<j.initializersLength();ut++){const st=j.initializers(ut);let ct=rt.get(st.name());if(ct===void 0){const dt=new q,pt=tt.ProtoUtil.tensorDimsFromORTFormat(st),lt=tt.ProtoUtil.tensorDataTypeFromProto(st.dataType());dt.type={shape:{dims:pt},tensorType:lt},ct=this._allData.push(dt)-1,rt.set(st.name(),ct)}this._allData[ct]._from=-1,this._allData[ct].tensor=Y.Tensor.fromOrtTensor(st)}for(let ut=0;ut<this._allData.length;ut++)this._allData[ut].tensor||(this._allInputIndices.push(ut),this._allInputNames.push(at[ut]));for(let ut=0;ut<j.outputsLength();ut++){const st=j.outputs(ut);if(rt.has(st))throw new Error(`duplicated output name: ${st}`);const ct=this._allData.push(new q)-1;rt.set(st,ct),this._allOutputIndices.push(ct),this._allOutputNames.push(st)}if(!j.nodes)throw new Error("missing information in graph: node");for(let ut=0;ut<j.nodesLength();ut++){const st=j.nodes(ut);let ct=st.name();if(!ct)for(let pt=0;ct=`unnamed_${st.opType()}_${pt}`,ot.has(ct);pt++);if(ot.has(ct))throw new Error(`duplicated node name: ${ct}`);const dt=this._nodes.push(new G(st,ct))-1;ot.set(ct,dt)}for(let ut=0;ut<this._nodes.length;ut++){const st=this._nodes[ut],ct=j.nodes(ut);if(ct==null)throw new Error(`No node exists at index ${ut}`);if((ct==null?void 0:ct.outputsLength())===0)throw new Error(`missing output for node: ${ct.name}`);for(let dt=0;dt<(ct==null?void 0:ct.outputsLength());dt++){const pt=ct==null?void 0:ct.outputs(dt);let lt=rt.get(pt);if(lt===void 0&&(lt=this._allData.push(new q)-1,rt.set(pt,lt)),st.outputs.push(lt),this._allData[lt]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${lt}`);if(this._allData[lt]._from=ut,ct.opType()==="Constant"){if(ct.attributesLength()!==1||!ct.attributes(0).t())throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(ct.outputsLength()!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");st.outputs.pop(),st.executeNode=!1,this._allData[lt]._from=-1,this._allData[lt].tensor=Y.Tensor.fromOrtTensor(ct.attributes(0).t())}}}for(let ut=0;ut<this._nodes.length;ut++){const st=this._nodes[ut],ct=j.nodes(ut);if(ct.inputsLength()===0)throw new Error(`missing input for node: ${ct.name}`);for(let dt=0;dt<ct.inputsLength();dt++){const pt=ct.inputs(dt),lt=rt.get(pt);if(lt===void 0)throw new Error(`unrecognized input '${pt}' for node: ${ct.name()}`);st.inputs.push(lt),this._allData[lt]._to.push(ut)}}}checkIsAcyclic(){const j=new Set;this._allInputIndices.forEach(nt=>{this._allData[nt]._to.forEach(rt=>{j.add(rt)})});const U=Array.from(j),J=new Array(this._nodes.length).fill("white");for(;U.length>0;){const nt=U.pop();J[nt]==="gray"?J[nt]="black":(U.push(nt),J[nt]="gray",this._nodes[nt].outputs.forEach(rt=>{const ot=this._allData[rt];if(ot.tensor!==void 0)throw new Error("node outputs should not be initialized");if(ot._from!==nt)throw new Error("from property of the Value object doesn't match index of Node being processed");ot._to.forEach(at=>{if(J[at]==="gray")throw new Error("model graph is cyclic");J[at]==="white"&&U.push(at)})}))}}transformGraph(j){this.removeAllIdentityNodes(),this.removeAllDropoutNodes(),this.fuseConvActivationNodes(),j&&j.transformGraph(this),this.finalizeGraph()}finalizeGraph(){let j=0;const U=new Array(this._nodes.length,0);let J=0;for(let nt=0;nt<this._nodes.length;nt++)U[nt]=J,this._nodes[nt].executeNode?(J!==nt&&(this._nodes[J]=this._nodes[nt]),J++):this._nodes[nt].outputs.forEach(rt=>{this._allData[rt]._from=-2});this._nodes.splice(J,this._nodes.length-J);for(let nt=0;nt<this._allData.length;nt++){const rt=this._allData[nt];rt._from!==void 0&&rt._from!==-1&&rt._from!==-2&&(rt._from=U[rt._from]);for(let ot=0;ot<rt._to.length;ot++){if(!(rt._to[ot]>=0))throw new Error("Trying to update a removed node");rt._to[ot]=U[rt._to[ot]]}}j=0;for(let nt=0;nt<this._allData.length;nt++)if(this._allData[nt].from!==-2||this._allOutputIndices.indexOf(nt+j)!==-1){if(j>0){let rt=-1;this._allData[nt].from!==void 0&&this._allData[nt].from!==-1?(rt=this._nodes[this._allData[nt].from].outputs.indexOf(nt+j),rt!==-1&&(this._nodes[this._allData[nt].from].outputs[rt]=nt)):(rt=this._allInputIndices.indexOf(nt+j),rt!==-1&&(this._allInputIndices[rt]=nt)),this._allData[nt].to.forEach(ot=>{rt=this._nodes[ot].inputs.indexOf(nt+j),rt!==-1&&(this._nodes[ot].inputs[rt]=nt)}),this._allData[nt].to.length===0&&(rt=this._allOutputIndices.indexOf(nt+j),rt!==-1&&(this._allOutputIndices[rt]=nt))}}else j++,this._allData.splice(nt,1),nt--}deleteNode(j){const U=this._nodes[j];if(U.outputs.length>1){for(let at=1;at<U.outputs.length;at++)if(this._allData[U.outputs[at]].to.length>0)throw new Error("Node deletion with more than one output connected to other nodes is not supported. ")}U.executeNode=!1;const J=U.inputs[0],nt=U.outputs[0],rt=this._allData[nt].to;for(let at=0;at<U.inputs.length;at++){const ut=this._allData[U.inputs[at]].to.indexOf(j);if(ut===-1)throw new Error("The Value object doesn't have the current Node in it's 'to' property ");this._allData[U.inputs[at]].to.splice(ut,1)}this._allData[nt]._to=[];const ot=this._allOutputIndices.indexOf(nt);if(ot!==-1&&(this._allOutputIndices[ot]=J),rt&&rt.length>0)for(const at of rt){const ut=this._nodes[at].inputs.indexOf(nt);if(ut===-1)throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");this._nodes[at].inputs[ut]=J,this._allData[J].to.push(at)}}removeAllDropoutNodes(){let j=0;for(const U of this._nodes){if(U.opType==="Dropout"){if(U.inputs.length!==1)throw new Error("Dropout nodes should only contain one input. ");if(U.outputs.length!==1&&U.outputs.length!==2)throw new Error("Dropout nodes should contain either 1 or 2 output(s)");if(U.outputs.length===2&&this._allData[U.outputs[1]]._to.length!==0)throw new Error("Dropout nodes's second output should not be referenced by other nodes");this.deleteNode(j)}j++}}removeAllIdentityNodes(){let j=0;for(const U of this._nodes)U.opType==="Identity"&&this.deleteNode(j),j++}isActivation(j){switch(j.opType){case"Relu":case"Sigmoid":case"Clip":return!0;default:return!1}}fuseConvActivationNodes(){for(const j of this._nodes)if(j.opType==="Conv"){const U=this._allData[j.outputs[0]]._to;if(U.length===1&&this.isActivation(this._nodes[U[0]])){const J=this._nodes[U[0]];if(J.opType==="Clip")if(J.inputs.length===1)try{j.attributes.set("activation_params","floats",[J.attributes.getFloat("min"),J.attributes.getFloat("max")])}catch{j.attributes.set("activation_params","floats",[tt.MIN_CLIP,tt.MAX_CLIP])}else{if(!(J.inputs.length>=3&&this._allData[J.inputs[1]].tensor!==void 0&&this._allData[J.inputs[2]].tensor!==void 0))continue;j.attributes.set("activation_params","floats",[this._allData[J.inputs[1]].tensor.floatData[0],this._allData[J.inputs[2]].tensor.floatData[0]])}j.attributes.set("activation","string",J.opType),this.deleteNode(U[0])}}}}},1315:(it,F)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.now=F.Profiler=F.Logger=void 0;const W={verbose:1e3,info:2e3,warning:4e3,error:5e3,fatal:6e3},X={none:new class{log(G,O,b){}},console:new class{log(G,O,b){console.log(`${this.color(G)} ${b?"\x1B[35m"+b+"\x1B[0m ":""}${O}`)}color(G){switch(G){case"verbose":return"\x1B[34;40mv\x1B[0m";case"info":return"\x1B[32mi\x1B[0m";case"warning":return"\x1B[30;43mw\x1B[0m";case"error":return"\x1B[31;40me\x1B[0m";case"fatal":return"\x1B[101mf\x1B[0m";default:throw new Error(`unsupported severity: ${G}`)}}}},K={provider:"console",minimalSeverity:"warning",logDateTime:!0,logSourceLocation:!1};let Q={"":K};function Y(G,O,b,j){if(O===void 0)return U=G,{verbose:Y.verbose.bind(null,U),info:Y.info.bind(null,U),warning:Y.warning.bind(null,U),error:Y.error.bind(null,U),fatal:Y.fatal.bind(null,U)};if(b===void 0)tt(G,O);else if(typeof b=="number"&&j===void 0)tt(G,O);else if(typeof b=="string"&&j===void 0)tt(G,b,0,O);else{if(typeof b!="string"||typeof j!="number")throw new TypeError("input is valid");tt(G,b,0,O)}var U}function tt(G,O,b,j){const U=Q[j||""]||Q[""];W[G]<W[U.minimalSeverity]||(U.logDateTime&&(O=`${new Date().toISOString()}|${O}`),U.logSourceLocation,X[U.provider].log(G,O,j))}(function(G){function O(j){Q={},b("",j||{})}function b(j,U){if(j==="*")O(U);else{const J=Q[j]||K;Q[j]={provider:U.provider||J.provider,minimalSeverity:U.minimalSeverity||J.minimalSeverity,logDateTime:U.logDateTime===void 0?J.logDateTime:U.logDateTime,logSourceLocation:U.logSourceLocation===void 0?J.logSourceLocation:U.logSourceLocation}}}G.verbose=function(j,U){G("verbose",j,U)},G.info=function(j,U){G("info",j,U)},G.warning=function(j,U){G("warning",j,U)},G.error=function(j,U){G("error",j,U)},G.fatal=function(j,U){G("fatal",j,U)},G.reset=O,G.set=b,G.setWithEnv=function(j){const U={};j.logLevel&&(U.minimalSeverity=j.logLevel),b("",U)}})(Y||(Y={})),F.Logger=Y;class et{constructor(O,b,j,U,J,nt){this.category=O,this.name=b,this.startTime=j,this.endCallback=U,this.timer=J,this.ctx=nt}async end(){return this.endCallback(this)}async checkTimer(){if(this.ctx===void 0||this.timer===void 0)throw new Error("No webgl timer found");return this.ctx.endTimer(),this.ctx.waitForQueryAndGetTime(this.timer)}}class q{constructor(O,b,j,U){this.category=O,this.name=b,this.startTime=j,this.endTime=U}}F.Profiler=class{static create(G){return G===void 0?new this:new this(G.maxNumberEvents,G.flushBatchSize,G.flushIntervalInMilliseconds)}constructor(G,O,b){this._started=!1,this._flushPointer=0,this._started=!1,this._maxNumberEvents=G===void 0?1e4:G,this._flushBatchSize=O===void 0?10:O,this._flushIntervalInMilliseconds=b===void 0?5e3:b}start(){this._started=!0,this._timingEvents=[],this._flushTime=(0,F.now)(),this._flushPointer=0}stop(){for(this._started=!1;this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer])}event(G,O,b,j){const U=this._started?this.begin(G,O,j):void 0;let J=!1;const nt=b();if(nt&&typeof nt.then=="function")return J=!0,new Promise((rt,ot)=>{nt.then(async at=>{U&&await U.end(),rt(at)},async at=>{U&&await U.end(),ot(at)})});if(!J&&U){const rt=U.end();if(rt&&typeof rt.then=="function")return new Promise((ot,at)=>{rt.then(()=>{ot(nt)},ut=>{at(ut)})})}return nt}begin(G,O,b){if(!this._started)throw new Error("profiler is not started yet");if(b===void 0){const j=(0,F.now)();return this.flush(j),new et(G,O,j,U=>this.endSync(U))}{const j=b.beginTimer();return new et(G,O,0,async U=>this.end(U),j,b)}}async end(G){const O=await G.checkTimer();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new q(G.category,G.name,G.startTime,O)),this.flush(O))}endSync(G){const O=(0,F.now)();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new q(G.category,G.name,G.startTime,O)),this.flush(O))}logOneEvent(G){F.Logger.verbose(`Profiler.${G.category}`,`${(G.endTime-G.startTime).toFixed(2)}ms on event '${G.name}' at ${G.endTime.toFixed(2)}`)}flush(G){if(this._timingEvents.length-this._flushPointer>=this._flushBatchSize||G-this._flushTime>=this._flushIntervalInMilliseconds){for(const O=this._flushPointer;this._flushPointer<O+this._flushBatchSize&&this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer]);this._flushTime=(0,F.now)()}}get started(){return this._started}},F.now=typeof performance<"u"&&performance.now?()=>performance.now():Date.now},1745:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.Model=void 0;const X=W(5686),K=W(1446),Q=W(4662),Y=W(1287),tt=W(7273);var et=Y.onnxruntime.experimental.fbs;F.Model=class{constructor(){}load(q,G,O){if(!O)try{return void this.loadFromOnnxFormat(q,G)}catch(b){if(O!==void 0)throw b}this.loadFromOrtFormat(q,G)}loadFromOnnxFormat(q,G){const O=K.onnx.ModelProto.decode(q);if(tt.LongUtil.longToNumber(O.irVersion)<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=O.opsetImport.map(b=>({domain:b.domain,version:tt.LongUtil.longToNumber(b.version)})),this._graph=Q.Graph.from(O.graph,G)}loadFromOrtFormat(q,G){const O=new X.flatbuffers.ByteBuffer(q),b=et.InferenceSession.getRootAsInferenceSession(O).model();if(tt.LongUtil.longToNumber(b.irVersion())<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=[];for(let j=0;j<b.opsetImportLength();j++){const U=b.opsetImport(j);this._opsets.push({domain:U==null?void 0:U.domain(),version:tt.LongUtil.longToNumber(U.version())})}this._graph=Q.Graph.from(b.graph(),G)}get graph(){return this._graph}get opsets(){return this._opsets}}},6145:(it,F)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.FLOAT_TYPES=F.INT_TYPES=F.NUMBER_TYPES=void 0,F.NUMBER_TYPES=["float32","float64","int32","int16","int8","uint16","uint32","uint8"],F.INT_TYPES=["int32","int16","int8","uint16","uint32","uint8"],F.FLOAT_TYPES=["float32","float64"]},5881:(it,F)=>{function W(X,K){if(K.endsWith("+")){const Q=Number.parseInt(K.substring(0,K.length-1),10);return!isNaN(Q)&&Q<=X}if(K.split("-").length===2){const Q=K.split("-"),Y=Number.parseInt(Q[0],10),tt=Number.parseInt(Q[1],10);return!isNaN(Y)&&!isNaN(tt)&&Y<=X&&X<=tt}return Number.parseInt(K,10)===X}Object.defineProperty(F,"__esModule",{value:!0}),F.resolveOperator=void 0,F.resolveOperator=function(X,K,Q){for(const Y of Q){const tt=Y[0],et=Y[1],q=Y[2],G=Y[3],O=Y[4];if(X.opType===tt){for(const b of K)if((b.domain===et||b.domain==="ai.onnx"&&et==="")&&W(b.version,q))return{opImpl:G,opInit:O}}}throw new TypeError(`cannot resolve operator '${X.opType}' with opsets: ${K.map(Y=>`${Y.domain||"ai.onnx"} v${Y.version}`).join(", ")}`)}},1287:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.onnxruntime=void 0;const X=W(5686);var K,Q;K=F.onnxruntime||(F.onnxruntime={}),function(Y){(function(tt){tt[tt.UNDEFINED=0]="UNDEFINED",tt[tt.FLOAT=1]="FLOAT",tt[tt.INT=2]="INT",tt[tt.STRING=3]="STRING",tt[tt.TENSOR=4]="TENSOR",tt[tt.GRAPH=5]="GRAPH",tt[tt.FLOATS=6]="FLOATS",tt[tt.INTS=7]="INTS",tt[tt.STRINGS=8]="STRINGS",tt[tt.TENSORS=9]="TENSORS",tt[tt.GRAPHS=10]="GRAPHS",tt[tt.SPARSE_TENSOR=11]="SPARSE_TENSOR",tt[tt.SPARSE_TENSORS=12]="SPARSE_TENSORS"})(Y.AttributeType||(Y.AttributeType={}))}((Q=K.experimental||(K.experimental={})).fbs||(Q.fbs={})),function(Y){(function(tt){(function(et){(function(q){q[q.UNKNOWN=0]="UNKNOWN",q[q.VALUE=1]="VALUE",q[q.PARAM=2]="PARAM"})(et.DimensionValueType||(et.DimensionValueType={}))})(tt.fbs||(tt.fbs={}))})(Y.experimental||(Y.experimental={}))}(F.onnxruntime||(F.onnxruntime={})),function(Y){(function(tt){(function(et){(function(q){q[q.UNDEFINED=0]="UNDEFINED",q[q.FLOAT=1]="FLOAT",q[q.UINT8=2]="UINT8",q[q.INT8=3]="INT8",q[q.UINT16=4]="UINT16",q[q.INT16=5]="INT16",q[q.INT32=6]="INT32",q[q.INT64=7]="INT64",q[q.STRING=8]="STRING",q[q.BOOL=9]="BOOL",q[q.FLOAT16=10]="FLOAT16",q[q.DOUBLE=11]="DOUBLE",q[q.UINT32=12]="UINT32",q[q.UINT64=13]="UINT64",q[q.COMPLEX64=14]="COMPLEX64",q[q.COMPLEX128=15]="COMPLEX128",q[q.BFLOAT16=16]="BFLOAT16"})(et.TensorDataType||(et.TensorDataType={}))})(tt.fbs||(tt.fbs={}))})(Y.experimental||(Y.experimental={}))}(F.onnxruntime||(F.onnxruntime={})),function(Y){(function(tt){(function(et){(function(q){q[q.Primitive=0]="Primitive",q[q.Fused=1]="Fused"})(et.NodeType||(et.NodeType={}))})(tt.fbs||(tt.fbs={}))})(Y.experimental||(Y.experimental={}))}(F.onnxruntime||(F.onnxruntime={})),function(Y){(function(tt){(function(et){(function(q){q[q.NONE=0]="NONE",q[q.tensor_type=1]="tensor_type",q[q.sequence_type=2]="sequence_type",q[q.map_type=3]="map_type"})(et.TypeInfoValue||(et.TypeInfoValue={}))})(tt.fbs||(tt.fbs={}))})(Y.experimental||(Y.experimental={}))}(F.onnxruntime||(F.onnxruntime={})),function(Y){(function(tt){(function(et){class q{constructor(){this.bb=null,this.bb_pos=0}__init(O,b){return this.bb_pos=O,this.bb=b,this}static getRootAsShape(O,b){return(b||new q).__init(O.readInt32(O.position())+O.position(),O)}static getSizePrefixedRootAsShape(O,b){return O.setPosition(O.position()+X.flatbuffers.SIZE_PREFIX_LENGTH),(b||new q).__init(O.readInt32(O.position())+O.position(),O)}dim(O,b){let j=this.bb.__offset(this.bb_pos,4);return j?(b||new Y.experimental.fbs.Dimension).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+j)+4*O),this.bb):null}dimLength(){let O=this.bb.__offset(this.bb_pos,4);return O?this.bb.__vector_len(this.bb_pos+O):0}static startShape(O){O.startObject(1)}static addDim(O,b){O.addFieldOffset(0,b,0)}static createDimVector(O,b){O.startVector(4,b.length,4);for(let j=b.length-1;j>=0;j--)O.addOffset(b[j]);return O.endVector()}static startDimVector(O,b){O.startVector(4,b,4)}static endShape(O){return O.endObject()}static createShape(O,b){return q.startShape(O),q.addDim(O,b),q.endShape(O)}}et.Shape=q})(tt.fbs||(tt.fbs={}))})(Y.experimental||(Y.experimental={}))}(F.onnxruntime||(F.onnxruntime={})),function(Y){(function(tt){(function(et){class q{constructor(){this.bb=null,this.bb_pos=0}__init(O,b){return this.bb_pos=O,this.bb=b,this}static getRootAsDimension(O,b){return(b||new q).__init(O.readInt32(O.position())+O.position(),O)}static getSizePrefixedRootAsDimension(O,b){return O.setPosition(O.position()+X.flatbuffers.SIZE_PREFIX_LENGTH),(b||new q).__init(O.readInt32(O.position())+O.position(),O)}value(O){let b=this.bb.__offset(this.bb_pos,4);return b?(O||new Y.experimental.fbs.DimensionValue).__init(this.bb.__indirect(this.bb_pos+b),this.bb):null}denotation(O){let b=this.bb.__offset(this.bb_pos,6);return b?this.bb.__string(this.bb_pos+b,O):null}static startDimension(O){O.startObject(2)}static addValue(O,b){O.addFieldOffset(0,b,0)}static addDenotation(O,b){O.addFieldOffset(1,b,0)}static endDimension(O){return O.endObject()}static createDimension(O,b,j){return q.startDimension(O),q.addValue(O,b),q.addDenotation(O,j),q.endDimension(O)}}et.Dimension=q})(tt.fbs||(tt.fbs={}))})(Y.experimental||(Y.experimental={}))}(F.onnxruntime||(F.onnxruntime={})),function(Y){(function(tt){(function(et){class q{constructor(){this.bb=null,this.bb_pos=0}__init(O,b){return this.bb_pos=O,this.bb=b,this}static getRootAsDimensionValue(O,b){return(b||new q).__init(O.readInt32(O.position())+O.position(),O)}static getSizePrefixedRootAsDimensionValue(O,b){return O.setPosition(O.position()+X.flatbuffers.SIZE_PREFIX_LENGTH),(b||new q).__init(O.readInt32(O.position())+O.position(),O)}dimType(){let O=this.bb.__offset(this.bb_pos,4);return O?this.bb.readInt8(this.bb_pos+O):Y.experimental.fbs.DimensionValueType.UNKNOWN}dimValue(){let O=this.bb.__offset(this.bb_pos,6);return O?this.bb.readInt64(this.bb_pos+O):this.bb.createLong(0,0)}dimParam(O){let b=this.bb.__offset(this.bb_pos,8);return b?this.bb.__string(this.bb_pos+b,O):null}static startDimensionValue(O){O.startObject(3)}static addDimType(O,b){O.addFieldInt8(0,b,Y.experimental.fbs.DimensionValueType.UNKNOWN)}static addDimValue(O,b){O.addFieldInt64(1,b,O.createLong(0,0))}static addDimParam(O,b){O.addFieldOffset(2,b,0)}static endDimensionValue(O){return O.endObject()}static createDimensionValue(O,b,j,U){return q.startDimensionValue(O),q.addDimType(O,b),q.addDimValue(O,j),q.addDimParam(O,U),q.endDimensionValue(O)}}et.DimensionValue=q})(tt.fbs||(tt.fbs={}))})(Y.experimental||(Y.experimental={}))}(F.onnxruntime||(F.onnxruntime={})),function(Y){(function(tt){(function(et){class q{constructor(){this.bb=null,this.bb_pos=0}__init(O,b){return this.bb_pos=O,this.bb=b,this}static getRootAsTensorTypeAndShape(O,b){return(b||new q).__init(O.readInt32(O.position())+O.position(),O)}static getSizePrefixedRootAsTensorTypeAndShape(O,b){return O.setPosition(O.position()+X.flatbuffers.SIZE_PREFIX_LENGTH),(b||new q).__init(O.readInt32(O.position())+O.position(),O)}elemType(){let O=this.bb.__offset(this.bb_pos,4);return O?this.bb.readInt32(this.bb_pos+O):Y.experimental.fbs.TensorDataType.UNDEFINED}shape(O){let b=this.bb.__offset(this.bb_pos,6);return b?(O||new Y.experimental.fbs.Shape).__init(this.bb.__indirect(this.bb_pos+b),this.bb):null}static startTensorTypeAndShape(O){O.startObject(2)}static addElemType(O,b){O.addFieldInt32(0,b,Y.experimental.fbs.TensorDataType.UNDEFINED)}static addShape(O,b){O.addFieldOffset(1,b,0)}static endTensorTypeAndShape(O){return O.endObject()}static createTensorTypeAndShape(O,b,j){return q.startTensorTypeAndShape(O),q.addElemType(O,b),q.addShape(O,j),q.endTensorTypeAndShape(O)}}et.TensorTypeAndShape=q})(tt.fbs||(tt.fbs={}))})(Y.experimental||(Y.experimental={}))}(F.onnxruntime||(F.onnxruntime={})),function(Y){(function(tt){(function(et){class q{constructor(){this.bb=null,this.bb_pos=0}__init(O,b){return this.bb_pos=O,this.bb=b,this}static getRootAsMapType(O,b){return(b||new q).__init(O.readInt32(O.position())+O.position(),O)}static getSizePrefixedRootAsMapType(O,b){return O.setPosition(O.position()+X.flatbuffers.SIZE_PREFIX_LENGTH),(b||new q).__init(O.readInt32(O.position())+O.position(),O)}keyType(){let O=this.bb.__offset(this.bb_pos,4);return O?this.bb.readInt32(this.bb_pos+O):Y.experimental.fbs.TensorDataType.UNDEFINED}valueType(O){let b=this.bb.__offset(this.bb_pos,6);return b?(O||new Y.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+b),this.bb):null}static startMapType(O){O.startObject(2)}static addKeyType(O,b){O.addFieldInt32(0,b,Y.experimental.fbs.TensorDataType.UNDEFINED)}static addValueType(O,b){O.addFieldOffset(1,b,0)}static endMapType(O){return O.endObject()}static createMapType(O,b,j){return q.startMapType(O),q.addKeyType(O,b),q.addValueType(O,j),q.endMapType(O)}}et.MapType=q})(tt.fbs||(tt.fbs={}))})(Y.experimental||(Y.experimental={}))}(F.onnxruntime||(F.onnxruntime={})),function(Y){(function(tt){(function(et){class q{constructor(){this.bb=null,this.bb_pos=0}__init(O,b){return this.bb_pos=O,this.bb=b,this}static getRootAsSequenceType(O,b){return(b||new q).__init(O.readInt32(O.position())+O.position(),O)}static getSizePrefixedRootAsSequenceType(O,b){return O.setPosition(O.position()+X.flatbuffers.SIZE_PREFIX_LENGTH),(b||new q).__init(O.readInt32(O.position())+O.position(),O)}elemType(O){let b=this.bb.__offset(this.bb_pos,4);return b?(O||new Y.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+b),this.bb):null}static startSequenceType(O){O.startObject(1)}static addElemType(O,b){O.addFieldOffset(0,b,0)}static endSequenceType(O){return O.endObject()}static createSequenceType(O,b){return q.startSequenceType(O),q.addElemType(O,b),q.endSequenceType(O)}}et.SequenceType=q})(tt.fbs||(tt.fbs={}))})(Y.experimental||(Y.experimental={}))}(F.onnxruntime||(F.onnxruntime={})),function(Y){(function(tt){(tt.fbs||(tt.fbs={})).EdgeEnd=class{constructor(){this.bb=null,this.bb_pos=0}__init(et,q){return this.bb_pos=et,this.bb=q,this}nodeIndex(){return this.bb.readUint32(this.bb_pos)}srcArgIndex(){return this.bb.readInt32(this.bb_pos+4)}dstArgIndex(){return this.bb.readInt32(this.bb_pos+8)}static createEdgeEnd(et,q,G,O){return et.prep(4,12),et.writeInt32(O),et.writeInt32(G),et.writeInt32(q),et.offset()}}})(Y.experimental||(Y.experimental={}))}(F.onnxruntime||(F.onnxruntime={})),function(Y){(function(tt){(function(et){class q{constructor(){this.bb=null,this.bb_pos=0}__init(O,b){return this.bb_pos=O,this.bb=b,this}static getRootAsNodeEdge(O,b){return(b||new q).__init(O.readInt32(O.position())+O.position(),O)}static getSizePrefixedRootAsNodeEdge(O,b){return O.setPosition(O.position()+X.flatbuffers.SIZE_PREFIX_LENGTH),(b||new q).__init(O.readInt32(O.position())+O.position(),O)}nodeIndex(){let O=this.bb.__offset(this.bb_pos,4);return O?this.bb.readUint32(this.bb_pos+O):0}inputEdges(O,b){let j=this.bb.__offset(this.bb_pos,6);return j?(b||new Y.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+j)+12*O,this.bb):null}inputEdgesLength(){let O=this.bb.__offset(this.bb_pos,6);return O?this.bb.__vector_len(this.bb_pos+O):0}outputEdges(O,b){let j=this.bb.__offset(this.bb_pos,8);return j?(b||new Y.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+j)+12*O,this.bb):null}outputEdgesLength(){let O=this.bb.__offset(this.bb_pos,8);return O?this.bb.__vector_len(this.bb_pos+O):0}static startNodeEdge(O){O.startObject(3)}static addNodeIndex(O,b){O.addFieldInt32(0,b,0)}static addInputEdges(O,b){O.addFieldOffset(1,b,0)}static startInputEdgesVector(O,b){O.startVector(12,b,4)}static addOutputEdges(O,b){O.addFieldOffset(2,b,0)}static startOutputEdgesVector(O,b){O.startVector(12,b,4)}static endNodeEdge(O){return O.endObject()}static createNodeEdge(O,b,j,U){return q.startNodeEdge(O),q.addNodeIndex(O,b),q.addInputEdges(O,j),q.addOutputEdges(O,U),q.endNodeEdge(O)}}et.NodeEdge=q})(tt.fbs||(tt.fbs={}))})(Y.experimental||(Y.experimental={}))}(F.onnxruntime||(F.onnxruntime={})),function(Y){(function(tt){(function(et){class q{constructor(){this.bb=null,this.bb_pos=0}__init(O,b){return this.bb_pos=O,this.bb=b,this}static getRootAsNode(O,b){return(b||new q).__init(O.readInt32(O.position())+O.position(),O)}static getSizePrefixedRootAsNode(O,b){return O.setPosition(O.position()+X.flatbuffers.SIZE_PREFIX_LENGTH),(b||new q).__init(O.readInt32(O.position())+O.position(),O)}name(O){let b=this.bb.__offset(this.bb_pos,4);return b?this.bb.__string(this.bb_pos+b,O):null}docString(O){let b=this.bb.__offset(this.bb_pos,6);return b?this.bb.__string(this.bb_pos+b,O):null}domain(O){let b=this.bb.__offset(this.bb_pos,8);return b?this.bb.__string(this.bb_pos+b,O):null}sinceVersion(){let O=this.bb.__offset(this.bb_pos,10);return O?this.bb.readInt32(this.bb_pos+O):0}index(){let O=this.bb.__offset(this.bb_pos,12);return O?this.bb.readUint32(this.bb_pos+O):0}opType(O){let b=this.bb.__offset(this.bb_pos,14);return b?this.bb.__string(this.bb_pos+b,O):null}type(){let O=this.bb.__offset(this.bb_pos,16);return O?this.bb.readInt32(this.bb_pos+O):Y.experimental.fbs.NodeType.Primitive}executionProviderType(O){let b=this.bb.__offset(this.bb_pos,18);return b?this.bb.__string(this.bb_pos+b,O):null}inputs(O,b){let j=this.bb.__offset(this.bb_pos,20);return j?this.bb.__string(this.bb.__vector(this.bb_pos+j)+4*O,b):null}inputsLength(){let O=this.bb.__offset(this.bb_pos,20);return O?this.bb.__vector_len(this.bb_pos+O):0}outputs(O,b){let j=this.bb.__offset(this.bb_pos,22);return j?this.bb.__string(this.bb.__vector(this.bb_pos+j)+4*O,b):null}outputsLength(){let O=this.bb.__offset(this.bb_pos,22);return O?this.bb.__vector_len(this.bb_pos+O):0}attributes(O,b){let j=this.bb.__offset(this.bb_pos,24);return j?(b||new Y.experimental.fbs.Attribute).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+j)+4*O),this.bb):null}attributesLength(){let O=this.bb.__offset(this.bb_pos,24);return O?this.bb.__vector_len(this.bb_pos+O):0}inputArgCounts(O){let b=this.bb.__offset(this.bb_pos,26);return b?this.bb.readInt32(this.bb.__vector(this.bb_pos+b)+4*O):0}inputArgCountsLength(){let O=this.bb.__offset(this.bb_pos,26);return O?this.bb.__vector_len(this.bb_pos+O):0}inputArgCountsArray(){let O=this.bb.__offset(this.bb_pos,26);return O?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+O),this.bb.__vector_len(this.bb_pos+O)):null}implicitInputs(O,b){let j=this.bb.__offset(this.bb_pos,28);return j?this.bb.__string(this.bb.__vector(this.bb_pos+j)+4*O,b):null}implicitInputsLength(){let O=this.bb.__offset(this.bb_pos,28);return O?this.bb.__vector_len(this.bb_pos+O):0}static startNode(O){O.startObject(13)}static addName(O,b){O.addFieldOffset(0,b,0)}static addDocString(O,b){O.addFieldOffset(1,b,0)}static addDomain(O,b){O.addFieldOffset(2,b,0)}static addSinceVersion(O,b){O.addFieldInt32(3,b,0)}static addIndex(O,b){O.addFieldInt32(4,b,0)}static addOpType(O,b){O.addFieldOffset(5,b,0)}static addType(O,b){O.addFieldInt32(6,b,Y.experimental.fbs.NodeType.Primitive)}static addExecutionProviderType(O,b){O.addFieldOffset(7,b,0)}static addInputs(O,b){O.addFieldOffset(8,b,0)}static createInputsVector(O,b){O.startVector(4,b.length,4);for(let j=b.length-1;j>=0;j--)O.addOffset(b[j]);return O.endVector()}static startInputsVector(O,b){O.startVector(4,b,4)}static addOutputs(O,b){O.addFieldOffset(9,b,0)}static createOutputsVector(O,b){O.startVector(4,b.length,4);for(let j=b.length-1;j>=0;j--)O.addOffset(b[j]);return O.endVector()}static startOutputsVector(O,b){O.startVector(4,b,4)}static addAttributes(O,b){O.addFieldOffset(10,b,0)}static createAttributesVector(O,b){O.startVector(4,b.length,4);for(let j=b.length-1;j>=0;j--)O.addOffset(b[j]);return O.endVector()}static startAttributesVector(O,b){O.startVector(4,b,4)}static addInputArgCounts(O,b){O.addFieldOffset(11,b,0)}static createInputArgCountsVector(O,b){O.startVector(4,b.length,4);for(let j=b.length-1;j>=0;j--)O.addInt32(b[j]);return O.endVector()}static startInputArgCountsVector(O,b){O.startVector(4,b,4)}static addImplicitInputs(O,b){O.addFieldOffset(12,b,0)}static createImplicitInputsVector(O,b){O.startVector(4,b.length,4);for(let j=b.length-1;j>=0;j--)O.addOffset(b[j]);return O.endVector()}static startImplicitInputsVector(O,b){O.startVector(4,b,4)}static endNode(O){return O.endObject()}static createNode(O,b,j,U,J,nt,rt,ot,at,ut,st,ct,dt,pt){return q.startNode(O),q.addName(O,b),q.addDocString(O,j),q.addDomain(O,U),q.addSinceVersion(O,J),q.addIndex(O,nt),q.addOpType(O,rt),q.addType(O,ot),q.addExecutionProviderType(O,at),q.addInputs(O,ut),q.addOutputs(O,st),q.addAttributes(O,ct),q.addInputArgCounts(O,dt),q.addImplicitInputs(O,pt),q.endNode(O)}}et.Node=q})(tt.fbs||(tt.fbs={}))})(Y.experimental||(Y.experimental={}))}(F.onnxruntime||(F.onnxruntime={})),function(Y){(function(tt){(function(et){class q{constructor(){this.bb=null,this.bb_pos=0}__init(O,b){return this.bb_pos=O,this.bb=b,this}static getRootAsValueInfo(O,b){return(b||new q).__init(O.readInt32(O.position())+O.position(),O)}static getSizePrefixedRootAsValueInfo(O,b){return O.setPosition(O.position()+X.flatbuffers.SIZE_PREFIX_LENGTH),(b||new q).__init(O.readInt32(O.position())+O.position(),O)}name(O){let b=this.bb.__offset(this.bb_pos,4);return b?this.bb.__string(this.bb_pos+b,O):null}docString(O){let b=this.bb.__offset(this.bb_pos,6);return b?this.bb.__string(this.bb_pos+b,O):null}type(O){let b=this.bb.__offset(this.bb_pos,8);return b?(O||new Y.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+b),this.bb):null}static startValueInfo(O){O.startObject(3)}static addName(O,b){O.addFieldOffset(0,b,0)}static addDocString(O,b){O.addFieldOffset(1,b,0)}static addType(O,b){O.addFieldOffset(2,b,0)}static endValueInfo(O){return O.endObject()}static createValueInfo(O,b,j,U){return q.startValueInfo(O),q.addName(O,b),q.addDocString(O,j),q.addType(O,U),q.endValueInfo(O)}}et.ValueInfo=q})(tt.fbs||(tt.fbs={}))})(Y.experimental||(Y.experimental={}))}(F.onnxruntime||(F.onnxruntime={})),function(Y){(function(tt){(function(et){class q{constructor(){this.bb=null,this.bb_pos=0}__init(O,b){return this.bb_pos=O,this.bb=b,this}static getRootAsTypeInfo(O,b){return(b||new q).__init(O.readInt32(O.position())+O.position(),O)}static getSizePrefixedRootAsTypeInfo(O,b){return O.setPosition(O.position()+X.flatbuffers.SIZE_PREFIX_LENGTH),(b||new q).__init(O.readInt32(O.position())+O.position(),O)}denotation(O){let b=this.bb.__offset(this.bb_pos,4);return b?this.bb.__string(this.bb_pos+b,O):null}valueType(){let O=this.bb.__offset(this.bb_pos,6);return O?this.bb.readUint8(this.bb_pos+O):Y.experimental.fbs.TypeInfoValue.NONE}value(O){let b=this.bb.__offset(this.bb_pos,8);return b?this.bb.__union(O,this.bb_pos+b):null}static startTypeInfo(O){O.startObject(3)}static addDenotation(O,b){O.addFieldOffset(0,b,0)}static addValueType(O,b){O.addFieldInt8(1,b,Y.experimental.fbs.TypeInfoValue.NONE)}static addValue(O,b){O.addFieldOffset(2,b,0)}static endTypeInfo(O){return O.endObject()}static createTypeInfo(O,b,j,U){return q.startTypeInfo(O),q.addDenotation(O,b),q.addValueType(O,j),q.addValue(O,U),q.endTypeInfo(O)}}et.TypeInfo=q})(tt.fbs||(tt.fbs={}))})(Y.experimental||(Y.experimental={}))}(F.onnxruntime||(F.onnxruntime={})),function(Y){(function(tt){(function(et){class q{constructor(){this.bb=null,this.bb_pos=0}__init(O,b){return this.bb_pos=O,this.bb=b,this}static getRootAsOperatorSetId(O,b){return(b||new q).__init(O.readInt32(O.position())+O.position(),O)}static getSizePrefixedRootAsOperatorSetId(O,b){return O.setPosition(O.position()+X.flatbuffers.SIZE_PREFIX_LENGTH),(b||new q).__init(O.readInt32(O.position())+O.position(),O)}domain(O){let b=this.bb.__offset(this.bb_pos,4);return b?this.bb.__string(this.bb_pos+b,O):null}version(){let O=this.bb.__offset(this.bb_pos,6);return O?this.bb.readInt64(this.bb_pos+O):this.bb.createLong(0,0)}static startOperatorSetId(O){O.startObject(2)}static addDomain(O,b){O.addFieldOffset(0,b,0)}static addVersion(O,b){O.addFieldInt64(1,b,O.createLong(0,0))}static endOperatorSetId(O){return O.endObject()}static createOperatorSetId(O,b,j){return q.startOperatorSetId(O),q.addDomain(O,b),q.addVersion(O,j),q.endOperatorSetId(O)}}et.OperatorSetId=q})(tt.fbs||(tt.fbs={}))})(Y.experimental||(Y.experimental={}))}(F.onnxruntime||(F.onnxruntime={})),function(Y){(function(tt){(function(et){class q{constructor(){this.bb=null,this.bb_pos=0}__init(O,b){return this.bb_pos=O,this.bb=b,this}static getRootAsTensor(O,b){return(b||new q).__init(O.readInt32(O.position())+O.position(),O)}static getSizePrefixedRootAsTensor(O,b){return O.setPosition(O.position()+X.flatbuffers.SIZE_PREFIX_LENGTH),(b||new q).__init(O.readInt32(O.position())+O.position(),O)}name(O){let b=this.bb.__offset(this.bb_pos,4);return b?this.bb.__string(this.bb_pos+b,O):null}docString(O){let b=this.bb.__offset(this.bb_pos,6);return b?this.bb.__string(this.bb_pos+b,O):null}dims(O){let b=this.bb.__offset(this.bb_pos,8);return b?this.bb.readInt64(this.bb.__vector(this.bb_pos+b)+8*O):this.bb.createLong(0,0)}dimsLength(){let O=this.bb.__offset(this.bb_pos,8);return O?this.bb.__vector_len(this.bb_pos+O):0}dataType(){let O=this.bb.__offset(this.bb_pos,10);return O?this.bb.readInt32(this.bb_pos+O):Y.experimental.fbs.TensorDataType.UNDEFINED}rawData(O){let b=this.bb.__offset(this.bb_pos,12);return b?this.bb.readUint8(this.bb.__vector(this.bb_pos+b)+O):0}rawDataLength(){let O=this.bb.__offset(this.bb_pos,12);return O?this.bb.__vector_len(this.bb_pos+O):0}rawDataArray(){let O=this.bb.__offset(this.bb_pos,12);return O?new Uint8Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+O),this.bb.__vector_len(this.bb_pos+O)):null}stringData(O,b){let j=this.bb.__offset(this.bb_pos,14);return j?this.bb.__string(this.bb.__vector(this.bb_pos+j)+4*O,b):null}stringDataLength(){let O=this.bb.__offset(this.bb_pos,14);return O?this.bb.__vector_len(this.bb_pos+O):0}static startTensor(O){O.startObject(6)}static addName(O,b){O.addFieldOffset(0,b,0)}static addDocString(O,b){O.addFieldOffset(1,b,0)}static addDims(O,b){O.addFieldOffset(2,b,0)}static createDimsVector(O,b){O.startVector(8,b.length,8);for(let j=b.length-1;j>=0;j--)O.addInt64(b[j]);return O.endVector()}static startDimsVector(O,b){O.startVector(8,b,8)}static addDataType(O,b){O.addFieldInt32(3,b,Y.experimental.fbs.TensorDataType.UNDEFINED)}static addRawData(O,b){O.addFieldOffset(4,b,0)}static createRawDataVector(O,b){O.startVector(1,b.length,1);for(let j=b.length-1;j>=0;j--)O.addInt8(b[j]);return O.endVector()}static startRawDataVector(O,b){O.startVector(1,b,1)}static addStringData(O,b){O.addFieldOffset(5,b,0)}static createStringDataVector(O,b){O.startVector(4,b.length,4);for(let j=b.length-1;j>=0;j--)O.addOffset(b[j]);return O.endVector()}static startStringDataVector(O,b){O.startVector(4,b,4)}static endTensor(O){return O.endObject()}static createTensor(O,b,j,U,J,nt,rt){return q.startTensor(O),q.addName(O,b),q.addDocString(O,j),q.addDims(O,U),q.addDataType(O,J),q.addRawData(O,nt),q.addStringData(O,rt),q.endTensor(O)}}et.Tensor=q})(tt.fbs||(tt.fbs={}))})(Y.experimental||(Y.experimental={}))}(F.onnxruntime||(F.onnxruntime={})),function(Y){(function(tt){(function(et){class q{constructor(){this.bb=null,this.bb_pos=0}__init(O,b){return this.bb_pos=O,this.bb=b,this}static getRootAsSparseTensor(O,b){return(b||new q).__init(O.readInt32(O.position())+O.position(),O)}static getSizePrefixedRootAsSparseTensor(O,b){return O.setPosition(O.position()+X.flatbuffers.SIZE_PREFIX_LENGTH),(b||new q).__init(O.readInt32(O.position())+O.position(),O)}values(O){let b=this.bb.__offset(this.bb_pos,4);return b?(O||new Y.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+b),this.bb):null}indices(O){let b=this.bb.__offset(this.bb_pos,6);return b?(O||new Y.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+b),this.bb):null}dims(O){let b=this.bb.__offset(this.bb_pos,8);return b?this.bb.readInt64(this.bb.__vector(this.bb_pos+b)+8*O):this.bb.createLong(0,0)}dimsLength(){let O=this.bb.__offset(this.bb_pos,8);return O?this.bb.__vector_len(this.bb_pos+O):0}static startSparseTensor(O){O.startObject(3)}static addValues(O,b){O.addFieldOffset(0,b,0)}static addIndices(O,b){O.addFieldOffset(1,b,0)}static addDims(O,b){O.addFieldOffset(2,b,0)}static createDimsVector(O,b){O.startVector(8,b.length,8);for(let j=b.length-1;j>=0;j--)O.addInt64(b[j]);return O.endVector()}static startDimsVector(O,b){O.startVector(8,b,8)}static endSparseTensor(O){return O.endObject()}static createSparseTensor(O,b,j,U){return q.startSparseTensor(O),q.addValues(O,b),q.addIndices(O,j),q.addDims(O,U),q.endSparseTensor(O)}}et.SparseTensor=q})(tt.fbs||(tt.fbs={}))})(Y.experimental||(Y.experimental={}))}(F.onnxruntime||(F.onnxruntime={})),function(Y){(function(tt){(function(et){class q{constructor(){this.bb=null,this.bb_pos=0}__init(O,b){return this.bb_pos=O,this.bb=b,this}static getRootAsAttribute(O,b){return(b||new q).__init(O.readInt32(O.position())+O.position(),O)}static getSizePrefixedRootAsAttribute(O,b){return O.setPosition(O.position()+X.flatbuffers.SIZE_PREFIX_LENGTH),(b||new q).__init(O.readInt32(O.position())+O.position(),O)}name(O){let b=this.bb.__offset(this.bb_pos,4);return b?this.bb.__string(this.bb_pos+b,O):null}docString(O){let b=this.bb.__offset(this.bb_pos,6);return b?this.bb.__string(this.bb_pos+b,O):null}type(){let O=this.bb.__offset(this.bb_pos,8);return O?this.bb.readInt32(this.bb_pos+O):Y.experimental.fbs.AttributeType.UNDEFINED}f(){let O=this.bb.__offset(this.bb_pos,10);return O?this.bb.readFloat32(this.bb_pos+O):0}i(){let O=this.bb.__offset(this.bb_pos,12);return O?this.bb.readInt64(this.bb_pos+O):this.bb.createLong(0,0)}s(O){let b=this.bb.__offset(this.bb_pos,14);return b?this.bb.__string(this.bb_pos+b,O):null}t(O){let b=this.bb.__offset(this.bb_pos,16);return b?(O||new Y.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+b),this.bb):null}g(O){let b=this.bb.__offset(this.bb_pos,18);return b?(O||new Y.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+b),this.bb):null}floats(O){let b=this.bb.__offset(this.bb_pos,20);return b?this.bb.readFloat32(this.bb.__vector(this.bb_pos+b)+4*O):0}floatsLength(){let O=this.bb.__offset(this.bb_pos,20);return O?this.bb.__vector_len(this.bb_pos+O):0}floatsArray(){let O=this.bb.__offset(this.bb_pos,20);return O?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+O),this.bb.__vector_len(this.bb_pos+O)):null}ints(O){let b=this.bb.__offset(this.bb_pos,22);return b?this.bb.readInt64(this.bb.__vector(this.bb_pos+b)+8*O):this.bb.createLong(0,0)}intsLength(){let O=this.bb.__offset(this.bb_pos,22);return O?this.bb.__vector_len(this.bb_pos+O):0}strings(O,b){let j=this.bb.__offset(this.bb_pos,24);return j?this.bb.__string(this.bb.__vector(this.bb_pos+j)+4*O,b):null}stringsLength(){let O=this.bb.__offset(this.bb_pos,24);return O?this.bb.__vector_len(this.bb_pos+O):0}tensors(O,b){let j=this.bb.__offset(this.bb_pos,26);return j?(b||new Y.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+j)+4*O),this.bb):null}tensorsLength(){let O=this.bb.__offset(this.bb_pos,26);return O?this.bb.__vector_len(this.bb_pos+O):0}graphs(O,b){let j=this.bb.__offset(this.bb_pos,28);return j?(b||new Y.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+j)+4*O),this.bb):null}graphsLength(){let O=this.bb.__offset(this.bb_pos,28);return O?this.bb.__vector_len(this.bb_pos+O):0}static startAttribute(O){O.startObject(13)}static addName(O,b){O.addFieldOffset(0,b,0)}static addDocString(O,b){O.addFieldOffset(1,b,0)}static addType(O,b){O.addFieldInt32(2,b,Y.experimental.fbs.AttributeType.UNDEFINED)}static addF(O,b){O.addFieldFloat32(3,b,0)}static addI(O,b){O.addFieldInt64(4,b,O.createLong(0,0))}static addS(O,b){O.addFieldOffset(5,b,0)}static addT(O,b){O.addFieldOffset(6,b,0)}static addG(O,b){O.addFieldOffset(7,b,0)}static addFloats(O,b){O.addFieldOffset(8,b,0)}static createFloatsVector(O,b){O.startVector(4,b.length,4);for(let j=b.length-1;j>=0;j--)O.addFloat32(b[j]);return O.endVector()}static startFloatsVector(O,b){O.startVector(4,b,4)}static addInts(O,b){O.addFieldOffset(9,b,0)}static createIntsVector(O,b){O.startVector(8,b.length,8);for(let j=b.length-1;j>=0;j--)O.addInt64(b[j]);return O.endVector()}static startIntsVector(O,b){O.startVector(8,b,8)}static addStrings(O,b){O.addFieldOffset(10,b,0)}static createStringsVector(O,b){O.startVector(4,b.length,4);for(let j=b.length-1;j>=0;j--)O.addOffset(b[j]);return O.endVector()}static startStringsVector(O,b){O.startVector(4,b,4)}static addTensors(O,b){O.addFieldOffset(11,b,0)}static createTensorsVector(O,b){O.startVector(4,b.length,4);for(let j=b.length-1;j>=0;j--)O.addOffset(b[j]);return O.endVector()}static startTensorsVector(O,b){O.startVector(4,b,4)}static addGraphs(O,b){O.addFieldOffset(12,b,0)}static createGraphsVector(O,b){O.startVector(4,b.length,4);for(let j=b.length-1;j>=0;j--)O.addOffset(b[j]);return O.endVector()}static startGraphsVector(O,b){O.startVector(4,b,4)}static endAttribute(O){return O.endObject()}static createAttribute(O,b,j,U,J,nt,rt,ot,at,ut,st,ct,dt,pt){return q.startAttribute(O),q.addName(O,b),q.addDocString(O,j),q.addType(O,U),q.addF(O,J),q.addI(O,nt),q.addS(O,rt),q.addT(O,ot),q.addG(O,at),q.addFloats(O,ut),q.addInts(O,st),q.addStrings(O,ct),q.addTensors(O,dt),q.addGraphs(O,pt),q.endAttribute(O)}}et.Attribute=q})(tt.fbs||(tt.fbs={}))})(Y.experimental||(Y.experimental={}))}(F.onnxruntime||(F.onnxruntime={})),function(Y){(function(tt){(function(et){class q{constructor(){this.bb=null,this.bb_pos=0}__init(O,b){return this.bb_pos=O,this.bb=b,this}static getRootAsGraph(O,b){return(b||new q).__init(O.readInt32(O.position())+O.position(),O)}static getSizePrefixedRootAsGraph(O,b){return O.setPosition(O.position()+X.flatbuffers.SIZE_PREFIX_LENGTH),(b||new q).__init(O.readInt32(O.position())+O.position(),O)}initializers(O,b){let j=this.bb.__offset(this.bb_pos,4);return j?(b||new Y.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+j)+4*O),this.bb):null}initializersLength(){let O=this.bb.__offset(this.bb_pos,4);return O?this.bb.__vector_len(this.bb_pos+O):0}nodeArgs(O,b){let j=this.bb.__offset(this.bb_pos,6);return j?(b||new Y.experimental.fbs.ValueInfo).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+j)+4*O),this.bb):null}nodeArgsLength(){let O=this.bb.__offset(this.bb_pos,6);return O?this.bb.__vector_len(this.bb_pos+O):0}nodes(O,b){let j=this.bb.__offset(this.bb_pos,8);return j?(b||new Y.experimental.fbs.Node).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+j)+4*O),this.bb):null}nodesLength(){let O=this.bb.__offset(this.bb_pos,8);return O?this.bb.__vector_len(this.bb_pos+O):0}maxNodeIndex(){let O=this.bb.__offset(this.bb_pos,10);return O?this.bb.readUint32(this.bb_pos+O):0}nodeEdges(O,b){let j=this.bb.__offset(this.bb_pos,12);return j?(b||new Y.experimental.fbs.NodeEdge).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+j)+4*O),this.bb):null}nodeEdgesLength(){let O=this.bb.__offset(this.bb_pos,12);return O?this.bb.__vector_len(this.bb_pos+O):0}inputs(O,b){let j=this.bb.__offset(this.bb_pos,14);return j?this.bb.__string(this.bb.__vector(this.bb_pos+j)+4*O,b):null}inputsLength(){let O=this.bb.__offset(this.bb_pos,14);return O?this.bb.__vector_len(this.bb_pos+O):0}outputs(O,b){let j=this.bb.__offset(this.bb_pos,16);return j?this.bb.__string(this.bb.__vector(this.bb_pos+j)+4*O,b):null}outputsLength(){let O=this.bb.__offset(this.bb_pos,16);return O?this.bb.__vector_len(this.bb_pos+O):0}sparseInitializers(O,b){let j=this.bb.__offset(this.bb_pos,18);return j?(b||new Y.experimental.fbs.SparseTensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+j)+4*O),this.bb):null}sparseInitializersLength(){let O=this.bb.__offset(this.bb_pos,18);return O?this.bb.__vector_len(this.bb_pos+O):0}static startGraph(O){O.startObject(8)}static addInitializers(O,b){O.addFieldOffset(0,b,0)}static createInitializersVector(O,b){O.startVector(4,b.length,4);for(let j=b.length-1;j>=0;j--)O.addOffset(b[j]);return O.endVector()}static startInitializersVector(O,b){O.startVector(4,b,4)}static addNodeArgs(O,b){O.addFieldOffset(1,b,0)}static createNodeArgsVector(O,b){O.startVector(4,b.length,4);for(let j=b.length-1;j>=0;j--)O.addOffset(b[j]);return O.endVector()}static startNodeArgsVector(O,b){O.startVector(4,b,4)}static addNodes(O,b){O.addFieldOffset(2,b,0)}static createNodesVector(O,b){O.startVector(4,b.length,4);for(let j=b.length-1;j>=0;j--)O.addOffset(b[j]);return O.endVector()}static startNodesVector(O,b){O.startVector(4,b,4)}static addMaxNodeIndex(O,b){O.addFieldInt32(3,b,0)}static addNodeEdges(O,b){O.addFieldOffset(4,b,0)}static createNodeEdgesVector(O,b){O.startVector(4,b.length,4);for(let j=b.length-1;j>=0;j--)O.addOffset(b[j]);return O.endVector()}static startNodeEdgesVector(O,b){O.startVector(4,b,4)}static addInputs(O,b){O.addFieldOffset(5,b,0)}static createInputsVector(O,b){O.startVector(4,b.length,4);for(let j=b.length-1;j>=0;j--)O.addOffset(b[j]);return O.endVector()}static startInputsVector(O,b){O.startVector(4,b,4)}static addOutputs(O,b){O.addFieldOffset(6,b,0)}static createOutputsVector(O,b){O.startVector(4,b.length,4);for(let j=b.length-1;j>=0;j--)O.addOffset(b[j]);return O.endVector()}static startOutputsVector(O,b){O.startVector(4,b,4)}static addSparseInitializers(O,b){O.addFieldOffset(7,b,0)}static createSparseInitializersVector(O,b){O.startVector(4,b.length,4);for(let j=b.length-1;j>=0;j--)O.addOffset(b[j]);return O.endVector()}static startSparseInitializersVector(O,b){O.startVector(4,b,4)}static endGraph(O){return O.endObject()}static createGraph(O,b,j,U,J,nt,rt,ot,at){return q.startGraph(O),q.addInitializers(O,b),q.addNodeArgs(O,j),q.addNodes(O,U),q.addMaxNodeIndex(O,J),q.addNodeEdges(O,nt),q.addInputs(O,rt),q.addOutputs(O,ot),q.addSparseInitializers(O,at),q.endGraph(O)}}et.Graph=q})(tt.fbs||(tt.fbs={}))})(Y.experimental||(Y.experimental={}))}(F.onnxruntime||(F.onnxruntime={})),function(Y){(function(tt){(function(et){class q{constructor(){this.bb=null,this.bb_pos=0}__init(O,b){return this.bb_pos=O,this.bb=b,this}static getRootAsModel(O,b){return(b||new q).__init(O.readInt32(O.position())+O.position(),O)}static getSizePrefixedRootAsModel(O,b){return O.setPosition(O.position()+X.flatbuffers.SIZE_PREFIX_LENGTH),(b||new q).__init(O.readInt32(O.position())+O.position(),O)}irVersion(){let O=this.bb.__offset(this.bb_pos,4);return O?this.bb.readInt64(this.bb_pos+O):this.bb.createLong(0,0)}opsetImport(O,b){let j=this.bb.__offset(this.bb_pos,6);return j?(b||new Y.experimental.fbs.OperatorSetId).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+j)+4*O),this.bb):null}opsetImportLength(){let O=this.bb.__offset(this.bb_pos,6);return O?this.bb.__vector_len(this.bb_pos+O):0}producerName(O){let b=this.bb.__offset(this.bb_pos,8);return b?this.bb.__string(this.bb_pos+b,O):null}producerVersion(O){let b=this.bb.__offset(this.bb_pos,10);return b?this.bb.__string(this.bb_pos+b,O):null}domain(O){let b=this.bb.__offset(this.bb_pos,12);return b?this.bb.__string(this.bb_pos+b,O):null}modelVersion(){let O=this.bb.__offset(this.bb_pos,14);return O?this.bb.readInt64(this.bb_pos+O):this.bb.createLong(0,0)}docString(O){let b=this.bb.__offset(this.bb_pos,16);return b?this.bb.__string(this.bb_pos+b,O):null}graph(O){let b=this.bb.__offset(this.bb_pos,18);return b?(O||new Y.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+b),this.bb):null}graphDocString(O){let b=this.bb.__offset(this.bb_pos,20);return b?this.bb.__string(this.bb_pos+b,O):null}static startModel(O){O.startObject(9)}static addIrVersion(O,b){O.addFieldInt64(0,b,O.createLong(0,0))}static addOpsetImport(O,b){O.addFieldOffset(1,b,0)}static createOpsetImportVector(O,b){O.startVector(4,b.length,4);for(let j=b.length-1;j>=0;j--)O.addOffset(b[j]);return O.endVector()}static startOpsetImportVector(O,b){O.startVector(4,b,4)}static addProducerName(O,b){O.addFieldOffset(2,b,0)}static addProducerVersion(O,b){O.addFieldOffset(3,b,0)}static addDomain(O,b){O.addFieldOffset(4,b,0)}static addModelVersion(O,b){O.addFieldInt64(5,b,O.createLong(0,0))}static addDocString(O,b){O.addFieldOffset(6,b,0)}static addGraph(O,b){O.addFieldOffset(7,b,0)}static addGraphDocString(O,b){O.addFieldOffset(8,b,0)}static endModel(O){return O.endObject()}static createModel(O,b,j,U,J,nt,rt,ot,at,ut){return q.startModel(O),q.addIrVersion(O,b),q.addOpsetImport(O,j),q.addProducerName(O,U),q.addProducerVersion(O,J),q.addDomain(O,nt),q.addModelVersion(O,rt),q.addDocString(O,ot),q.addGraph(O,at),q.addGraphDocString(O,ut),q.endModel(O)}}et.Model=q})(tt.fbs||(tt.fbs={}))})(Y.experimental||(Y.experimental={}))}(F.onnxruntime||(F.onnxruntime={})),function(Y){(function(tt){(function(et){class q{constructor(){this.bb=null,this.bb_pos=0}__init(O,b){return this.bb_pos=O,this.bb=b,this}static getRootAsKernelCreateInfos(O,b){return(b||new q).__init(O.readInt32(O.position())+O.position(),O)}static getSizePrefixedRootAsKernelCreateInfos(O,b){return O.setPosition(O.position()+X.flatbuffers.SIZE_PREFIX_LENGTH),(b||new q).__init(O.readInt32(O.position())+O.position(),O)}nodeIndices(O){let b=this.bb.__offset(this.bb_pos,4);return b?this.bb.readUint32(this.bb.__vector(this.bb_pos+b)+4*O):0}nodeIndicesLength(){let O=this.bb.__offset(this.bb_pos,4);return O?this.bb.__vector_len(this.bb_pos+O):0}nodeIndicesArray(){let O=this.bb.__offset(this.bb_pos,4);return O?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+O),this.bb.__vector_len(this.bb_pos+O)):null}kernelDefHashes(O){let b=this.bb.__offset(this.bb_pos,6);return b?this.bb.readUint64(this.bb.__vector(this.bb_pos+b)+8*O):this.bb.createLong(0,0)}kernelDefHashesLength(){let O=this.bb.__offset(this.bb_pos,6);return O?this.bb.__vector_len(this.bb_pos+O):0}static startKernelCreateInfos(O){O.startObject(2)}static addNodeIndices(O,b){O.addFieldOffset(0,b,0)}static createNodeIndicesVector(O,b){O.startVector(4,b.length,4);for(let j=b.length-1;j>=0;j--)O.addInt32(b[j]);return O.endVector()}static startNodeIndicesVector(O,b){O.startVector(4,b,4)}static addKernelDefHashes(O,b){O.addFieldOffset(1,b,0)}static createKernelDefHashesVector(O,b){O.startVector(8,b.length,8);for(let j=b.length-1;j>=0;j--)O.addInt64(b[j]);return O.endVector()}static startKernelDefHashesVector(O,b){O.startVector(8,b,8)}static endKernelCreateInfos(O){return O.endObject()}static createKernelCreateInfos(O,b,j){return q.startKernelCreateInfos(O),q.addNodeIndices(O,b),q.addKernelDefHashes(O,j),q.endKernelCreateInfos(O)}}et.KernelCreateInfos=q})(tt.fbs||(tt.fbs={}))})(Y.experimental||(Y.experimental={}))}(F.onnxruntime||(F.onnxruntime={})),function(Y){(function(tt){(function(et){class q{constructor(){this.bb=null,this.bb_pos=0}__init(O,b){return this.bb_pos=O,this.bb=b,this}static getRootAsSubGraphSessionState(O,b){return(b||new q).__init(O.readInt32(O.position())+O.position(),O)}static getSizePrefixedRootAsSubGraphSessionState(O,b){return O.setPosition(O.position()+X.flatbuffers.SIZE_PREFIX_LENGTH),(b||new q).__init(O.readInt32(O.position())+O.position(),O)}graphId(O){let b=this.bb.__offset(this.bb_pos,4);return b?this.bb.__string(this.bb_pos+b,O):null}sessionState(O){let b=this.bb.__offset(this.bb_pos,6);return b?(O||new Y.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+b),this.bb):null}static startSubGraphSessionState(O){O.startObject(2)}static addGraphId(O,b){O.addFieldOffset(0,b,0)}static addSessionState(O,b){O.addFieldOffset(1,b,0)}static endSubGraphSessionState(O){let b=O.endObject();return O.requiredField(b,4),b}static createSubGraphSessionState(O,b,j){return q.startSubGraphSessionState(O),q.addGraphId(O,b),q.addSessionState(O,j),q.endSubGraphSessionState(O)}}et.SubGraphSessionState=q})(tt.fbs||(tt.fbs={}))})(Y.experimental||(Y.experimental={}))}(F.onnxruntime||(F.onnxruntime={})),function(Y){(function(tt){(function(et){class q{constructor(){this.bb=null,this.bb_pos=0}__init(O,b){return this.bb_pos=O,this.bb=b,this}static getRootAsSessionState(O,b){return(b||new q).__init(O.readInt32(O.position())+O.position(),O)}static getSizePrefixedRootAsSessionState(O,b){return O.setPosition(O.position()+X.flatbuffers.SIZE_PREFIX_LENGTH),(b||new q).__init(O.readInt32(O.position())+O.position(),O)}kernels(O){let b=this.bb.__offset(this.bb_pos,4);return b?(O||new Y.experimental.fbs.KernelCreateInfos).__init(this.bb.__indirect(this.bb_pos+b),this.bb):null}subGraphSessionStates(O,b){let j=this.bb.__offset(this.bb_pos,6);return j?(b||new Y.experimental.fbs.SubGraphSessionState).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+j)+4*O),this.bb):null}subGraphSessionStatesLength(){let O=this.bb.__offset(this.bb_pos,6);return O?this.bb.__vector_len(this.bb_pos+O):0}static startSessionState(O){O.startObject(2)}static addKernels(O,b){O.addFieldOffset(0,b,0)}static addSubGraphSessionStates(O,b){O.addFieldOffset(1,b,0)}static createSubGraphSessionStatesVector(O,b){O.startVector(4,b.length,4);for(let j=b.length-1;j>=0;j--)O.addOffset(b[j]);return O.endVector()}static startSubGraphSessionStatesVector(O,b){O.startVector(4,b,4)}static endSessionState(O){return O.endObject()}static createSessionState(O,b,j){return q.startSessionState(O),q.addKernels(O,b),q.addSubGraphSessionStates(O,j),q.endSessionState(O)}}et.SessionState=q})(tt.fbs||(tt.fbs={}))})(Y.experimental||(Y.experimental={}))}(F.onnxruntime||(F.onnxruntime={})),function(Y){(function(tt){(function(et){class q{constructor(){this.bb=null,this.bb_pos=0}__init(O,b){return this.bb_pos=O,this.bb=b,this}static getRootAsInferenceSession(O,b){return(b||new q).__init(O.readInt32(O.position())+O.position(),O)}static getSizePrefixedRootAsInferenceSession(O,b){return O.setPosition(O.position()+X.flatbuffers.SIZE_PREFIX_LENGTH),(b||new q).__init(O.readInt32(O.position())+O.position(),O)}static bufferHasIdentifier(O){return O.__has_identifier("ORTM")}ortVersion(O){let b=this.bb.__offset(this.bb_pos,4);return b?this.bb.__string(this.bb_pos+b,O):null}model(O){let b=this.bb.__offset(this.bb_pos,6);return b?(O||new Y.experimental.fbs.Model).__init(this.bb.__indirect(this.bb_pos+b),this.bb):null}sessionState(O){let b=this.bb.__offset(this.bb_pos,8);return b?(O||new Y.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+b),this.bb):null}static startInferenceSession(O){O.startObject(3)}static addOrtVersion(O,b){O.addFieldOffset(0,b,0)}static addModel(O,b){O.addFieldOffset(1,b,0)}static addSessionState(O,b){O.addFieldOffset(2,b,0)}static endInferenceSession(O){return O.endObject()}static finishInferenceSessionBuffer(O,b){O.finish(b,"ORTM")}static finishSizePrefixedInferenceSessionBuffer(O,b){O.finish(b,"ORTM",!0)}static createInferenceSession(O,b,j,U){return q.startInferenceSession(O),q.addOrtVersion(O,b),q.addModel(O,j),q.addSessionState(O,U),q.endInferenceSession(O)}}et.InferenceSession=q})(tt.fbs||(tt.fbs={}))})(Y.experimental||(Y.experimental={}))}(F.onnxruntime||(F.onnxruntime={}))},1723:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.OnnxjsSessionHandler=void 0;const X=W(8453),K=W(9240);F.OnnxjsSessionHandler=class{constructor(Q){this.session=Q,this.inputNames=this.session.inputNames,this.outputNames=this.session.outputNames}async dispose(){}async run(Q,Y,tt){const et=new Map;for(const O in Q)if(Object.hasOwnProperty.call(Q,O)){const b=Q[O];et.set(O,new K.Tensor(b.dims,b.type,void 0,void 0,b.data))}const q=await this.session.run(et),G={};return q.forEach((O,b)=>{G[b]=new X.Tensor(O.type,O.data,O.dims)}),G}startProfiling(){this.session.startProfiling()}endProfiling(){this.session.endProfiling()}}},6027:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.Session=void 0;const X=W(7067),K=W(1296),Q=W(1975),Y=W(6496),tt=W(1315),et=W(1745);F.Session=class{constructor(q={}){this._initialized=!1,this.backendHint=q.backendHint,this.profiler=tt.Profiler.create(q.profiler),this.context={profiler:this.profiler,graphInputTypes:[],graphInputDims:[]}}get inputNames(){return this._model.graph.getInputNames()}get outputNames(){return this._model.graph.getOutputNames()}startProfiling(){this.profiler.start()}endProfiling(){this.profiler.stop()}async loadModel(q,G,O){await this.profiler.event("session","Session.loadModel",async()=>{const b=await(0,Q.resolveBackend)(this.backendHint);if(this.sessionHandler=b.createSessionHandler(this.context),this._model=new et.Model,typeof q=="string"){const j=q.endsWith(".ort");if(typeof fetch>"u"){const U=await(0,K.promisify)(X.readFile)(q);this.initialize(U,j)}else{const U=await fetch(q),J=await U.arrayBuffer();this.initialize(new Uint8Array(J),j)}}else if(ArrayBuffer.isView(q))this.initialize(q);else{const j=new Uint8Array(q,G||0,O||q.byteLength);this.initialize(j)}})}initialize(q,G){if(this._initialized)throw new Error("already initialized");this.profiler.event("session","Session.initialize",()=>{const O=this.sessionHandler.transformGraph?this.sessionHandler:void 0;this._model.load(q,O,G),this.sessionHandler.onGraphInitialized&&this.sessionHandler.onGraphInitialized(this._model.graph),this.initializeOps(this._model.graph),this._executionPlan=new Y.ExecutionPlan(this._model.graph,this._ops,this.profiler)}),this._initialized=!0}async run(q){if(!this._initialized)throw new Error("session not initialized yet");return this.profiler.event("session","Session.run",async()=>{const G=this.normalizeAndValidateInputs(q),O=await this._executionPlan.execute(this.sessionHandler,G);return this.createOutput(O)})}normalizeAndValidateInputs(q){const G=this._model.graph.getInputNames();if(Array.isArray(q)){if(q.length!==G.length)throw new Error(`incorrect input array length: expected ${G.length} but got ${q.length}`)}else{if(q.size!==G.length)throw new Error(`incorrect input map size: expected ${G.length} but got ${q.size}`);const O=new Array(q.size);let b=0;for(let j=0;j<G.length;++j){const U=q.get(G[j]);if(!U)throw new Error(`missing input tensor for: '${name}'`);O[b++]=U}q=O}if(this.context.graphInputTypes&&this.context.graphInputTypes.length!==0&&this.context.graphInputDims&&this.context.graphInputDims.length!==0)this.validateInputTensorDims(this.context.graphInputDims,q,!1);else{const O=this._model.graph.getInputIndices(),b=this._model.graph.getValues(),j=new Array(O.length);for(let U=0;U<O.length;++U){const J=b[O[U]];j[U]=J.type.shape.dims,this.context.graphInputTypes.push(J.type.tensorType),this.context.graphInputDims.push(q[U].dims)}this.validateInputTensorDims(j,q,!0)}return this.validateInputTensorTypes(this.context.graphInputTypes,q),q}validateInputTensorTypes(q,G){for(let O=0;O<G.length;O++){const b=q[O],j=G[O].type;if(b!==j)throw new Error(`input tensor[${O}] check failed: expected type '${b}' but got ${j}`)}}validateInputTensorDims(q,G,O){for(let b=0;b<G.length;b++){const j=q[b],U=G[b].dims;if(!this.compareTensorDims(j,U,O))throw new Error(`input tensor[${b}] check failed: expected shape '[${j.join(",")}]' but got [${U.join(",")}]`)}}compareTensorDims(q,G,O){if(q.length!==G.length)return!1;for(let b=0;b<q.length;++b)if(q[b]!==G[b]&&(!O||q[b]!==0))return!1;return!0}createOutput(q){const G=this._model.graph.getOutputNames();if(q.length!==G.length)throw new Error("expected number of outputs do not match number of generated outputs");const O=new Map;for(let b=0;b<G.length;++b)O.set(G[b],q[b]);return O}initializeOps(q){const G=q.getNodes();this._ops=new Array(G.length);for(let O=0;O<G.length;O++)this._ops[O]=this.sessionHandler.resolve(G[O],this._model.opsets,q)}}},9240:function(it,F,W){var X=this&&this.__importDefault||function(J){return J&&J.__esModule?J:{default:J}};Object.defineProperty(F,"__esModule",{value:!0}),F.Tensor=void 0;const K=W(3442),Q=X(W(3720)),Y=W(1446),tt=W(1287),et=W(7273);var q=tt.onnxruntime.experimental.fbs;class G{get data(){if(this.cache===void 0){const nt=this.dataProvider(this.dataId);if(nt.length!==this.size)throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");this.cache=nt}return this.cache}get stringData(){if(this.type!=="string")throw new TypeError("data type is not string");return this.data}get integerData(){switch(this.type){case"uint8":case"int8":case"uint16":case"int16":case"int32":case"uint32":case"bool":return this.data;default:throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)")}}get floatData(){switch(this.type){case"float32":case"float64":return this.data;default:throw new TypeError("data type is not float (float32, float64)")}}get numberData(){if(this.type!=="string")return this.data;throw new TypeError("type cannot be non-number (string)")}get(nt){return this.data[et.ShapeUtil.indicesToOffset(nt,this.strides)]}set(nt,rt){this.data[et.ShapeUtil.indicesToOffset(nt,this.strides)]=rt}async getData(){return this.cache===void 0&&(this.cache=await this.asyncDataProvider(this.dataId)),this.cache}get strides(){return this._strides||(this._strides=et.ShapeUtil.computeStrides(this.dims)),this._strides}constructor(nt,rt,ot,at,ut,st=K.Guid.create()){this.dims=nt,this.type=rt,this.dataProvider=ot,this.asyncDataProvider=at,this.cache=ut,this.dataId=st,this.size=et.ShapeUtil.validateDimsAndCalcSize(nt);const ct=this.size,dt=ot===void 0&&at===void 0&&ut===void 0;if(ut!==void 0&&ut.length!==ct)throw new RangeError("Input dims doesn't match data length.");if(rt==="string"){if(!(ut===void 0||Array.isArray(ut)&&ut.every(pt=>typeof pt=="string")))throw new TypeError("cache should be a string array");dt&&(this.cache=new Array(ct))}else{if(ut!==void 0){const pt=b(rt);if(!(ut instanceof pt))throw new TypeError(`cache should be type ${pt.name}`)}if(dt){const pt=new ArrayBuffer(ct*function(lt){switch(lt){case"bool":case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;case"float64":return 8;default:throw new Error(`cannot calculate sizeof() on type ${lt}`)}}(rt));this.cache=function(lt,ft){return new(b(ft))(lt)}(pt,rt)}}}static fromProto(nt){if(!nt)throw new Error("cannot construct Value from an empty tensor");const rt=et.ProtoUtil.tensorDataTypeFromProto(nt.dataType),ot=et.ProtoUtil.tensorDimsFromProto(nt.dims),at=new G(ot,rt);if(rt==="string")nt.stringData.forEach((ut,st)=>{at.data[st]=(0,et.decodeUtf8String)(ut)});else if(nt.rawData&&typeof nt.rawData.byteLength=="number"&&nt.rawData.byteLength>0){const ut=at.data,st=new DataView(nt.rawData.buffer,nt.rawData.byteOffset,nt.rawData.byteLength),ct=O(nt.dataType),dt=nt.rawData.byteLength/ct;if(nt.rawData.byteLength%ct!=0)throw new Error("invalid buffer length");if(ut.length!==dt)throw new Error("buffer length mismatch");for(let pt=0;pt<dt;pt++){const lt=U(st,nt.dataType,pt*ct);ut[pt]=lt}}else{let ut;switch(nt.dataType){case Y.onnx.TensorProto.DataType.FLOAT:ut=nt.floatData;break;case Y.onnx.TensorProto.DataType.INT32:case Y.onnx.TensorProto.DataType.INT16:case Y.onnx.TensorProto.DataType.UINT16:case Y.onnx.TensorProto.DataType.INT8:case Y.onnx.TensorProto.DataType.UINT8:case Y.onnx.TensorProto.DataType.BOOL:ut=nt.int32Data;break;case Y.onnx.TensorProto.DataType.INT64:ut=nt.int64Data;break;case Y.onnx.TensorProto.DataType.DOUBLE:ut=nt.doubleData;break;case Y.onnx.TensorProto.DataType.UINT32:case Y.onnx.TensorProto.DataType.UINT64:ut=nt.uint64Data;break;default:throw new Error("unspecific error")}if(ut==null)throw new Error("failed to populate data from a tensorproto value");const st=at.data;if(st.length!==ut.length)throw new Error("array length mismatch");for(let ct=0;ct<ut.length;ct++){const dt=ut[ct];Q.default.isLong(dt)?st[ct]=j(dt,nt.dataType):st[ct]=dt}}return at}static fromData(nt,rt,ot){return new G(rt,ot,void 0,void 0,nt)}static fromOrtTensor(nt){if(!nt)throw new Error("cannot construct Value from an empty tensor");const rt=et.ProtoUtil.tensorDimsFromORTFormat(nt),ot=et.ProtoUtil.tensorDataTypeFromProto(nt.dataType()),at=new G(rt,ot);if(ot==="string")for(let ut=0;ut<nt.stringDataLength();ut++)at.data[ut]=nt.stringData(ut);else if(nt.rawDataArray()&&typeof nt.rawDataLength()=="number"&&nt.rawDataLength()>0){const ut=at.data,st=new DataView(nt.rawDataArray().buffer,nt.rawDataArray().byteOffset,nt.rawDataLength()),ct=O(nt.dataType()),dt=nt.rawDataLength()/ct;if(nt.rawDataLength()%ct!=0)throw new Error("invalid buffer length");if(ut.length!==dt)throw new Error("buffer length mismatch");for(let pt=0;pt<dt;pt++){const lt=U(st,nt.dataType(),pt*ct);ut[pt]=lt}}return at}}function O(J){switch(J){case Y.onnx.TensorProto.DataType.UINT8:case Y.onnx.TensorProto.DataType.INT8:case Y.onnx.TensorProto.DataType.BOOL:return 1;case Y.onnx.TensorProto.DataType.UINT16:case Y.onnx.TensorProto.DataType.INT16:return 2;case Y.onnx.TensorProto.DataType.FLOAT:case Y.onnx.TensorProto.DataType.INT32:case Y.onnx.TensorProto.DataType.UINT32:return 4;case Y.onnx.TensorProto.DataType.INT64:case Y.onnx.TensorProto.DataType.DOUBLE:case Y.onnx.TensorProto.DataType.UINT64:return 8;default:throw new Error(`cannot calculate sizeof() on type ${Y.onnx.TensorProto.DataType[J]}`)}}function b(J){switch(J){case"bool":case"uint8":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"uint16":return Uint16Array;case"int32":return Int32Array;case"uint32":return Uint32Array;case"float32":return Float32Array;case"float64":return Float64Array;default:throw new Error("unspecified error")}}function j(J,nt){if(nt===Y.onnx.TensorProto.DataType.INT64||nt===q.TensorDataType.INT64){if(J.greaterThanOrEqual(2147483648)||J.lessThan(-2147483648))throw new TypeError("int64 is not supported")}else{if(nt!==Y.onnx.TensorProto.DataType.UINT32&&nt!==q.TensorDataType.UINT32&&nt!==Y.onnx.TensorProto.DataType.UINT64&&nt!==q.TensorDataType.UINT64)throw new TypeError(`not a LONG type: ${Y.onnx.TensorProto.DataType[nt]}`);if(J.greaterThanOrEqual(4294967296)||J.lessThan(0))throw new TypeError("uint64 is not supported")}return J.toNumber()}function U(J,nt,rt){switch(nt){case Y.onnx.TensorProto.DataType.BOOL:case Y.onnx.TensorProto.DataType.UINT8:return J.getUint8(rt);case Y.onnx.TensorProto.DataType.INT8:return J.getInt8(rt);case Y.onnx.TensorProto.DataType.UINT16:return J.getUint16(rt,!0);case Y.onnx.TensorProto.DataType.INT16:return J.getInt16(rt,!0);case Y.onnx.TensorProto.DataType.FLOAT:return J.getFloat32(rt,!0);case Y.onnx.TensorProto.DataType.INT32:return J.getInt32(rt,!0);case Y.onnx.TensorProto.DataType.UINT32:return J.getUint32(rt,!0);case Y.onnx.TensorProto.DataType.INT64:return j(Q.default.fromBits(J.getUint32(rt,!0),J.getUint32(rt+4,!0),!1),nt);case Y.onnx.TensorProto.DataType.DOUBLE:return J.getFloat64(rt,!0);case Y.onnx.TensorProto.DataType.UINT64:return j(Q.default.fromBits(J.getUint32(rt,!0),J.getUint32(rt+4,!0),!0),nt);default:throw new Error(`cannot read from DataView for type ${Y.onnx.TensorProto.DataType[nt]}`)}}F.Tensor=G},7273:function(it,F,W){var X=this&&this.__importDefault||function(nt){return nt&&nt.__esModule?nt:{default:nt}};Object.defineProperty(F,"__esModule",{value:!0}),F.decodeUtf8String=F.MAX_CLIP=F.MIN_CLIP=F.PoolConvUtil=F.ReduceUtil=F.SplitUtil=F.MathUtil=F.ShapeUtil=F.LongUtil=F.ProtoUtil=F.GemmUtil=F.arrayCopyHelper=F.BroadcastUtil=F.MatMulUtil=F.ArrayUtil=F.assert=F.checkInputsShape=void 0;const K=W(5686),Q=X(W(3720)),Y=W(1446),tt=W(9240);F.checkInputsShape=function(nt,...rt){if(!nt||nt.length!==rt.length)return!1;for(let ot=0;ot<nt.length;ot++)if(!nt[ot].dims||nt[ot].dims.length!==rt[ot])return!1;return!0},F.assert=function(nt,rt){if(!nt)throw new Error(typeof rt=="string"?rt:rt())},F.ArrayUtil=class{static arraysEqual(nt,rt){if(nt.length!==rt.length)return!1;for(let ot=0;ot<nt.length;ot++)if(nt[ot]!==rt[ot])return!1;return!0}};class et{static preprocessInputShapes(rt,ot){return[rt.length===1?[1,rt[0]]:rt,ot.length===1?[ot[0],1]:ot]}static postprocessOutputShape(rt,ot,at){ot===1&&rt.splice(rt.length-2,1),at===1&&rt.pop()}static calcMatMulShape(rt,ot){return rt[1]!==ot[0]?void 0:[rt[0],ot[1]]}}F.MatMulUtil=et;class q{static calcShape(rt,ot,at=!1){const ut=rt.length,st=ot.length;if(ut===0)return ot;if(st===0)return rt;const ct=Math.max(rt.length,ot.length),dt=new Array(ct);if(at){if(ut<2||st<2)return;const pt=et.calcMatMulShape([rt[ut-2],rt[ut-1]],[ot[st-2],ot[st-1]]);if(pt===void 0)return;[dt[ct-2],dt[ct-1]]=pt}for(let pt=at?3:1;pt<=ct;pt++){const lt=ut-pt<0?1:rt[ut-pt],ft=st-pt<0?1:ot[st-pt];if(lt!==ft&&lt>1&&ft>1)return;dt[ct-pt]=Math.max(lt,ft)}return dt}static index(rt,ot){const at=new Array(ot.length);return q.fillIndex(rt,ot,at),at}static fillIndex(rt,ot,at){const ut=rt.length-ot.length;for(let st=0;st<ot.length;st++)at[st]=rt[ut+st]%ot[st]}static calc(rt,ot,at,ut,st){const ct=q.calcShape(rt.dims,ot.dims);if(ct){if(ut&&!b.areEqual(ct,rt.dims))return;const dt=b.size(ct),pt=ut?rt:new tt.Tensor(ct,st||rt.type);if(ct.length===0)pt.set([],at(rt.get([]),ot.get([])));else{const lt=new Array(ct.length),ft=new Array(rt.dims.length),gt=new Array(ot.dims.length);let _t,wt=0,bt=0,Ot=!1,vt=!1;rt.dims.length===0&&(wt=rt.get([]),Ot=!0),ot.dims.length===0&&(bt=ot.get([]),vt=!0);for(let xt=0;xt<dt;xt++){_t=xt;for(let Rt=ct.length-1;Rt>=0;Rt--)lt[Rt]=_t%ct[Rt],_t=Math.floor(_t/ct[Rt]);Ot||(q.fillIndex(lt,rt.dims,ft),wt=rt.get(ft)),vt||(q.fillIndex(lt,ot.dims,gt),bt=ot.get(gt)),pt.set(lt,at(wt,bt))}}return pt}}static isValidBroadcast(rt,ot){const at=rt.length,ut=ot.length;if(at>ut)return!1;for(let st=1;st<=at;st++)if(rt[at-st]!==1&&rt[at-st]!==ot[ut-st])return!1;return!0}static getBroadcastDims(rt,ot){const at=rt.length,ut=[];for(let st=0;st<at;st++){const ct=at-1-st,dt=rt[ct]||1;(ot[ot.length-1-st]||1)>1&&dt===1&&ut.unshift(ct)}return ut}}F.BroadcastUtil=q,F.arrayCopyHelper=function(nt,rt,ot,at,ut){if(at<0||at>=rt.length)throw new Error("sourceIndex out of bounds");if(ot<0||ot>=nt.length)throw new Error("targetIndex out of bounds");if(at+ut>rt.length)throw new Error("source indices to be copied are outside bounds");if(ot+ut>nt.length)throw new Error("target array is too small to hold result");for(let st=0;st<ut;st++)nt[ot+st]=rt[at+st]},F.GemmUtil=class{static getShapeOfGemmResult(nt,rt,ot,at,ut){if(nt.length!==2||ot.length!==2)throw new Error("shape need to be of size 2");let st,ct,dt;rt?(st=nt[1],ct=nt[0]):(st=nt[0],ct=nt[1]);let pt=-1;if(at?(dt=ot[0],pt=1):(dt=ot[1],pt=0),ot[pt]!==ct)throw new Error("dimension mismatch");if(st<=0||dt<=0||ct<=0)throw new Error("invalid shape specified");if(ut&&!q.isValidBroadcast(ut,[st,dt]))throw new Error("gemm: invalid bias shape for broadcast");return[st,dt,ct]}};class G{static tensorDataTypeFromProto(rt){switch(rt){case Y.onnx.TensorProto.DataType.INT8:return"int8";case Y.onnx.TensorProto.DataType.UINT8:return"uint8";case Y.onnx.TensorProto.DataType.BOOL:return"bool";case Y.onnx.TensorProto.DataType.INT16:return"int16";case Y.onnx.TensorProto.DataType.UINT16:return"uint16";case Y.onnx.TensorProto.DataType.INT32:return"int32";case Y.onnx.TensorProto.DataType.UINT32:return"uint32";case Y.onnx.TensorProto.DataType.FLOAT:return"float32";case Y.onnx.TensorProto.DataType.DOUBLE:return"float64";case Y.onnx.TensorProto.DataType.STRING:return"string";case Y.onnx.TensorProto.DataType.INT64:return"int32";case Y.onnx.TensorProto.DataType.UINT64:return"uint32";default:throw new Error(`unsupported data type: ${Y.onnx.TensorProto.DataType[rt]}`)}}static tensorDataTypeStringToEnum(rt){switch(rt){case"int8":return Y.onnx.TensorProto.DataType.INT8;case"uint8":return Y.onnx.TensorProto.DataType.UINT8;case"bool":return Y.onnx.TensorProto.DataType.BOOL;case"int16":return Y.onnx.TensorProto.DataType.INT16;case"uint16":return Y.onnx.TensorProto.DataType.UINT16;case"int32":return Y.onnx.TensorProto.DataType.INT32;case"uint32":return Y.onnx.TensorProto.DataType.UINT32;case"float32":return Y.onnx.TensorProto.DataType.FLOAT;case"float64":return Y.onnx.TensorProto.DataType.DOUBLE;case"string":return Y.onnx.TensorProto.DataType.STRING;case"int64":return Y.onnx.TensorProto.DataType.INT64;case"uint64":return Y.onnx.TensorProto.DataType.UINT64;default:throw new Error(`unsupported data type: ${rt}`)}}static tensorDimsFromProto(rt){return rt.map(ot=>Q.default.isLong(ot)?ot.toNumber():ot)}static tensorValueTypeFromProto(rt){return{tensorType:G.tensorDataTypeFromProto(rt.elemType),shape:{dims:G.tensorDimsFromProto(rt.shape.dim.map(ot=>ot.dimValue))}}}static tensorDimsFromORTFormat(rt){const ot=[];for(let at=0;at<rt.dimsLength();at++)ot.push(O.longToNumber(rt.dims(at)));return ot}static tensorAttributesFromORTFormat(rt){const ot=[];for(let at=0;at<rt.attributesLength();at++)ot.push(rt.attributes(at));return ot}}F.ProtoUtil=G;class O{static longToNumber(rt,ot){return Q.default.isLong(rt)?rt.toNumber():rt instanceof K.flatbuffers.Long?Q.default.fromValue({low:rt.low,high:rt.high,unsigned:ot!=null&&ot}).toNumber():rt}static isLong(rt){return Q.default.isLong(rt)||rt instanceof K.flatbuffers.Long}}F.LongUtil=O;class b{static size(rt){return b.getSizeFromDimensionRange(rt,0,rt.length)}static sizeFromDimension(rt,ot){if(ot<0||ot>rt.length)throw new Error(`invalid dimension of ${ot} for sizeFromDimension as Tensor has ${rt.length} dimensions.`);return b.getSizeFromDimensionRange(rt,ot,rt.length)}static sizeToDimension(rt,ot){if(ot<0||ot>rt.length)throw new Error(`invalid dimension of ${ot} for sizeToDimension as Tensor has ${rt.length} dimensions.`);return b.getSizeFromDimensionRange(rt,0,ot)}static getSizeFromDimensionRange(rt,ot,at){let ut=1;for(let st=ot;st<at;st++){if(rt[st]<=0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");ut*=rt[st]}return ut}static computeStrides(rt){const ot=rt.length;if(ot===0)return[];if(ot===1)return[1];const at=new Array(ot);at[ot-1]=1,at[ot-2]=rt[ot-1];for(let ut=ot-3;ut>=0;--ut)at[ut]=at[ut+1]*rt[ut+1];return at}static transpose(rt){return rt.slice().reverse()}static indicesToOffset(rt,ot,at){at===void 0&&(at=rt.length);let ut=0;for(let st=0;st<at;++st)ut+=ot[st]*rt[st];return ut}static offsetToIndices(rt,ot){const at=ot.length;if(at===0)return[];if(at===1)return[rt*ot[0]];const ut=new Array(ot.length);for(let st=0;st<ut.length-1;++st)ut[st]=Math.floor(rt/ot[st]),rt-=ut[st]*ot[st];return ut[ut.length-1]=rt,ut}static normalizeAxis(rt,ot){if(rt<-ot&&rt>=ot)throw new Error("unsupported axis for this operation.");return rt<0?rt+ot:rt}static normalizeAxes(rt,ot){return rt.map(at=>this.normalizeAxis(at,ot))}static incrementIndex(rt,ot,at){if(ot.length===0||rt.length===0)throw new Error("Index incrementing unsupported for scalar Tensor");if(at===void 0)at=ot.length;else if(at<=0||at>ot.length)throw new Error("Incorrect axis to increment on");for(let ut=at-1;ut>=0&&(rt[ut]++,!(rt[ut]<ot[ut]));--ut)rt[ut]=0}static calculateReshapedDims(rt,ot){if(ot.length===0){if(rt.length===0||b.size(rt)===1)return[];throw new Error("cannot reshape to a scalar Tensor")}const at=ot.length,ut=new Array(at);let st=-1,ct=1;for(let pt=0;pt<at;pt++){if(ot[pt]<-1)throw new Error("a dimension in shape hints cannot be less than -1");if(ot[pt]===-1){if(st!==-1)throw new Error("at most one dimension in shape hints can be -1");st=pt}else{if(ot[pt]===0){if(pt>=rt.length)throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");ut[pt]=rt[pt]}else ut[pt]=ot[pt];ct*=ut[pt]}}const dt=b.size(rt);if(st!==-1){if(dt%ct!=0)throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${rt}] Output shape: [${ot}]`);ut[st]=dt/ct}else if(ct!==dt)throw new Error("reshapedDims and originalDims don't have matching sizes");return ut}static sortBasedOnPerm(rt,ot){return ot?ot.map(at=>rt[at]):rt.slice().reverse()}static padShape(rt,ot){const at=rt.length;return rt.map((ut,st)=>ut+ot[st]+ot[st+at])}static areEqual(rt,ot){return rt.length===ot.length&&rt.every((at,ut)=>at===ot[ut])}static validateDimsAndCalcSize(rt){if(rt.length>6)throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");let ot=1;for(const at of rt){if(!Number.isInteger(at))throw new TypeError(`Invalid shape: ${at} is not an integer`);if(at<0||at>2147483647)throw new TypeError(`Invalid shape: length ${at} is not allowed`);ot*=at}return ot}static flattenShape(rt,ot){ot<0&&(ot+=rt.length);const at=rt.reduce((st,ct)=>st*ct,1),ut=rt.slice(ot).reduce((st,ct)=>st*ct,1);return[at/ut,ut]}static squeezeShape(rt,ot){const at=new Array;ot=b.normalizeAxes(ot,rt.length);for(let ut=0;ut<rt.length;ut++){const st=ot.indexOf(ut)>=0;if(st&&rt[ut]!==1)throw new Error("squeeze an axis of size different than 1");(ot.length===0&&rt[ut]>1||ot.length>0&&!st)&&at.push(rt[ut])}return at}static unsqueezeShape(rt,ot){const at=new Array(rt.length+ot.length);at.fill(0);for(let st=0;st<ot.length;st++){const ct=b.normalizeAxis(ot[st],at.length);if(ct>=at.length)throw new Error("'axes' has an out of range axis");if(at[ct]!==0)throw new Error("'axes' has a duplicate axis");at[ct]=1}let ut=0;for(let st=0;st<at.length;st++)at[st]===0&&(at[st]=rt[ut++]);if(ut!==rt.length)throw new Error("the unsqueezed dimension could not be established");return at}}F.ShapeUtil=b,F.MathUtil=class{static sqr(nt,rt,ot,at,ut){if(at<0||at>=rt.length)throw new Error("sourceIndex out of bounds");if(ot<0||ot>=nt.length)throw new Error("targetIndex out of bounds");if(at+ut>rt.length)throw new Error("source indices to be copied are outside bounds");if(ot+ut>nt.length)throw new Error("target array is too small to hold result");for(let st=0;st<ut;st++)nt[ot+st]+=Math.pow(rt[at+st],2)}static axpy(nt,rt,ot,at,ut,st){if(at<0||at>=rt.length)throw new Error("sourceIndex out of bounds");if(ot<0||ot>=nt.length)throw new Error("targetIndex out of bounds");if(at+ut>rt.length)throw new Error("source indices to be copied are outside bounds");if(ot+ut>nt.length)throw new Error("target array is too small to hold result");for(let ct=0;ct<ut;ct++)nt[ot+ct]+=st*rt[at+ct]}static powx(nt,rt,ot,at,ut,st){if(at<0||at>=rt.length)throw new Error("sourceIndex out of bounds");if(ot<0||ot>=nt.length)throw new Error("targetIndex out of bounds");if(at+ut>rt.length)throw new Error("source indices to be copied are outside bounds");if(ot+ut>nt.length)throw new Error("target array is too small to hold result");for(let ct=0;ct<ut;ct++)nt[ot+ct]=Math.pow(rt[at+ct],st)}static mul(nt,rt,ot,at,ut){if(at<0||at>=rt.length)throw new Error("sourceIndex out of bounds");if(ot<0||ot>=nt.length)throw new Error("targetIndex out of bounds");if(at+ut>rt.length)throw new Error("source indices to be copied are outside bounds");if(ot+ut>nt.length)throw new Error("target array is too small to hold result");for(let st=0;st<ut;st++)nt[ot+st]=rt[at+st]*nt[ot+st]}};class j{static splitShape(rt,ot,at,ut){if(at.length===0){if(!ut)throw new Error("need to know number of outputs when the 'split' attribute is not specified");j.determineSplit(rt[ot],ut,at)}const st=[],ct=[0];for(let dt=0;dt<at.length;++dt){dt!==0&&ct.push(ct[dt-1]+at[dt-1]);const pt=rt.slice();pt[ot]=at[dt],st.push(pt)}return[st,ct]}static determineSplit(rt,ot,at){if(rt%ot!=0)throw new Error("cannot split tensor to equal sized parts");for(let ut=0;ut<ot;++ut)at.push(rt/ot)}}F.SplitUtil=j;class U{static calcReduce(rt,ot,at,ut,st){const ct=rt.dims.slice(0);ot.length===0&&ct.forEach((wt,bt)=>ot.push(bt));const dt=U.calcReduceShape(ct,ot,!0),pt=b.size(dt),lt=new tt.Tensor(dt,rt.type),ft=b.computeStrides(dt),gt=b.computeStrides(ct),_t=new Array(ct.length);for(let wt=0;wt<pt;wt++){const bt=b.offsetToIndices(wt,ft);q.fillIndex(bt,ct,_t),lt.set(bt,U.calcReduceByAxis(rt.numberData,ot,ct,0,b.indicesToOffset(_t,gt),ut,st))}return at?lt:new tt.Tensor(U.calcReduceShape(ct,ot,at),lt.type,void 0,void 0,lt.data,lt.dataId)}static calcReduceByAxis(rt,ot,at,ut,st,ct,dt){let pt=0;if(ut>=ot.length)return ct(rt[st]);const lt=ot[ut],ft=lt>=at.length?1:b.size(at.slice(lt+1));for(let gt=0;gt<at[lt];gt++)pt=gt===0?U.calcReduceByAxis(rt,ot,at,ut+1,st,ct,dt):dt(pt,U.calcReduceByAxis(rt,ot,at,ut+1,st,ct,dt)),st+=ft;return pt}static calcReduceShape(rt,ot,at){const ut=rt.slice();for(let st=0;st<ot.length;st++)ut[ot[st]]=at?1:0;return ut.filter(st=>st!==0)}}F.ReduceUtil=U;class J{static adjustPoolAttributes(rt,ot,at,ut,st,ct){if(!rt&&at.length!==ot.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(rt)for(let dt=0;dt<ot.length-2;dt++)dt>=at.length?at.push(ot[dt+2]):at[dt]=ot[dt+2];for(let dt=0;dt<at.length;dt++)if(dt<ut.length){if(ut[dt]<0)throw new Error("strides should be greater than or equal to 1")}else ut.push(1);for(let dt=0;dt<at.length;dt++)if(dt<st.length){if(st[dt]<0)throw new Error("dilations should be greater than or equal to 1")}else st.push(1);for(let dt=0;dt<2*at.length;dt++)if(dt<ct.length){if(ct[dt]<0)throw new Error("pad should be greater than or equal to 1")}else ct.push(0);for(let dt=0;dt<at.length;dt++){if(at[dt]<=0)throw new Error("kernel shapes need to be greater than 0");if(ct[dt]>=at[dt]||ct[dt+at.length]>=at[dt])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(rt,ot,at,ut,st,ct){if(ct){if(st.length!==2*(rt.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(ot.length!==rt.length-2)throw new Error("length of strides should be the length of data dimensions");if(ut.length!==rt.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let dt=0;dt<rt.length-2;dt++)J.adjustPadAndReturnShape(rt[dt+2],ot[dt],at[dt],ut[dt],st,dt,dt+rt.length-2,ct)}}static computePoolOutputShape(rt,ot,at,ut,st,ct,dt){if(ot.length<=0)throw new Error("input shape must be of size greater than 0");const pt=[ot[0],ot[1]];return J.computeShapeHelper(rt,ot,pt,at,ut,st,ct,dt),pt}static computeConvOutputShape(rt,ot,at,ut,st,ct,dt){if(rt.length<=0||ot.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");const pt=[rt[0],ot[0]];return J.computeShapeHelper(!1,rt,pt,at,ut,st,ct,dt),pt}static computeShapeHelper(rt,ot,at,ut,st,ct,dt,pt){if(rt)for(let lt=0;lt<ot.length-2;lt++)at.push(1);else for(let lt=0;lt<ot.length-2;lt++)at.push(J.adjustPadAndReturnShape(ot[lt+2],ut[lt],st[lt],ct[lt],dt,lt,lt+ot.length-2,pt))}static adjustPadAndReturnShape(rt,ot,at,ut,st,ct,dt,pt){const lt=at*(ut-1)+1;if(!pt||pt==="NOTSET")return Math.floor((rt+st[ct]+st[dt]-lt)/ot+1);switch(pt){case"VALID":return st[ct]=0,st[dt]=0,Math.floor((rt-lt)/ot+1);case"SAME_LOWER":case"SAME_UPPER":if(at!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{const ft=((rt+ot-1)/ot-1)*ot+ut-rt;return st[ct]=Math.floor(pt==="SAME_LOWER"?(ft+1)/2:ft/2),st[dt]=ft-st[ct],Math.floor((rt+ft-ut)/ot+1)}default:throw new Error("Unsupported AutoPad type")}}}F.PoolConvUtil=J,F.MIN_CLIP=-34028234663852886e22,F.MAX_CLIP=34028234663852886e22,F.decodeUtf8String=function(nt){return new TextDecoder().decode(nt)}},3838:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.WebGpuBackend=void 0;const X=W(8453),K=W(4955),Q=W(7771),Y=W(8510),tt=W(8305);F.WebGpuBackend=class{constructor(){this.currentKernelId=null,this.commandEncoder=null,this.computePassEncoder=null,this.pendingDispatchNumber=0,this.profilingEnabled=!1}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let et=this.kernelCustomData.get(this.currentKernelId);return et||(et={},this.kernelCustomData.set(this.currentKernelId,et)),et}async initialize(){if(!navigator.gpu)throw new Error("WebGpuBackend: WebGPU is not available.");const et=await navigator.gpu.requestAdapter();if(!et)throw new Error("WebGpuBackend: Failed to get GPU adapter.");const q={requiredLimits:{maxComputeWorkgroupStorageSize:et.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:et.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:et.limits.maxStorageBufferBindingSize}};et.features.has("timestamp-query-inside-passes")&&X.env.webgpu.profilingMode==="default"&&(this.profilingEnabled=!0,q.requiredFeatures=["timestamp-query-inside-passes"]),this.device=await et.requestDevice(q),this.gpuDataManager=(0,Q.createGpuDataManager)(this),this.programManager=new tt.ProgramManager(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,this.device.onuncapturederror=G=>{G.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${G.error.message}`)},this.profilingEnabled&&(this.profilingQuerySet=this.device.createQuerySet({type:"timestamp",count:2}))}dispose(){}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){return this.computePassEncoder||(this.computePassEncoder=this.getCommandEncoder().beginComputePass()),this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){this.endComputePass(),this.device.queue.submit([this.getCommandEncoder().finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0}run(et,q,G,O,b){if(q.length!==et.inputTypes.length)throw new Error(`Input size must be equal to ${et.inputTypes.length}.`);const j=[];for(let st=0;st<q.length;++st){const ct=this.gpuDataManager.get(q[st].data);if(!ct)throw new Error(`no GPU data for input: ${q[st].data}`);j[st]=ct}const U=((st,ct,dt)=>{const pt=ct.map(gt=>`${gt.join(",")}`).join("_"),lt=dt.join("_");let ft=st.name;return st.cacheHint&&(ft+="["+st.cacheHint+"]"),ft+=":"+pt+";"+lt,ft})(et,q.map(st=>st.dims),j.map(st=>st.type));let J=this.programManager.getArtifact(U);const nt=J?J.programInfo:typeof et.get=="function"?et.get():et,rt=G.length===0?nt.outputs.map((st,ct)=>ct):G;if(rt.length!==nt.outputs.length)throw new Error(`Output size ${rt.length} must be equal to ${nt.outputs.length}.`);const ot=[],at=[];for(let st=0;st<nt.outputs.length;++st){if(!Number.isInteger(rt[st])||rt[st]<-2||rt[st]>=nt.outputs.length)throw new Error(`Invalid output index: ${rt[st]}`);const ct=rt[st]===-1,dt=rt[st]===-2,pt=ct||dt?b(nt.outputs[st].dataType,nt.outputs[st].dims):O(rt[st],nt.outputs[st].dataType,nt.outputs[st].dims),lt=this.gpuDataManager.get(pt.data);if(!lt)throw new Error(`no GPU data for output: ${pt.data}`);if(ct&&this.temporaryData.push(lt),dt){let ft=this.kernelPersistentData.get(this.currentKernelId);ft||(ft=[],this.kernelPersistentData.set(this.currentKernelId,ft)),ft.push(lt)}ot.push(pt),at.push(lt)}const ut=this.programManager.normalizeDispatchGroupSize(nt.dispatchGroup(q));return J||(J=this.programManager.build(nt,ut),this.programManager.setArtifact(U,J)),(0,K.LOG_DEBUG)("info",()=>`[ProgramManager] run "${nt.name}" (key=${U}) with ${ut[0]}x${ut[1]}x${ut[2]}`),this.programManager.run(J,j,at,ut),ot}upload(et,q){this.gpuDataManager.upload(et,q)}memcpy(et,q){this.gpuDataManager.memcpy(et,q)}async download(et,q){const G=await this.gpuDataManager.download(et);q().set(new Uint8Array(G))}alloc(et){return this.gpuDataManager.create(et).id}free(et){return this.gpuDataManager.release(et)}createKernel(et,q,G){const O=Y.WEBGPU_OP_RESOLVE_RULES.get(et);if(!O)throw new Error(`kernel not implemented: ${et}`);this.kernels.set(q,[et,O[0],[O[1],G]])}releaseKernel(et){const q=this.kernelPersistentData.get(et);if(q){for(const G of q)this.gpuDataManager.release(G.id);this.kernelPersistentData.delete(et)}this.kernelCustomData.delete(et),this.kernels.delete(et)}computeKernel(et,q){const G=this.kernels.get(et);if(!G)throw new Error(`kernel not created: ${et}`);const[O,b,j]=G;if(this.currentKernelId!==null)throw new Error(`kernel "${O}" is not allowed to be called recursively`);this.currentKernelId=et,j[0]&&(j[1]=j[0](j[1]),j[0]=void 0),(0,K.LOG_DEBUG)("info",()=>`[WebGPU] Start to run kernel "${O}"...`),this.temporaryData=[];try{return b(q,j[1]),0}catch(U){return(0,K.LOG_DEBUG)("warning",`[WebGPU] Kernel "${O}" failed. Error: ${U}`),1}finally{for(const U of this.temporaryData)this.gpuDataManager.release(U.id);this.temporaryData=[],this.currentKernelId=null}}}},7675:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.init=void 0;const X=W(7917),K=W(3838),Q=W(4955),Y=W(6952);class tt{constructor(G,O,b,j){this.module=G,this.dataType=O,this.data=b,this.dims=j}getFloat32Array(){return new Float32Array(this.module.HEAP8.buffer,this.data,Y.ShapeUtil.size(this.dims))}reshape(G){if(Y.ShapeUtil.size(G)!==Y.ShapeUtil.size(this.dims))throw new Error("Invalid new shape");return new tt(this.module,this.dataType,this.data,G)}}class et{get customData(){return this.backend.currentKernelCustomData}constructor(G,O,b){this.module=G,this.backend=O;const j=G.HEAPU32;let U=b>>2;this.opKernelContext=j[U++];const J=j[U++],nt=[];for(let rt=0;rt<J;rt++){const ot=j[U++],at=j[U++],ut=j[U++],st=[];for(let ct=0;ct<ut;ct++)st.push(j[U++]);nt.push(new tt(G,ot,at,st))}this.inputs=nt}compute(G,O){var b,j,U;const J=(j=(b=O==null?void 0:O.inputs)===null||b===void 0?void 0:b.map(rt=>typeof rt=="number"?this.inputs[rt]:rt))!==null&&j!==void 0?j:this.inputs,nt=(U=O==null?void 0:O.outputs)!==null&&U!==void 0?U:[];return this.backend.run(G,J,nt,(rt,ot,at)=>new tt(this.module,ot,this.output(rt,at),at),(rt,ot)=>{const at=(0,X.getTensorElementSize)(rt);if(!at)throw new Error(`Unsupported data type: ${rt}`);const ut=at*Y.ShapeUtil.size(ot);return new tt(this.module,rt,this.backend.gpuDataManager.create(ut).id,ot)})}output(G,O){const b=this.module.stackSave();try{const j=this.module.stackAlloc(4*(1+O.length));let U=j>>2;this.module.HEAPU32[U++]=O.length;for(let J=0;J<O.length;J++)this.module.HEAPU32[U++]=O[J];return this.module._JsepOutput(this.opKernelContext,G,j)}finally{this.module.stackRestore(b)}}}F.init=async q=>{const G=q.jsepInit;if(G&&navigator.gpu){const O=new K.WebGpuBackend;await O.initialize(),G({backend:O},b=>O.alloc(b),b=>O.free(b),(b,j,U,J=!1)=>{if(J)(0,Q.LOG_DEBUG)("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${b}, dst=${j}, size=${U}`),O.memcpy(b,j);else{(0,Q.LOG_DEBUG)("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${b}, gpuDataId=${j}, size=${U}`);const nt=q.HEAPU8.subarray(b,b+U);O.upload(j,nt)}},async(b,j,U)=>{(0,Q.LOG_DEBUG)("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${b}, dataOffset=${j}, size=${U}`),await O.download(b,()=>q.HEAPU8.subarray(j,j+U))},(b,j,U)=>O.createKernel(b,j,U),b=>O.releaseKernel(b),(b,j)=>{(0,Q.LOG_DEBUG)("verbose",()=>`[WebGPU] jsepRun: kernel=${b}, contextDataOffset=${j}`);const U=new et(q,O,j);return O.computeKernel(b,U)})}}},4955:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.LOG_DEBUG=F.LOG=void 0;const X=W(8453),K=W(7917),Q=["V","I","W","E","F"];F.LOG=(Y,tt)=>{const et=(0,K.logLevelStringToEnum)(Y);var q,G;et>=(0,K.logLevelStringToEnum)(X.env.logLevel)&&(q=et,G=typeof tt=="function"?tt():tt,console.log(`[${Q[q]},${new Date().toISOString()}]${G}`))},F.LOG_DEBUG=(...Y)=>{X.env.debug&&(0,F.LOG)(...Y)}},6952:(it,F)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.MAX_CLIP=F.MIN_CLIP=F.GemmUtil=F.PoolConvUtil=F.ShapeUtil=F.BroadcastUtil=F.MatMulUtil=void 0;class W{static calcMatMulShape(tt,et){return tt[1]!==et[0]?void 0:[tt[0],et[1]]}}F.MatMulUtil=W;class X{static calcShape(tt,et,q=!1){const G=tt.length,O=et.length;if(G===0)return et;if(O===0)return tt;const b=Math.max(tt.length,et.length),j=new Array(b);if(q){if(G<2||O<2)return;const U=W.calcMatMulShape([tt[G-2],tt[G-1]],[et[O-2],et[O-1]]);if(U===void 0)return;[j[b-2],j[b-1]]=U}for(let U=q?3:1;U<=b;U++){const J=G-U<0?1:tt[G-U],nt=O-U<0?1:et[O-U];if(J!==nt&&J>1&&nt>1)return;j[b-U]=Math.max(J,nt)}return j}static isValidBroadcast(tt,et){const q=tt.length,G=et.length;if(q>G)return!1;for(let O=1;O<=q;O++)if(tt[q-O]!==1&&tt[q-O]!==et[G-O])return!1;return!0}}F.BroadcastUtil=X;class K{static size(tt){return K.getSizeFromDimensionRange(tt,0,tt.length)}static sizeFromDimension(tt,et){if(et<0||et>tt.length)throw new Error(`invalid dimension of ${et} for sizeFromDimension as Tensor has ${tt.length} dimensions.`);return K.getSizeFromDimensionRange(tt,et,tt.length)}static sizeToDimension(tt,et){if(et<0||et>tt.length)throw new Error(`invalid dimension of ${et} for sizeToDimension as Tensor has ${tt.length} dimensions.`);return K.getSizeFromDimensionRange(tt,0,et)}static getSizeFromDimensionRange(tt,et,q){let G=1;for(let O=et;O<q;O++){if(tt[O]<=0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");G*=tt[O]}return G}static computeStrides(tt){const et=tt.length;if(et===0)return[];if(et===1)return[1];const q=new Array(et);q[et-1]=1,q[et-2]=tt[et-1];for(let G=et-3;G>=0;--G)q[G]=q[G+1]*tt[G+1];return q}static normalizeAxis(tt,et){if(tt<-et&&tt>=et)throw new Error("unsupported axis for this operation.");return tt<0?tt+et:tt}static normalizeAxes(tt,et){return tt.map(q=>this.normalizeAxis(q,et??tt.length))}static sortBasedOnPerm(tt,et){return et?et.map(q=>tt[q]):tt.slice().reverse()}static padShape(tt,et){const q=tt.length;return tt.map((G,O)=>G+et[O]+et[O+q])}static areEqual(tt,et){return tt.length===et.length&&tt.every((q,G)=>q===et[G])}}F.ShapeUtil=K;class Q{static adjustPoolAttributes(tt,et,q,G,O,b){if(!tt&&q.length!==et.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(tt)for(let j=0;j<et.length-2;j++)j>=q.length?q.push(et[j+2]):q[j]=et[j+2];for(let j=0;j<q.length;j++)if(j<G.length){if(G[j]<0)throw new Error("strides should be greater than or equal to 1")}else G.push(1);for(let j=0;j<q.length;j++)if(j<O.length){if(O[j]<0)throw new Error("dilations should be greater than or equal to 1")}else O.push(1);for(let j=0;j<2*q.length;j++)if(j<b.length){if(b[j]<0)throw new Error("pad should be greater than or equal to 1")}else b.push(0);for(let j=0;j<q.length;j++){if(q[j]<=0)throw new Error("kernel shapes need to be greater than 0");if(b[j]>=q[j]||b[j+q.length]>=q[j])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(tt,et,q,G,O,b,j){if(j){if(O.length!==2*(tt.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(et.length!==tt.length-2)throw new Error("length of strides should be the length of data dimensions");if(G.length!==tt.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let U=0;U<tt.length-2;U++)Q.adjustPadAndReturnShape(tt[U+(b?1:2)],et[U],q[U],G[U],O,U,U+tt.length-2,j)}}static computePoolOutputShape(tt,et,q,G,O,b,j){if(et.length<=0)throw new Error("input shape must be of size greater than 0");const U=[et[0],et[1]];return Q.computeShapeHelper(tt,et,U,q,G,O,b,j),U}static computeConvOutputShape(tt,et,q,G,O,b,j){if(tt.length<=0||et.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");const U=[tt[0],et[0]];return Q.computeShapeHelper(!1,tt,U,q,G,O,b,j),U}static computeShapeHelper(tt,et,q,G,O,b,j,U){if(tt)for(let J=0;J<et.length-2;J++)q.push(1);else for(let J=0;J<et.length-2;J++)q.push(Q.adjustPadAndReturnShape(et[J+2],G[J],O[J],b[J],j,J,J+et.length-2,U))}static adjustPadAndReturnShape(tt,et,q,G,O,b,j,U){const J=q*(G-1)+1;if(!U||U==="NOTSET")return Math.floor((tt+O[b]+O[j]-J)/et+1);switch(U){case"VALID":return O[b]=0,O[j]=0,Math.floor((tt-J)/et+1);case"SAME_LOWER":case"SAME_UPPER":if(q!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{const nt=((tt+et-1)/et-1)*et+G-tt;return O[b]=Math.floor(U==="SAME_LOWER"?(nt+1)/2:nt/2),O[j]=nt-O[b],Math.floor((tt+nt-G)/et+1)}default:throw new Error("Unsupported AutoPad type")}}}F.PoolConvUtil=Q,F.GemmUtil=class{static getShapeOfGemmResult(Y,tt,et,q,G){if(Y.length!==2||et.length!==2)throw new Error("shape need to be of size 2");let O,b,j;tt?(O=Y[1],b=Y[0]):(O=Y[0],b=Y[1]);let U=-1;if(q?(j=et[0],U=1):(j=et[1],U=0),et[U]!==b)throw new Error("dimension mismatch");if(O<=0||j<=0||b<=0)throw new Error("invalid shape specified");if(G&&!X.isValidBroadcast(G,[O,j]))throw new Error("gemm: invalid bias shape for broadcast");return[O,j,b]}},F.MIN_CLIP=-34028234663852886e22,F.MAX_CLIP=34028234663852886e22},387:(it,F)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.createAttributeWithCacheKey=void 0;class W{constructor(K){Object.assign(this,K)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map(K=>`${this[K]}`).join(";")),this._cacheKey}}F.createAttributeWithCacheKey=X=>new W(X)},7771:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.createGpuDataManager=void 0;const X=W(4955),K=W(1163),Q=et=>16*Math.ceil(et/16);let Y=0;class tt{constructor(q){this.backend=q,this.storageCache=new Map,this.downloadCache=new Map,this.buffersForUploadingPending=[],this.buffersPending=[]}upload(q,G){const O=G.buffer,b=G.byteOffset,j=G.byteLength,U=Q(j),J=this.storageCache.get(q);if(!J)throw new Error("gpu data for uploading does not exist");if(J.originalSize!==j)throw new Error(`inconsistent data size. gpu data size=${J.originalSize}, data size=${j}`);const nt=this.backend.device.createBuffer({mappedAtCreation:!0,size:U,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),rt=nt.getMappedRange();new Uint8Array(rt).set(new Uint8Array(O,b,j)),nt.unmap();const ot=this.backend.getCommandEncoder();this.backend.endComputePass(),ot.copyBufferToBuffer(nt,0,J.gpuData.buffer,0,U),(0,X.LOG_DEBUG)("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${q})`),this.buffersForUploadingPending.push(nt)}memcpy(q,G){const O=this.storageCache.get(q);if(!O)throw new Error("source gpu data for memcpy does not exist");const b=this.storageCache.get(G);if(!b)throw new Error("destination gpu data for memcpy does not exist");if(O.originalSize!==b.originalSize)throw new Error("inconsistent source and destination gpu data size");const j=Q(O.originalSize);this.backend.getCommandEncoder().copyBufferToBuffer(O.gpuData.buffer,0,b.gpuData.buffer,0,j)}create(q,G=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){const O=Q(q),b=this.backend.device.createBuffer({size:O,usage:G}),j={id:Y++,type:K.GpuDataType.default,buffer:b};return this.storageCache.set(j.id,{gpuData:j,originalSize:q}),(0,X.LOG_DEBUG)("verbose",()=>`[WebGPU] GpuDataManager.create(size=${q}) => id=${j.id}`),j}get(q){var G;return(G=this.storageCache.get(q))===null||G===void 0?void 0:G.gpuData}release(q){const G=this.storageCache.get(q);if(!G)throw new Error("releasing data does not exist");return(0,X.LOG_DEBUG)("verbose",()=>`[WebGPU] GpuDataManager.release(id=${q}), gpuDataId=${G.gpuData.id}`),this.storageCache.delete(q),this.buffersPending.push(G.gpuData.buffer),this.downloadCache.get(q)&&this.downloadCache.delete(q),G.originalSize}async download(q){const G=this.downloadCache.get(q);if(G)return G.data;const O=this.storageCache.get(q);if(!O)throw new Error("data does not exist");const b=this.backend.getCommandEncoder();this.backend.endComputePass();const j=this.backend.device.createBuffer({size:O.originalSize,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});b.copyBufferToBuffer(O.gpuData.buffer,0,j,0,O.originalSize),this.backend.flush();const U=new Promise(J=>{j.mapAsync(GPUMapMode.READ).then(()=>{const nt=j.getMappedRange().slice(0);j.destroy(),J(nt)})});return this.downloadCache.set(q,{data:U}),U}refreshPendingBuffers(){for(const q of this.buffersForUploadingPending)q.destroy();for(const q of this.buffersPending)q.destroy()}}F.createGpuDataManager=(...et)=>new tt(...et)},8510:function(it,F,W){var X=this&&this.__createBinding||(Object.create?function(j,U,J,nt){nt===void 0&&(nt=J);var rt=Object.getOwnPropertyDescriptor(U,J);rt&&!("get"in rt?!U.__esModule:rt.writable||rt.configurable)||(rt={enumerable:!0,get:function(){return U[J]}}),Object.defineProperty(j,nt,rt)}:function(j,U,J,nt){nt===void 0&&(nt=J),j[nt]=U[J]}),K=this&&this.__setModuleDefault||(Object.create?function(j,U){Object.defineProperty(j,"default",{enumerable:!0,value:U})}:function(j,U){j.default=U}),Q=this&&this.__importStar||function(j){if(j&&j.__esModule)return j;var U={};if(j!=null)for(var J in j)J!=="default"&&Object.prototype.hasOwnProperty.call(j,J)&&X(U,j,J);return K(U,j),U};Object.defineProperty(F,"__esModule",{value:!0}),F.WEBGPU_OP_RESOLVE_RULES=void 0;const Y=Q(W(504)),tt=W(9770),et=W(4271),q=W(1522),G=Q(W(5262)),O=W(2625),b=Q(W(9302));F.WEBGPU_OP_RESOLVE_RULES=new Map([["Abs",[b.abs]],["Acos",[b.acos]],["Acosh",[b.acosh]],["Add",[Y.add]],["Asin",[b.asin]],["Asinh",[b.asinh]],["Atan",[b.atan]],["Atanh",[b.atanh]],["AveragePool",[G.averagePool,G.parseAveragePoolAttributes]],["Ceil",[b.ceil]],["ClipV10",[b.clipV10]],["Clip",[b.clip]],["Conv",[tt.conv,tt.parseConvAttributes]],["Cos",[b.cos]],["Cosh",[b.cosh]],["Div",[Y.div]],["Elu",[b.elu,b.parseAlphaAttributes]],["Erf",[b.erf]],["Exp",[b.exp]],["Floor",[b.floor]],["Gemm",[et.gemm,et.parseGemmAttributes]],["GlobalAveragePool",[G.globalAveragePool,G.parseGlobalAveragePoolAttributes]],["GlobalMaxPool",[G.globalMaxPool,G.parseGlobalMaxPoolAttributes]],["LeakyRelu",[b.leakyRelu,b.parseAlphaAttributes]],["MatMul",[q.matMul]],["MaxPool",[G.maxPool,G.parseMaxPoolAttributes]],["Mul",[Y.mul]],["Neg",[b.neg]],["Pow",[Y.pow]],["Reciprocal",[b.reciprocal]],["Relu",[b.relu]],["Sigmoid",[b.sigmoid]],["Sin",[b.sin]],["Sinh",[b.sinh]],["Sqrt",[b.sqrt]],["Sub",[Y.sub]],["Tan",[b.tan]],["Tanh",[b.tanh]],["ThresholdedRelu",[b.thresholdedRelu,b.parseAlphaAttributes]],["Transpose",[O.transpose,O.parseTransposeAttributes]]])},1427:(it,F)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.biasActivationSnippet=F.activationFnSnippet=F.typeSnippet=void 0,F.typeSnippet=W=>{switch(W){case 1:return"f32";case 2:return"vec2<f32>";case 3:return"vec3<f32>";case 4:return"vec4<f32>";default:throw new Error(`${W}-component is not supported.`)}},F.activationFnSnippet=(W,X=!1,K=!1,Q=3)=>"",F.biasActivationSnippet=(W,X)=>`
      ${W?"value = value + getBiasByOutputCoords(coords);":""}
      ${X?"value = activation(value, coords);":""}
      `},9456:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.createConv2DMatMulProgramInfo=void 0;const X=W(4955),K=W(6952),Q=W(1163),Y=W(1427),tt=W(4085),et=W(158);F.createConv2DMatMulProgramInfo=(q,G,O,b,j,U,J,nt,rt)=>{const ot=O.format==="NHWC",at=ot?q[0].dims[3]:q[0].dims[1],ut=b[0],st=ot?b[2]:b[3],ct=ot?b[1]:b[2],dt=ot?b[3]:b[1],pt=((at%4==0||at%3==0)&&ot||st%4==0&&!ot)&&dt%4==0,lt=ot?dt:st*ct,ft=ot?st*ct:dt,gt=pt?[8,8,1]:[lt<=4?4:16,lt>4&&ft<=4?4:16,1],_t=pt?[4,4,1]:[lt<=4?1:2,lt>4&&ft<=4?1:2,1],wt=[Math.ceil(lt/gt[0]/_t[0]),Math.ceil(ft/gt[1]/_t[1]),Math.ceil(ut/gt[2]/_t[1])];(0,X.LOG_DEBUG)("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${wt}`);const bt=pt?ot&&at%4!=0?3:4:_t[0],Ot=gt[1]*_t[1],vt=gt[0]*_t[0],xt=Math.max(gt[0]*bt,gt[1]),Rt=j%Ot==0,kt=U%vt==0,Ht=J%xt==0,Mt=pt?[bt,4,4]:[1,1,1],qt=[`@group(0) @binding(0) var<storage, read> x: array<${pt&&bt===4?"vec4<f32>":"f32"}>;`,`@group(0) @binding(1) var<storage, read> w: array<${pt?"vec4<f32>":"f32"}>;`];let Jt=`
      fn setOutputAtIndex(flatIndex : i32, value : ${pt?"vec4<f32>":"f32"}) {
        result[flatIndex] = ${pt?"vec4<f32>":"f32"}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${pt?"vec4<f32>":"f32"}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${pt?"/ 4":""}, value);
      }`;return nt&&(qt.push(`@group(0) @binding(2) var<storage, read> bias: array<${pt?"vec4<f32>":"f32"}>;`),Jt+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${pt?"vec4<f32>":"f32"} {
          return bias[coords.${ot?"w":"y"}${pt?"/ 4":""}];
        }`),Object.assign(Object.assign({},G),{outputs:[{dims:b,dataType:q[0].dataType,gpuDataType:Q.GpuDataType.default}],dispatchGroup:()=>({x:wt[0],y:wt[1],z:wt[2]}),getShaderSource:()=>`
        ${tt.utilFunctions}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${qt.join("")}
        @group(0) @binding(${qt.length}) var<storage, read_write> result: array<${pt?"vec4<f32>":"f32"}>;
        //@group(0) @binding(${qt.length+1}) var<uniform> uniforms: Uniforms;

        const xShape : vec4<i32> = vec4<i32>(${q[0].dims.join(",")});
        const wShape : vec4<i32> = vec4<i32>(${q[1].dims.join(",")});
        const outShape : vec4<i32> = vec4<i32>(${b.join(",")});
        const outShapeStrides : vec3<i32> = vec3<i32>(${K.ShapeUtil.computeStrides(b).slice(0,3).join(",")});
        const filterDims : vec2<i32> = vec2<i32>(${O.kernelShape[0]}, ${O.kernelShape[1]});
        const pad : vec2<i32> = vec2<i32>(${O.pads[0]}, ${O.pads[1]});
        const stride : vec2<i32> = vec2<i32>(${O.strides[0]}, ${O.strides[1]});
        const dilation : vec2<i32> = vec2<i32>(${O.dilations[0]}, ${O.dilations[1]});
        const dimAOuter : i32 = ${j};
        const dimBOuter : i32 = ${U};
        const dimInner : i32 = ${J};
        ${Jt}
        ${((Bt,ee,ne,Yt,ae=!1,Wt,se=!1,Zt=4,ue=4,re=4)=>{const pe=Bt?`
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    `:`
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `,ye=Bt?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,Ae=Bt?"xShape[1]":"xShape[2]",Oe=Bt?"xShape[2]":"xShape[3]",Ie=Bt?"row":"col",Ee=Bt?"col":"row",le=`
    let inChannels = wShape[2];
    let outWidth = ${Bt?"outShape[2]":"outShape[3]"};
    let outRow = ${Ie} / outWidth;
    let outCol = ${Ie} % outWidth;

    let WRow = ${Ee} / (filterDims[1] * inChannels);
    let WCol = ${Ee} / inChannels % filterDims[1];
    let xRow = outRow * stride[0] + dilation[0] * WRow - pad[0];
    let xCol = outCol * stride[1] + dilation[1] * WCol - pad[1];
    let xCh = ${Ee} % inChannels;
    var resData = ${(0,Y.typeSnippet)(Zt)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${Ae} && xCol >= 0 && xCol < ${Oe}) {
      ${pe}
      let xIndex = getIndexFromCoords4D(coord, xShape);
      ${(Ct=>{switch(Ct){case 1:return"resData = x[xIndex];";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${Ct} is not supported.`)}})(Zt)}
    }
    return resData;`,ve=Bt?ee&&Yt?`
    let col = colIn * ${Zt};
    ${le}`:`
    let col = colIn * ${Zt};
    if (row < dimAOuter && col < dimInner) {
      ${le}
    }
    return ${(0,Y.typeSnippet)(Zt)}(0.0);`:Yt&&ne?`
    let col = colIn * ${Zt};
    ${le}`:`
    let col = colIn * ${Zt};
    if (row < dimInner && col < dimBOuter) {
      ${le}
    }
    return ${(0,Y.typeSnippet)(Zt)}(0.0);`,fe=`${(Ct=>{switch(Ct){case 1:return"return w[row * wShape[3] + colIn];";case 4:return"return w[row * wShape[3] / 4 + colIn];";default:throw new Error(`innerElementSize ${Ct} is not supported.`)}})(ue)}`,ge=(0,Y.typeSnippet)(re),At=Bt?(0,Y.typeSnippet)(Zt):(0,Y.typeSnippet)(ue),Pt=Bt?(0,Y.typeSnippet)(ue):(0,Y.typeSnippet)(Zt);return`
    ${(0,Y.activationFnSnippet)(Wt,se,re===4,4)}
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${At} {
      ${Bt?ve:fe}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${Pt} {
      ${Bt?fe:ve}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${ge}) {
      let col = colIn * ${re};
      if (row < dimAOuter && col < dimBOuter)
      {
      var value = valueIn;
      let outWidth = ${Bt?"outShape[2]":"outShape[3]"};
      ${ye}
      ${(0,Y.biasActivationSnippet)(ae,Wt)}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`})(ot,Rt,kt,Ht,nt,void 0,!1,Mt[0],Mt[1],Mt[2])}
            ${pt?(0,et.makeMatMulPackedVec4Source)(_t,gt,!ot,xt):(0,et.makeMatMulPackedSource)(_t,gt,!ot,xt,!1,void 0,rt)}`})}},4085:(it,F)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.utilFunctions=void 0,F.utilFunctions=`
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    outShapeStrides.x, outShapeStrides.y, outShapeStrides.z, 1));
}
`},158:(it,F)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.makeMatMulPackedSource=F.makeMatMulPackedVec4Source=void 0,F.makeMatMulPackedVec4Source=(X,K,Q=!1,Y=32,tt=!1,et=32,q=!1)=>{const G=K[1]*X[1],O=K[0]*X[0],b=Q?G:Y,j=Q?Y:G,U=b/K[0],J=Y/K[1];if((!Q||U!==4||X[1]!==4)&&(Q||U!==3&&U!==4)||b%K[0]!=0||Y%K[1]!=0||X[0]!==4)throw new Error(`If transposeA ${Q} is true, innerElementSize ${U} and workPerThread[1] ${X[1]} must be 4.
      Otherwise, innerElementSize ${U} must be 3 or 4.
  tileAWidth ${b} must be divisible by workgroupSize[0]${K[0]}. tileInner ${Y} must be divisible by workgroupSize[1] ${K[1]}. colPerThread ${X[0]} must be 4.`);return`
var<workgroup> mm_Asub : array<array<vec${U}<f32>, ${b/U}>, ${j}>;
var<workgroup> mm_Bsub : array<array<vec4<f32>, ${O/X[0]}>, ${Y}>;

const rowPerThread = ${X[1]};
const colPerThread = ${X[0]};
const innerElementSize = ${U};
const tileInner = ${Y};

@compute @workgroup_size(${K[0]}, ${K[1]}, ${K[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = ${q?"0":"localRow * rowPerThread"};
  let tileCol = i32(localId.x);

  let globalRow = ${q?"0":"i32(globalId.y) * rowPerThread"};
  let globalCol = i32(globalId.x);
  let batch = ${tt?"0":"i32(globalId.z)"};
  let globalRowStart = i32(workgroupId.y) * ${G};

  let numTiles = ${tt?`${Math.ceil(et/Y)}`:"(dimInner - 1) / tileInner + 1"};
  var kStart = ${tt?`i32(globalId.z) * ${et}`:"0"};

  var acc: array<vec4<f32>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${J};
  for (var t = 0; t < numTiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${nt=Q,nt?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol);
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol);
        `}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${J}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol);
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${U===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${((rt,ot)=>rt?`
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${ot===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${ot===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`:`
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${ot===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}
        }`)(Q,U)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`;var nt};const W=X=>X?`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol);
            `:`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol);
            `;F.makeMatMulPackedSource=(X,K,Q=!1,Y=32,tt=!1,et=32,q=!1)=>{const G=X[1]*K[1],O=X[0]*K[0],b=Q?G:Y,j=Q?Y:G;if(j%K[1]!=0||b%K[0]!=0||Y%K[1]!=0)throw new Error(`tileAHight ${j} must be divisible by workgroupSize[1]${K[1]}, tileAWidth ${b} must be divisible by workgroupSize[0]${K[0]}, tileInner ${Y} must be divisible by workgroupSize[1]${K[1]}`);const U=j/K[1],J=b/K[0],nt=Y/K[1],rt=q?`
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${G};
    let globalColStart = i32(workgroupId.x) * ${O};

    // Loop over shared dimension.
    for (var t = 0; t < numTiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${j}; inputRow = inputRow + ${K[1]}) {
        for (var inputCol = localCol; inputCol < ${b}; inputCol = inputCol + ${K[0]}) {
          ${W(Q)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${Y}; inputRow = inputRow + ${K[1]}) {
            for (var inputCol = localCol; inputCol < ${O}; inputCol = inputCol + ${K[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol);
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<f32, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${K[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${Q?`mm_Asub[k][localRow + innerRow * ${K[1]}];`:`mm_Asub[localRow + innerRow * ${K[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${K[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${K[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    `:`
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${G};

let tileRowA = i32(localId.y) * ${U};
let tileColA = i32(localId.x) * ${J};
let tileRowB = i32(localId.y) * ${nt};
// Loop over shared dimension.
for (var t = 0; t < numTiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${U}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${J}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${W(Q)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${nt}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol);
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<f32, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${(ot=>ot?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];")(Q)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;return`
  var<workgroup> mm_Asub : array<array<f32, ${b}>, ${j}>;
  var<workgroup> mm_Bsub : array<array<f32, ${O}>, ${Y}>;
  const rowPerThread = ${X[1]};
  const colPerThread = ${X[0]};
  const tileInner = ${Y};

@compute @workgroup_size(${K[0]}, ${K[1]}, ${K[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${tt?"0":"i32(globalId.z)"};
    let numTiles = ${tt?`${Math.ceil(et/Y)}`:"(dimInner - 1) / tileInner + 1"};
    var kStart = ${tt?`i32(globalId.z) * ${et}`:"0"};

    var acc : array<array<f32, colPerThread>, rowPerThread>;

    // Without this initialization strange values show up in acc.
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = 0.0;
      }
    }
    ${rt}
  }
`}},504:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.sub=F.pow=F.mul=F.div=F.add=void 0;const X=W(6952),K=W(1163),Q=W(2075),Y=(tt,et,q,G,O)=>{const b={name:et,inputTypes:[K.GpuDataType.default,K.GpuDataType.default],cacheHint:O};return Object.assign(Object.assign({},b),{get:()=>((j,U,J,nt,rt,ot=U.dataType)=>{var at,ut;const st=!X.ShapeUtil.areEqual(U.dims,J.dims);let ct=U.dims,dt=X.ShapeUtil.size(U.dims),pt=!1;if(st){const lt=X.BroadcastUtil.calcShape(U.dims,J.dims,!1);if(!lt)throw new Error("Can't perform binary op on the given tensors");ct=lt,dt=X.ShapeUtil.size(ct);let ft=1;for(let gt=0;gt<ct.length;gt++){const _t=(at=U.dims[U.dims.length-gt])!==null&&at!==void 0?at:1;if(_t!==((ut=J.dims[J.dims.length-gt])!==null&&ut!==void 0?ut:1))break;ft*=_t}ft%4==0&&(pt=!0)}else pt=!0;return Object.assign(Object.assign({},j),{getShaderSource:lt=>((ft,gt,_t,wt,bt,Ot,vt,xt,Rt="f32",kt="f32",Ht="f32")=>{const Mt=X.ShapeUtil.size(wt),qt=Math.ceil(Mt/4);let Jt,Bt;typeof vt=="string"?Jt=Bt=(ae,Wt)=>`${vt}((${ae}),(${Wt}))`:typeof vt=="function"?Jt=Bt=vt:(Jt=vt.scalar,Bt=vt.vector);let ee="";const ne=(0,Q.createIndicesHelper)("output",wt);if(Ot){const ae=Wt=>{const se=X.ShapeUtil.computeStrides(Wt),Zt=[];for(let ue=Wt.length-1;ue>=0;ue--){const re=wt.length===0?"0u":wt.length===1?"(*outputIndices)":`(*outputIndices)[${ue+wt.length-Wt.length}]`;Zt.push(`${se[ue]}u * (${re} % ${Wt[ue]}u)`)}return Zt.length>0?Zt.join("+"):"0u"};ee=`
  ${ne.o2iImpl}

  fn calcOffsetA(outputIndices: ptr<function, ${ne.iType}>) -> u32 {
    return ${ae(gt)};
  }

  fn calcOffsetB(outputIndices: ptr<function, ${ne.iType}>) -> u32 {
    return ${ae(_t)};
  }
  `}let Yt;if(bt)Yt=Ot?`
      ${ne.indicesVariableDeclaration("outputIndices")}
      ${ne.o2iCall("global_idx * 4u","outputIndices")}
      let offsetA = calcOffsetA(&outputIndices);
      let offsetB = calcOffsetB(&outputIndices);
      outputData[global_idx] = ${Bt("aData[offsetA / 4u]","bData[offsetB / 4u]")};`:`outputData[global_idx] = ${Bt("aData[global_idx]","bData[global_idx]")};`;else{if(!Ot)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");const ae=Wt=>{const se=`aData[indexA${Wt}][componentA${Wt}]`,Zt=`bData[indexB${Wt}][componentB${Wt}]`;return`
      ${ne.o2iCall(`global_idx * 4u + ${Wt}u`,"outputIndices")}
      let offsetA${Wt} = calcOffsetA(&outputIndices);
      let offsetB${Wt} = calcOffsetB(&outputIndices);
      let indexA${Wt} = offsetA${Wt} / 4u;
      let indexB${Wt} = offsetB${Wt} / 4u;
      let componentA${Wt} = offsetA${Wt} % 4u;
      let componentB${Wt} = offsetB${Wt} % 4u;
      outputData[global_idx][${Wt}] = ${Jt(se,Zt)};`};Yt=`
      ${ne.indicesVariableDeclaration("outputIndices")}
      ${ae(0)}
      ${ae(1)}
      ${ae(2)}
      ${ae(3)}`}return`
  @group(0) @binding(0) var<storage, read> aData : array<vec4<${Rt}>>;
  @group(0) @binding(1) var<storage, read> bData : array<vec4<${kt}>>;
  @group(0) @binding(2) var<storage, read_write> outputData : array<vec4<${Ht}>>;

  ${xt??""}
  ${ee}

  ${ft.mainStart()}
    ${ft.guardAgainstOutOfBoundsWorkgroupSizes(qt)}
    ${Yt}
  }`})(lt,U.dims,J.dims,ct,pt,st,nt,rt),outputs:[{dims:ct,dataType:ot,gpuDataType:K.GpuDataType.default}],dispatchGroup:()=>({x:Math.ceil(dt/64/(pt?4:1))})})})(b,tt[0],tt[1],q,G)})};F.add=tt=>{tt.compute(Y(tt.inputs,"Add",(et,q)=>`${et}+${q}`))},F.div=tt=>{tt.compute(Y(tt.inputs,"Div",(et,q)=>`${et}/${q}`))},F.mul=tt=>{tt.compute(Y(tt.inputs,"Mul",(et,q)=>`${et}*${q}`))},F.pow=tt=>{tt.compute(Y(tt.inputs,"Pow",{scalar:(et,q)=>`pow_f32(${et},${q})`,vector:(et,q)=>`pow_vf32(${et},${q})`},`
    fn pow_f32(a : f32, b : f32) -> f32 {
      if (b == 0.0) {
        return 1.0;
      } else if (a < 0.0 && b != floor(b)) {
        return pow(a, b); // NaN
      }
      return select(sign(a), 1.0, round(abs(b) % 2.0) != 1.0) * pow(abs(a), b);
    }
    fn pow_vf32(a : vec4<f32>, b : vec4<f32>) -> vec4<f32> {
      // TODO: implement vectorized pow
      return vec4<f32>(pow_f32(a.x, b.x), pow_f32(a.y, b.y), pow_f32(a.z, b.z), pow_f32(a.w, b.w));
    }
      `))},F.sub=tt=>{tt.compute(Y(tt.inputs,"Sub",(et,q)=>`${et}-${q}`))}},2075:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.createShaderHelper=F.createIndicesHelper=F.WORKGROUP_SIZE=void 0;const X=W(6952);F.WORKGROUP_SIZE=64,F.createIndicesHelper=(Q,Y)=>{const tt=Y.length<2?"u32":`array<u32, ${Y.length}>`,et=X.ShapeUtil.computeStrides(Y);let q="";for(let b=0;b<Y.length-1;b++)q+=`
    let dim${b} = current / ${et[b]}u;
    let rest${b} = current % ${et[b]}u;
    (*indices)[${b}] = dim${b};
    current = rest${b};
    `;q+=`(*indices)[${Y.length-1}] = current;`;const G=Y.length<2?"":`
  fn ih_o2i_${Q}(offset: u32, indices: ptr<function, ${tt}>) {
    var current = offset;
    ${q}
  }`,O=[];if(Y.length===0)O.push("0u");else if(Y.length<2)O.push("(*indices)");else for(let b=Y.length-1;b>=0;b--)O.push(`${et[b]}u * ((*indices)[${b}])`);return{o2iImpl:G,o2iCall:(b,j)=>Y.length<2?`${j}=${b};`:`ih_o2i_${Q}(${b}, &${j});`,i2oImpl:Y.length<2?"":`
  fn ih_i2o_${Q}(indices: ptr<function, ${tt}>) -> u32 {
    return ${O.join("+")};
  }`,i2oExpression:(b,j)=>Y.length<2?`(${j?"*":""}${b})`:`ih_i2o_${Q}(${j?"":"&"}${b})`,indicesVariableDeclaration:(b,j)=>`var ${b}:${tt}${j?`=${tt}(${j.join(",")})`:""};`,iType:tt}};class K{constructor(Y){this.normalizedDispatchGroup=Y}guardAgainstOutOfBoundsWorkgroupSizes(Y){return`if (global_idx >= ${typeof Y=="number"?`${Y}u`:Y}) { return; }`}mainStart(Y=F.WORKGROUP_SIZE){const tt=typeof Y=="number"?Y:Y[0],et=typeof Y=="number"?1:Y[1],q=typeof Y=="number"?1:Y[2],G=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1;return`@compute @workgroup_size(${tt}, ${et}, ${q})
  fn main(${G?"@builtin(global_invocation_id) global_id : vec3<u32>":`@builtin(local_invocation_index) local_index : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>`}) {
    ${G?"let global_idx = global_id.x;":`let global_idx = (workgroup_id.z * ${this.normalizedDispatchGroup[0]*this.normalizedDispatchGroup[1]}u +
          workgroup_id.y * ${this.normalizedDispatchGroup[0]}u + workgroup_id.x) * ${tt*et*q}u + local_index;`}
  `}}F.createShaderHelper=Q=>new K(Q)},9192:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.createGroupedConvProgramInfoLoader=void 0;const X=W(6952),K=W(1163),Q=W(2075),Y=W(9770),tt=W(3997);F.createGroupedConvProgramInfoLoader=(et,q,G)=>{const O=(b=et.length>2,j=q.cacheKey,{name:"GroupedConv",inputTypes:b?[K.GpuDataType.default,K.GpuDataType.default,K.GpuDataType.default]:[K.GpuDataType.default,K.GpuDataType.default],cacheHint:j});var b,j;return Object.assign(Object.assign({},O),{get:()=>((U,J,nt,rt)=>{const ot=U.length>2,at=ot?"value += b[output_channel];":"",ut=U[0].dims,st=U[1].dims,ct=st[0]/nt.group,dt="f32",{activationFunction:pt,applyActivation:lt}=(0,tt.getActicationSnippet)(nt),ft=[`@group(0) @binding(0) var<storage, read> x : array<${dt}>;`,`@group(0) @binding(1) var<storage, read> w : array<${dt}>;`];ot&&ft.push(`@group(0) @binding(2) var<storage, read> b : array<${dt}>;`);const gt=nt.format==="NHWC",_t=(0,Y.calculateOutputShape)(ut,st,nt.dilations,nt.pads,nt.strides,gt),wt=X.ShapeUtil.size(_t),bt=(0,Q.createIndicesHelper)("output",_t),Ot=(0,Q.createIndicesHelper)("x",ut),vt=(0,Q.createIndicesHelper)("w",st);return Object.assign(Object.assign({},J),{outputs:[{dims:rt?rt(_t):_t,dataType:U[0].dataType,gpuDataType:K.GpuDataType.default}],getShaderSource:xt=>`
  const strides: vec2<u32> = vec2(${nt.strides[0]}u, ${nt.strides[1]}u);
  const pads: vec2<u32> = vec2(${nt.pads[0]}u, ${nt.pads[1]}u);

  ${ft.join(`
`)}
  @group(0) @binding(${ft.length}) var<storage, read_write> output : array<${dt}>;

  ${pt}
  ${bt.o2iImpl}
  ${Ot.i2oImpl}
  ${vt.i2oImpl}

  ${xt.mainStart()}
    ${xt.guardAgainstOutOfBoundsWorkgroupSizes(wt)}

    ${bt.indicesVariableDeclaration("outputIndices")}
    ${bt.o2iCall("global_idx","outputIndices")}
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${gt?3:1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${gt?1:2}], outputIndices[${gt?2:3}]) * strides - pads;
    let group_id: u32 = output_channel / ${ct}u;

    var value: ${dt} = ${dt}(0);
    for (var wInChannel: u32 = 0u; wInChannel < ${st[1]}u; wInChannel++) {
      let input_channel = group_id * ${st[1]}u + wInChannel;
      for (var wHeight: u32 = 0u; wHeight < ${st[2]}u; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * ${nt.dilations[0]}u;

        if (xHeight < 0u || xHeight >= ${ut[gt?1:2]}u) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < ${st[3]}u; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * ${nt.dilations[1]}u;
          if (xWidth < 0u || xWidth >= ${ut[gt?2:3]}u) {
            continue;
          }

          ${Ot.indicesVariableDeclaration("xIndices",gt?["batch","xHeight","xWidth","input_channel"]:["batch","input_channel","xHeight","xWidth"])}
          let xVal = x[${Ot.i2oExpression("xIndices")}];
          ${vt.indicesVariableDeclaration("wIndices",["output_channel","wInChannel","wHeight","wWidth"])}
          let wVal = w[${vt.i2oExpression("wIndices")}];
          value += xVal*wVal;
        }
      }
    }
    ${at}
    ${lt}
    output[global_idx] = value;
  }`,dispatchGroup:()=>({x:Math.ceil(wt/64)})})})(et,O,q,G)})}},9770:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.conv=F.parseConvAttributes=F.calculateOutputShape=void 0;const X=W(6952),K=W(387),Q=W(9192),Y=W(3822),tt=W(3997),et=W(2625);F.calculateOutputShape=(O,b,j,U,J,nt)=>{const rt=O[0],ot=O.slice(nt?1:2,nt?3:4),at=ot.length,ut=b[0],st=b.slice(2).map((dt,pt)=>dt+(dt-1)*(j[pt]-1)),ct=ot.map((dt,pt)=>dt+U[pt]+U[pt+at]).map((dt,pt)=>Math.floor((dt-st[pt]+J[pt])/J[pt]));return ct.splice(0,0,rt),ct.splice(nt?3:1,0,ut),ct};const q=(0,K.createAttributeWithCacheKey)({perm:[2,3,1,0]}),G=(O,b)=>{const j=O.kernelShape.slice();for(let nt=2;nt<b[1].dims.length;++nt)j[nt-2]===0&&(j[nt-2]=b[1].dims[nt]);const U=O.pads.slice();X.PoolConvUtil.adjustPadsBasedOnAutoPad(b[0].dims,O.strides,O.dilations,j,U,O.format==="NHWC",O.autoPad);const J=Object.assign({},O);return Object.assign(J,{kernelShape:j,pads:U,cacheKey:O.cacheKey}),J};F.parseConvAttributes=O=>{const b=(0,tt.parseInternalActivationAttributes)(O),j=O.format,U=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][O.auto_pad],J=O.dilations,nt=O.group,rt=O.kernel_shape,ot=O.pads,at=O.strides,ut=O.w_is_const();return(0,K.createAttributeWithCacheKey)(Object.assign({autoPad:U,format:j,dilations:J,group:nt,kernelShape:rt,pads:ot,strides:at,wIsConst:ut},b))},F.conv=(O,b)=>{((j,U)=>{if(!j||j.length!==2&&j.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(j[0].dims.length!==4&&j[0].dims.length!==3)throw new Error("currently only support conv 1D and 2D");if(j[0].dims.length!==j[1].dims.length)throw new Error("filter does not have same dimension as input");if(j[0].dims[U.format==="NHWC"?j[0].dims.length-1:1]!==j[1].dims[1]*U.group)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(j.length===3&&(j[2].dims.length!==1||j[1].dims[0]!==j[2].dims[0]))throw new Error("invalid bias");const J=j[0].dims.length-2;if(U.dilations.length!==J)throw new Error(`dilations should be ${J}D`);if(U.strides.length!==J)throw new Error(`strides should be ${J}D`);if(U.pads.length!==2*J)throw new Error(`pads should be ${2*J}D`);if(U.kernelShape.length!==0&&U.kernelShape.length!==j[1].dims.length-2)throw new Error("invalid kernel shape");if(j[0].dataType!==1||j[1].dataType!==1)throw new Error("Conv input(X,W) should be float tensor");if(j.length===3&&j[2].dataType!==1)throw new Error("Conv input(bias) should be float tensor")})(O.inputs,b),O.inputs[0].dims.length===3?((j,U)=>{const J=U.format==="NHWC",nt=[j.inputs[0].reshape(J?[j.inputs[0].dims[0],1,j.inputs[0].dims[1],j.inputs[0].dims[2]]:[j.inputs[0].dims[0],j.inputs[0].dims[1],1,j.inputs[0].dims[2]]),j.inputs[1].reshape([j.inputs[1].dims[0],j.inputs[1].dims[1],1,j.inputs[1].dims[2]])];j.inputs.length===3&&nt.push(j.inputs[2]);const rt=[0,U.pads[0],0,U.pads[1]],ot=[1].concat(U.strides),at=[1].concat(U.dilations),ut=[1].concat(U.kernelShape),st=G(Object.assign(Object.assign({},U),{pads:rt,strides:ot,dilations:at,kernelShape:ut}),nt);j.compute((0,Q.createGroupedConvProgramInfoLoader)(nt,st,ct=>J?[ct[0],ct[2],ct[3]]:[]))})(O,b):((j,U,J)=>{var nt;const rt=G(J,U),ot=U.length===3,at=J.format==="NHWC",ut=U[0].dims[at?1:2],st=U[0].dims[at?2:3],ct=U[0].dims[at?3:1],dt=U[1].dims[2],pt=U[1].dims[3],lt=(0,F.calculateOutputShape)(U[0].dims,U[1].dims,J.dilations,rt.pads,J.strides,at),ft=lt[at?1:2],gt=lt[at?2:3],_t=lt[at?3:1];if(at&&dt===ut&&pt===st&&J.autoPad==="VALID"||dt===1&&pt===1&&J.dilations[0]===1&&J.dilations[1]===1&&J.strides[0]===1&&J.strides[1]===1&&(J.autoPad==="SAME_UPPER"||J.autoPad==="SAME_LOWER"||J.autoPad==="VALID")||!at||J.group!==1)return void j.compute((0,Q.createGroupedConvProgramInfoLoader)(U,rt));const wt=at?ft*gt:_t,bt=at?_t:ft*gt,Ot=dt*pt*ct,vt=(nt=j.customData.wT)!==null&&nt!==void 0?nt:j.compute(Object.assign(Object.assign({},et.transposeProgramMetadata),{cacheHint:q.cacheKey,get:()=>(0,et.createTransposeProgramInfo)(U[1],q.perm)}),{inputs:[1],outputs:[J.wIsConst?-2:-1]})[0];J.wIsConst&&!j.customData.wT&&(j.customData.wT=vt);const xt=[U[0],vt];ot&&(at||U[2].dims.length!==1?xt.push(U[2]):xt.push(U[2].reshape([U[2].dims[0],1,1]))),j.compute((0,Y.createConv2DMatMulProgramInfoLoader)(xt,rt,lt,wt,bt,Ot,ot,!0),{inputs:xt})})(O,O.inputs,b)}},3822:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.createConv2DMatMulProgramInfoLoader=void 0;const X=W(1163),K=W(9456);F.createConv2DMatMulProgramInfoLoader=(Q,Y,tt,et,q,G,O,b)=>{const j=((U,J)=>({name:"Conv2DMatMul",inputTypes:U?[X.GpuDataType.default,X.GpuDataType.default,X.GpuDataType.default]:[X.GpuDataType.default,X.GpuDataType.default],cacheHint:J}))(O,Y.cacheKey);return Object.assign(Object.assign({},j),{get:()=>(0,K.createConv2DMatMulProgramInfo)(Q,j,Y,tt,et,q,G,O,b)})}},3997:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.parseInternalActivationAttributes=F.getActicationSnippet=void 0;const X=W(6952);F.getActicationSnippet=K=>{switch(K.activation){case"Relu":return{activationFunction:"",applyActivation:"value = max(value, 0.0);"};case"Sigmoid":return{activationFunction:"",applyActivation:"value = (1.0 / (1.0 + exp(-value)));"};case"Clip":return{activationFunction:`const clip_min_=f32(${K.clipMin});const clip_max_=f32(${K.clipMax});`,applyActivation:"value = clamp(value, clip_min_, clip_max_);"};default:return{activationFunction:"",applyActivation:""}}},F.parseInternalActivationAttributes=K=>{const Q=(K==null?void 0:K.activation)||"";if(Q==="Clip"){const[Y,tt]=(K==null?void 0:K.activation_params)||[X.MIN_CLIP,X.MAX_CLIP];return{activation:Q,clipMax:tt,clipMin:Y,activationCacheKey:`${Q}:${Y},${tt}`}}return{activation:Q,activationCacheKey:Q}}},4271:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.parseGemmAttributes=F.gemm=void 0;const X=W(6952),K=W(387),Q=W(1163);F.gemm=(Y,tt)=>{(et=>{if(!et)throw new Error("Input is missing");if(et.length<2||et.length>3)throw new Error("Invaid input number.");if(et.length===3&&et[2].dims.length>2)throw new Error("Invalid input shape of C");if(et[0].dataType!==1||et[1].dataType!==1||et.length===3&&et[2].dataType!==1)throw new Error("Invalid input type.");if(et[0].dataType!==et[1].dataType||et.length===3&&et[0].dataType!==et[2].dataType)throw new Error("Input types are mismatched")})(Y.inputs),Y.compute(((et,q)=>{const G={name:"Gemm",inputTypes:et.length===3?[Q.GpuDataType.default,Q.GpuDataType.default,Q.GpuDataType.default]:[Q.GpuDataType.default,Q.GpuDataType.default],cacheHint:q.cacheKey};return Object.assign(Object.assign({},G),{get:()=>((O,b,j)=>{const U=b[0].dims.slice(),J=b[1].dims.slice(),[nt,rt,ot]=X.GemmUtil.getShapeOfGemmResult(U,j.transA,J,j.transB,b.length===3?b[2].dims:void 0),at=[nt,rt];if(!at)throw new Error("Can't use gemm on the given tensors");const ut=X.ShapeUtil.size(at);let st="";j.transA&&j.transB?st="value += a[k * M + m] * b[n * K + k];":j.transA&&!j.transB?st="value += a[k * M + m] * b[k * N + n];":!j.transA&&j.transB?st="value += a[m * K + k] * b[n * K + k];":j.transA||j.transB||(st="value += a[m * K + k] * b[k * N + n];");const ct="f32",dt=j.alpha===1?"":"value *= alpha;",pt=b.length===3?`value += beta * c[${((ft,gt,_t)=>{if(_t.length===0)return"0u";const wt=_t.length===1&&ft!==1||_t.length===2&&_t[0]!==ft,bt=_t[_t.length-1]!==gt;let Ot="0u";return wt||(Ot+=`+ m * ${_t[_t.length-1]}u`),bt||(Ot+="+n"),Ot})(nt,rt,b[2].dims)}];`:"",lt=[`@group(0) @binding(0) var<storage, read> a : array<${ct}>;`,`@group(0) @binding(1) var<storage, read> b : array<${ct}>;`];return b.length===3&&lt.push(`@group(0) @binding(2) var<storage, read> c : array<${ct}>;`),Object.assign(Object.assign({},O),{outputs:[{dims:at,dataType:b[0].dataType,gpuDataType:Q.GpuDataType.default}],getShaderSource:ft=>`
  const M: u32 = ${nt}u;
  const N: u32 = ${rt}u;
  const K: u32 = ${ot}u;
  const alpha = ${ct}(${j.alpha});
  const beta = ${ct}(${j.beta});

  ${lt.join(`
`)}
  @group(0) @binding(${b.length}) var<storage, read_write> output : array<${ct}>;

  ${ft.mainStart()}
    ${ft.guardAgainstOutOfBoundsWorkgroupSizes(ut)}

    let m = global_id.x / N;
    let n = global_id.x % N;

    var value = ${ct}(0);
    for (var k: u32 = 0u; k<${ot}u; k++) {
      ${st}
    }

    ${dt}
    ${pt}
    output[global_id.x] = value;

  }`,dispatchGroup:()=>({x:Math.ceil(ut/64)})})})(G,et,q)})})(Y.inputs,tt))},F.parseGemmAttributes=Y=>(0,K.createAttributeWithCacheKey)(Y)},1522:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.matMul=F.createMatmulProgramInfoLoader=void 0;const X=W(6952),K=W(1163),Q=W(3997);F.createMatmulProgramInfoLoader=(Y,tt)=>{const et=(q=Y.length>2,G=tt.activationCacheKey,{name:"MatMul",inputTypes:q?[K.GpuDataType.default,K.GpuDataType.default,K.GpuDataType.default]:[K.GpuDataType.default,K.GpuDataType.default],cacheHint:G});var q,G;return Object.assign(Object.assign({},et),{get:()=>((O,b,j)=>{const U=b[0].dims,J=b[1].dims,nt=X.BroadcastUtil.calcShape(U,J,!0);if(!nt)throw new Error("Can't use matmul on the given tensors");const rt=X.ShapeUtil.size(nt),ot="f32",{activationFunction:at,applyActivation:ut}=(0,Q.getActicationSnippet)(j),st=nt[nt.length-2],ct=U[U.length-1],dt=nt[nt.length-1];return Object.assign(Object.assign({},O),{outputs:[{dims:nt,dataType:b[0].dataType,gpuDataType:K.GpuDataType.default}],getShaderSource:pt=>`
  const M: u32 = ${st}u;
  const N: u32 = ${dt}u;
  const K: u32 = ${ct}u;

  @group(0) @binding(0) var<storage, read> a : array<${ot}>;
  @group(0) @binding(1) var<storage, read> b : array<${ot}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${ot}>;

  ${at}

  ${pt.mainStart()}
    ${pt.guardAgainstOutOfBoundsWorkgroupSizes(rt)}

    let stack = global_idx / (M * N);
    let mn = global_idx % (M * N);
    let n = global_idx % N;
    let m = mn / N;

    let offsetA = stack * (M * K);
    let offsetB = stack * (K * N);

    var value = ${ot}(0);
    for (var k: u32 = 0u; k<${ct}u; k++) {
      value += a[offsetA + m * K + k] * b[offsetB + k * N + n];
    }
    ${ut}
    output[global_idx] = value;
  }`,dispatchGroup:()=>({x:Math.ceil(rt/64)})})})(et,Y,tt)})},F.matMul=Y=>{(tt=>{if(!tt||tt.length!==2)throw new Error("MatMul requires 2 inputs.");if(tt[0].dims[tt[0].dims.length-1]!==tt[1].dims[tt[1].dims.length-2])throw new Error("shared dimension does not match.");if(tt[0].dataType!==1||tt[1].dataType!==1)throw new Error("inputs should be float type")})(Y.inputs),Y.compute((0,F.createMatmulProgramInfoLoader)(Y.inputs,{activation:"",activationCacheKey:""}))}},5262:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.globalMaxPool=F.parseGlobalMaxPoolAttributes=F.parseMaxPoolAttributes=F.maxPool=F.globalAveragePool=F.parseGlobalAveragePoolAttributes=F.averagePool=F.parseAveragePoolAttributes=void 0;const X=W(6952),K=W(387),Q=W(1163),Y=W(2075),tt=U=>{if(!U||U.length!==1)throw new Error("Pool ops requires 1 input.");if(U[0].dims.length!==4)throw new Error("Pool ops supports 2-D inputs only for now.");if(U[0].dataType!==1)throw new Error("Invalid input type.")},et=(U,J,nt)=>{const rt=J.format==="NHWC",ot=rt?[U[0].dims[0],U[0].dims[3],U[0].dims[1],U[0].dims[2]]:U[0].dims.slice(),at=Object.hasOwnProperty.call(J,"dilations"),ut=J.kernelShape.slice(),st=J.strides.slice(),ct=at?J.dilations.slice():[],dt=J.pads.slice();X.PoolConvUtil.adjustPoolAttributes(nt,ot,ut,st,ct,dt);const pt=X.PoolConvUtil.computePoolOutputShape(nt,ot,st,ct,ut,dt,J.autoPad),lt=Object.assign({},J);return at?Object.assign(lt,{kernelShape:ut,strides:st,pads:dt,dilations:ct,cacheKey:J.cacheKey}):Object.assign(lt,{kernelShape:ut,strides:st,pads:dt,cacheKey:J.cacheKey}),[lt,rt?[pt[0],pt[2],pt[3],pt[1]]:pt]},q=(U,J,nt,rt,ot,at,ut,st)=>{const ct=rt.format==="NHWC",dt=J.length,pt=X.ShapeUtil.size(nt),lt=(0,Y.createIndicesHelper)("output",nt),ft=(0,Y.createIndicesHelper)("x",J);if(rt.kernelShape.length<=2){const gt=rt.kernelShape[rt.kernelShape.length-1],_t=rt.strides[rt.strides.length-1],wt=rt.pads[rt.pads.length/2-1],bt=dt-(ct?2:1);let Ot="",vt="",xt="";if(Ot=wt+rt.pads[rt.pads.length-1]!==0?`
              for (var i: u32 = 0u; i < ${gt}u; i++) {
                xIndices[${bt}] = indices[${bt}] * ${_t} - ${wt} + i;
                if (xIndices[${bt}] < 0 || xIndices[${bt}] >= ${J[bt]}) {
                  pad++;
                  continue;
                }
                let x_val = x[${ft.i2oExpression("xIndices")}];
                ${ot}
              }`:`
              for (var i: u32 = 0u; i < ${gt}u; i++) {
                xIndices[${bt}] = indices[${bt}] * ${_t} - ${wt} + i;
                let x_val = x[${ft.i2oExpression("xIndices")}];
                ${ot}
              }`,rt.kernelShape.length===2){const Rt=rt.kernelShape[rt.kernelShape.length-2],kt=rt.strides[rt.strides.length-2],Ht=rt.pads[rt.pads.length/2-2],Mt=rt.pads[rt.pads.length-2],qt=dt-(ct?3:2),Jt=J[qt];vt=Ht+Mt!==0?`
                for (var j: u32 = 0u; j < ${Rt}u; j++) {
                  xIndices[${qt}] = indices[${qt}] * ${kt} - ${Ht} + j;
                  if (xIndices[${qt}] < 0 || xIndices[${qt}] >= ${Jt}) {
                    pad+= ${gt};
                    continue;
                  }
              `:`
                for (var j: u32 = 0u; j < ${Rt}u; j++) {
                  xIndices[${qt}] = indices[${qt}] * ${kt} - ${Ht} + j;
                `,xt=`
              }
            `}return`
            @group(0) @binding(0) var<storage, read> x : array<${ut}>;
            @group(0) @binding(1) var<storage, read_write> output : array<${ut}>;

            ${lt.o2iImpl}
            ${ft.i2oImpl}

            ${U.mainStart()}
              ${U.guardAgainstOutOfBoundsWorkgroupSizes(pt)}

              ${lt.indicesVariableDeclaration("indices")}
              ${lt.o2iCall("global_idx","indices")}
              ${lt.indicesVariableDeclaration("xIndices")}
              ${lt.o2iCall("global_idx","xIndices")}

              var value: ${ut} = ${ut}(${st});
              var pad = 0;
              ${vt}
              ${Ot}
              ${xt}
              ${at}

              output[global_idx] = value;
            }`}{if(ct)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");const gt=X.ShapeUtil.size(rt.kernelShape),_t=X.ShapeUtil.computeStrides(rt.kernelShape),wt=_t.length,bt=rt.pads.length;let Ot="";return Ot=rt.pads.reduce((vt,xt)=>vt+xt)?`
                if (xIndices[j] >= inputDims[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${ft.i2oExpression("xIndices")}];
                ${ot}
              }`:`
              }
              let x_val = x[${ft.i2oExpression("xIndices")}];
              ${ot}
            `,`
            @group(0) @binding(0) var<storage, read> x : array<${ut}>;
            @group(0) @binding(1) var<storage, read_write> output : array<${ut}>;

            ${lt.o2iImpl}
            ${ft.i2oImpl}

            const pads = array<u32, ${bt}>(${rt.pads.map(vt=>`${vt}u`).join(",")});
            const inputDims = array<u32, ${dt}>(${J.map(vt=>`${vt}u`).join(",")});
            const kernelStrides = array<u32, ${wt}>(${_t.map(vt=>`${vt}u`).join(",")});
            const strides = array<u32, ${wt}>(${rt.strides.map(vt=>`${vt}u`).join(",")});

            ${U.mainStart()}
              ${U.guardAgainstOutOfBoundsWorkgroupSizes(pt)}

              ${lt.indicesVariableDeclaration("indices")}
              ${lt.o2iCall("global_idx","indices")}
              ${lt.indicesVariableDeclaration("xIndices")}
              ${lt.o2iCall("global_idx","xIndices")}

              var offsets: array<u32, ${wt}>;

              var value = ${ut}(${st});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < ${gt}u; i++) {
                var offset = i;
                for (var j = 0u; j < ${wt-1}u; j++) {
                  offsets[j] = offset / kernelStrides[j];
                  offset -= offsets[j] * kernelStrides[j];
                }
                offsets[${wt-1}] = offset;

                isPad = false;
                for (var j = ${dt-wt}u; j < ${dt}u; j++) {
                  xIndices[j] = indices[j] * strides[j - ${dt-wt}u]
                    + offsets[j - ${dt-wt}u] - pads[j - 2u];
                  ${Ot}
              }
              ${at}

              output[global_idx] = value;
            }`}},G=U=>({format:U.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][U.auto_pad],ceilMode:U.ceil_mode,kernelShape:U.kernel_shape,strides:U.strides,pads:U.pads}),O=(U,J,nt,rt)=>{const[ot,at]=et(U,rt,nt),ut=X.ShapeUtil.size(ot.kernelShape),st="f32";let ct="";return ot.countIncludePad?ct+=`value /= ${st}(${ut});`:ct+=`value /= ${st}(${ut} - pad);`,Object.assign(Object.assign({},J),{outputs:[{dims:at,dataType:U[0].dataType,gpuDataType:Q.GpuDataType.default}],getShaderSource:dt=>q(dt,U[0].dims,at,ot,"value += x_val;",ct,st,"0.0"),dispatchGroup:()=>({x:Math.ceil(X.ShapeUtil.size(at)/64)})})};F.parseAveragePoolAttributes=U=>{const J=U.count_include_pad!==0,nt=G(U);if(nt.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return(0,K.createAttributeWithCacheKey)(Object.assign({countIncludePad:J},nt))},F.averagePool=(U,J)=>{tt(U.inputs);const nt={name:"AveragePool",inputTypes:[Q.GpuDataType.default],cacheHint:J.cacheKey};U.compute(Object.assign(Object.assign({},nt),{get:()=>O(U.inputs,nt,!1,J)}))};const b={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""};F.parseGlobalAveragePoolAttributes=U=>{const J=U.format;return Object.assign(Object.assign({format:J},b),{cacheKey:J})},F.globalAveragePool=(U,J)=>{tt(U.inputs);const nt={name:"GlobalAveragePool",inputTypes:[Q.GpuDataType.default],cacheHint:J.cacheKey};U.compute(Object.assign(Object.assign({},nt),{get:()=>O(U.inputs,nt,!0,J)}))};const j=(U,J,nt,rt)=>{const[ot,at]=et(U,rt,nt);return Object.assign(Object.assign({},J),{outputs:[{dims:at,dataType:U[0].dataType,gpuDataType:Q.GpuDataType.default}],getShaderSource:ut=>q(ut,U[0].dims,at,ot,`
      value = max(x_val, value);
    `,"","f32","-1e5"),dispatchGroup:()=>({x:Math.ceil(X.ShapeUtil.size(at)/64)})})};F.maxPool=(U,J)=>{tt(U.inputs);const nt={name:"MaxPool",inputTypes:[Q.GpuDataType.default],cacheHint:J.cacheKey};U.compute(Object.assign(Object.assign({},nt),{get:()=>j(U.inputs,nt,!1,J)}))},F.parseMaxPoolAttributes=U=>{const J=U.storage_order,nt=U.dilations,rt=G(U);if(J!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(rt.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return(0,K.createAttributeWithCacheKey)(Object.assign({storageOrder:J,dilations:nt},rt))},F.parseGlobalMaxPoolAttributes=U=>{const J=U.format;return Object.assign(Object.assign({format:J},b),{cacheKey:J})},F.globalMaxPool=(U,J)=>{tt(U.inputs);const nt={name:"GlobalMaxPool",inputTypes:[Q.GpuDataType.default],cacheHint:J.cacheKey};U.compute(Object.assign(Object.assign({},nt),{get:()=>j(U.inputs,nt,!0,J)}))}},2625:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.parseTransposeAttributes=F.transpose=F.createTransposeProgramInfo=F.transposeProgramMetadata=void 0;const X=W(6952),K=W(387),Q=W(1163),Y=W(2075);F.transposeProgramMetadata={name:"Transpose",inputTypes:[Q.GpuDataType.default]};const tt=(et,q)=>q&&q.length!==et.length?[...et.keys()].reverse():q;F.createTransposeProgramInfo=(et,q)=>{const G=et.dims,O=tt(G,q),b=((rt,ot)=>X.ShapeUtil.sortBasedOnPerm(rt,tt(rt,ot)))(G,O),j=G.length,U=X.ShapeUtil.size(b),J=(0,Y.createIndicesHelper)("output",b),nt=(0,Y.createIndicesHelper)("a",G);return Object.assign(Object.assign({},F.transposeProgramMetadata),{outputs:[{dims:b,dataType:et.dataType,gpuDataType:Q.GpuDataType.default}],getShaderSource:rt=>`
  @group(0) @binding(0) var<storage, read> a : array<f32>;
  @group(0) @binding(1) var<storage, read_write> output : array<f32>;

  ${((ot,at)=>{const ut=[];ut.push(`fn perm(a: ptr<function, array<u32, ${at}>>, i: ptr<function, array<u32, ${at}>>) {`);for(let st=0;st<at;++st)ut.push(`	(*a)[${ot[st]}]=(*i)[${st}];`);return ut.push("	}"),ut.join(`
`)})(O,j)}
  ${J.o2iImpl}
  ${nt.i2oImpl}

  ${rt.mainStart()}
    ${rt.guardAgainstOutOfBoundsWorkgroupSizes(U)}

    ${J.indicesVariableDeclaration("indices")}
    ${J.o2iCall("global_idx","indices")}
    ${nt.indicesVariableDeclaration("aIndices")}
    perm(&aIndices, &indices);

    output[global_idx] = a[${nt.i2oExpression("aIndices")}];
  }`,dispatchGroup:()=>({x:Math.ceil(U/64)})})},F.transpose=(et,q)=>{(G=>{if(!G||G.length!==1)throw new Error("Transpose requires 1 input.");if(G[0].dataType!==1)throw new Error("input should be float tensor")})(et.inputs),et.compute(Object.assign(Object.assign({},F.transposeProgramMetadata),{cacheHint:q.cacheKey,get:()=>(0,F.createTransposeProgramInfo)(et.inputs[0],q.perm)}))},F.parseTransposeAttributes=et=>(0,K.createAttributeWithCacheKey)({perm:et.perm})},9302:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.thresholdedRelu=F.tanh=F.tan=F.sqrt=F.sinh=F.sin=F.sigmoid=F.relu=F.reciprocal=F.neg=F.leakyRelu=F.floor=F.exp=F.erf=F.elu=F.parseAlphaAttributes=F.cosh=F.cos=F.ceil=F.clip=F.clipV10=F.atanh=F.atan=F.asinh=F.asin=F.acosh=F.acos=F.abs=void 0;const X=W(6952),K=W(387),Q=W(1163),Y=(tt,et,q,G,O)=>{const b={name:et,inputTypes:[Q.GpuDataType.default],cacheHint:O};return Object.assign(Object.assign({},b),{get:()=>((j,U,J,nt)=>Object.assign(Object.assign({},j),{getShaderSource:rt=>((ot,at,ut,st)=>{const ct=Math.ceil(at/4);let dt="";return dt=typeof ut=="string"?`${ut}(a)`:ut("a"),`
  @group(0) @binding(0) var<storage, read> inputData : array<vec4<f32>>;
  @group(0) @binding(1) var<storage, read_write> outputData : array<vec4<f32>>;

  ${st??""}

  ${ot.mainStart()}
    ${ot.guardAgainstOutOfBoundsWorkgroupSizes(ct)}

    let a = inputData[global_idx];
    outputData[global_idx] = ${dt};
  }`})(rt,X.ShapeUtil.size(U.dims),J,nt),outputs:[{dims:U.dims,dataType:U.dataType,gpuDataType:Q.GpuDataType.default}],dispatchGroup:rt=>({x:Math.ceil(X.ShapeUtil.size(rt[0].dims)/64/4)})}))(b,tt,q,G)})};F.abs=tt=>{tt.compute(Y(tt.inputs[0],"Abs","abs"))},F.acos=tt=>{tt.compute(Y(tt.inputs[0],"Acos","acos"))},F.acosh=tt=>{tt.compute(Y(tt.inputs[0],"Acosh","acosh"))},F.asin=tt=>{tt.compute(Y(tt.inputs[0],"Asin","asin"))},F.asinh=tt=>{tt.compute(Y(tt.inputs[0],"Asinh","asinh"))},F.atan=tt=>{tt.compute(Y(tt.inputs[0],"Atan","atan"))},F.atanh=tt=>{tt.compute(Y(tt.inputs[0],"Atanh","atanh"))},F.clipV10=(tt,et)=>{tt.compute(Y(tt.inputs[0],"Clip",q=>`clamp(${q}, clip_min_, clip_max_)`,`
    const clip_min_: vec4<f32> = vec4(f32(${et.min}));
    const clip_max_: vec4<f32> = vec4(f32(${et.max}));
`,et.cacheKey),{inputs:[0]})},F.clip=tt=>{const et=(q=>{const G=q.length>=2?q[1].getFloat32Array()[0]:X.MIN_CLIP,O=q.length>=3?q[2].getFloat32Array()[0]:X.MAX_CLIP;return(0,K.createAttributeWithCacheKey)({min:G,max:O})})(tt.inputs);(0,F.clipV10)(tt,et)},F.ceil=tt=>{tt.compute(Y(tt.inputs[0],"Ceil","ceil"))},F.cos=tt=>{tt.compute(Y(tt.inputs[0],"Cos","cos"))},F.cosh=tt=>{tt.compute(Y(tt.inputs[0],"Cosh","cosh"))},F.parseAlphaAttributes=tt=>(0,K.createAttributeWithCacheKey)(tt),F.elu=(tt,et)=>{tt.compute(Y(tt.inputs[0],"Elu",q=>`elu_vf32(${q})`,`
  const elu_alpha_: f32 = f32(${et.alpha});

  fn elu_f32(a: f32) -> f32 {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<f32>) -> vec4<f32> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,et.cacheKey))},F.erf=tt=>{tt.compute(Y(tt.inputs[0],"Erf",et=>`erf_vf32(${et})`,`
  const r0: f32 = 0.3275911;
  const r1: f32 = 0.254829592;
  const r2: f32 = -0.284496736;
  const r3: f32 = 1.421413741;
  const r4: f32 = -1.453152027;
  const r5: f32 = 1.061405429;

  fn erf_vf32(v: vec4<f32>) -> vec4<f32> {
    let absv = abs(v);
    let x = 1.0 / (1.0 + r0 * absv);
    return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
  }`))},F.exp=tt=>{tt.compute(Y(tt.inputs[0],"Exp","exp"))},F.floor=tt=>{tt.compute(Y(tt.inputs[0],"Floor","floor"))},F.leakyRelu=(tt,et)=>{tt.compute(Y(tt.inputs[0],"LeakyRelu",q=>`select(leaky_relu_alpha_ * ${q}, ${q}, ${q} >= vec4<f32>(0.0))`,`const leaky_relu_alpha_: f32 = f32(${et.alpha});`,et.cacheKey))},F.neg=tt=>{tt.compute(Y(tt.inputs[0],"Neg",et=>`-${et}`))},F.reciprocal=tt=>{tt.compute(Y(tt.inputs[0],"Reciprocal",et=>`1.0/${et}`))},F.relu=tt=>{tt.compute(Y(tt.inputs[0],"Relu",et=>`select(vec4<f32>(0.0), ${et}, ${et} > vec4<f32>(0.0))`))},F.sigmoid=tt=>{tt.compute(Y(tt.inputs[0],"Sigmoid",et=>`(1.0 / (1.0 + exp(-${et})))`))},F.sin=tt=>{tt.compute(Y(tt.inputs[0],"Sin","sin"))},F.sinh=tt=>{tt.compute(Y(tt.inputs[0],"Sinh","sinh"))},F.sqrt=tt=>{tt.compute(Y(tt.inputs[0],"Sqrt","sqrt"))},F.tan=tt=>{tt.compute(Y(tt.inputs[0],"Tan","tan"))},F.tanh=tt=>{tt.compute(Y(tt.inputs[0],"Tanh","tanh"))},F.thresholdedRelu=(tt,et)=>(tt.compute(Y(tt.inputs[0],"ThresholdedRelu",q=>`select(vec4<f32>(0.0), ${q}, ${q} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_: vec4<f32> = vec4<f32>(${et.alpha});`,et.cacheKey)),0)},8305:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.ProgramManager=void 0;const X=W(4955),K=W(2075);F.ProgramManager=class{constructor(Q){this.backend=Q,this.repo=new Map,this.attributesBound=!1}getArtifact(Q){return this.repo.get(Q)}setArtifact(Q,Y){this.repo.set(Q,Y)}run(Q,Y,tt,et){const q=this.backend.device,G=this.backend.getComputePassEncoder();this.backend.profilingEnabled&&G.writeTimestamp(this.backend.profilingQuerySet,0),G.setPipeline(Q.computePipeline);const O=[];for(const j of Y)O.push({binding:O.length,resource:{buffer:j.buffer}});for(const j of tt)O.push({binding:O.length,resource:{buffer:j.buffer}});const b=q.createBindGroup({layout:Q.computePipeline.getBindGroupLayout(0),entries:O});if(G.setBindGroup(0,b),G.dispatchWorkgroups(...et),this.backend.pendingDispatchNumber++,this.backend.profilingEnabled){G.writeTimestamp(this.backend.profilingQuerySet,1);const j=this.backend.gpuDataManager.create(16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),U=this.backend.gpuDataManager.create(16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.backend.endComputePass(),this.backend.getCommandEncoder().resolveQuerySet(this.backend.profilingQuerySet,0,2,j.buffer,0),this.backend.getCommandEncoder().copyBufferToBuffer(j.buffer,0,U.buffer,0,16),this.backend.flush();const J=this.backend.currentKernelId,nt=this.backend.kernels.get(J)[0];U.buffer.mapAsync(GPUMapMode.READ).then(()=>{const rt=new BigUint64Array(U.buffer.getMappedRange()),ot=rt[0],at=rt[1];U.buffer.unmap(),this.backend.profilingTimeBase===void 0&&(this.backend.profilingTimeBase=ot);const ut=Number(ot-this.backend.profilingTimeBase),st=Number(at-this.backend.profilingTimeBase);if(!Number.isSafeInteger(ut)||!Number.isSafeInteger(st))throw new RangeError("incorrect timestamp range");this.backend.gpuDataManager.release(j.id),this.backend.gpuDataManager.release(U.id),console.log(`[profiling] kernel "${J}|${nt}" execution time: ${st-ut} ns`)})}this.backend.pendingDispatchNumber>=16&&this.backend.flush()}dispose(){}build(Q,Y){const tt=this.backend.device,et=Q.getShaderSource((0,K.createShaderHelper)(Y)),q=tt.createShaderModule({code:et});return(0,X.LOG_DEBUG)("verbose",()=>`[WebGPU] shader code: ${et}`),{programInfo:Q,computePipeline:tt.createComputePipeline({compute:{module:q,entryPoint:"main"},layout:"auto"})}}normalizeDispatchGroupSize(Q){const Y=typeof Q=="number"?Q:Q.x,tt=typeof Q=="number"?1:Q.y||1,et=typeof Q=="number"?1:Q.z||1,q=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(Y<=q&&tt<=q&&et<=q)return[Y,tt,et];const G=Y*tt*et;let O=Math.ceil(Math.sqrt(G));if(O>q){if(O=Math.ceil(Math.cbrt(G)),O>q)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[O,O,O]}return[O,O,1]}}},1163:(it,F)=>{var W;Object.defineProperty(F,"__esModule",{value:!0}),F.GpuDataType=void 0,(W=F.GpuDataType||(F.GpuDataType={}))[W.default=0]="default",W[W.upload=1]="upload",W[W.profile=2]="profile"},3899:(it,F)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.iterateExtraOptions=void 0,F.iterateExtraOptions=(W,X,K,Q)=>{if(typeof W=="object"&&W!==null){if(K.has(W))throw new Error("Circular reference in options");K.add(W)}Object.entries(W).forEach(([Y,tt])=>{const et=X?X+Y:Y;if(typeof tt=="object")(0,F.iterateExtraOptions)(tt,et+".",K,Q);else if(typeof tt=="string"||typeof tt=="number")Q(et,tt.toString());else{if(typeof tt!="boolean")throw new Error("Can't handle extra config type: "+typeof tt);Q(et,tt?"1":"0")}})}},9544:function(it,F,W){var X,K=this&&this.__createBinding||(Object.create?function(gt,_t,wt,bt){bt===void 0&&(bt=wt);var Ot=Object.getOwnPropertyDescriptor(_t,wt);Ot&&!("get"in Ot?!_t.__esModule:Ot.writable||Ot.configurable)||(Ot={enumerable:!0,get:function(){return _t[wt]}}),Object.defineProperty(gt,bt,Ot)}:function(gt,_t,wt,bt){bt===void 0&&(bt=wt),gt[bt]=_t[wt]}),Q=this&&this.__setModuleDefault||(Object.create?function(gt,_t){Object.defineProperty(gt,"default",{enumerable:!0,value:_t})}:function(gt,_t){gt.default=_t}),Y=this&&this.__importStar||function(gt){if(gt&&gt.__esModule)return gt;var _t={};if(gt!=null)for(var wt in gt)wt!=="default"&&Object.prototype.hasOwnProperty.call(gt,wt)&&K(_t,gt,wt);return Q(_t,gt),_t};Object.defineProperty(F,"__esModule",{value:!0}),F.endProfiling=F.run=F.releaseSession=F.createSession=F.createSessionFinalize=F.createSessionAllocate=F.initOrt=F.initWasm=void 0;const tt=W(8453),et=W(7675),q=Y(W(1259)),G=W(263),O=()=>!!tt.env.wasm.proxy&&typeof document<"u";let b,j,U,J=!1,nt=!1,rt=!1;const ot=[],at=[],ut=[],st=[],ct=[],dt=[],pt=()=>{if(J||!nt||rt||!b)throw new Error("worker not ready")},lt=gt=>{switch(gt.data.type){case"init-wasm":J=!1,gt.data.err?(rt=!0,j[1](gt.data.err)):(nt=!0,j[0]());break;case"init-ort":gt.data.err?U[1](gt.data.err):U[0]();break;case"create_allocate":gt.data.err?ot.shift()[1](gt.data.err):ot.shift()[0](gt.data.out);break;case"create_finalize":gt.data.err?at.shift()[1](gt.data.err):at.shift()[0](gt.data.out);break;case"create":gt.data.err?ut.shift()[1](gt.data.err):ut.shift()[0](gt.data.out);break;case"release":gt.data.err?st.shift()[1](gt.data.err):st.shift()[0]();break;case"run":gt.data.err?ct.shift()[1](gt.data.err):ct.shift()[0](gt.data.out);break;case"end-profiling":gt.data.err?dt.shift()[1](gt.data.err):dt.shift()[0]()}},ft=typeof document<"u"?(X=document==null?void 0:document.currentScript)===null||X===void 0?void 0:X.src:void 0;F.initWasm=async()=>{if(O()){if(nt)return;if(J)throw new Error("multiple calls to 'initWasm()' detected.");if(rt)throw new Error("previous call to 'initWasm()' failed.");return J=!0,tt.env.wasm.wasmPaths===void 0&&ft&&ft.indexOf("blob:")!==0&&(tt.env.wasm.wasmPaths=ft.substr(0,+ft.lastIndexOf("/")+1)),new Promise((gt,_t)=>{b==null||b.terminate(),b=W(8050).Z(),b.onmessage=lt,j=[gt,_t];const wt={type:"init-wasm",in:tt.env.wasm};b.postMessage(wt)})}return(0,G.initializeWebAssembly)(tt.env.wasm)},F.initOrt=async(gt,_t)=>{if(O())return pt(),new Promise((wt,bt)=>{U=[wt,bt];const Ot={type:"init-ort",in:{numThreads:gt,loggingLevel:_t}};b.postMessage(Ot)});q.initOrt(gt,_t),await(0,et.init)((0,G.getInstance)())},F.createSessionAllocate=async gt=>O()?(pt(),new Promise((_t,wt)=>{ot.push([_t,wt]);const bt={type:"create_allocate",in:{model:gt}};b.postMessage(bt,[gt.buffer])})):q.createSessionAllocate(gt),F.createSessionFinalize=async(gt,_t)=>O()?(pt(),new Promise((wt,bt)=>{at.push([wt,bt]);const Ot={type:"create_finalize",in:{modeldata:gt,options:_t}};b.postMessage(Ot)})):q.createSessionFinalize(gt,_t),F.createSession=async(gt,_t)=>O()?(pt(),new Promise((wt,bt)=>{ut.push([wt,bt]);const Ot={type:"create",in:{model:gt,options:_t}};b.postMessage(Ot,[gt.buffer])})):q.createSession(gt,_t),F.releaseSession=async gt=>{if(O())return pt(),new Promise((_t,wt)=>{st.push([_t,wt]);const bt={type:"release",in:gt};b.postMessage(bt)});q.releaseSession(gt)},F.run=async(gt,_t,wt,bt,Ot)=>O()?(pt(),new Promise((vt,xt)=>{ct.push([vt,xt]);const Rt={type:"run",in:{sessionId:gt,inputIndices:_t,inputs:wt,outputIndices:bt,options:Ot}};b.postMessage(Rt,q.extractTransferableBuffers(wt))})):q.run(gt,_t,wt,bt,Ot),F.endProfiling=async gt=>{if(O())return pt(),new Promise((_t,wt)=>{dt.push([_t,wt]);const bt={type:"end-profiling",in:gt};b.postMessage(bt)});q.endProfiling(gt)}},7918:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.setRunOptions=void 0;const X=W(3899),K=W(9444),Q=W(263);F.setRunOptions=Y=>{const tt=(0,Q.getInstance)();let et=0;const q=[],G=Y||{};try{if((Y==null?void 0:Y.logSeverityLevel)===void 0)G.logSeverityLevel=2;else if(typeof Y.logSeverityLevel!="number"||!Number.isInteger(Y.logSeverityLevel)||Y.logSeverityLevel<0||Y.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${Y.logSeverityLevel}`);if((Y==null?void 0:Y.logVerbosityLevel)===void 0)G.logVerbosityLevel=0;else if(typeof Y.logVerbosityLevel!="number"||!Number.isInteger(Y.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${Y.logVerbosityLevel}`);(Y==null?void 0:Y.terminate)===void 0&&(G.terminate=!1);let O=0;if((Y==null?void 0:Y.tag)!==void 0&&(O=(0,K.allocWasmString)(Y.tag,q)),et=tt._OrtCreateRunOptions(G.logSeverityLevel,G.logVerbosityLevel,!!G.terminate,O),et===0)throw new Error("Can't create run options");return(Y==null?void 0:Y.extra)!==void 0&&(0,X.iterateExtraOptions)(Y.extra,"",new WeakSet,(b,j)=>{const U=(0,K.allocWasmString)(b,q),J=(0,K.allocWasmString)(j,q);if(tt._OrtAddRunConfigEntry(et,U,J)!==0)throw new Error(`Can't set a run config entry: ${b} - ${j}`)}),[et,q]}catch(O){throw et!==0&&tt._OrtReleaseRunOptions(et),q.forEach(tt._free),O}}},6640:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.OnnxruntimeWebAssemblySessionHandler=void 0;const X=W(2806),K=W(8453),Q=W(2850),Y=W(9544),tt=W(7917);let et;F.OnnxruntimeWebAssemblySessionHandler=class{async createSessionAllocate(q){const G=await fetch(q),O=await G.arrayBuffer();return(0,Y.createSessionAllocate)(new Uint8Array(O))}async loadModel(q,G){if(et||(await(0,Y.initOrt)(K.env.wasm.numThreads,(0,tt.logLevelStringToEnum)(K.env.logLevel)),et=!0),typeof q=="string")if(typeof fetch>"u"){const O=await(0,Q.promisify)(X.readFile)(q);[this.sessionId,this.inputNames,this.outputNames]=await(0,Y.createSession)(O,G)}else{const O=await this.createSessionAllocate(q);[this.sessionId,this.inputNames,this.outputNames]=await(0,Y.createSessionFinalize)(O,G)}else[this.sessionId,this.inputNames,this.outputNames]=await(0,Y.createSession)(q,G)}async dispose(){return(0,Y.releaseSession)(this.sessionId)}async run(q,G,O){const b=[],j=[];Object.entries(q).forEach(rt=>{const ot=rt[0],at=rt[1],ut=this.inputNames.indexOf(ot);if(ut===-1)throw new Error(`invalid input '${ot}'`);b.push(at),j.push(ut)});const U=[];Object.entries(G).forEach(rt=>{const ot=rt[0],at=this.outputNames.indexOf(ot);if(at===-1)throw new Error(`invalid output '${ot}'`);U.push(at)});const J=await(0,Y.run)(this.sessionId,j,b.map(rt=>[rt.type,rt.dims,rt.data]),U,O),nt={};for(let rt=0;rt<J.length;rt++)nt[this.outputNames[U[rt]]]=new K.Tensor(J[rt][0],J[rt][2],J[rt][1]);return nt}startProfiling(){}endProfiling(){(0,Y.endProfiling)(this.sessionId)}}},7622:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.setSessionOptions=void 0;const X=W(3899),K=W(9444),Q=W(263);F.setSessionOptions=Y=>{var tt,et,q,G;const O=(0,Q.getInstance)();let b=0;const j=[],U=Y||{};(J=>{J.extra||(J.extra={}),J.extra.session||(J.extra.session={});const nt=J.extra.session;nt.use_ort_model_bytes_directly||(nt.use_ort_model_bytes_directly="1"),J.executionProviders&&J.executionProviders.some(rt=>(typeof rt=="string"?rt:rt.name)==="webgpu")&&(J.enableMemPattern=!1)})(U);try{const J=(st=>{switch(st){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${st}`)}})((tt=U.graphOptimizationLevel)!==null&&tt!==void 0?tt:"all"),nt=(st=>{switch(st){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${st}`)}})((et=U.executionMode)!==null&&et!==void 0?et:"sequential"),rt=typeof U.logId=="string"?(0,K.allocWasmString)(U.logId,j):0,ot=(q=U.logSeverityLevel)!==null&&q!==void 0?q:2;if(!Number.isInteger(ot)||ot<0||ot>4)throw new Error(`log serverity level is not valid: ${ot}`);const at=(G=U.logVerbosityLevel)!==null&&G!==void 0?G:0;if(!Number.isInteger(at)||at<0||at>4)throw new Error(`log verbosity level is not valid: ${at}`);const ut=typeof U.optimizedModelFilePath=="string"?(0,K.allocWasmString)(U.optimizedModelFilePath,j):0;if(b=O._OrtCreateSessionOptions(J,!!U.enableCpuMemArena,!!U.enableMemPattern,nt,!!U.enableProfiling,0,rt,ot,at,ut),b===0)throw new Error("Can't create session options");return U.executionProviders&&((st,ct,dt)=>{for(const pt of ct){let lt=typeof pt=="string"?pt:pt.name;switch(lt){case"xnnpack":lt="XNNPACK";break;case"webgpu":lt="JS";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported EP: ${lt}`)}const ft=(0,K.allocWasmString)(lt,dt);if((0,Q.getInstance)()._OrtAppendExecutionProvider(st,ft)!==0)throw new Error(`Can't append execution provider: ${lt}`)}})(b,U.executionProviders,j),U.extra!==void 0&&(0,X.iterateExtraOptions)(U.extra,"",new WeakSet,(st,ct)=>{const dt=(0,K.allocWasmString)(st,j),pt=(0,K.allocWasmString)(ct,j);if(O._OrtAddSessionConfigEntry(b,dt,pt)!==0)throw new Error(`Can't set a session config entry: ${st} - ${ct}`)}),[b,j]}catch(J){throw b!==0&&O._OrtReleaseSessionOptions(b),j.forEach(O._free),J}}},9444:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.allocWasmString=void 0;const X=W(263);F.allocWasmString=(K,Q)=>{const Y=(0,X.getInstance)(),tt=Y.lengthBytesUTF8(K)+1,et=Y._malloc(tt);return Y.stringToUTF8(K,et,tt),Q.push(et),et}},7917:(it,F)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.logLevelStringToEnum=F.tensorTypeToTypedArrayConstructor=F.getTensorElementSize=F.tensorDataTypeEnumToString=F.tensorDataTypeStringToEnum=void 0,F.tensorDataTypeStringToEnum=W=>{switch(W){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${W}`)}},F.tensorDataTypeEnumToString=W=>{switch(W){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${W}`)}},F.getTensorElementSize=W=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][W],F.tensorTypeToTypedArrayConstructor=W=>{switch(W){case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${W}`)}},F.logLevelStringToEnum=W=>{switch(W){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${W}`)}}},1259:(it,F,W)=>{Object.defineProperty(F,"__esModule",{value:!0}),F.extractTransferableBuffers=F.endProfiling=F.run=F.releaseSession=F.createSession=F.createSessionFinalize=F.createSessionAllocate=F.initOrt=void 0;const X=W(7918),K=W(7622),Q=W(9444),Y=W(7917),tt=W(263);F.initOrt=(q,G)=>{const O=(0,tt.getInstance)()._OrtInit(q,G);if(O!==0)throw new Error(`Can't initialize onnxruntime. error code = ${O}`)};const et=new Map;F.createSessionAllocate=q=>{const G=(0,tt.getInstance)(),O=G._malloc(q.byteLength);return G.HEAPU8.set(q,O),[O,q.byteLength]},F.createSessionFinalize=(q,G)=>{const O=(0,tt.getInstance)();let b=0,j=0,U=[];try{if([j,U]=(0,K.setSessionOptions)(G),b=O._OrtCreateSession(q[0],q[1],j),b===0)throw new Error("Can't create a session")}finally{O._free(q[0]),j!==0&&O._OrtReleaseSessionOptions(j),U.forEach(O._free)}const J=O._OrtGetInputCount(b),nt=O._OrtGetOutputCount(b),rt=[],ot=[],at=[],ut=[];for(let st=0;st<J;st++){const ct=O._OrtGetInputName(b,st);if(ct===0)throw new Error("Can't get an input name");ot.push(ct),rt.push(O.UTF8ToString(ct))}for(let st=0;st<nt;st++){const ct=O._OrtGetOutputName(b,st);if(ct===0)throw new Error("Can't get an output name");ut.push(ct),at.push(O.UTF8ToString(ct))}return et.set(b,[b,ot,ut]),[b,rt,at]},F.createSession=(q,G)=>{const O=(0,F.createSessionAllocate)(q);return(0,F.createSessionFinalize)(O,G)},F.releaseSession=q=>{const G=(0,tt.getInstance)(),O=et.get(q);if(!O)throw new Error("invalid session id");const b=O[0],j=O[1],U=O[2];j.forEach(G._OrtFree),U.forEach(G._OrtFree),G._OrtReleaseSession(b),et.delete(q)},F.run=async(q,G,O,b,j)=>{const U=(0,tt.getInstance)(),J=et.get(q);if(!J)throw new Error("invalid session id");const nt=J[0],rt=J[1],ot=J[2],at=G.length,ut=b.length;let st=0,ct=[];const dt=[],pt=[];try{[st,ct]=(0,X.setRunOptions)(j);for(let bt=0;bt<at;bt++){const Ot=O[bt][0],vt=O[bt][1],xt=O[bt][2];let Rt,kt;if(Array.isArray(xt)){kt=4*xt.length,Rt=U._malloc(kt),pt.push(Rt);let qt=Rt/4;for(let Jt=0;Jt<xt.length;Jt++){if(typeof xt[Jt]!="string")throw new TypeError(`tensor data at index ${Jt} is not a string`);U.HEAPU32[qt++]=(0,Q.allocWasmString)(xt[Jt],pt)}}else kt=xt.byteLength,Rt=U._malloc(kt),pt.push(Rt),U.HEAPU8.set(new Uint8Array(xt.buffer,xt.byteOffset,kt),Rt);const Ht=U.stackSave(),Mt=U.stackAlloc(4*vt.length);try{let qt=Mt/4;vt.forEach(Bt=>U.HEAP32[qt++]=Bt);const Jt=U._OrtCreateTensor((0,Y.tensorDataTypeStringToEnum)(Ot),Rt,kt,Mt,vt.length);if(Jt===0)throw new Error("Can't create a tensor");dt.push(Jt)}finally{U.stackRestore(Ht)}}const lt=U.stackSave(),ft=U.stackAlloc(4*at),gt=U.stackAlloc(4*at),_t=U.stackAlloc(4*ut),wt=U.stackAlloc(4*ut);try{let bt=ft/4,Ot=gt/4,vt=_t/4,xt=wt/4;for(let Mt=0;Mt<at;Mt++)U.HEAPU32[bt++]=dt[Mt],U.HEAPU32[Ot++]=rt[G[Mt]];for(let Mt=0;Mt<ut;Mt++)U.HEAPU32[vt++]=0,U.HEAPU32[xt++]=ot[b[Mt]];let Rt=U._OrtRun(nt,gt,ft,at,wt,ut,_t,st);const kt=U.jsepRunPromise;kt&&kt.then!==void 0&&(Rt=await kt);const Ht=[];if(Rt===0)for(let Mt=0;Mt<ut;Mt++){const qt=U.HEAPU32[_t/4+Mt],Jt=U.stackSave(),Bt=U.stackAlloc(16);let ee,ne=0;try{if(Rt=U._OrtGetTensorData(qt,Bt,Bt+4,Bt+8,Bt+12),Rt!==0)throw new Error(`Can't access output tensor data. error code = ${Rt}`);let Yt=Bt/4;const ae=U.HEAPU32[Yt++];ne=U.HEAPU32[Yt++];const Wt=U.HEAPU32[Yt++],se=U.HEAPU32[Yt++],Zt=[];for(let re=0;re<se;re++)Zt.push(U.HEAPU32[Wt/4+re]);U._OrtFree(Wt);const ue=Zt.length===0?1:Zt.reduce((re,pe)=>re*pe);if(ee=(0,Y.tensorDataTypeEnumToString)(ae),ee==="string"){const re=[];let pe=ne/4;for(let ye=0;ye<ue;ye++){const Ae=U.HEAPU32[pe++],Oe=ye===ue-1?void 0:U.HEAPU32[pe]-Ae;re.push(U.UTF8ToString(Ae,Oe))}Ht.push([ee,Zt,re])}else{const re=new((0,Y.tensorTypeToTypedArrayConstructor)(ee))(ue);new Uint8Array(re.buffer,re.byteOffset,re.byteLength).set(U.HEAPU8.subarray(ne,ne+re.byteLength)),Ht.push([ee,Zt,re])}}finally{U.stackRestore(Jt),ee==="string"&&ne&&U._free(ne),U._OrtReleaseTensor(qt)}}if(Rt===0)return Ht;throw new Error(`failed to call OrtRun(). error code = ${Rt}.`)}finally{U.stackRestore(lt)}}finally{dt.forEach(U._OrtReleaseTensor),pt.forEach(U._free),U._OrtReleaseRunOptions(st),ct.forEach(U._free)}},F.endProfiling=q=>{const G=(0,tt.getInstance)(),O=et.get(q);if(!O)throw new Error("invalid session id");const b=O[0],j=G._OrtEndProfiling(b);if(j===0)throw new Error("Can't get an profile file name");G._OrtFree(j)},F.extractTransferableBuffers=q=>{const G=[];for(const O of q){const b=O[2];!Array.isArray(b)&&b.buffer&&G.push(b.buffer)}return G}},263:function(it,F,W){var X=this&&this.__createBinding||(Object.create?function(j,U,J,nt){nt===void 0&&(nt=J);var rt=Object.getOwnPropertyDescriptor(U,J);rt&&!("get"in rt?!U.__esModule:rt.writable||rt.configurable)||(rt={enumerable:!0,get:function(){return U[J]}}),Object.defineProperty(j,nt,rt)}:function(j,U,J,nt){nt===void 0&&(nt=J),j[nt]=U[J]}),K=this&&this.__setModuleDefault||(Object.create?function(j,U){Object.defineProperty(j,"default",{enumerable:!0,value:U})}:function(j,U){j.default=U}),Q=this&&this.__importStar||function(j){if(j&&j.__esModule)return j;var U={};if(j!=null)for(var J in j)J!=="default"&&Object.prototype.hasOwnProperty.call(j,J)&&X(U,j,J);return K(U,j),U};Object.defineProperty(F,"__esModule",{value:!0}),F.dispose=F.getInstance=F.initializeWebAssembly=void 0;const Y=Q(W(6449)),tt=W(932),et=W(3474);let q,G=!1,O=!1,b=!1;F.initializeWebAssembly=async j=>{if(G)return Promise.resolve();if(O)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(b)throw new Error("previous call to 'initializeWebAssembly()' failed.");O=!0;const U=j.initTimeout,J=j.numThreads,nt=j.simd,rt=J>1&&(()=>{try{return typeof SharedArrayBuffer<"u"&&(typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch{return!1}})(),ot=nt&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}})(),at=j.wasmPaths,ut=typeof at=="string"?at:void 0,st=((lt,ft)=>ft?lt?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":lt?"ort-wasm-simd.wasm":"ort-wasm.wasm")(ot,rt),ct=typeof at=="object"?at[st]:void 0;let dt=!1;const pt=[];if(U>0&&pt.push(new Promise(lt=>{setTimeout(()=>{dt=!0,lt()},U)})),pt.push(new Promise((lt,ft)=>{const gt=rt?et:tt,_t={locateFile:(wt,bt)=>rt&&wt.endsWith(".worker.js")&&typeof Blob<"u"?URL.createObjectURL(new Blob([W(4154)],{type:"text/javascript"})):wt.endsWith(".wasm")?ct||(ut??bt)+st:bt+wt};if(rt)if(typeof Blob>"u")_t.mainScriptUrlOrBlob=Y.join("/","ort-wasm-threaded.js");else{const wt=`var ortWasmThreaded=(function(){var _scriptDir;return ${gt.toString()}})();`;_t.mainScriptUrlOrBlob=new Blob([wt],{type:"text/javascript"})}gt(_t).then(wt=>{O=!1,G=!0,q=wt,lt()},wt=>{O=!1,b=!0,ft(wt)})})),await Promise.race(pt),dt)throw new Error(`WebAssembly backend initializing failed due to timeout: ${U}ms`)},F.getInstance=()=>{if(G&&q)return q;throw new Error("WebAssembly is not initialized yet.")},F.dispose=()=>{var j;!G||O||b||(O=!0,(j=q.PThread)===null||j===void 0||j.terminateAllThreads(),q=void 0,O=!1,G=!1,b=!0)}},8050:(it,F,W)=>{W.d(F,{Z:()=>Q});var X=W(6614),K=W.n(X);function Q(){return K()('/*!\n* ONNX Runtime Web v1.15.1\n* Copyright (c) Microsoft Corporation. All rights reserved.\n* Licensed under the MIT License.\n*/\n(()=>{var e={899:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.iterateExtraOptions=void 0,t.iterateExtraOptions=(e,n,r,a)=>{if("object"==typeof e&&null!==e){if(r.has(e))throw new Error("Circular reference in options");r.add(e)}Object.entries(e).forEach((([e,o])=>{const i=n?n+e:e;if("object"==typeof o)(0,t.iterateExtraOptions)(o,i+".",r,a);else if("string"==typeof o||"number"==typeof o)a(i,o.toString());else{if("boolean"!=typeof o)throw new Error("Can\'t handle extra config type: "+typeof o);a(i,o?"1":"0")}}))}},918:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.setRunOptions=void 0;const r=n(899),a=n(444),o=n(263);t.setRunOptions=e=>{const t=(0,o.getInstance)();let n=0;const i=[],s=e||{};try{if(void 0===(null==e?void 0:e.logSeverityLevel))s.logSeverityLevel=2;else if("number"!=typeof e.logSeverityLevel||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(void 0===(null==e?void 0:e.logVerbosityLevel))s.logVerbosityLevel=0;else if("number"!=typeof e.logVerbosityLevel||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);void 0===(null==e?void 0:e.terminate)&&(s.terminate=!1);let o=0;if(void 0!==(null==e?void 0:e.tag)&&(o=(0,a.allocWasmString)(e.tag,i)),n=t._OrtCreateRunOptions(s.logSeverityLevel,s.logVerbosityLevel,!!s.terminate,o),0===n)throw new Error("Can\'t create run options");return void 0!==(null==e?void 0:e.extra)&&(0,r.iterateExtraOptions)(e.extra,"",new WeakSet,((e,r)=>{const o=(0,a.allocWasmString)(e,i),s=(0,a.allocWasmString)(r,i);if(0!==t._OrtAddRunConfigEntry(n,o,s))throw new Error(`Can\'t set a run config entry: ${e} - ${r}`)})),[n,i]}catch(e){throw 0!==n&&t._OrtReleaseRunOptions(n),i.forEach(t._free),e}}},622:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.setSessionOptions=void 0;const r=n(899),a=n(444),o=n(263);t.setSessionOptions=e=>{var t,n,i,s;const u=(0,o.getInstance)();let c=0;const l=[],f=e||{};(e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});const t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some((e=>"webgpu"===("string"==typeof e?e:e.name)))&&(e.enableMemPattern=!1)})(f);try{const e=(e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}})(null!==(t=f.graphOptimizationLevel)&&void 0!==t?t:"all"),p=(e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}})(null!==(n=f.executionMode)&&void 0!==n?n:"sequential"),d="string"==typeof f.logId?(0,a.allocWasmString)(f.logId,l):0,m=null!==(i=f.logSeverityLevel)&&void 0!==i?i:2;if(!Number.isInteger(m)||m<0||m>4)throw new Error(`log serverity level is not valid: ${m}`);const g=null!==(s=f.logVerbosityLevel)&&void 0!==s?s:0;if(!Number.isInteger(g)||g<0||g>4)throw new Error(`log verbosity level is not valid: ${g}`);const h="string"==typeof f.optimizedModelFilePath?(0,a.allocWasmString)(f.optimizedModelFilePath,l):0;if(c=u._OrtCreateSessionOptions(e,!!f.enableCpuMemArena,!!f.enableMemPattern,p,!!f.enableProfiling,0,d,m,g,h),0===c)throw new Error("Can\'t create session options");return f.executionProviders&&((e,t,n)=>{for(const r of t){let t="string"==typeof r?r:r.name;switch(t){case"xnnpack":t="XNNPACK";break;case"webgpu":t="JS";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported EP: ${t}`)}const i=(0,a.allocWasmString)(t,n);if(0!==(0,o.getInstance)()._OrtAppendExecutionProvider(e,i))throw new Error(`Can\'t append execution provider: ${t}`)}})(c,f.executionProviders,l),void 0!==f.extra&&(0,r.iterateExtraOptions)(f.extra,"",new WeakSet,((e,t)=>{const n=(0,a.allocWasmString)(e,l),r=(0,a.allocWasmString)(t,l);if(0!==u._OrtAddSessionConfigEntry(c,n,r))throw new Error(`Can\'t set a session config entry: ${e} - ${t}`)})),[c,l]}catch(e){throw 0!==c&&u._OrtReleaseSessionOptions(c),l.forEach(u._free),e}}},444:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.allocWasmString=void 0;const r=n(263);t.allocWasmString=(e,t)=>{const n=(0,r.getInstance)(),a=n.lengthBytesUTF8(e)+1,o=n._malloc(a);return n.stringToUTF8(e,o,a),t.push(o),o}},917:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.logLevelStringToEnum=t.tensorTypeToTypedArrayConstructor=t.getTensorElementSize=t.tensorDataTypeEnumToString=t.tensorDataTypeStringToEnum=void 0,t.tensorDataTypeStringToEnum=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},t.tensorDataTypeEnumToString=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},t.getTensorElementSize=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],t.tensorTypeToTypedArrayConstructor=e=>{switch(e){case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},t.logLevelStringToEnum=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}}},259:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.extractTransferableBuffers=t.endProfiling=t.run=t.releaseSession=t.createSession=t.createSessionFinalize=t.createSessionAllocate=t.initOrt=void 0;const r=n(918),a=n(622),o=n(444),i=n(917),s=n(263);t.initOrt=(e,t)=>{const n=(0,s.getInstance)()._OrtInit(e,t);if(0!==n)throw new Error(`Can\'t initialize onnxruntime. error code = ${n}`)};const u=new Map;t.createSessionAllocate=e=>{const t=(0,s.getInstance)(),n=t._malloc(e.byteLength);return t.HEAPU8.set(e,n),[n,e.byteLength]},t.createSessionFinalize=(e,t)=>{const n=(0,s.getInstance)();let r=0,o=0,i=[];try{if([o,i]=(0,a.setSessionOptions)(t),r=n._OrtCreateSession(e[0],e[1],o),0===r)throw new Error("Can\'t create a session")}finally{n._free(e[0]),0!==o&&n._OrtReleaseSessionOptions(o),i.forEach(n._free)}const c=n._OrtGetInputCount(r),l=n._OrtGetOutputCount(r),f=[],p=[],d=[],m=[];for(let e=0;e<c;e++){const t=n._OrtGetInputName(r,e);if(0===t)throw new Error("Can\'t get an input name");p.push(t),f.push(n.UTF8ToString(t))}for(let e=0;e<l;e++){const t=n._OrtGetOutputName(r,e);if(0===t)throw new Error("Can\'t get an output name");m.push(t),d.push(n.UTF8ToString(t))}return u.set(r,[r,p,m]),[r,f,d]},t.createSession=(e,n)=>{const r=(0,t.createSessionAllocate)(e);return(0,t.createSessionFinalize)(r,n)},t.releaseSession=e=>{const t=(0,s.getInstance)(),n=u.get(e);if(!n)throw new Error("invalid session id");const r=n[0],a=n[1],o=n[2];a.forEach(t._OrtFree),o.forEach(t._OrtFree),t._OrtReleaseSession(r),u.delete(e)},t.run=async(e,t,n,a,c)=>{const l=(0,s.getInstance)(),f=u.get(e);if(!f)throw new Error("invalid session id");const p=f[0],d=f[1],m=f[2],g=t.length,h=a.length;let y=0,v=[];const b=[],w=[];try{[y,v]=(0,r.setRunOptions)(c);for(let e=0;e<g;e++){const t=n[e][0],r=n[e][1],a=n[e][2];let s,u;if(Array.isArray(a)){u=4*a.length,s=l._malloc(u),w.push(s);let e=s/4;for(let t=0;t<a.length;t++){if("string"!=typeof a[t])throw new TypeError(`tensor data at index ${t} is not a string`);l.HEAPU32[e++]=(0,o.allocWasmString)(a[t],w)}}else u=a.byteLength,s=l._malloc(u),w.push(s),l.HEAPU8.set(new Uint8Array(a.buffer,a.byteOffset,u),s);const c=l.stackSave(),f=l.stackAlloc(4*r.length);try{let e=f/4;r.forEach((t=>l.HEAP32[e++]=t));const n=l._OrtCreateTensor((0,i.tensorDataTypeStringToEnum)(t),s,u,f,r.length);if(0===n)throw new Error("Can\'t create a tensor");b.push(n)}finally{l.stackRestore(c)}}const e=l.stackSave(),s=l.stackAlloc(4*g),u=l.stackAlloc(4*g),f=l.stackAlloc(4*h),_=l.stackAlloc(4*h);try{let e=s/4,n=u/4,r=f/4,o=_/4;for(let r=0;r<g;r++)l.HEAPU32[e++]=b[r],l.HEAPU32[n++]=d[t[r]];for(let e=0;e<h;e++)l.HEAPU32[r++]=0,l.HEAPU32[o++]=m[a[e]];let c=l._OrtRun(p,u,s,g,_,h,f,y);const v=l.jsepRunPromise;v&&void 0!==v.then&&(c=await v);const w=[];if(0===c)for(let e=0;e<h;e++){const t=l.HEAPU32[f/4+e],n=l.stackSave(),r=l.stackAlloc(16);let a,o=0;try{if(c=l._OrtGetTensorData(t,r,r+4,r+8,r+12),0!==c)throw new Error(`Can\'t access output tensor data. error code = ${c}`);let e=r/4;const n=l.HEAPU32[e++];o=l.HEAPU32[e++];const s=l.HEAPU32[e++],u=l.HEAPU32[e++],f=[];for(let e=0;e<u;e++)f.push(l.HEAPU32[s/4+e]);l._OrtFree(s);const p=0===f.length?1:f.reduce(((e,t)=>e*t));if(a=(0,i.tensorDataTypeEnumToString)(n),"string"===a){const e=[];let t=o/4;for(let n=0;n<p;n++){const r=l.HEAPU32[t++],a=n===p-1?void 0:l.HEAPU32[t]-r;e.push(l.UTF8ToString(r,a))}w.push([a,f,e])}else{const e=new((0,i.tensorTypeToTypedArrayConstructor)(a))(p);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(l.HEAPU8.subarray(o,o+e.byteLength)),w.push([a,f,e])}}finally{l.stackRestore(n),"string"===a&&o&&l._free(o),l._OrtReleaseTensor(t)}}if(0===c)return w;throw new Error(`failed to call OrtRun(). error code = ${c}.`)}finally{l.stackRestore(e)}}finally{b.forEach(l._OrtReleaseTensor),w.forEach(l._free),l._OrtReleaseRunOptions(y),v.forEach(l._free)}},t.endProfiling=e=>{const t=(0,s.getInstance)(),n=u.get(e);if(!n)throw new Error("invalid session id");const r=n[0],a=t._OrtEndProfiling(r);if(0===a)throw new Error("Can\'t get an profile file name");t._OrtFree(a)},t.extractTransferableBuffers=e=>{const t=[];for(const n of e){const e=n[2];!Array.isArray(e)&&e.buffer&&t.push(e.buffer)}return t}},263:function(e,t,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,t,n,r){void 0===r&&(r=n);var a=Object.getOwnPropertyDescriptor(t,n);a&&!("get"in a?!t.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,r,a)}:function(e,t,n,r){void 0===r&&(r=n),e[r]=t[n]}),a=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)"default"!==n&&Object.prototype.hasOwnProperty.call(e,n)&&r(t,e,n);return a(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.dispose=t.getInstance=t.initializeWebAssembly=void 0;const i=o(n(449)),s=n(932),u=n(474);let c,l=!1,f=!1,p=!1;t.initializeWebAssembly=async e=>{if(l)return Promise.resolve();if(f)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(p)throw new Error("previous call to \'initializeWebAssembly()\' failed.");f=!0;const t=e.initTimeout,r=e.numThreads,a=e.simd,o=r>1&&(()=>{try{return"undefined"!=typeof SharedArrayBuffer&&("undefined"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(e){return!1}})(),d=a&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(e){return!1}})(),m=e.wasmPaths,g="string"==typeof m?m:void 0,h=((e,t)=>t?e?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":e?"ort-wasm-simd.wasm":"ort-wasm.wasm")(d,o),y="object"==typeof m?m[h]:void 0;let v=!1;const b=[];if(t>0&&b.push(new Promise((e=>{setTimeout((()=>{v=!0,e()}),t)}))),b.push(new Promise(((e,t)=>{const r=o?u:s,a={locateFile:(e,t)=>o&&e.endsWith(".worker.js")&&"undefined"!=typeof Blob?URL.createObjectURL(new Blob([n(154)],{type:"text/javascript"})):e.endsWith(".wasm")?y||(null!=g?g:t)+h:t+e};if(o)if("undefined"==typeof Blob)a.mainScriptUrlOrBlob=i.join("/","ort-wasm-threaded.js");else{const e=`var ortWasmThreaded=(function(){var _scriptDir;return ${r.toString()}})();`;a.mainScriptUrlOrBlob=new Blob([e],{type:"text/javascript"})}r(a).then((t=>{f=!1,l=!0,c=t,e()}),(e=>{f=!1,p=!0,t(e)}))}))),await Promise.race(b),v)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},t.getInstance=()=>{if(l&&c)return c;throw new Error("WebAssembly is not initialized yet.")},t.dispose=()=>{var e;!l||f||p||(f=!0,null===(e=c.PThread)||void 0===e||e.terminateAllThreads(),c=void 0,f=!1,l=!1,p=!0)}},474:(e,t,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(e){function t(){return P.buffer!=D&&G(P.buffer),F}function r(){return P.buffer!=D&&G(P.buffer),U}function a(){return P.buffer!=D&&G(P.buffer),I}function o(){return P.buffer!=D&&G(P.buffer),W}function i(){return P.buffer!=D&&G(P.buffer),j}var s,u,c;e=e||{},s||(s=void 0!==e?e:{}),s.ready=new Promise((function(e,t){u=e,c=t}));var l,f,p,d,m,g,h=Object.assign({},s),y="./this.program",v=(e,t)=>{throw t},b="object"==typeof window,w="function"==typeof importScripts,_="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,O=s.ENVIRONMENT_IS_PTHREAD||!1,S="";function T(e){return s.locateFile?s.locateFile(e,S):S+e}if(_){let t;S=w?n(908).dirname(S)+"/":"//",g=()=>{m||(d=n(384),m=n(908))},l=function(e,t){return g(),e=m.normalize(e),d.readFileSync(e,t?void 0:"utf8")},p=e=>((e=l(e,!0)).buffer||(e=new Uint8Array(e)),e),f=(e,t,n)=>{g(),e=m.normalize(e),d.readFile(e,(function(e,r){e?n(e):t(r.buffer)}))},1<process.argv.length&&(y=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof ie))throw e})),process.on("unhandledRejection",(function(e){throw e})),v=(e,t)=>{if(C)throw process.exitCode=e,t;t instanceof ie||x("exiting due to exception: "+t),process.exit(e)},s.inspect=function(){return"[Emscripten Module object]"};try{t=n(925)}catch(e){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),e}n.g.Worker=t.Worker}else(b||w)&&(w?S=self.location.href:"undefined"!=typeof document&&document.currentScript&&(S=document.currentScript.src),_scriptDir&&(S=_scriptDir),S=0!==S.indexOf("blob:")?S.substr(0,S.replace(/[?#].*/,"").lastIndexOf("/")+1):"",_||(l=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},w&&(p=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),f=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)}));_&&"undefined"==typeof performance&&(n.g.performance=n(953).performance);var A=console.log.bind(console),E=console.warn.bind(console);_&&(g(),A=e=>d.writeSync(1,e+"\\n"),E=e=>d.writeSync(2,e+"\\n"));var M,R=s.print||A,x=s.printErr||E;Object.assign(s,h),h=null,s.thisProgram&&(y=s.thisProgram),s.quit&&(v=s.quit),s.wasmBinary&&(M=s.wasmBinary);var C=s.noExitRuntime||!0;"object"!=typeof WebAssembly&&ne("no native wasm support detected");var P,k,D,F,U,I,W,j,H=!1,L="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function Y(e,t,n){var r=(t>>>=0)+n;for(n=t;e[n]&&!(n>=r);)++n;if(16<n-t&&e.buffer&&L)return L.decode(e.buffer instanceof SharedArrayBuffer?e.slice(t,n):e.subarray(t,n));for(r="";t<n;){var a=e[t++];if(128&a){var o=63&e[t++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|o);else{var i=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|o<<6|i:(7&a)<<18|o<<12|i<<6|63&e[t++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function z(e,t){return(e>>>=0)?Y(r(),e,t):""}function B(e,t,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var o=0;o<e.length;++o){var i=e.charCodeAt(o);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++o)),127>=i){if(n>=r)break;t[n++>>>0]=i}else{if(2047>=i){if(n+1>=r)break;t[n++>>>0]=192|i>>6}else{if(65535>=i){if(n+2>=r)break;t[n++>>>0]=224|i>>12}else{if(n+3>=r)break;t[n++>>>0]=240|i>>18,t[n++>>>0]=128|i>>12&63}t[n++>>>0]=128|i>>6&63}t[n++>>>0]=128|63&i}}return t[n>>>0]=0,n-a}function N(e){for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);127>=r?t++:2047>=r?t+=2:55296<=r&&57343>=r?(t+=4,++n):t+=3}return t}function G(e){D=e,s.HEAP8=F=new Int8Array(e),s.HEAP16=new Int16Array(e),s.HEAP32=I=new Int32Array(e),s.HEAPU8=U=new Uint8Array(e),s.HEAPU16=new Uint16Array(e),s.HEAPU32=W=new Uint32Array(e),s.HEAPF32=new Float32Array(e),s.HEAPF64=j=new Float64Array(e)}O&&(D=s.buffer);var q=s.INITIAL_MEMORY||16777216;if(O)P=s.wasmMemory,D=s.buffer;else if(s.wasmMemory)P=s.wasmMemory;else if(!((P=new WebAssembly.Memory({initial:q/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw x("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),_&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");P&&(D=P.buffer),q=D.byteLength,G(D);var $,V=[],J=[],Q=[];function X(){var e=s.preRun.shift();V.unshift(e)}var K,Z=0,ee=null,te=null;function ne(e){throw O?postMessage({cmd:"onAbort",arg:e}):s.onAbort&&s.onAbort(e),x(e="Aborted("+e+")"),H=!0,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),c(e),e}function re(){return K.startsWith("data:application/octet-stream;base64,")}function ae(){var e=K;try{if(e==K&&M)return new Uint8Array(M);if(p)return p(e);throw"both async and sync fetching of the wasm failed"}catch(e){ne(e)}}K="ort-wasm-threaded.wasm",re()||(K=T(K));var oe={};function ie(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function se(e){(e=fe.La[e])||ne(),fe.Xa(e)}function ue(e){var t=fe.lb();if(!t)return 6;fe.Ra.push(t),fe.La[e.Ka]=t,t.Ka=e.Ka;var n={cmd:"run",start_routine:e.pb,arg:e.ib,pthread_ptr:e.Ka};return t.Qa=()=>{n.time=performance.now(),t.postMessage(n,e.vb)},t.loaded&&(t.Qa(),delete t.Qa),0}function ce(e){if(O)return He(1,1,e);C||(fe.qb(),s.onExit&&s.onExit(e),H=!0),v(e,new ie(e))}function le(e,t){if(!t&&O)throw de(e),"unwind";ce(e)}var fe={Oa:[],Ra:[],$a:[],La:{},Ua:function(){O&&fe.mb()},xb:function(){},mb:function(){fe.receiveObjectTransfer=fe.ob,fe.threadInitTLS=fe.Za,fe.setExitStatus=fe.Ya,C=!1},Ya:function(){},qb:function(){for(var e of Object.values(fe.La))fe.Xa(e);for(e of fe.Oa)e.terminate();fe.Oa=[]},Xa:function(e){var t=e.Ka;delete fe.La[t],fe.Oa.push(e),fe.Ra.splice(fe.Ra.indexOf(e),1),e.Ka=0,ct(t)},ob:function(){},Za:function(){fe.$a.forEach((e=>e()))},nb:function(e,t){e.onmessage=n=>{var r=(n=n.data).cmd;if(e.Ka&&(fe.kb=e.Ka),n.targetThread&&n.targetThread!=rt()){var a=fe.La[n.yb];a?a.postMessage(n,n.transferList):x(\'Internal error! Worker sent a message "\'+r+\'" to target pthread \'+n.targetThread+", but that thread no longer exists!")}else"processProxyingQueue"===r?De(n.queue):"spawnThread"===r?ue(n):"cleanupThread"===r?se(n.thread):"killThread"===r?(n=n.thread,r=fe.La[n],delete fe.La[n],r.terminate(),ct(n),fe.Ra.splice(fe.Ra.indexOf(r),1),r.Ka=0):"cancelThread"===r?fe.La[n.thread].postMessage({cmd:"cancel"}):"loaded"===r?(e.loaded=!0,t&&t(e),e.Qa&&(e.Qa(),delete e.Qa)):"print"===r?R("Thread "+n.threadId+": "+n.text):"printErr"===r?x("Thread "+n.threadId+": "+n.text):"alert"===r?alert("Thread "+n.threadId+": "+n.text):"setimmediate"===n.target?e.postMessage(n):"onAbort"===r?s.onAbort&&s.onAbort(n.arg):r&&x("worker sent an unknown command "+r);fe.kb=void 0},e.onerror=e=>{throw x("worker sent an error! "+e.filename+":"+e.lineno+": "+e.message),e},_&&(e.on("message",(function(t){e.onmessage({data:t})})),e.on("error",(function(t){e.onerror(t)})),e.on("detachedExit",(function(){}))),e.postMessage({cmd:"load",urlOrBlob:s.mainScriptUrlOrBlob||_scriptDir,wasmMemory:P,wasmModule:k})},hb:function(){var e=T("ort-wasm-threaded.worker.js");fe.Oa.push(new Worker(e))},lb:function(){return 0==fe.Oa.length&&(fe.hb(),fe.nb(fe.Oa[0])),fe.Oa.pop()}};function pe(e){for(;0<e.length;)e.shift()(s)}function de(e){if(O)return He(2,0,e);try{le(e)}catch(e){e instanceof ie||"unwind"==e||v(1,e)}}s.PThread=fe,s.establishStackSpace=function(){var e=rt(),t=a()[e+44>>2>>>0];e=a()[e+48>>2>>>0],ft(t,t-e),dt(t)};var me,ge,he=[];function ye(e){this.Pa=e-24,this.gb=function(e){o()[this.Pa+4>>2>>>0]=e},this.cb=function(e){o()[this.Pa+8>>2>>>0]=e},this.eb=function(){a()[this.Pa>>2>>>0]=0},this.bb=function(){t()[this.Pa+12>>0>>>0]=0},this.fb=function(){t()[this.Pa+13>>0>>>0]=0},this.Ua=function(e,t){this.ab(),this.gb(e),this.cb(t),this.eb(),this.bb(),this.fb()},this.ab=function(){o()[this.Pa+16>>2>>>0]=0}}function ve(e,t,n,r){return O?He(3,1,e,t,n,r):be(e,t,n,r)}function be(e,t,n,r){if("undefined"==typeof SharedArrayBuffer)return x("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[];return O&&0===a.length?ve(e,t,n,r):(e={pb:n,Ka:e,ib:r,vb:a},O?(e.wb="spawnThread",postMessage(e,a),0):ue(e))}function we(e,t,n){return O?He(4,1,e,t,n):0}function _e(e,t){if(O)return He(5,1,e,t)}function Oe(e,t){if(O)return He(6,1,e,t)}function Se(e,t,n){if(O)return He(7,1,e,t,n)}function Te(e,t,n){return O?He(8,1,e,t,n):0}function Ae(e,t){if(O)return He(9,1,e,t)}function Ee(e,t,n){if(O)return He(10,1,e,t,n)}function Me(e,t,n,r){if(O)return He(11,1,e,t,n,r)}function Re(e,t,n,r){if(O)return He(12,1,e,t,n,r)}function xe(e,t,n,r){if(O)return He(13,1,e,t,n,r)}function Ce(e){if(O)return He(14,1,e)}function Pe(e,t){if(O)return He(15,1,e,t)}function ke(e,t,n){if(O)return He(16,1,e,t,n)}function De(e){Atomics.store(a(),e>>2,1),rt()&&ut(e),Atomics.compareExchange(a(),e>>2,1,0)}function Fe(e){return o()[e>>>2]+4294967296*a()[e+4>>>2]}function Ue(e,t,n,r,a,o){return O?He(17,1,e,t,n,r,a,o):-52}function Ie(e,t,n,r,a,o){if(O)return He(18,1,e,t,n,r,a,o)}function We(e){var n=N(e)+1,r=at(n);return r&&B(e,t(),r,n),r}function je(e,t,n){function r(e){return(e=e.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?e[1]:"GMT"}if(O)return He(19,1,e,t,n);var i=(new Date).getFullYear(),s=new Date(i,0,1),u=new Date(i,6,1);i=s.getTimezoneOffset();var c=u.getTimezoneOffset(),l=Math.max(i,c);a()[e>>2>>>0]=60*l,a()[t>>2>>>0]=Number(i!=c),e=r(s),t=r(u),e=We(e),t=We(t),c<i?(o()[n>>2>>>0]=e,o()[n+4>>2>>>0]=t):(o()[n>>2>>>0]=t,o()[n+4>>2>>>0]=e)}function He(e,t){var n=arguments.length-2,r=arguments;return function(e){var t=pt();return e=e(),dt(t),e}((()=>{for(var a=mt(8*n),o=a>>3,s=0;s<n;s++){var u=r[2+s];i()[o+s>>>0]=u}return st(e,n,a,t)}))}s.invokeEntryPoint=function(e,t){var n=he[e];n||(e>=he.length&&(he.length=e+1),he[e]=n=$.get(e)),e=n(t),C?fe.Ya(e):lt(e)},s.executeNotifiedProxyingQueue=De,ge=_?()=>{var e=process.hrtime();return 1e3*e[0]+e[1]/1e6}:O?()=>performance.now()-s.__performance_now_clock_drift:()=>performance.now();var Le,Ye=[],ze={};function Be(){if(!Le){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:y||"./this.program"};for(e in ze)void 0===ze[e]?delete t[e]:t[e]=ze[e];var n=[];for(e in t)n.push(e+"="+t[e]);Le=n}return Le}function Ne(e,n){if(O)return He(20,1,e,n);var r=0;return Be().forEach((function(a,i){var s=n+r;for(i=o()[e+4*i>>2>>>0]=s,s=0;s<a.length;++s)t()[i++>>0>>>0]=a.charCodeAt(s);t()[i>>0>>>0]=0,r+=a.length+1})),0}function Ge(e,t){if(O)return He(21,1,e,t);var n=Be();o()[e>>2>>>0]=n.length;var r=0;return n.forEach((function(e){r+=e.length+1})),o()[t>>2>>>0]=r,0}function qe(e){return O?He(22,1,e):52}function $e(e,t,n,r){return O?He(23,1,e,t,n,r):52}function Ve(e,t,n,r,a){return O?He(24,1,e,t,n,r,a):70}var Je=[null,[],[]];function Qe(e,t,n,a){if(O)return He(25,1,e,t,n,a);for(var i=0,s=0;s<n;s++){var u=o()[t>>2>>>0],c=o()[t+4>>2>>>0];t+=8;for(var l=0;l<c;l++){var f=r()[u+l>>>0],p=Je[e];0===f||10===f?((1===e?R:x)(Y(p,0)),p.length=0):p.push(f)}i+=c}return o()[a>>2>>>0]=i,0}function Xe(e){return 0==e%4&&(0!=e%100||0==e%400)}var Ke=[31,29,31,30,31,30,31,31,30,31,30,31],Ze=[31,28,31,30,31,30,31,31,30,31,30,31];function et(e,n,r,o){function i(e,t,n){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=n[0]+e;return e}function s(e,t){return i(e,t,"0")}function u(e,t){function n(e){return 0>e?-1:0<e?1:0}var r;return 0===(r=n(e.getFullYear()-t.getFullYear()))&&0===(r=n(e.getMonth()-t.getMonth()))&&(r=n(e.getDate()-t.getDate())),r}function c(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function l(e){var t=e.Ma;for(e=new Date(new Date(e.Na+1900,0,1).getTime());0<t;){var n=e.getMonth(),r=(Xe(e.getFullYear())?Ke:Ze)[n];if(!(t>r-e.getDate())){e.setDate(e.getDate()+t);break}t-=r-e.getDate()+1,e.setDate(1),11>n?e.setMonth(n+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return n=new Date(e.getFullYear()+1,0,4),t=c(new Date(e.getFullYear(),0,4)),n=c(n),0>=u(t,e)?0>=u(n,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}var f=a()[o+40>>2>>>0];for(var p in o={tb:a()[o>>2>>>0],sb:a()[o+4>>2>>>0],Sa:a()[o+8>>2>>>0],Va:a()[o+12>>2>>>0],Ta:a()[o+16>>2>>>0],Na:a()[o+20>>2>>>0],Ja:a()[o+24>>2>>>0],Ma:a()[o+28>>2>>>0],zb:a()[o+32>>2>>>0],rb:a()[o+36>>2>>>0],ub:f?z(f):""},r=z(r),f={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})r=r.replace(new RegExp(p,"g"),f[p]);var d="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),m="January February March April May June July August September October November December".split(" ");for(p in f={"%a":function(e){return d[e.Ja].substring(0,3)},"%A":function(e){return d[e.Ja]},"%b":function(e){return m[e.Ta].substring(0,3)},"%B":function(e){return m[e.Ta]},"%C":function(e){return s((e.Na+1900)/100|0,2)},"%d":function(e){return s(e.Va,2)},"%e":function(e){return i(e.Va,2," ")},"%g":function(e){return l(e).toString().substring(2)},"%G":function(e){return l(e)},"%H":function(e){return s(e.Sa,2)},"%I":function(e){return 0==(e=e.Sa)?e=12:12<e&&(e-=12),s(e,2)},"%j":function(e){for(var t=0,n=0;n<=e.Ta-1;t+=(Xe(e.Na+1900)?Ke:Ze)[n++]);return s(e.Va+t,3)},"%m":function(e){return s(e.Ta+1,2)},"%M":function(e){return s(e.sb,2)},"%n":function(){return"\\n"},"%p":function(e){return 0<=e.Sa&&12>e.Sa?"AM":"PM"},"%S":function(e){return s(e.tb,2)},"%t":function(){return"\\t"},"%u":function(e){return e.Ja||7},"%U":function(e){return s(Math.floor((e.Ma+7-e.Ja)/7),2)},"%V":function(e){var t=Math.floor((e.Ma+7-(e.Ja+6)%7)/7);if(2>=(e.Ja+371-e.Ma-2)%7&&t++,t)53==t&&(4==(n=(e.Ja+371-e.Ma)%7)||3==n&&Xe(e.Na)||(t=1));else{t=52;var n=(e.Ja+7-e.Ma-1)%7;(4==n||5==n&&Xe(e.Na%400-1))&&t++}return s(t,2)},"%w":function(e){return e.Ja},"%W":function(e){return s(Math.floor((e.Ma+7-(e.Ja+6)%7)/7),2)},"%y":function(e){return(e.Na+1900).toString().substring(2)},"%Y":function(e){return e.Na+1900},"%z":function(e){var t=0<=(e=e.rb);return e=Math.abs(e)/60,(t?"+":"-")+String("0000"+(e/60*100+e%60)).slice(-4)},"%Z":function(e){return e.ub},"%%":function(){return"%"}},r=r.replace(/%%/g,"\\0\\0"),f)r.includes(p)&&(r=r.replace(new RegExp(p,"g"),f[p](o)));return p=function(e){var t=Array(N(e)+1);return B(e,t,0,t.length),t}(r=r.replace(/\\0\\0/g,"%")),p.length>n?0:(function(e,n){t().set(e,n>>>0)}(p,e),p.length-1)}fe.Ua();var tt=[null,ce,de,ve,we,_e,Oe,Se,Te,Ae,Ee,Me,Re,xe,Ce,Pe,ke,Ue,Ie,je,Ne,Ge,qe,$e,Ve,Qe],nt={b:function(e){return at(e+24)+24},c:function(e,t,n){throw new ye(e).Ua(t,n),e},L:function(e){ot(e,!w,1,!b),fe.Za()},l:function(e){O?postMessage({cmd:"cleanupThread",thread:e}):se(e)},D:be,i:we,R:_e,z:Oe,B:Se,T:Te,P:Ae,I:Ee,O:Me,p:Re,A:xe,x:Ce,Q:Pe,y:ke,r:function(){},j:function(){ne("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},s:function(){ne("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},q:function(){return Date.now()},E:function(){return 2097152},V:function(){return!0},F:function(e,t,n,r){if(e==t)setTimeout((()=>De(r)));else if(O)postMessage({targetThread:e,cmd:"processProxyingQueue",queue:r});else{if(!(e=fe.La[e]))return;e.postMessage({cmd:"processProxyingQueue",queue:r})}return 1},K:function(){return-1},W:function(e,t){e=new Date(1e3*Fe(e)),a()[t>>2>>>0]=e.getUTCSeconds(),a()[t+4>>2>>>0]=e.getUTCMinutes(),a()[t+8>>2>>>0]=e.getUTCHours(),a()[t+12>>2>>>0]=e.getUTCDate(),a()[t+16>>2>>>0]=e.getUTCMonth(),a()[t+20>>2>>>0]=e.getUTCFullYear()-1900,a()[t+24>>2>>>0]=e.getUTCDay(),e=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[t+28>>2>>>0]=e},X:function(e,t){e=new Date(1e3*Fe(e)),a()[t>>2>>>0]=e.getSeconds(),a()[t+4>>2>>>0]=e.getMinutes(),a()[t+8>>2>>>0]=e.getHours(),a()[t+12>>2>>>0]=e.getDate(),a()[t+16>>2>>>0]=e.getMonth(),a()[t+20>>2>>>0]=e.getFullYear()-1900,a()[t+24>>2>>>0]=e.getDay();var n=new Date(e.getFullYear(),0,1),r=(e.getTime()-n.getTime())/864e5|0;a()[t+28>>2>>>0]=r,a()[t+36>>2>>>0]=-60*e.getTimezoneOffset(),r=new Date(e.getFullYear(),6,1).getTimezoneOffset(),e=0|(r!=(n=n.getTimezoneOffset())&&e.getTimezoneOffset()==Math.min(n,r)),a()[t+32>>2>>>0]=e},Y:function(e){var t=new Date(a()[e+20>>2>>>0]+1900,a()[e+16>>2>>>0],a()[e+12>>2>>>0],a()[e+8>>2>>>0],a()[e+4>>2>>>0],a()[e>>2>>>0],0),n=a()[e+32>>2>>>0],r=t.getTimezoneOffset(),o=new Date(t.getFullYear(),0,1),i=new Date(t.getFullYear(),6,1).getTimezoneOffset(),s=o.getTimezoneOffset(),u=Math.min(s,i);return 0>n?a()[e+32>>2>>>0]=Number(i!=s&&u==r):0<n!=(u==r)&&(i=Math.max(s,i),t.setTime(t.getTime()+6e4*((0<n?u:i)-r))),a()[e+24>>2>>>0]=t.getDay(),n=(t.getTime()-o.getTime())/864e5|0,a()[e+28>>2>>>0]=n,a()[e>>2>>>0]=t.getSeconds(),a()[e+4>>2>>>0]=t.getMinutes(),a()[e+8>>2>>>0]=t.getHours(),a()[e+12>>2>>>0]=t.getDate(),a()[e+16>>2>>>0]=t.getMonth(),t.getTime()/1e3|0},G:Ue,H:Ie,Z:function e(t,n,r){e.jb||(e.jb=!0,je(t,n,r))},d:function(){ne("")},m:function(){if(!_&&!w){var e="Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";me||(me={}),me[e]||(me[e]=1,_&&(e="warning: "+e),x(e))}},w:function(){return 4294901760},f:ge,S:function(e,t,n){r().copyWithin(e>>>0,t>>>0,t+n>>>0)},g:function(){return _?n(993).cpus().length:navigator.hardwareConcurrency},J:function(e,t,n){Ye.length=t,n>>=3;for(var r=0;r<t;r++)Ye[r]=i()[n+r>>>0];return(0>e?oe[-e-1]:tt[e]).apply(null,Ye)},v:function(e){var t=r().length;if((e>>>=0)<=t||4294901760<e)return!1;for(var n=1;4>=n;n*=2){var a=t*(1+.2/n);a=Math.min(a,e+100663296);var o=Math;a=Math.max(e,a),o=o.min.call(o,4294901760,a+(65536-a%65536)%65536);e:{try{P.grow(o-D.byteLength+65535>>>16),G(P.buffer);var i=1;break e}catch(e){}i=void 0}if(i)return!0}return!1},U:function(){throw"unwind"},M:Ne,N:Ge,k:le,h:qe,o:$e,t:Ve,n:Qe,u:function e(r,a){e.Wa||(e.Wa=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var e=new Uint8Array(1);return()=>(crypto.getRandomValues(e),e[0])}if(_)try{var t=n(760);return()=>t.randomBytes(1)[0]}catch(e){}return()=>ne("randomDevice")}());for(var o=0;o<a;o++)t()[r+o>>0>>>0]=e.Wa();return 0},a:P||s.wasmMemory,C:et,e:function(e,t,n,r){return et(e,t,n,r)}};!function(){function e(e,t){s.asm=e.exports,fe.$a.push(s.asm.wa),$=s.asm.za,J.unshift(s.asm._),k=t,O||(Z--,s.monitorRunDependencies&&s.monitorRunDependencies(Z),0==Z&&(null!==ee&&(clearInterval(ee),ee=null),te&&(e=te,te=null,e())))}function t(t){e(t.instance,t.module)}function n(e){return function(){if(!M&&(b||w)){if("function"==typeof fetch&&!K.startsWith("file://"))return fetch(K,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at \'"+K+"\'";return e.arrayBuffer()})).catch((function(){return ae()}));if(f)return new Promise((function(e,t){f(K,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return ae()}))}().then((function(e){return WebAssembly.instantiate(e,r)})).then((function(e){return e})).then(e,(function(e){x("failed to asynchronously prepare wasm: "+e),ne(e)}))}var r={a:nt};if(O||(Z++,s.monitorRunDependencies&&s.monitorRunDependencies(Z)),s.instantiateWasm)try{return s.instantiateWasm(r,e)}catch(e){return x("Module.instantiateWasm callback failed with error: "+e),!1}(M||"function"!=typeof WebAssembly.instantiateStreaming||re()||K.startsWith("file://")||_||"function"!=typeof fetch?n(t):fetch(K,{credentials:"same-origin"}).then((function(e){return WebAssembly.instantiateStreaming(e,r).then(t,(function(e){return x("wasm streaming compile failed: "+e),x("falling back to ArrayBuffer instantiation"),n(t)}))}))).catch(c)}(),s.___wasm_call_ctors=function(){return(s.___wasm_call_ctors=s.asm._).apply(null,arguments)},s._OrtInit=function(){return(s._OrtInit=s.asm.$).apply(null,arguments)},s._OrtCreateSessionOptions=function(){return(s._OrtCreateSessionOptions=s.asm.aa).apply(null,arguments)},s._OrtAppendExecutionProvider=function(){return(s._OrtAppendExecutionProvider=s.asm.ba).apply(null,arguments)},s._OrtAddSessionConfigEntry=function(){return(s._OrtAddSessionConfigEntry=s.asm.ca).apply(null,arguments)},s._OrtReleaseSessionOptions=function(){return(s._OrtReleaseSessionOptions=s.asm.da).apply(null,arguments)},s._OrtCreateSession=function(){return(s._OrtCreateSession=s.asm.ea).apply(null,arguments)},s._OrtReleaseSession=function(){return(s._OrtReleaseSession=s.asm.fa).apply(null,arguments)},s._OrtGetInputCount=function(){return(s._OrtGetInputCount=s.asm.ga).apply(null,arguments)},s._OrtGetOutputCount=function(){return(s._OrtGetOutputCount=s.asm.ha).apply(null,arguments)},s._OrtGetInputName=function(){return(s._OrtGetInputName=s.asm.ia).apply(null,arguments)},s._OrtGetOutputName=function(){return(s._OrtGetOutputName=s.asm.ja).apply(null,arguments)},s._OrtFree=function(){return(s._OrtFree=s.asm.ka).apply(null,arguments)},s._OrtCreateTensor=function(){return(s._OrtCreateTensor=s.asm.la).apply(null,arguments)},s._OrtGetTensorData=function(){return(s._OrtGetTensorData=s.asm.ma).apply(null,arguments)},s._OrtReleaseTensor=function(){return(s._OrtReleaseTensor=s.asm.na).apply(null,arguments)},s._OrtCreateRunOptions=function(){return(s._OrtCreateRunOptions=s.asm.oa).apply(null,arguments)},s._OrtAddRunConfigEntry=function(){return(s._OrtAddRunConfigEntry=s.asm.pa).apply(null,arguments)},s._OrtReleaseRunOptions=function(){return(s._OrtReleaseRunOptions=s.asm.qa).apply(null,arguments)},s._OrtRun=function(){return(s._OrtRun=s.asm.ra).apply(null,arguments)},s._OrtEndProfiling=function(){return(s._OrtEndProfiling=s.asm.sa).apply(null,arguments)};var rt=s._pthread_self=function(){return(rt=s._pthread_self=s.asm.ta).apply(null,arguments)},at=s._malloc=function(){return(at=s._malloc=s.asm.ua).apply(null,arguments)};s._free=function(){return(s._free=s.asm.va).apply(null,arguments)},s.__emscripten_tls_init=function(){return(s.__emscripten_tls_init=s.asm.wa).apply(null,arguments)};var ot=s.__emscripten_thread_init=function(){return(ot=s.__emscripten_thread_init=s.asm.xa).apply(null,arguments)};s.__emscripten_thread_crashed=function(){return(s.__emscripten_thread_crashed=s.asm.ya).apply(null,arguments)};var it,st=s._emscripten_run_in_main_runtime_thread_js=function(){return(st=s._emscripten_run_in_main_runtime_thread_js=s.asm.Aa).apply(null,arguments)},ut=s.__emscripten_proxy_execute_task_queue=function(){return(ut=s.__emscripten_proxy_execute_task_queue=s.asm.Ba).apply(null,arguments)},ct=s.__emscripten_thread_free_data=function(){return(ct=s.__emscripten_thread_free_data=s.asm.Ca).apply(null,arguments)},lt=s.__emscripten_thread_exit=function(){return(lt=s.__emscripten_thread_exit=s.asm.Da).apply(null,arguments)},ft=s._emscripten_stack_set_limits=function(){return(ft=s._emscripten_stack_set_limits=s.asm.Ea).apply(null,arguments)},pt=s.stackSave=function(){return(pt=s.stackSave=s.asm.Fa).apply(null,arguments)},dt=s.stackRestore=function(){return(dt=s.stackRestore=s.asm.Ga).apply(null,arguments)},mt=s.stackAlloc=function(){return(mt=s.stackAlloc=s.asm.Ha).apply(null,arguments)};function gt(){function e(){if(!it&&(it=!0,s.calledRun=!0,!H)&&(O||pe(J),u(s),s.onRuntimeInitialized&&s.onRuntimeInitialized(),!O)){if(s.postRun)for("function"==typeof s.postRun&&(s.postRun=[s.postRun]);s.postRun.length;){var e=s.postRun.shift();Q.unshift(e)}pe(Q)}}if(!(0<Z))if(O)u(s),O||pe(J),postMessage({cmd:"loaded"});else{if(s.preRun)for("function"==typeof s.preRun&&(s.preRun=[s.preRun]);s.preRun.length;)X();pe(V),0<Z||(s.setStatus?(s.setStatus("Running..."),setTimeout((function(){setTimeout((function(){s.setStatus("")}),1),e()}),1)):e())}}if(s.___cxa_is_pointer_type=function(){return(s.___cxa_is_pointer_type=s.asm.Ia).apply(null,arguments)},s.UTF8ToString=z,s.stringToUTF8=function(e,t,n){return B(e,r(),t,n)},s.lengthBytesUTF8=N,s.keepRuntimeAlive=function(){return C},s.wasmMemory=P,s.stackSave=pt,s.stackRestore=dt,s.stackAlloc=mt,s.ExitStatus=ie,s.PThread=fe,te=function e(){it||gt(),it||(te=e)},s.preInit)for("function"==typeof s.preInit&&(s.preInit=[s.preInit]);0<s.preInit.length;)s.preInit.pop()();return gt(),e.ready});e.exports=r},932:(e,t,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(e){var t,r,a;e=e||{},t||(t=void 0!==e?e:{}),t.ready=new Promise((function(e,t){r=e,a=t}));var o,i,s,u,c,l,f=Object.assign({},t),p="./this.program",d=(e,t)=>{throw t},m="object"==typeof window,g="function"==typeof importScripts,h="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,y="";h?(y=g?n(908).dirname(y)+"/":"//",l=()=>{c||(u=n(384),c=n(908))},o=function(e,t){return l(),e=c.normalize(e),u.readFileSync(e,t?void 0:"utf8")},s=e=>((e=o(e,!0)).buffer||(e=new Uint8Array(e)),e),i=(e,t,n)=>{l(),e=c.normalize(e),u.readFile(e,(function(e,r){e?n(e):t(r.buffer)}))},1<process.argv.length&&(p=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof $))throw e})),process.on("unhandledRejection",(function(e){throw e})),d=(e,t)=>{if(_)throw process.exitCode=e,t;t instanceof $||w("exiting due to exception: "+t),process.exit(e)},t.inspect=function(){return"[Emscripten Module object]"}):(m||g)&&(g?y=self.location.href:"undefined"!=typeof document&&document.currentScript&&(y=document.currentScript.src),_scriptDir&&(y=_scriptDir),y=0!==y.indexOf("blob:")?y.substr(0,y.replace(/[?#].*/,"").lastIndexOf("/")+1):"",o=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},g&&(s=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),i=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)});var v,b=t.print||console.log.bind(console),w=t.printErr||console.warn.bind(console);Object.assign(t,f),f=null,t.thisProgram&&(p=t.thisProgram),t.quit&&(d=t.quit),t.wasmBinary&&(v=t.wasmBinary);var _=t.noExitRuntime||!0;"object"!=typeof WebAssembly&&B("no native wasm support detected");var O,S,T,A,E,M,R=!1,x="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function C(e,t,n){var r=(t>>>=0)+n;for(n=t;e[n]&&!(n>=r);)++n;if(16<n-t&&e.buffer&&x)return x.decode(e.subarray(t,n));for(r="";t<n;){var a=e[t++];if(128&a){var o=63&e[t++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|o);else{var i=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|o<<6|i:(7&a)<<18|o<<12|i<<6|63&e[t++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function P(e,t){return(e>>>=0)?C(A,e,t):""}function k(e,t,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var o=0;o<e.length;++o){var i=e.charCodeAt(o);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++o)),127>=i){if(n>=r)break;t[n++>>>0]=i}else{if(2047>=i){if(n+1>=r)break;t[n++>>>0]=192|i>>6}else{if(65535>=i){if(n+2>=r)break;t[n++>>>0]=224|i>>12}else{if(n+3>=r)break;t[n++>>>0]=240|i>>18,t[n++>>>0]=128|i>>12&63}t[n++>>>0]=128|i>>6&63}t[n++>>>0]=128|63&i}}return t[n>>>0]=0,n-a}function D(e){for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);127>=r?t++:2047>=r?t+=2:55296<=r&&57343>=r?(t+=4,++n):t+=3}return t}function F(){var e=O.buffer;S=e,t.HEAP8=T=new Int8Array(e),t.HEAP16=new Int16Array(e),t.HEAP32=E=new Int32Array(e),t.HEAPU8=A=new Uint8Array(e),t.HEAPU16=new Uint16Array(e),t.HEAPU32=M=new Uint32Array(e),t.HEAPF32=new Float32Array(e),t.HEAPF64=new Float64Array(e)}var U=[],I=[],W=[];function j(){var e=t.preRun.shift();U.unshift(e)}var H,L=0,Y=null,z=null;function B(e){throw t.onAbort&&t.onAbort(e),w(e="Aborted("+e+")"),R=!0,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),a(e),e}function N(){return H.startsWith("data:application/octet-stream;base64,")}if(H="ort-wasm.wasm",!N()){var G=H;H=t.locateFile?t.locateFile(G,y):y+G}function q(){var e=H;try{if(e==H&&v)return new Uint8Array(v);if(s)return s(e);throw"both async and sync fetching of the wasm failed"}catch(e){B(e)}}function $(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function V(e){for(;0<e.length;)e.shift()(t)}function J(e){this.sa=e-24,this.Ia=function(e){M[this.sa+4>>2>>>0]=e},this.Ba=function(e){M[this.sa+8>>2>>>0]=e},this.Ga=function(){E[this.sa>>2>>>0]=0},this.Aa=function(){T[this.sa+12>>0>>>0]=0},this.Ha=function(){T[this.sa+13>>0>>>0]=0},this.ya=function(e,t){this.za(),this.Ia(e),this.Ba(t),this.Ga(),this.Aa(),this.Ha()},this.za=function(){M[this.sa+16>>2>>>0]=0}}function Q(e){var t=D(e)+1,n=ie(t);return n&&k(e,T,n,t),n}var X={};function K(){if(!Z){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:p||"./this.program"};for(e in X)void 0===X[e]?delete t[e]:t[e]=X[e];var n=[];for(e in t)n.push(e+"="+t[e]);Z=n}return Z}var Z,ee=[null,[],[]];function te(e){return 0==e%4&&(0!=e%100||0==e%400)}var ne=[31,29,31,30,31,30,31,31,30,31,30,31],re=[31,28,31,30,31,30,31,31,30,31,30,31];function ae(e,t,n,r){function a(e,t,n){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=n[0]+e;return e}function o(e,t){return a(e,t,"0")}function i(e,t){function n(e){return 0>e?-1:0<e?1:0}var r;return 0===(r=n(e.getFullYear()-t.getFullYear()))&&0===(r=n(e.getMonth()-t.getMonth()))&&(r=n(e.getDate()-t.getDate())),r}function s(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function u(e){var t=e.qa;for(e=new Date(new Date(e.ra+1900,0,1).getTime());0<t;){var n=e.getMonth(),r=(te(e.getFullYear())?ne:re)[n];if(!(t>r-e.getDate())){e.setDate(e.getDate()+t);break}t-=r-e.getDate()+1,e.setDate(1),11>n?e.setMonth(n+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return n=new Date(e.getFullYear()+1,0,4),t=s(new Date(e.getFullYear(),0,4)),n=s(n),0>=i(t,e)?0>=i(n,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}var c=E[r+40>>2>>>0];for(var l in r={Ea:E[r>>2>>>0],Da:E[r+4>>2>>>0],ta:E[r+8>>2>>>0],va:E[r+12>>2>>>0],ua:E[r+16>>2>>>0],ra:E[r+20>>2>>>0],la:E[r+24>>2>>>0],qa:E[r+28>>2>>>0],Ja:E[r+32>>2>>>0],Ca:E[r+36>>2>>>0],Fa:c?P(c):""},n=P(n),c={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})n=n.replace(new RegExp(l,"g"),c[l]);var f="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),p="January February March April May June July August September October November December".split(" ");for(l in c={"%a":function(e){return f[e.la].substring(0,3)},"%A":function(e){return f[e.la]},"%b":function(e){return p[e.ua].substring(0,3)},"%B":function(e){return p[e.ua]},"%C":function(e){return o((e.ra+1900)/100|0,2)},"%d":function(e){return o(e.va,2)},"%e":function(e){return a(e.va,2," ")},"%g":function(e){return u(e).toString().substring(2)},"%G":function(e){return u(e)},"%H":function(e){return o(e.ta,2)},"%I":function(e){return 0==(e=e.ta)?e=12:12<e&&(e-=12),o(e,2)},"%j":function(e){for(var t=0,n=0;n<=e.ua-1;t+=(te(e.ra+1900)?ne:re)[n++]);return o(e.va+t,3)},"%m":function(e){return o(e.ua+1,2)},"%M":function(e){return o(e.Da,2)},"%n":function(){return"\\n"},"%p":function(e){return 0<=e.ta&&12>e.ta?"AM":"PM"},"%S":function(e){return o(e.Ea,2)},"%t":function(){return"\\t"},"%u":function(e){return e.la||7},"%U":function(e){return o(Math.floor((e.qa+7-e.la)/7),2)},"%V":function(e){var t=Math.floor((e.qa+7-(e.la+6)%7)/7);if(2>=(e.la+371-e.qa-2)%7&&t++,t)53==t&&(4==(n=(e.la+371-e.qa)%7)||3==n&&te(e.ra)||(t=1));else{t=52;var n=(e.la+7-e.qa-1)%7;(4==n||5==n&&te(e.ra%400-1))&&t++}return o(t,2)},"%w":function(e){return e.la},"%W":function(e){return o(Math.floor((e.qa+7-(e.la+6)%7)/7),2)},"%y":function(e){return(e.ra+1900).toString().substring(2)},"%Y":function(e){return e.ra+1900},"%z":function(e){var t=0<=(e=e.Ca);return e=Math.abs(e)/60,(t?"+":"-")+String("0000"+(e/60*100+e%60)).slice(-4)},"%Z":function(e){return e.Fa},"%%":function(){return"%"}},n=n.replace(/%%/g,"\\0\\0"),c)n.includes(l)&&(n=n.replace(new RegExp(l,"g"),c[l](r)));return l=function(e){var t=Array(D(e)+1);return k(e,t,0,t.length),t}(n=n.replace(/\\0\\0/g,"%")),l.length>t?0:(T.set(l,e>>>0),l.length-1)}var oe={a:function(e){return ie(e+24)+24},b:function(e,t,n){throw new J(e).ya(t,n),e},g:function(){return 0},I:function(){},w:function(){},y:function(){},K:function(){return 0},G:function(){},C:function(){},F:function(){},k:function(){},x:function(){},u:function(){},H:function(){},v:function(){},n:function(){},p:function(){B("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},o:function(){B("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},l:function(){return Date.now()},L:function(){return!0},M:function(e,t){e=new Date(1e3*(M[e>>>2]+4294967296*E[e+4>>>2])),E[t>>2>>>0]=e.getUTCSeconds(),E[t+4>>2>>>0]=e.getUTCMinutes(),E[t+8>>2>>>0]=e.getUTCHours(),E[t+12>>2>>>0]=e.getUTCDate(),E[t+16>>2>>>0]=e.getUTCMonth(),E[t+20>>2>>>0]=e.getUTCFullYear()-1900,E[t+24>>2>>>0]=e.getUTCDay(),E[t+28>>2>>>0]=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},N:function(e,t){e=new Date(1e3*(M[e>>>2]+4294967296*E[e+4>>>2])),E[t>>2>>>0]=e.getSeconds(),E[t+4>>2>>>0]=e.getMinutes(),E[t+8>>2>>>0]=e.getHours(),E[t+12>>2>>>0]=e.getDate(),E[t+16>>2>>>0]=e.getMonth(),E[t+20>>2>>>0]=e.getFullYear()-1900,E[t+24>>2>>>0]=e.getDay();var n=new Date(e.getFullYear(),0,1);E[t+28>>2>>>0]=(e.getTime()-n.getTime())/864e5|0,E[t+36>>2>>>0]=-60*e.getTimezoneOffset();var r=new Date(e.getFullYear(),6,1).getTimezoneOffset();n=n.getTimezoneOffset(),E[t+32>>2>>>0]=0|(r!=n&&e.getTimezoneOffset()==Math.min(n,r))},O:function(e){var t=new Date(E[e+20>>2>>>0]+1900,E[e+16>>2>>>0],E[e+12>>2>>>0],E[e+8>>2>>>0],E[e+4>>2>>>0],E[e>>2>>>0],0),n=E[e+32>>2>>>0],r=t.getTimezoneOffset(),a=new Date(t.getFullYear(),0,1),o=new Date(t.getFullYear(),6,1).getTimezoneOffset(),i=a.getTimezoneOffset(),s=Math.min(i,o);return 0>n?E[e+32>>2>>>0]=Number(o!=i&&s==r):0<n!=(s==r)&&(o=Math.max(i,o),t.setTime(t.getTime()+6e4*((0<n?s:o)-r))),E[e+24>>2>>>0]=t.getDay(),E[e+28>>2>>>0]=(t.getTime()-a.getTime())/864e5|0,E[e>>2>>>0]=t.getSeconds(),E[e+4>>2>>>0]=t.getMinutes(),E[e+8>>2>>>0]=t.getHours(),E[e+12>>2>>>0]=t.getDate(),E[e+16>>2>>>0]=t.getMonth(),t.getTime()/1e3|0},z:function(){return-52},B:function(){},m:function e(t,n,r){e.xa||(e.xa=!0,function(e,t,n){function r(e){return(e=e.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?e[1]:"GMT"}var a=(new Date).getFullYear(),o=new Date(a,0,1),i=new Date(a,6,1);a=o.getTimezoneOffset();var s=i.getTimezoneOffset();E[e>>2>>>0]=60*Math.max(a,s),E[t>>2>>>0]=Number(a!=s),e=r(o),t=r(i),e=Q(e),t=Q(t),s<a?(M[n>>2>>>0]=e,M[n+4>>2>>>0]=t):(M[n>>2>>>0]=t,M[n+4>>2>>>0]=e)}(t,n,r))},d:function(){B("")},t:function(){return 4294901760},h:h?()=>{var e=process.hrtime();return 1e3*e[0]+e[1]/1e6}:()=>performance.now(),J:function(e,t,n){A.copyWithin(e>>>0,t>>>0,t+n>>>0)},f:function(e){var t=A.length;if(4294901760<(e>>>=0))return!1;for(var n=1;4>=n;n*=2){var r=t*(1+.2/n);r=Math.min(r,e+100663296);var a=Math;r=Math.max(e,r),a=a.min.call(a,4294901760,r+(65536-r%65536)%65536);e:{try{O.grow(a-S.byteLength+65535>>>16),F();var o=1;break e}catch(e){}o=void 0}if(o)return!0}return!1},D:function(e,t){var n=0;return K().forEach((function(r,a){var o=t+n;for(a=M[e+4*a>>2>>>0]=o,o=0;o<r.length;++o)T[a++>>0>>>0]=r.charCodeAt(o);T[a>>0>>>0]=0,n+=r.length+1})),0},E:function(e,t){var n=K();M[e>>2>>>0]=n.length;var r=0;return n.forEach((function(e){r+=e.length+1})),M[t>>2>>>0]=r,0},r:function(e){_||(t.onExit&&t.onExit(e),R=!0),d(e,new $(e))},e:function(){return 52},j:function(){return 52},q:function(){return 70},i:function(e,t,n,r){for(var a=0,o=0;o<n;o++){var i=M[t>>2>>>0],s=M[t+4>>2>>>0];t+=8;for(var u=0;u<s;u++){var c=A[i+u>>>0],l=ee[e];0===c||10===c?((1===e?b:w)(C(l,0)),l.length=0):l.push(c)}a+=s}return M[r>>2>>>0]=a,0},s:function e(t,r){e.wa||(e.wa=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var e=new Uint8Array(1);return()=>(crypto.getRandomValues(e),e[0])}if(h)try{var t=n(760);return()=>t.randomBytes(1)[0]}catch(e){}return()=>B("randomDevice")}());for(var a=0;a<r;a++)T[t+a>>0>>>0]=e.wa();return 0},A:ae,c:function(e,t,n,r){return ae(e,t,n,r)}};!function(){function e(e){t.asm=e.exports,O=t.asm.P,F(),I.unshift(t.asm.Q),L--,t.monitorRunDependencies&&t.monitorRunDependencies(L),0==L&&(null!==Y&&(clearInterval(Y),Y=null),z&&(e=z,z=null,e()))}function n(t){e(t.instance)}function r(e){return function(){if(!v&&(m||g)){if("function"==typeof fetch&&!H.startsWith("file://"))return fetch(H,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at \'"+H+"\'";return e.arrayBuffer()})).catch((function(){return q()}));if(i)return new Promise((function(e,t){i(H,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return q()}))}().then((function(e){return WebAssembly.instantiate(e,o)})).then((function(e){return e})).then(e,(function(e){w("failed to asynchronously prepare wasm: "+e),B(e)}))}var o={a:oe};if(L++,t.monitorRunDependencies&&t.monitorRunDependencies(L),t.instantiateWasm)try{return t.instantiateWasm(o,e)}catch(e){return w("Module.instantiateWasm callback failed with error: "+e),!1}(v||"function"!=typeof WebAssembly.instantiateStreaming||N()||H.startsWith("file://")||h||"function"!=typeof fetch?r(n):fetch(H,{credentials:"same-origin"}).then((function(e){return WebAssembly.instantiateStreaming(e,o).then(n,(function(e){return w("wasm streaming compile failed: "+e),w("falling back to ArrayBuffer instantiation"),r(n)}))}))).catch(a)}(),t.___wasm_call_ctors=function(){return(t.___wasm_call_ctors=t.asm.Q).apply(null,arguments)},t._OrtInit=function(){return(t._OrtInit=t.asm.R).apply(null,arguments)},t._OrtCreateSessionOptions=function(){return(t._OrtCreateSessionOptions=t.asm.S).apply(null,arguments)},t._OrtAppendExecutionProvider=function(){return(t._OrtAppendExecutionProvider=t.asm.T).apply(null,arguments)},t._OrtAddSessionConfigEntry=function(){return(t._OrtAddSessionConfigEntry=t.asm.U).apply(null,arguments)},t._OrtReleaseSessionOptions=function(){return(t._OrtReleaseSessionOptions=t.asm.V).apply(null,arguments)},t._OrtCreateSession=function(){return(t._OrtCreateSession=t.asm.W).apply(null,arguments)},t._OrtReleaseSession=function(){return(t._OrtReleaseSession=t.asm.X).apply(null,arguments)},t._OrtGetInputCount=function(){return(t._OrtGetInputCount=t.asm.Y).apply(null,arguments)},t._OrtGetOutputCount=function(){return(t._OrtGetOutputCount=t.asm.Z).apply(null,arguments)},t._OrtGetInputName=function(){return(t._OrtGetInputName=t.asm._).apply(null,arguments)},t._OrtGetOutputName=function(){return(t._OrtGetOutputName=t.asm.$).apply(null,arguments)},t._OrtFree=function(){return(t._OrtFree=t.asm.aa).apply(null,arguments)},t._OrtCreateTensor=function(){return(t._OrtCreateTensor=t.asm.ba).apply(null,arguments)},t._OrtGetTensorData=function(){return(t._OrtGetTensorData=t.asm.ca).apply(null,arguments)},t._OrtReleaseTensor=function(){return(t._OrtReleaseTensor=t.asm.da).apply(null,arguments)},t._OrtCreateRunOptions=function(){return(t._OrtCreateRunOptions=t.asm.ea).apply(null,arguments)},t._OrtAddRunConfigEntry=function(){return(t._OrtAddRunConfigEntry=t.asm.fa).apply(null,arguments)},t._OrtReleaseRunOptions=function(){return(t._OrtReleaseRunOptions=t.asm.ga).apply(null,arguments)},t._OrtRun=function(){return(t._OrtRun=t.asm.ha).apply(null,arguments)},t._OrtEndProfiling=function(){return(t._OrtEndProfiling=t.asm.ia).apply(null,arguments)};var ie=t._malloc=function(){return(ie=t._malloc=t.asm.ja).apply(null,arguments)};t._free=function(){return(t._free=t.asm.ka).apply(null,arguments)};var se,ue=t.stackSave=function(){return(ue=t.stackSave=t.asm.ma).apply(null,arguments)},ce=t.stackRestore=function(){return(ce=t.stackRestore=t.asm.na).apply(null,arguments)},le=t.stackAlloc=function(){return(le=t.stackAlloc=t.asm.oa).apply(null,arguments)};function fe(){function e(){if(!se&&(se=!0,t.calledRun=!0,!R)){if(V(I),r(t),t.onRuntimeInitialized&&t.onRuntimeInitialized(),t.postRun)for("function"==typeof t.postRun&&(t.postRun=[t.postRun]);t.postRun.length;){var e=t.postRun.shift();W.unshift(e)}V(W)}}if(!(0<L)){if(t.preRun)for("function"==typeof t.preRun&&(t.preRun=[t.preRun]);t.preRun.length;)j();V(U),0<L||(t.setStatus?(t.setStatus("Running..."),setTimeout((function(){setTimeout((function(){t.setStatus("")}),1),e()}),1)):e())}}if(t.___cxa_is_pointer_type=function(){return(t.___cxa_is_pointer_type=t.asm.pa).apply(null,arguments)},t.UTF8ToString=P,t.stringToUTF8=function(e,t,n){return k(e,A,t,n)},t.lengthBytesUTF8=D,t.stackSave=ue,t.stackRestore=ce,t.stackAlloc=le,z=function e(){se||fe(),se||(z=e)},t.preInit)for("function"==typeof t.preInit&&(t.preInit=[t.preInit]);0<t.preInit.length;)t.preInit.pop()();return fe(),e.ready});e.exports=r},154:e=>{"use strict";e.exports=\'"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\\n\'},760:()=>{},384:()=>{},993:()=>{},908:()=>{},953:()=>{},925:()=>{},449:()=>{}},t={};function n(r){var a=t[r];if(void 0!==a)return a.exports;var o=t[r]={exports:{}};return e[r].call(o.exports,o,o.exports,n),o.exports}n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),(()=>{"use strict";const e=n(259),t=n(263);self.onmessage=n=>{switch(n.data.type){case"init-wasm":(0,t.initializeWebAssembly)(n.data.in).then((()=>postMessage({type:"init-wasm"})),(e=>postMessage({type:"init-wasm",err:e})));break;case"init-ort":try{const{numThreads:t,loggingLevel:r}=n.data.in;(0,e.initOrt)(t,r),postMessage({type:"init-ort"})}catch(e){postMessage({type:"init-ort",err:e})}break;case"create_allocate":try{const{model:t}=n.data.in,r=(0,e.createSessionAllocate)(t);postMessage({type:"create_allocate",out:r})}catch(e){postMessage({type:"create_allocate",err:e})}break;case"create_finalize":try{const{modeldata:t,options:r}=n.data.in,a=(0,e.createSessionFinalize)(t,r);postMessage({type:"create_finalize",out:a})}catch(e){postMessage({type:"create_finalize",err:e})}break;case"create":try{const{model:t,options:r}=n.data.in,a=(0,e.createSession)(t,r);postMessage({type:"create",out:a})}catch(e){postMessage({type:"create",err:e})}break;case"release":try{const t=n.data.in;(0,e.releaseSession)(t),postMessage({type:"release"})}catch(e){postMessage({type:"release",err:e})}break;case"run":try{const{sessionId:t,inputIndices:r,inputs:a,outputIndices:o,options:i}=n.data.in;(0,e.run)(t,r,a,o,i).then((t=>{postMessage({type:"run",out:t},(0,e.extractTransferableBuffers)(t))}),(e=>{postMessage({type:"run",err:e})}))}catch(e){postMessage({type:"run",err:e})}break;case"end-profiling":try{const t=n.data.in;(0,e.endProfiling)(t),postMessage({type:"end-profiling"})}catch(e){postMessage({type:"end-profiling",err:e})}}}})()})();\n',"Worker",void 0,void 0)}},6614:it=>{it.exports=function(F,W,X,K){var Q=self||window;try{try{var Y;try{Y=new Q.Blob([F])}catch{(Y=new(Q.BlobBuilder||Q.WebKitBlobBuilder||Q.MozBlobBuilder||Q.MSBlobBuilder)).append(F),Y=Y.getBlob()}var tt=Q.URL||Q.webkitURL,et=tt.createObjectURL(Y),q=new Q[W](et,X);return tt.revokeObjectURL(et),q}catch{return new Q[W]("data:application/javascript,".concat(encodeURIComponent(F)),X)}}catch{if(!K)throw Error("Inline worker is not supported");return new Q[W](K,X)}}},3474:(it,F,W)=>{var X,K=(X=(X=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(Q){function Y(){return kt.buffer!=Mt&&re(kt.buffer),qt}function tt(){return kt.buffer!=Mt&&re(kt.buffer),Jt}function et(){return kt.buffer!=Mt&&re(kt.buffer),Bt}function q(){return kt.buffer!=Mt&&re(kt.buffer),ee}function G(){return kt.buffer!=Mt&&re(kt.buffer),ne}var O,b,j;Q=Q||{},O||(O=Q!==void 0?Q:{}),O.ready=new Promise(function(ht,mt){b=ht,j=mt});var U,J,nt,rt,ot,at,ut=Object.assign({},O),st="./this.program",ct=(ht,mt)=>{throw mt},dt=typeof window=="object",pt=typeof importScripts=="function",lt=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",ft=O.ENVIRONMENT_IS_PTHREAD||!1,gt="";function _t(ht){return O.locateFile?O.locateFile(ht,gt):gt+ht}if(lt){let ht;gt=pt?W(908).dirname(gt)+"/":"//",at=()=>{ot||(rt=W(1384),ot=W(908))},U=function(mt,Tt){return at(),mt=ot.normalize(mt),rt.readFileSync(mt,Tt?void 0:"utf8")},nt=mt=>((mt=U(mt,!0)).buffer||(mt=new Uint8Array(mt)),mt),J=(mt,Tt,Et)=>{at(),mt=ot.normalize(mt),rt.readFile(mt,function(jt,Ut){jt?Et(jt):Tt(Ut.buffer)})},1<process.argv.length&&(st=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",function(mt){if(!(mt instanceof Ft))throw mt}),process.on("unhandledRejection",function(mt){throw mt}),ct=(mt,Tt)=>{if(Rt)throw process.exitCode=mt,Tt;Tt instanceof Ft||xt("exiting due to exception: "+Tt),process.exit(mt)},O.inspect=function(){return"[Emscripten Module object]"};try{ht=W(9925)}catch(mt){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),mt}W.g.Worker=ht.Worker}else(dt||pt)&&(pt?gt=self.location.href:typeof document<"u"&&document.currentScript&&(gt=document.currentScript.src),X&&(gt=X),gt=gt.indexOf("blob:")!==0?gt.substr(0,gt.replace(/[?#].*/,"").lastIndexOf("/")+1):"",lt||(U=ht=>{var mt=new XMLHttpRequest;return mt.open("GET",ht,!1),mt.send(null),mt.responseText},pt&&(nt=ht=>{var mt=new XMLHttpRequest;return mt.open("GET",ht,!1),mt.responseType="arraybuffer",mt.send(null),new Uint8Array(mt.response)}),J=(ht,mt,Tt)=>{var Et=new XMLHttpRequest;Et.open("GET",ht,!0),Et.responseType="arraybuffer",Et.onload=()=>{Et.status==200||Et.status==0&&Et.response?mt(Et.response):Tt()},Et.onerror=Tt,Et.send(null)}));lt&&typeof performance>"u"&&(W.g.performance=W(6953).performance);var wt=console.log.bind(console),bt=console.warn.bind(console);lt&&(at(),wt=ht=>rt.writeSync(1,ht+`
`),bt=ht=>rt.writeSync(2,ht+`
`));var Ot,vt=O.print||wt,xt=O.printErr||bt;Object.assign(O,ut),ut=null,O.thisProgram&&(st=O.thisProgram),O.quit&&(ct=O.quit),O.wasmBinary&&(Ot=O.wasmBinary);var Rt=O.noExitRuntime||!0;typeof WebAssembly!="object"&&ge("no native wasm support detected");var kt,Ht,Mt,qt,Jt,Bt,ee,ne,Yt=!1,ae=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function Wt(ht,mt,Tt){var Et=(mt>>>=0)+Tt;for(Tt=mt;ht[Tt]&&!(Tt>=Et);)++Tt;if(16<Tt-mt&&ht.buffer&&ae)return ae.decode(ht.buffer instanceof SharedArrayBuffer?ht.slice(mt,Tt):ht.subarray(mt,Tt));for(Et="";mt<Tt;){var jt=ht[mt++];if(128&jt){var Ut=63&ht[mt++];if((224&jt)==192)Et+=String.fromCharCode((31&jt)<<6|Ut);else{var te=63&ht[mt++];65536>(jt=(240&jt)==224?(15&jt)<<12|Ut<<6|te:(7&jt)<<18|Ut<<12|te<<6|63&ht[mt++])?Et+=String.fromCharCode(jt):(jt-=65536,Et+=String.fromCharCode(55296|jt>>10,56320|1023&jt))}}else Et+=String.fromCharCode(jt)}return Et}function se(ht,mt){return(ht>>>=0)?Wt(tt(),ht,mt):""}function Zt(ht,mt,Tt,Et){if(!(0<Et))return 0;var jt=Tt>>>=0;Et=Tt+Et-1;for(var Ut=0;Ut<ht.length;++Ut){var te=ht.charCodeAt(Ut);if(55296<=te&&57343>=te&&(te=65536+((1023&te)<<10)|1023&ht.charCodeAt(++Ut)),127>=te){if(Tt>=Et)break;mt[Tt++>>>0]=te}else{if(2047>=te){if(Tt+1>=Et)break;mt[Tt++>>>0]=192|te>>6}else{if(65535>=te){if(Tt+2>=Et)break;mt[Tt++>>>0]=224|te>>12}else{if(Tt+3>=Et)break;mt[Tt++>>>0]=240|te>>18,mt[Tt++>>>0]=128|te>>12&63}mt[Tt++>>>0]=128|te>>6&63}mt[Tt++>>>0]=128|63&te}}return mt[Tt>>>0]=0,Tt-jt}function ue(ht){for(var mt=0,Tt=0;Tt<ht.length;++Tt){var Et=ht.charCodeAt(Tt);127>=Et?mt++:2047>=Et?mt+=2:55296<=Et&&57343>=Et?(mt+=4,++Tt):mt+=3}return mt}function re(ht){Mt=ht,O.HEAP8=qt=new Int8Array(ht),O.HEAP16=new Int16Array(ht),O.HEAP32=Bt=new Int32Array(ht),O.HEAPU8=Jt=new Uint8Array(ht),O.HEAPU16=new Uint16Array(ht),O.HEAPU32=ee=new Uint32Array(ht),O.HEAPF32=new Float32Array(ht),O.HEAPF64=ne=new Float64Array(ht)}ft&&(Mt=O.buffer);var pe=O.INITIAL_MEMORY||16777216;if(ft)kt=O.wasmMemory,Mt=O.buffer;else if(O.wasmMemory)kt=O.wasmMemory;else if(!((kt=new WebAssembly.Memory({initial:pe/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw xt("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),lt&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");kt&&(Mt=kt.buffer),pe=Mt.byteLength,re(Mt);var ye,Ae=[],Oe=[],Ie=[];function Ee(){var ht=O.preRun.shift();Ae.unshift(ht)}var le,ve=0,fe=null;function ge(ht){throw ft?postMessage({cmd:"onAbort",arg:ht}):O.onAbort&&O.onAbort(ht),xt(ht="Aborted("+ht+")"),Yt=!0,ht=new WebAssembly.RuntimeError(ht+". Build with -sASSERTIONS for more info."),j(ht),ht}function At(){return le.startsWith("data:application/octet-stream;base64,")}function Pt(){var ht=le;try{if(ht==le&&Ot)return new Uint8Array(Ot);if(nt)return nt(ht);throw"both async and sync fetching of the wasm failed"}catch(mt){ge(mt)}}le="ort-wasm-threaded.wasm",At()||(le=_t(le));var Ct={};function Ft(ht){this.name="ExitStatus",this.message="Program terminated with exit("+ht+")",this.status=ht}function zt(ht){(ht=Nt.La[ht])||ge(),Nt.Xa(ht)}function he(ht){var mt=Nt.lb();if(!mt)return 6;Nt.Ra.push(mt),Nt.La[ht.Ka]=mt,mt.Ka=ht.Ka;var Tt={cmd:"run",start_routine:ht.pb,arg:ht.ib,pthread_ptr:ht.Ka};return mt.Qa=()=>{Tt.time=performance.now(),mt.postMessage(Tt,ht.vb)},mt.loaded&&(mt.Qa(),delete mt.Qa),0}function Kt(ht){if(ft)return ce(1,1,ht);Rt||(Nt.qb(),O.onExit&&O.onExit(ht),Yt=!0),ct(ht,new Ft(ht))}function Xt(ht,mt){if(!mt&&ft)throw St(ht),"unwind";Kt(ht)}var Nt={Oa:[],Ra:[],$a:[],La:{},Ua:function(){ft&&Nt.mb()},xb:function(){},mb:function(){Nt.receiveObjectTransfer=Nt.ob,Nt.threadInitTLS=Nt.Za,Nt.setExitStatus=Nt.Ya,Rt=!1},Ya:function(){},qb:function(){for(var ht of Object.values(Nt.La))Nt.Xa(ht);for(ht of Nt.Oa)ht.terminate();Nt.Oa=[]},Xa:function(ht){var mt=ht.Ka;delete Nt.La[mt],Nt.Oa.push(ht),Nt.Ra.splice(Nt.Ra.indexOf(ht),1),ht.Ka=0,He(mt)},ob:function(){},Za:function(){Nt.$a.forEach(ht=>ht())},nb:function(ht,mt){ht.onmessage=Tt=>{var Et=(Tt=Tt.data).cmd;if(ht.Ka&&(Nt.kb=ht.Ka),Tt.targetThread&&Tt.targetThread!=Le()){var jt=Nt.La[Tt.yb];jt?jt.postMessage(Tt,Tt.transferList):xt('Internal error! Worker sent a message "'+Et+'" to target pthread '+Tt.targetThread+", but that thread no longer exists!")}else Et==="processProxyingQueue"?Be(Tt.queue):Et==="spawnThread"?he(Tt):Et==="cleanupThread"?zt(Tt.thread):Et==="killThread"?(Tt=Tt.thread,Et=Nt.La[Tt],delete Nt.La[Tt],Et.terminate(),He(Tt),Nt.Ra.splice(Nt.Ra.indexOf(Et),1),Et.Ka=0):Et==="cancelThread"?Nt.La[Tt.thread].postMessage({cmd:"cancel"}):Et==="loaded"?(ht.loaded=!0,mt&&mt(ht),ht.Qa&&(ht.Qa(),delete ht.Qa)):Et==="print"?vt("Thread "+Tt.threadId+": "+Tt.text):Et==="printErr"?xt("Thread "+Tt.threadId+": "+Tt.text):Et==="alert"?alert("Thread "+Tt.threadId+": "+Tt.text):Tt.target==="setimmediate"?ht.postMessage(Tt):Et==="onAbort"?O.onAbort&&O.onAbort(Tt.arg):Et&&xt("worker sent an unknown command "+Et);Nt.kb=void 0},ht.onerror=Tt=>{throw xt("worker sent an error! "+Tt.filename+":"+Tt.lineno+": "+Tt.message),Tt},lt&&(ht.on("message",function(Tt){ht.onmessage({data:Tt})}),ht.on("error",function(Tt){ht.onerror(Tt)}),ht.on("detachedExit",function(){})),ht.postMessage({cmd:"load",urlOrBlob:O.mainScriptUrlOrBlob||X,wasmMemory:kt,wasmModule:Ht})},hb:function(){var ht=_t("ort-wasm-threaded.worker.js");Nt.Oa.push(new Worker(ht))},lb:function(){return Nt.Oa.length==0&&(Nt.hb(),Nt.nb(Nt.Oa[0])),Nt.Oa.pop()}};function yt(ht){for(;0<ht.length;)ht.shift()(O)}function St(ht){if(ft)return ce(2,0,ht);try{Xt(ht)}catch(mt){mt instanceof Ft||mt=="unwind"||ct(1,mt)}}O.PThread=Nt,O.establishStackSpace=function(){var ht=Le(),mt=et()[ht+44>>2>>>0];ht=et()[ht+48>>2>>>0],bn(mt,mt-ht),je(mt)};var Dt,Lt,Gt=[];function Vt(ht){this.Pa=ht-24,this.gb=function(mt){q()[this.Pa+4>>2>>>0]=mt},this.cb=function(mt){q()[this.Pa+8>>2>>>0]=mt},this.eb=function(){et()[this.Pa>>2>>>0]=0},this.bb=function(){Y()[this.Pa+12>>0>>>0]=0},this.fb=function(){Y()[this.Pa+13>>0>>>0]=0},this.Ua=function(mt,Tt){this.ab(),this.gb(mt),this.cb(Tt),this.eb(),this.bb(),this.fb()},this.ab=function(){q()[this.Pa+16>>2>>>0]=0}}function Qt(ht,mt,Tt,Et){return ft?ce(3,1,ht,mt,Tt,Et):_e(ht,mt,Tt,Et)}function _e(ht,mt,Tt,Et){if(typeof SharedArrayBuffer>"u")return xt("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var jt=[];return ft&&jt.length===0?Qt(ht,mt,Tt,Et):(ht={pb:Tt,Ka:ht,ib:Et,vb:jt},ft?(ht.wb="spawnThread",postMessage(ht,jt),0):he(ht))}function Te(ht,mt,Tt){return ft?ce(4,1,ht,mt,Tt):0}function we(ht,mt){if(ft)return ce(5,1,ht,mt)}function be(ht,mt){if(ft)return ce(6,1,ht,mt)}function De(ht,mt,Tt){if(ft)return ce(7,1,ht,mt,Tt)}function Ce(ht,mt,Tt){return ft?ce(8,1,ht,mt,Tt):0}function $t(ht,mt){if(ft)return ce(9,1,ht,mt)}function ie(ht,mt,Tt){if(ft)return ce(10,1,ht,mt,Tt)}function de(ht,mt,Tt,Et){if(ft)return ce(11,1,ht,mt,Tt,Et)}function Pe(ht,mt,Tt,Et){if(ft)return ce(12,1,ht,mt,Tt,Et)}function Ne(ht,mt,Tt,Et){if(ft)return ce(13,1,ht,mt,Tt,Et)}function Ke(ht){if(ft)return ce(14,1,ht)}function Ye(ht,mt){if(ft)return ce(15,1,ht,mt)}function Xe(ht,mt,Tt){if(ft)return ce(16,1,ht,mt,Tt)}function Be(ht){Atomics.store(et(),ht>>2,1),Le()&&gn(ht),Atomics.compareExchange(et(),ht>>2,1,0)}function Je(ht){return q()[ht>>>2]+4294967296*et()[ht+4>>>2]}function Ze(ht,mt,Tt,Et,jt,Ut){return ft?ce(17,1,ht,mt,Tt,Et,jt,Ut):-52}function Qe(ht,mt,Tt,Et,jt,Ut){if(ft)return ce(18,1,ht,mt,Tt,Et,jt,Ut)}function tn(ht){var mt=ue(ht)+1,Tt=ze(mt);return Tt&&Zt(ht,Y(),Tt,mt),Tt}function en(ht,mt,Tt){function Et(Se){return(Se=Se.toTimeString().match(/\(([A-Za-z ]+)\)$/))?Se[1]:"GMT"}if(ft)return ce(19,1,ht,mt,Tt);var jt=new Date().getFullYear(),Ut=new Date(jt,0,1),te=new Date(jt,6,1);jt=Ut.getTimezoneOffset();var xe=te.getTimezoneOffset(),ke=Math.max(jt,xe);et()[ht>>2>>>0]=60*ke,et()[mt>>2>>>0]=+(jt!=xe),ht=Et(Ut),mt=Et(te),ht=tn(ht),mt=tn(mt),xe<jt?(q()[Tt>>2>>>0]=ht,q()[Tt+4>>2>>>0]=mt):(q()[Tt>>2>>>0]=mt,q()[Tt+4>>2>>>0]=ht)}function ce(ht,mt){var Tt=arguments.length-2,Et=arguments;return function(jt){var Ut=We();return jt=jt(),je(Ut),jt}(()=>{for(var jt=qe(8*Tt),Ut=jt>>3,te=0;te<Tt;te++){var xe=Et[2+te];G()[Ut+te>>>0]=xe}return fn(ht,Tt,jt,mt)})}O.invokeEntryPoint=function(ht,mt){var Tt=Gt[ht];Tt||(ht>=Gt.length&&(Gt.length=ht+1),Gt[ht]=Tt=ye.get(ht)),ht=Tt(mt),Rt?Nt.Ya(ht):mn(ht)},O.executeNotifiedProxyingQueue=Be,Lt=lt?()=>{var ht=process.hrtime();return 1e3*ht[0]+ht[1]/1e6}:ft?()=>performance.now()-O.__performance_now_clock_drift:()=>performance.now();var Ue,Ge=[],Ve={};function nn(){if(!Ue){var ht,mt={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:st||"./this.program"};for(ht in Ve)Ve[ht]===void 0?delete mt[ht]:mt[ht]=Ve[ht];var Tt=[];for(ht in mt)Tt.push(ht+"="+mt[ht]);Ue=Tt}return Ue}function rn(ht,mt){if(ft)return ce(20,1,ht,mt);var Tt=0;return nn().forEach(function(Et,jt){var Ut=mt+Tt;for(jt=q()[ht+4*jt>>2>>>0]=Ut,Ut=0;Ut<Et.length;++Ut)Y()[jt++>>0>>>0]=Et.charCodeAt(Ut);Y()[jt>>0>>>0]=0,Tt+=Et.length+1}),0}function on(ht,mt){if(ft)return ce(21,1,ht,mt);var Tt=nn();q()[ht>>2>>>0]=Tt.length;var Et=0;return Tt.forEach(function(jt){Et+=jt.length+1}),q()[mt>>2>>>0]=Et,0}function an(ht){return ft?ce(22,1,ht):52}function sn(ht,mt,Tt,Et){return ft?ce(23,1,ht,mt,Tt,Et):52}function un(ht,mt,Tt,Et,jt){return ft?ce(24,1,ht,mt,Tt,Et,jt):70}var xn=[null,[],[]];function ln(ht,mt,Tt,Et){if(ft)return ce(25,1,ht,mt,Tt,Et);for(var jt=0,Ut=0;Ut<Tt;Ut++){var te=q()[mt>>2>>>0],xe=q()[mt+4>>2>>>0];mt+=8;for(var ke=0;ke<xe;ke++){var Se=tt()[te+ke>>>0],$e=xn[ht];Se===0||Se===10?((ht===1?vt:xt)(Wt($e,0)),$e.length=0):$e.push(Se)}jt+=xe}return q()[Et>>2>>>0]=jt,0}function Me(ht){return ht%4==0&&(ht%100!=0||ht%400==0)}var cn=[31,29,31,30,31,30,31,31,30,31,30,31],dn=[31,28,31,30,31,30,31,31,30,31,30,31];function pn(ht,mt,Tt,Et){function jt(It,oe,me){for(It=typeof It=="number"?It.toString():It||"";It.length<oe;)It=me[0]+It;return It}function Ut(It,oe){return jt(It,oe,"0")}function te(It,oe){function me(wn){return 0>wn?-1:0<wn?1:0}var Re;return(Re=me(It.getFullYear()-oe.getFullYear()))===0&&(Re=me(It.getMonth()-oe.getMonth()))===0&&(Re=me(It.getDate()-oe.getDate())),Re}function xe(It){switch(It.getDay()){case 0:return new Date(It.getFullYear()-1,11,29);case 1:return It;case 2:return new Date(It.getFullYear(),0,3);case 3:return new Date(It.getFullYear(),0,2);case 4:return new Date(It.getFullYear(),0,1);case 5:return new Date(It.getFullYear()-1,11,31);case 6:return new Date(It.getFullYear()-1,11,30)}}function ke(It){var oe=It.Ma;for(It=new Date(new Date(It.Na+1900,0,1).getTime());0<oe;){var me=It.getMonth(),Re=(Me(It.getFullYear())?cn:dn)[me];if(!(oe>Re-It.getDate())){It.setDate(It.getDate()+oe);break}oe-=Re-It.getDate()+1,It.setDate(1),11>me?It.setMonth(me+1):(It.setMonth(0),It.setFullYear(It.getFullYear()+1))}return me=new Date(It.getFullYear()+1,0,4),oe=xe(new Date(It.getFullYear(),0,4)),me=xe(me),0>=te(oe,It)?0>=te(me,It)?It.getFullYear()+1:It.getFullYear():It.getFullYear()-1}var Se=et()[Et+40>>2>>>0];for(var $e in Et={tb:et()[Et>>2>>>0],sb:et()[Et+4>>2>>>0],Sa:et()[Et+8>>2>>>0],Va:et()[Et+12>>2>>>0],Ta:et()[Et+16>>2>>>0],Na:et()[Et+20>>2>>>0],Ja:et()[Et+24>>2>>>0],Ma:et()[Et+28>>2>>>0],zb:et()[Et+32>>2>>>0],rb:et()[Et+36>>2>>>0],ub:Se?se(Se):""},Tt=se(Tt),Se={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})Tt=Tt.replace(new RegExp($e,"g"),Se[$e]);var vn="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),_n="January February March April May June July August September October November December".split(" ");for($e in Se={"%a":function(It){return vn[It.Ja].substring(0,3)},"%A":function(It){return vn[It.Ja]},"%b":function(It){return _n[It.Ta].substring(0,3)},"%B":function(It){return _n[It.Ta]},"%C":function(It){return Ut((It.Na+1900)/100|0,2)},"%d":function(It){return Ut(It.Va,2)},"%e":function(It){return jt(It.Va,2," ")},"%g":function(It){return ke(It).toString().substring(2)},"%G":function(It){return ke(It)},"%H":function(It){return Ut(It.Sa,2)},"%I":function(It){return(It=It.Sa)==0?It=12:12<It&&(It-=12),Ut(It,2)},"%j":function(It){for(var oe=0,me=0;me<=It.Ta-1;oe+=(Me(It.Na+1900)?cn:dn)[me++]);return Ut(It.Va+oe,3)},"%m":function(It){return Ut(It.Ta+1,2)},"%M":function(It){return Ut(It.sb,2)},"%n":function(){return`
`},"%p":function(It){return 0<=It.Sa&&12>It.Sa?"AM":"PM"},"%S":function(It){return Ut(It.tb,2)},"%t":function(){return"	"},"%u":function(It){return It.Ja||7},"%U":function(It){return Ut(Math.floor((It.Ma+7-It.Ja)/7),2)},"%V":function(It){var oe=Math.floor((It.Ma+7-(It.Ja+6)%7)/7);if(2>=(It.Ja+371-It.Ma-2)%7&&oe++,oe)oe==53&&((me=(It.Ja+371-It.Ma)%7)==4||me==3&&Me(It.Na)||(oe=1));else{oe=52;var me=(It.Ja+7-It.Ma-1)%7;(me==4||me==5&&Me(It.Na%400-1))&&oe++}return Ut(oe,2)},"%w":function(It){return It.Ja},"%W":function(It){return Ut(Math.floor((It.Ma+7-(It.Ja+6)%7)/7),2)},"%y":function(It){return(It.Na+1900).toString().substring(2)},"%Y":function(It){return It.Na+1900},"%z":function(It){var oe=0<=(It=It.rb);return It=Math.abs(It)/60,(oe?"+":"-")+("0000"+(It/60*100+It%60)).slice(-4)},"%Z":function(It){return It.ub},"%%":function(){return"%"}},Tt=Tt.replace(/%%/g,"\0\0"),Se)Tt.includes($e)&&(Tt=Tt.replace(new RegExp($e,"g"),Se[$e](Et)));return $e=function(It){var oe=Array(ue(It)+1);return Zt(It,oe,0,oe.length),oe}(Tt=Tt.replace(/\0\0/g,"%")),$e.length>mt?0:(function(It,oe){Y().set(It,oe>>>0)}($e,ht),$e.length-1)}Nt.Ua();var Tn=[null,Kt,St,Qt,Te,we,be,De,Ce,$t,ie,de,Pe,Ne,Ke,Ye,Xe,Ze,Qe,en,rn,on,an,sn,un,ln],Sn={b:function(ht){return ze(ht+24)+24},c:function(ht,mt,Tt){throw new Vt(ht).Ua(mt,Tt),ht},L:function(ht){hn(ht,!pt,1,!dt),Nt.Za()},l:function(ht){ft?postMessage({cmd:"cleanupThread",thread:ht}):zt(ht)},D:_e,i:Te,R:we,z:be,B:De,T:Ce,P:$t,I:ie,O:de,p:Pe,A:Ne,x:Ke,Q:Ye,y:Xe,r:function(){},j:function(){ge("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},s:function(){ge("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},q:function(){return Date.now()},E:function(){return 2097152},V:function(){return!0},F:function(ht,mt,Tt,Et){if(ht==mt)setTimeout(()=>Be(Et));else if(ft)postMessage({targetThread:ht,cmd:"processProxyingQueue",queue:Et});else{if(!(ht=Nt.La[ht]))return;ht.postMessage({cmd:"processProxyingQueue",queue:Et})}return 1},K:function(){return-1},W:function(ht,mt){ht=new Date(1e3*Je(ht)),et()[mt>>2>>>0]=ht.getUTCSeconds(),et()[mt+4>>2>>>0]=ht.getUTCMinutes(),et()[mt+8>>2>>>0]=ht.getUTCHours(),et()[mt+12>>2>>>0]=ht.getUTCDate(),et()[mt+16>>2>>>0]=ht.getUTCMonth(),et()[mt+20>>2>>>0]=ht.getUTCFullYear()-1900,et()[mt+24>>2>>>0]=ht.getUTCDay(),ht=(ht.getTime()-Date.UTC(ht.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,et()[mt+28>>2>>>0]=ht},X:function(ht,mt){ht=new Date(1e3*Je(ht)),et()[mt>>2>>>0]=ht.getSeconds(),et()[mt+4>>2>>>0]=ht.getMinutes(),et()[mt+8>>2>>>0]=ht.getHours(),et()[mt+12>>2>>>0]=ht.getDate(),et()[mt+16>>2>>>0]=ht.getMonth(),et()[mt+20>>2>>>0]=ht.getFullYear()-1900,et()[mt+24>>2>>>0]=ht.getDay();var Tt=new Date(ht.getFullYear(),0,1),Et=(ht.getTime()-Tt.getTime())/864e5|0;et()[mt+28>>2>>>0]=Et,et()[mt+36>>2>>>0]=-60*ht.getTimezoneOffset(),Et=new Date(ht.getFullYear(),6,1).getTimezoneOffset(),ht=0|(Et!=(Tt=Tt.getTimezoneOffset())&&ht.getTimezoneOffset()==Math.min(Tt,Et)),et()[mt+32>>2>>>0]=ht},Y:function(ht){var mt=new Date(et()[ht+20>>2>>>0]+1900,et()[ht+16>>2>>>0],et()[ht+12>>2>>>0],et()[ht+8>>2>>>0],et()[ht+4>>2>>>0],et()[ht>>2>>>0],0),Tt=et()[ht+32>>2>>>0],Et=mt.getTimezoneOffset(),jt=new Date(mt.getFullYear(),0,1),Ut=new Date(mt.getFullYear(),6,1).getTimezoneOffset(),te=jt.getTimezoneOffset(),xe=Math.min(te,Ut);return 0>Tt?et()[ht+32>>2>>>0]=+(Ut!=te&&xe==Et):0<Tt!=(xe==Et)&&(Ut=Math.max(te,Ut),mt.setTime(mt.getTime()+6e4*((0<Tt?xe:Ut)-Et))),et()[ht+24>>2>>>0]=mt.getDay(),Tt=(mt.getTime()-jt.getTime())/864e5|0,et()[ht+28>>2>>>0]=Tt,et()[ht>>2>>>0]=mt.getSeconds(),et()[ht+4>>2>>>0]=mt.getMinutes(),et()[ht+8>>2>>>0]=mt.getHours(),et()[ht+12>>2>>>0]=mt.getDate(),et()[ht+16>>2>>>0]=mt.getMonth(),mt.getTime()/1e3|0},G:Ze,H:Qe,Z:function ht(mt,Tt,Et){ht.jb||(ht.jb=!0,en(mt,Tt,Et))},d:function(){ge("")},m:function(){if(!lt&&!pt){var ht="Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";Dt||(Dt={}),Dt[ht]||(Dt[ht]=1,lt&&(ht="warning: "+ht),xt(ht))}},w:function(){return 4294901760},f:Lt,S:function(ht,mt,Tt){tt().copyWithin(ht>>>0,mt>>>0,mt+Tt>>>0)},g:function(){return lt?W(3993).cpus().length:navigator.hardwareConcurrency},J:function(ht,mt,Tt){Ge.length=mt,Tt>>=3;for(var Et=0;Et<mt;Et++)Ge[Et]=G()[Tt+Et>>>0];return(0>ht?Ct[-ht-1]:Tn[ht]).apply(null,Ge)},v:function(ht){var mt=tt().length;if((ht>>>=0)<=mt||4294901760<ht)return!1;for(var Tt=1;4>=Tt;Tt*=2){var Et=mt*(1+.2/Tt);Et=Math.min(Et,ht+100663296);var jt=Math;Et=Math.max(ht,Et),jt=jt.min.call(jt,4294901760,Et+(65536-Et%65536)%65536);t:{try{kt.grow(jt-Mt.byteLength+65535>>>16),re(kt.buffer);var Ut=1;break t}catch{}Ut=void 0}if(Ut)return!0}return!1},U:function(){throw"unwind"},M:rn,N:on,k:Xt,h:an,o:sn,t:un,n:ln,u:function ht(mt,Tt){ht.Wa||(ht.Wa=function(){if(typeof crypto=="object"&&typeof crypto.getRandomValues=="function"){var jt=new Uint8Array(1);return()=>(crypto.getRandomValues(jt),jt[0])}if(lt)try{var Ut=W(760);return()=>Ut.randomBytes(1)[0]}catch{}return()=>ge("randomDevice")}());for(var Et=0;Et<Tt;Et++)Y()[mt+Et>>0>>>0]=ht.Wa();return 0},a:kt||O.wasmMemory,C:pn,e:function(ht,mt,Tt,Et){return pn(ht,mt,Tt,Et)}};(function(){function ht(jt,Ut){O.asm=jt.exports,Nt.$a.push(O.asm.wa),ye=O.asm.za,Oe.unshift(O.asm._),Ht=Ut,ft||(ve--,O.monitorRunDependencies&&O.monitorRunDependencies(ve),ve==0&&fe&&(jt=fe,fe=null,jt()))}function mt(jt){ht(jt.instance,jt.module)}function Tt(jt){return function(){if(!Ot&&(dt||pt)){if(typeof fetch=="function"&&!le.startsWith("file://"))return fetch(le,{credentials:"same-origin"}).then(function(Ut){if(!Ut.ok)throw"failed to load wasm binary file at '"+le+"'";return Ut.arrayBuffer()}).catch(function(){return Pt()});if(J)return new Promise(function(Ut,te){J(le,function(xe){Ut(new Uint8Array(xe))},te)})}return Promise.resolve().then(function(){return Pt()})}().then(function(Ut){return WebAssembly.instantiate(Ut,Et)}).then(function(Ut){return Ut}).then(jt,function(Ut){xt("failed to asynchronously prepare wasm: "+Ut),ge(Ut)})}var Et={a:Sn};if(ft||(ve++,O.monitorRunDependencies&&O.monitorRunDependencies(ve)),O.instantiateWasm)try{return O.instantiateWasm(Et,ht)}catch(jt){return xt("Module.instantiateWasm callback failed with error: "+jt),!1}(Ot||typeof WebAssembly.instantiateStreaming!="function"||At()||le.startsWith("file://")||lt||typeof fetch!="function"?Tt(mt):fetch(le,{credentials:"same-origin"}).then(function(jt){return WebAssembly.instantiateStreaming(jt,Et).then(mt,function(Ut){return xt("wasm streaming compile failed: "+Ut),xt("falling back to ArrayBuffer instantiation"),Tt(mt)})})).catch(j)})(),O.___wasm_call_ctors=function(){return(O.___wasm_call_ctors=O.asm._).apply(null,arguments)},O._OrtInit=function(){return(O._OrtInit=O.asm.$).apply(null,arguments)},O._OrtCreateSessionOptions=function(){return(O._OrtCreateSessionOptions=O.asm.aa).apply(null,arguments)},O._OrtAppendExecutionProvider=function(){return(O._OrtAppendExecutionProvider=O.asm.ba).apply(null,arguments)},O._OrtAddSessionConfigEntry=function(){return(O._OrtAddSessionConfigEntry=O.asm.ca).apply(null,arguments)},O._OrtReleaseSessionOptions=function(){return(O._OrtReleaseSessionOptions=O.asm.da).apply(null,arguments)},O._OrtCreateSession=function(){return(O._OrtCreateSession=O.asm.ea).apply(null,arguments)},O._OrtReleaseSession=function(){return(O._OrtReleaseSession=O.asm.fa).apply(null,arguments)},O._OrtGetInputCount=function(){return(O._OrtGetInputCount=O.asm.ga).apply(null,arguments)},O._OrtGetOutputCount=function(){return(O._OrtGetOutputCount=O.asm.ha).apply(null,arguments)},O._OrtGetInputName=function(){return(O._OrtGetInputName=O.asm.ia).apply(null,arguments)},O._OrtGetOutputName=function(){return(O._OrtGetOutputName=O.asm.ja).apply(null,arguments)},O._OrtFree=function(){return(O._OrtFree=O.asm.ka).apply(null,arguments)},O._OrtCreateTensor=function(){return(O._OrtCreateTensor=O.asm.la).apply(null,arguments)},O._OrtGetTensorData=function(){return(O._OrtGetTensorData=O.asm.ma).apply(null,arguments)},O._OrtReleaseTensor=function(){return(O._OrtReleaseTensor=O.asm.na).apply(null,arguments)},O._OrtCreateRunOptions=function(){return(O._OrtCreateRunOptions=O.asm.oa).apply(null,arguments)},O._OrtAddRunConfigEntry=function(){return(O._OrtAddRunConfigEntry=O.asm.pa).apply(null,arguments)},O._OrtReleaseRunOptions=function(){return(O._OrtReleaseRunOptions=O.asm.qa).apply(null,arguments)},O._OrtRun=function(){return(O._OrtRun=O.asm.ra).apply(null,arguments)},O._OrtEndProfiling=function(){return(O._OrtEndProfiling=O.asm.sa).apply(null,arguments)};var Le=O._pthread_self=function(){return(Le=O._pthread_self=O.asm.ta).apply(null,arguments)},ze=O._malloc=function(){return(ze=O._malloc=O.asm.ua).apply(null,arguments)};O._free=function(){return(O._free=O.asm.va).apply(null,arguments)},O.__emscripten_tls_init=function(){return(O.__emscripten_tls_init=O.asm.wa).apply(null,arguments)};var hn=O.__emscripten_thread_init=function(){return(hn=O.__emscripten_thread_init=O.asm.xa).apply(null,arguments)};O.__emscripten_thread_crashed=function(){return(O.__emscripten_thread_crashed=O.asm.ya).apply(null,arguments)};var Fe,fn=O._emscripten_run_in_main_runtime_thread_js=function(){return(fn=O._emscripten_run_in_main_runtime_thread_js=O.asm.Aa).apply(null,arguments)},gn=O.__emscripten_proxy_execute_task_queue=function(){return(gn=O.__emscripten_proxy_execute_task_queue=O.asm.Ba).apply(null,arguments)},He=O.__emscripten_thread_free_data=function(){return(He=O.__emscripten_thread_free_data=O.asm.Ca).apply(null,arguments)},mn=O.__emscripten_thread_exit=function(){return(mn=O.__emscripten_thread_exit=O.asm.Da).apply(null,arguments)},bn=O._emscripten_stack_set_limits=function(){return(bn=O._emscripten_stack_set_limits=O.asm.Ea).apply(null,arguments)},We=O.stackSave=function(){return(We=O.stackSave=O.asm.Fa).apply(null,arguments)},je=O.stackRestore=function(){return(je=O.stackRestore=O.asm.Ga).apply(null,arguments)},qe=O.stackAlloc=function(){return(qe=O.stackAlloc=O.asm.Ha).apply(null,arguments)};function yn(){function ht(){if(!Fe&&(Fe=!0,O.calledRun=!0,!Yt)&&(ft||yt(Oe),b(O),O.onRuntimeInitialized&&O.onRuntimeInitialized(),!ft)){if(O.postRun)for(typeof O.postRun=="function"&&(O.postRun=[O.postRun]);O.postRun.length;){var mt=O.postRun.shift();Ie.unshift(mt)}yt(Ie)}}if(!(0<ve))if(ft)b(O),ft||yt(Oe),postMessage({cmd:"loaded"});else{if(O.preRun)for(typeof O.preRun=="function"&&(O.preRun=[O.preRun]);O.preRun.length;)Ee();yt(Ae),0<ve||(O.setStatus?(O.setStatus("Running..."),setTimeout(function(){setTimeout(function(){O.setStatus("")},1),ht()},1)):ht())}}if(O.___cxa_is_pointer_type=function(){return(O.___cxa_is_pointer_type=O.asm.Ia).apply(null,arguments)},O.UTF8ToString=se,O.stringToUTF8=function(ht,mt,Tt){return Zt(ht,tt(),mt,Tt)},O.lengthBytesUTF8=ue,O.keepRuntimeAlive=function(){return Rt},O.wasmMemory=kt,O.stackSave=We,O.stackRestore=je,O.stackAlloc=qe,O.ExitStatus=Ft,O.PThread=Nt,fe=function ht(){Fe||yn(),Fe||(fe=ht)},O.preInit)for(typeof O.preInit=="function"&&(O.preInit=[O.preInit]);0<O.preInit.length;)O.preInit.pop()();return yn(),Q.ready});it.exports=K},932:(it,F,W)=>{var X,K=(X=(X=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(Q){var Y,tt,et;Q=Q||{},Y||(Y=Q!==void 0?Q:{}),Y.ready=new Promise(function(yt,St){tt=yt,et=St});var q,G,O,b,j,U,J=Object.assign({},Y),nt="./this.program",rt=(yt,St)=>{throw St},ot=typeof window=="object",at=typeof importScripts=="function",ut=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",st="";ut?(st=at?W(908).dirname(st)+"/":"//",U=()=>{j||(b=W(1384),j=W(908))},q=function(yt,St){return U(),yt=j.normalize(yt),b.readFileSync(yt,St?void 0:"utf8")},O=yt=>((yt=q(yt,!0)).buffer||(yt=new Uint8Array(yt)),yt),G=(yt,St,Dt)=>{U(),yt=j.normalize(yt),b.readFile(yt,function(Lt,Gt){Lt?Dt(Lt):St(Gt.buffer)})},1<process.argv.length&&(nt=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",function(yt){if(!(yt instanceof pe))throw yt}),process.on("unhandledRejection",function(yt){throw yt}),rt=(yt,St)=>{if(lt)throw process.exitCode=yt,St;St instanceof pe||pt("exiting due to exception: "+St),process.exit(yt)},Y.inspect=function(){return"[Emscripten Module object]"}):(ot||at)&&(at?st=self.location.href:typeof document<"u"&&document.currentScript&&(st=document.currentScript.src),X&&(st=X),st=st.indexOf("blob:")!==0?st.substr(0,st.replace(/[?#].*/,"").lastIndexOf("/")+1):"",q=yt=>{var St=new XMLHttpRequest;return St.open("GET",yt,!1),St.send(null),St.responseText},at&&(O=yt=>{var St=new XMLHttpRequest;return St.open("GET",yt,!1),St.responseType="arraybuffer",St.send(null),new Uint8Array(St.response)}),G=(yt,St,Dt)=>{var Lt=new XMLHttpRequest;Lt.open("GET",yt,!0),Lt.responseType="arraybuffer",Lt.onload=()=>{Lt.status==200||Lt.status==0&&Lt.response?St(Lt.response):Dt()},Lt.onerror=Dt,Lt.send(null)});var ct,dt=Y.print||console.log.bind(console),pt=Y.printErr||console.warn.bind(console);Object.assign(Y,J),J=null,Y.thisProgram&&(nt=Y.thisProgram),Y.quit&&(rt=Y.quit),Y.wasmBinary&&(ct=Y.wasmBinary);var lt=Y.noExitRuntime||!0;typeof WebAssembly!="object"&&se("no native wasm support detected");var ft,gt,_t,wt,bt,Ot,vt=!1,xt=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function Rt(yt,St,Dt){var Lt=(St>>>=0)+Dt;for(Dt=St;yt[Dt]&&!(Dt>=Lt);)++Dt;if(16<Dt-St&&yt.buffer&&xt)return xt.decode(yt.subarray(St,Dt));for(Lt="";St<Dt;){var Gt=yt[St++];if(128&Gt){var Vt=63&yt[St++];if((224&Gt)==192)Lt+=String.fromCharCode((31&Gt)<<6|Vt);else{var Qt=63&yt[St++];65536>(Gt=(240&Gt)==224?(15&Gt)<<12|Vt<<6|Qt:(7&Gt)<<18|Vt<<12|Qt<<6|63&yt[St++])?Lt+=String.fromCharCode(Gt):(Gt-=65536,Lt+=String.fromCharCode(55296|Gt>>10,56320|1023&Gt))}}else Lt+=String.fromCharCode(Gt)}return Lt}function kt(yt,St){return(yt>>>=0)?Rt(wt,yt,St):""}function Ht(yt,St,Dt,Lt){if(!(0<Lt))return 0;var Gt=Dt>>>=0;Lt=Dt+Lt-1;for(var Vt=0;Vt<yt.length;++Vt){var Qt=yt.charCodeAt(Vt);if(55296<=Qt&&57343>=Qt&&(Qt=65536+((1023&Qt)<<10)|1023&yt.charCodeAt(++Vt)),127>=Qt){if(Dt>=Lt)break;St[Dt++>>>0]=Qt}else{if(2047>=Qt){if(Dt+1>=Lt)break;St[Dt++>>>0]=192|Qt>>6}else{if(65535>=Qt){if(Dt+2>=Lt)break;St[Dt++>>>0]=224|Qt>>12}else{if(Dt+3>=Lt)break;St[Dt++>>>0]=240|Qt>>18,St[Dt++>>>0]=128|Qt>>12&63}St[Dt++>>>0]=128|Qt>>6&63}St[Dt++>>>0]=128|63&Qt}}return St[Dt>>>0]=0,Dt-Gt}function Mt(yt){for(var St=0,Dt=0;Dt<yt.length;++Dt){var Lt=yt.charCodeAt(Dt);127>=Lt?St++:2047>=Lt?St+=2:55296<=Lt&&57343>=Lt?(St+=4,++Dt):St+=3}return St}function qt(){var yt=ft.buffer;gt=yt,Y.HEAP8=_t=new Int8Array(yt),Y.HEAP16=new Int16Array(yt),Y.HEAP32=bt=new Int32Array(yt),Y.HEAPU8=wt=new Uint8Array(yt),Y.HEAPU16=new Uint16Array(yt),Y.HEAPU32=Ot=new Uint32Array(yt),Y.HEAPF32=new Float32Array(yt),Y.HEAPF64=new Float64Array(yt)}var Jt=[],Bt=[],ee=[];function ne(){var yt=Y.preRun.shift();Jt.unshift(yt)}var Yt,ae=0,Wt=null;function se(yt){throw Y.onAbort&&Y.onAbort(yt),pt(yt="Aborted("+yt+")"),vt=!0,yt=new WebAssembly.RuntimeError(yt+". Build with -sASSERTIONS for more info."),et(yt),yt}function Zt(){return Yt.startsWith("data:application/octet-stream;base64,")}if(Yt="ort-wasm.wasm",!Zt()){var ue=Yt;Yt=Y.locateFile?Y.locateFile(ue,st):st+ue}function re(){var yt=Yt;try{if(yt==Yt&&ct)return new Uint8Array(ct);if(O)return O(yt);throw"both async and sync fetching of the wasm failed"}catch(St){se(St)}}function pe(yt){this.name="ExitStatus",this.message="Program terminated with exit("+yt+")",this.status=yt}function ye(yt){for(;0<yt.length;)yt.shift()(Y)}function Ae(yt){this.sa=yt-24,this.Ia=function(St){Ot[this.sa+4>>2>>>0]=St},this.Ba=function(St){Ot[this.sa+8>>2>>>0]=St},this.Ga=function(){bt[this.sa>>2>>>0]=0},this.Aa=function(){_t[this.sa+12>>0>>>0]=0},this.Ha=function(){_t[this.sa+13>>0>>>0]=0},this.ya=function(St,Dt){this.za(),this.Ia(St),this.Ba(Dt),this.Ga(),this.Aa(),this.Ha()},this.za=function(){Ot[this.sa+16>>2>>>0]=0}}function Oe(yt){var St=Mt(yt)+1,Dt=Ft(St);return Dt&&Ht(yt,_t,Dt,St),Dt}var Ie={};function Ee(){if(!le){var yt,St={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:nt||"./this.program"};for(yt in Ie)Ie[yt]===void 0?delete St[yt]:St[yt]=Ie[yt];var Dt=[];for(yt in St)Dt.push(yt+"="+St[yt]);le=Dt}return le}var le,ve=[null,[],[]];function fe(yt){return yt%4==0&&(yt%100!=0||yt%400==0)}var ge=[31,29,31,30,31,30,31,31,30,31,30,31],At=[31,28,31,30,31,30,31,31,30,31,30,31];function Pt(yt,St,Dt,Lt){function Gt($t,ie,de){for($t=typeof $t=="number"?$t.toString():$t||"";$t.length<ie;)$t=de[0]+$t;return $t}function Vt($t,ie){return Gt($t,ie,"0")}function Qt($t,ie){function de(Ne){return 0>Ne?-1:0<Ne?1:0}var Pe;return(Pe=de($t.getFullYear()-ie.getFullYear()))===0&&(Pe=de($t.getMonth()-ie.getMonth()))===0&&(Pe=de($t.getDate()-ie.getDate())),Pe}function _e($t){switch($t.getDay()){case 0:return new Date($t.getFullYear()-1,11,29);case 1:return $t;case 2:return new Date($t.getFullYear(),0,3);case 3:return new Date($t.getFullYear(),0,2);case 4:return new Date($t.getFullYear(),0,1);case 5:return new Date($t.getFullYear()-1,11,31);case 6:return new Date($t.getFullYear()-1,11,30)}}function Te($t){var ie=$t.qa;for($t=new Date(new Date($t.ra+1900,0,1).getTime());0<ie;){var de=$t.getMonth(),Pe=(fe($t.getFullYear())?ge:At)[de];if(!(ie>Pe-$t.getDate())){$t.setDate($t.getDate()+ie);break}ie-=Pe-$t.getDate()+1,$t.setDate(1),11>de?$t.setMonth(de+1):($t.setMonth(0),$t.setFullYear($t.getFullYear()+1))}return de=new Date($t.getFullYear()+1,0,4),ie=_e(new Date($t.getFullYear(),0,4)),de=_e(de),0>=Qt(ie,$t)?0>=Qt(de,$t)?$t.getFullYear()+1:$t.getFullYear():$t.getFullYear()-1}var we=bt[Lt+40>>2>>>0];for(var be in Lt={Ea:bt[Lt>>2>>>0],Da:bt[Lt+4>>2>>>0],ta:bt[Lt+8>>2>>>0],va:bt[Lt+12>>2>>>0],ua:bt[Lt+16>>2>>>0],ra:bt[Lt+20>>2>>>0],la:bt[Lt+24>>2>>>0],qa:bt[Lt+28>>2>>>0],Ja:bt[Lt+32>>2>>>0],Ca:bt[Lt+36>>2>>>0],Fa:we?kt(we):""},Dt=kt(Dt),we={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})Dt=Dt.replace(new RegExp(be,"g"),we[be]);var De="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),Ce="January February March April May June July August September October November December".split(" ");for(be in we={"%a":function($t){return De[$t.la].substring(0,3)},"%A":function($t){return De[$t.la]},"%b":function($t){return Ce[$t.ua].substring(0,3)},"%B":function($t){return Ce[$t.ua]},"%C":function($t){return Vt(($t.ra+1900)/100|0,2)},"%d":function($t){return Vt($t.va,2)},"%e":function($t){return Gt($t.va,2," ")},"%g":function($t){return Te($t).toString().substring(2)},"%G":function($t){return Te($t)},"%H":function($t){return Vt($t.ta,2)},"%I":function($t){return($t=$t.ta)==0?$t=12:12<$t&&($t-=12),Vt($t,2)},"%j":function($t){for(var ie=0,de=0;de<=$t.ua-1;ie+=(fe($t.ra+1900)?ge:At)[de++]);return Vt($t.va+ie,3)},"%m":function($t){return Vt($t.ua+1,2)},"%M":function($t){return Vt($t.Da,2)},"%n":function(){return`
`},"%p":function($t){return 0<=$t.ta&&12>$t.ta?"AM":"PM"},"%S":function($t){return Vt($t.Ea,2)},"%t":function(){return"	"},"%u":function($t){return $t.la||7},"%U":function($t){return Vt(Math.floor(($t.qa+7-$t.la)/7),2)},"%V":function($t){var ie=Math.floor(($t.qa+7-($t.la+6)%7)/7);if(2>=($t.la+371-$t.qa-2)%7&&ie++,ie)ie==53&&((de=($t.la+371-$t.qa)%7)==4||de==3&&fe($t.ra)||(ie=1));else{ie=52;var de=($t.la+7-$t.qa-1)%7;(de==4||de==5&&fe($t.ra%400-1))&&ie++}return Vt(ie,2)},"%w":function($t){return $t.la},"%W":function($t){return Vt(Math.floor(($t.qa+7-($t.la+6)%7)/7),2)},"%y":function($t){return($t.ra+1900).toString().substring(2)},"%Y":function($t){return $t.ra+1900},"%z":function($t){var ie=0<=($t=$t.Ca);return $t=Math.abs($t)/60,(ie?"+":"-")+("0000"+($t/60*100+$t%60)).slice(-4)},"%Z":function($t){return $t.Fa},"%%":function(){return"%"}},Dt=Dt.replace(/%%/g,"\0\0"),we)Dt.includes(be)&&(Dt=Dt.replace(new RegExp(be,"g"),we[be](Lt)));return be=function($t){var ie=Array(Mt($t)+1);return Ht($t,ie,0,ie.length),ie}(Dt=Dt.replace(/\0\0/g,"%")),be.length>St?0:(_t.set(be,yt>>>0),be.length-1)}var Ct={a:function(yt){return Ft(yt+24)+24},b:function(yt,St,Dt){throw new Ae(yt).ya(St,Dt),yt},g:function(){return 0},I:function(){},w:function(){},y:function(){},K:function(){return 0},G:function(){},C:function(){},F:function(){},k:function(){},x:function(){},u:function(){},H:function(){},v:function(){},n:function(){},p:function(){se("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},o:function(){se("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},l:function(){return Date.now()},L:function(){return!0},M:function(yt,St){yt=new Date(1e3*(Ot[yt>>>2]+4294967296*bt[yt+4>>>2])),bt[St>>2>>>0]=yt.getUTCSeconds(),bt[St+4>>2>>>0]=yt.getUTCMinutes(),bt[St+8>>2>>>0]=yt.getUTCHours(),bt[St+12>>2>>>0]=yt.getUTCDate(),bt[St+16>>2>>>0]=yt.getUTCMonth(),bt[St+20>>2>>>0]=yt.getUTCFullYear()-1900,bt[St+24>>2>>>0]=yt.getUTCDay(),bt[St+28>>2>>>0]=(yt.getTime()-Date.UTC(yt.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},N:function(yt,St){yt=new Date(1e3*(Ot[yt>>>2]+4294967296*bt[yt+4>>>2])),bt[St>>2>>>0]=yt.getSeconds(),bt[St+4>>2>>>0]=yt.getMinutes(),bt[St+8>>2>>>0]=yt.getHours(),bt[St+12>>2>>>0]=yt.getDate(),bt[St+16>>2>>>0]=yt.getMonth(),bt[St+20>>2>>>0]=yt.getFullYear()-1900,bt[St+24>>2>>>0]=yt.getDay();var Dt=new Date(yt.getFullYear(),0,1);bt[St+28>>2>>>0]=(yt.getTime()-Dt.getTime())/864e5|0,bt[St+36>>2>>>0]=-60*yt.getTimezoneOffset();var Lt=new Date(yt.getFullYear(),6,1).getTimezoneOffset();Dt=Dt.getTimezoneOffset(),bt[St+32>>2>>>0]=0|(Lt!=Dt&&yt.getTimezoneOffset()==Math.min(Dt,Lt))},O:function(yt){var St=new Date(bt[yt+20>>2>>>0]+1900,bt[yt+16>>2>>>0],bt[yt+12>>2>>>0],bt[yt+8>>2>>>0],bt[yt+4>>2>>>0],bt[yt>>2>>>0],0),Dt=bt[yt+32>>2>>>0],Lt=St.getTimezoneOffset(),Gt=new Date(St.getFullYear(),0,1),Vt=new Date(St.getFullYear(),6,1).getTimezoneOffset(),Qt=Gt.getTimezoneOffset(),_e=Math.min(Qt,Vt);return 0>Dt?bt[yt+32>>2>>>0]=+(Vt!=Qt&&_e==Lt):0<Dt!=(_e==Lt)&&(Vt=Math.max(Qt,Vt),St.setTime(St.getTime()+6e4*((0<Dt?_e:Vt)-Lt))),bt[yt+24>>2>>>0]=St.getDay(),bt[yt+28>>2>>>0]=(St.getTime()-Gt.getTime())/864e5|0,bt[yt>>2>>>0]=St.getSeconds(),bt[yt+4>>2>>>0]=St.getMinutes(),bt[yt+8>>2>>>0]=St.getHours(),bt[yt+12>>2>>>0]=St.getDate(),bt[yt+16>>2>>>0]=St.getMonth(),St.getTime()/1e3|0},z:function(){return-52},B:function(){},m:function yt(St,Dt,Lt){yt.xa||(yt.xa=!0,function(Gt,Vt,Qt){function _e(Ce){return(Ce=Ce.toTimeString().match(/\(([A-Za-z ]+)\)$/))?Ce[1]:"GMT"}var Te=new Date().getFullYear(),we=new Date(Te,0,1),be=new Date(Te,6,1);Te=we.getTimezoneOffset();var De=be.getTimezoneOffset();bt[Gt>>2>>>0]=60*Math.max(Te,De),bt[Vt>>2>>>0]=+(Te!=De),Gt=_e(we),Vt=_e(be),Gt=Oe(Gt),Vt=Oe(Vt),De<Te?(Ot[Qt>>2>>>0]=Gt,Ot[Qt+4>>2>>>0]=Vt):(Ot[Qt>>2>>>0]=Vt,Ot[Qt+4>>2>>>0]=Gt)}(St,Dt,Lt))},d:function(){se("")},t:function(){return 4294901760},h:ut?()=>{var yt=process.hrtime();return 1e3*yt[0]+yt[1]/1e6}:()=>performance.now(),J:function(yt,St,Dt){wt.copyWithin(yt>>>0,St>>>0,St+Dt>>>0)},f:function(yt){var St=wt.length;if(4294901760<(yt>>>=0))return!1;for(var Dt=1;4>=Dt;Dt*=2){var Lt=St*(1+.2/Dt);Lt=Math.min(Lt,yt+100663296);var Gt=Math;Lt=Math.max(yt,Lt),Gt=Gt.min.call(Gt,4294901760,Lt+(65536-Lt%65536)%65536);t:{try{ft.grow(Gt-gt.byteLength+65535>>>16),qt();var Vt=1;break t}catch{}Vt=void 0}if(Vt)return!0}return!1},D:function(yt,St){var Dt=0;return Ee().forEach(function(Lt,Gt){var Vt=St+Dt;for(Gt=Ot[yt+4*Gt>>2>>>0]=Vt,Vt=0;Vt<Lt.length;++Vt)_t[Gt++>>0>>>0]=Lt.charCodeAt(Vt);_t[Gt>>0>>>0]=0,Dt+=Lt.length+1}),0},E:function(yt,St){var Dt=Ee();Ot[yt>>2>>>0]=Dt.length;var Lt=0;return Dt.forEach(function(Gt){Lt+=Gt.length+1}),Ot[St>>2>>>0]=Lt,0},r:function(yt){lt||(Y.onExit&&Y.onExit(yt),vt=!0),rt(yt,new pe(yt))},e:function(){return 52},j:function(){return 52},q:function(){return 70},i:function(yt,St,Dt,Lt){for(var Gt=0,Vt=0;Vt<Dt;Vt++){var Qt=Ot[St>>2>>>0],_e=Ot[St+4>>2>>>0];St+=8;for(var Te=0;Te<_e;Te++){var we=wt[Qt+Te>>>0],be=ve[yt];we===0||we===10?((yt===1?dt:pt)(Rt(be,0)),be.length=0):be.push(we)}Gt+=_e}return Ot[Lt>>2>>>0]=Gt,0},s:function yt(St,Dt){yt.wa||(yt.wa=function(){if(typeof crypto=="object"&&typeof crypto.getRandomValues=="function"){var Gt=new Uint8Array(1);return()=>(crypto.getRandomValues(Gt),Gt[0])}if(ut)try{var Vt=W(760);return()=>Vt.randomBytes(1)[0]}catch{}return()=>se("randomDevice")}());for(var Lt=0;Lt<Dt;Lt++)_t[St+Lt>>0>>>0]=yt.wa();return 0},A:Pt,c:function(yt,St,Dt,Lt){return Pt(yt,St,Dt,Lt)}};(function(){function yt(Gt){Y.asm=Gt.exports,ft=Y.asm.P,qt(),Bt.unshift(Y.asm.Q),ae--,Y.monitorRunDependencies&&Y.monitorRunDependencies(ae),ae==0&&Wt&&(Gt=Wt,Wt=null,Gt())}function St(Gt){yt(Gt.instance)}function Dt(Gt){return function(){if(!ct&&(ot||at)){if(typeof fetch=="function"&&!Yt.startsWith("file://"))return fetch(Yt,{credentials:"same-origin"}).then(function(Vt){if(!Vt.ok)throw"failed to load wasm binary file at '"+Yt+"'";return Vt.arrayBuffer()}).catch(function(){return re()});if(G)return new Promise(function(Vt,Qt){G(Yt,function(_e){Vt(new Uint8Array(_e))},Qt)})}return Promise.resolve().then(function(){return re()})}().then(function(Vt){return WebAssembly.instantiate(Vt,Lt)}).then(function(Vt){return Vt}).then(Gt,function(Vt){pt("failed to asynchronously prepare wasm: "+Vt),se(Vt)})}var Lt={a:Ct};if(ae++,Y.monitorRunDependencies&&Y.monitorRunDependencies(ae),Y.instantiateWasm)try{return Y.instantiateWasm(Lt,yt)}catch(Gt){return pt("Module.instantiateWasm callback failed with error: "+Gt),!1}(ct||typeof WebAssembly.instantiateStreaming!="function"||Zt()||Yt.startsWith("file://")||ut||typeof fetch!="function"?Dt(St):fetch(Yt,{credentials:"same-origin"}).then(function(Gt){return WebAssembly.instantiateStreaming(Gt,Lt).then(St,function(Vt){return pt("wasm streaming compile failed: "+Vt),pt("falling back to ArrayBuffer instantiation"),Dt(St)})})).catch(et)})(),Y.___wasm_call_ctors=function(){return(Y.___wasm_call_ctors=Y.asm.Q).apply(null,arguments)},Y._OrtInit=function(){return(Y._OrtInit=Y.asm.R).apply(null,arguments)},Y._OrtCreateSessionOptions=function(){return(Y._OrtCreateSessionOptions=Y.asm.S).apply(null,arguments)},Y._OrtAppendExecutionProvider=function(){return(Y._OrtAppendExecutionProvider=Y.asm.T).apply(null,arguments)},Y._OrtAddSessionConfigEntry=function(){return(Y._OrtAddSessionConfigEntry=Y.asm.U).apply(null,arguments)},Y._OrtReleaseSessionOptions=function(){return(Y._OrtReleaseSessionOptions=Y.asm.V).apply(null,arguments)},Y._OrtCreateSession=function(){return(Y._OrtCreateSession=Y.asm.W).apply(null,arguments)},Y._OrtReleaseSession=function(){return(Y._OrtReleaseSession=Y.asm.X).apply(null,arguments)},Y._OrtGetInputCount=function(){return(Y._OrtGetInputCount=Y.asm.Y).apply(null,arguments)},Y._OrtGetOutputCount=function(){return(Y._OrtGetOutputCount=Y.asm.Z).apply(null,arguments)},Y._OrtGetInputName=function(){return(Y._OrtGetInputName=Y.asm._).apply(null,arguments)},Y._OrtGetOutputName=function(){return(Y._OrtGetOutputName=Y.asm.$).apply(null,arguments)},Y._OrtFree=function(){return(Y._OrtFree=Y.asm.aa).apply(null,arguments)},Y._OrtCreateTensor=function(){return(Y._OrtCreateTensor=Y.asm.ba).apply(null,arguments)},Y._OrtGetTensorData=function(){return(Y._OrtGetTensorData=Y.asm.ca).apply(null,arguments)},Y._OrtReleaseTensor=function(){return(Y._OrtReleaseTensor=Y.asm.da).apply(null,arguments)},Y._OrtCreateRunOptions=function(){return(Y._OrtCreateRunOptions=Y.asm.ea).apply(null,arguments)},Y._OrtAddRunConfigEntry=function(){return(Y._OrtAddRunConfigEntry=Y.asm.fa).apply(null,arguments)},Y._OrtReleaseRunOptions=function(){return(Y._OrtReleaseRunOptions=Y.asm.ga).apply(null,arguments)},Y._OrtRun=function(){return(Y._OrtRun=Y.asm.ha).apply(null,arguments)},Y._OrtEndProfiling=function(){return(Y._OrtEndProfiling=Y.asm.ia).apply(null,arguments)};var Ft=Y._malloc=function(){return(Ft=Y._malloc=Y.asm.ja).apply(null,arguments)};Y._free=function(){return(Y._free=Y.asm.ka).apply(null,arguments)};var zt,he=Y.stackSave=function(){return(he=Y.stackSave=Y.asm.ma).apply(null,arguments)},Kt=Y.stackRestore=function(){return(Kt=Y.stackRestore=Y.asm.na).apply(null,arguments)},Xt=Y.stackAlloc=function(){return(Xt=Y.stackAlloc=Y.asm.oa).apply(null,arguments)};function Nt(){function yt(){if(!zt&&(zt=!0,Y.calledRun=!0,!vt)){if(ye(Bt),tt(Y),Y.onRuntimeInitialized&&Y.onRuntimeInitialized(),Y.postRun)for(typeof Y.postRun=="function"&&(Y.postRun=[Y.postRun]);Y.postRun.length;){var St=Y.postRun.shift();ee.unshift(St)}ye(ee)}}if(!(0<ae)){if(Y.preRun)for(typeof Y.preRun=="function"&&(Y.preRun=[Y.preRun]);Y.preRun.length;)ne();ye(Jt),0<ae||(Y.setStatus?(Y.setStatus("Running..."),setTimeout(function(){setTimeout(function(){Y.setStatus("")},1),yt()},1)):yt())}}if(Y.___cxa_is_pointer_type=function(){return(Y.___cxa_is_pointer_type=Y.asm.pa).apply(null,arguments)},Y.UTF8ToString=kt,Y.stringToUTF8=function(yt,St,Dt){return Ht(yt,wt,St,Dt)},Y.lengthBytesUTF8=Mt,Y.stackSave=he,Y.stackRestore=Kt,Y.stackAlloc=Xt,Wt=function yt(){zt||Nt(),zt||(Wt=yt)},Y.preInit)for(typeof Y.preInit=="function"&&(Y.preInit=[Y.preInit]);0<Y.preInit.length;)Y.preInit.pop()();return Nt(),Q.ready});it.exports=K},4537:it=>{it.exports=function(F,W){for(var X=new Array(arguments.length-1),K=0,Q=2,Y=!0;Q<arguments.length;)X[K++]=arguments[Q++];return new Promise(function(tt,et){X[K]=function(q){if(Y)if(Y=!1,q)et(q);else{for(var G=new Array(arguments.length-1),O=0;O<G.length;)G[O++]=arguments[O];tt.apply(null,G)}};try{F.apply(W||null,X)}catch(q){Y&&(Y=!1,et(q))}})}},7419:(it,F)=>{var W=F;W.length=function(tt){var et=tt.length;if(!et)return 0;for(var q=0;--et%4>1&&tt.charAt(et)==="=";)++q;return Math.ceil(3*tt.length)/4-q};for(var X=new Array(64),K=new Array(123),Q=0;Q<64;)K[X[Q]=Q<26?Q+65:Q<52?Q+71:Q<62?Q-4:Q-59|43]=Q++;W.encode=function(tt,et,q){for(var G,O=null,b=[],j=0,U=0;et<q;){var J=tt[et++];switch(U){case 0:b[j++]=X[J>>2],G=(3&J)<<4,U=1;break;case 1:b[j++]=X[G|J>>4],G=(15&J)<<2,U=2;break;case 2:b[j++]=X[G|J>>6],b[j++]=X[63&J],U=0}j>8191&&((O||(O=[])).push(String.fromCharCode.apply(String,b)),j=0)}return U&&(b[j++]=X[G],b[j++]=61,U===1&&(b[j++]=61)),O?(j&&O.push(String.fromCharCode.apply(String,b.slice(0,j))),O.join("")):String.fromCharCode.apply(String,b.slice(0,j))};var Y="invalid encoding";W.decode=function(tt,et,q){for(var G,O=q,b=0,j=0;j<tt.length;){var U=tt.charCodeAt(j++);if(U===61&&b>1)break;if((U=K[U])===void 0)throw Error(Y);switch(b){case 0:G=U,b=1;break;case 1:et[q++]=G<<2|(48&U)>>4,G=U,b=2;break;case 2:et[q++]=(15&G)<<4|(60&U)>>2,G=U,b=3;break;case 3:et[q++]=(3&G)<<6|U,b=0}}if(b===1)throw Error(Y);return q-O},W.test=function(tt){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(tt)}},9211:it=>{function F(){this._listeners={}}it.exports=F,F.prototype.on=function(W,X,K){return(this._listeners[W]||(this._listeners[W]=[])).push({fn:X,ctx:K||this}),this},F.prototype.off=function(W,X){if(W===void 0)this._listeners={};else if(X===void 0)this._listeners[W]=[];else for(var K=this._listeners[W],Q=0;Q<K.length;)K[Q].fn===X?K.splice(Q,1):++Q;return this},F.prototype.emit=function(W){var X=this._listeners[W];if(X){for(var K=[],Q=1;Q<arguments.length;)K.push(arguments[Q++]);for(Q=0;Q<X.length;)X[Q].fn.apply(X[Q++].ctx,K)}return this}},945:it=>{function F(Y){return typeof Float32Array<"u"?function(){var tt=new Float32Array([-0]),et=new Uint8Array(tt.buffer),q=et[3]===128;function G(U,J,nt){tt[0]=U,J[nt]=et[0],J[nt+1]=et[1],J[nt+2]=et[2],J[nt+3]=et[3]}function O(U,J,nt){tt[0]=U,J[nt]=et[3],J[nt+1]=et[2],J[nt+2]=et[1],J[nt+3]=et[0]}function b(U,J){return et[0]=U[J],et[1]=U[J+1],et[2]=U[J+2],et[3]=U[J+3],tt[0]}function j(U,J){return et[3]=U[J],et[2]=U[J+1],et[1]=U[J+2],et[0]=U[J+3],tt[0]}Y.writeFloatLE=q?G:O,Y.writeFloatBE=q?O:G,Y.readFloatLE=q?b:j,Y.readFloatBE=q?j:b}():function(){function tt(q,G,O,b){var j=G<0?1:0;if(j&&(G=-G),G===0)q(1/G>0?0:2147483648,O,b);else if(isNaN(G))q(2143289344,O,b);else if(G>34028234663852886e22)q((j<<31|2139095040)>>>0,O,b);else if(G<11754943508222875e-54)q((j<<31|Math.round(G/1401298464324817e-60))>>>0,O,b);else{var U=Math.floor(Math.log(G)/Math.LN2);q((j<<31|U+127<<23|8388607&Math.round(G*Math.pow(2,-U)*8388608))>>>0,O,b)}}function et(q,G,O){var b=q(G,O),j=2*(b>>31)+1,U=b>>>23&255,J=8388607&b;return U===255?J?NaN:j*(1/0):U===0?1401298464324817e-60*j*J:j*Math.pow(2,U-150)*(J+8388608)}Y.writeFloatLE=tt.bind(null,W),Y.writeFloatBE=tt.bind(null,X),Y.readFloatLE=et.bind(null,K),Y.readFloatBE=et.bind(null,Q)}(),typeof Float64Array<"u"?function(){var tt=new Float64Array([-0]),et=new Uint8Array(tt.buffer),q=et[7]===128;function G(U,J,nt){tt[0]=U,J[nt]=et[0],J[nt+1]=et[1],J[nt+2]=et[2],J[nt+3]=et[3],J[nt+4]=et[4],J[nt+5]=et[5],J[nt+6]=et[6],J[nt+7]=et[7]}function O(U,J,nt){tt[0]=U,J[nt]=et[7],J[nt+1]=et[6],J[nt+2]=et[5],J[nt+3]=et[4],J[nt+4]=et[3],J[nt+5]=et[2],J[nt+6]=et[1],J[nt+7]=et[0]}function b(U,J){return et[0]=U[J],et[1]=U[J+1],et[2]=U[J+2],et[3]=U[J+3],et[4]=U[J+4],et[5]=U[J+5],et[6]=U[J+6],et[7]=U[J+7],tt[0]}function j(U,J){return et[7]=U[J],et[6]=U[J+1],et[5]=U[J+2],et[4]=U[J+3],et[3]=U[J+4],et[2]=U[J+5],et[1]=U[J+6],et[0]=U[J+7],tt[0]}Y.writeDoubleLE=q?G:O,Y.writeDoubleBE=q?O:G,Y.readDoubleLE=q?b:j,Y.readDoubleBE=q?j:b}():function(){function tt(q,G,O,b,j,U){var J=b<0?1:0;if(J&&(b=-b),b===0)q(0,j,U+G),q(1/b>0?0:2147483648,j,U+O);else if(isNaN(b))q(0,j,U+G),q(2146959360,j,U+O);else if(b>17976931348623157e292)q(0,j,U+G),q((J<<31|2146435072)>>>0,j,U+O);else{var nt;if(b<22250738585072014e-324)q((nt=b/5e-324)>>>0,j,U+G),q((J<<31|nt/4294967296)>>>0,j,U+O);else{var rt=Math.floor(Math.log(b)/Math.LN2);rt===1024&&(rt=1023),q(4503599627370496*(nt=b*Math.pow(2,-rt))>>>0,j,U+G),q((J<<31|rt+1023<<20|1048576*nt&1048575)>>>0,j,U+O)}}}function et(q,G,O,b,j){var U=q(b,j+G),J=q(b,j+O),nt=2*(J>>31)+1,rt=J>>>20&2047,ot=4294967296*(1048575&J)+U;return rt===2047?ot?NaN:nt*(1/0):rt===0?5e-324*nt*ot:nt*Math.pow(2,rt-1075)*(ot+4503599627370496)}Y.writeDoubleLE=tt.bind(null,W,0,4),Y.writeDoubleBE=tt.bind(null,X,4,0),Y.readDoubleLE=et.bind(null,K,0,4),Y.readDoubleBE=et.bind(null,Q,4,0)}(),Y}function W(Y,tt,et){tt[et]=255&Y,tt[et+1]=Y>>>8&255,tt[et+2]=Y>>>16&255,tt[et+3]=Y>>>24}function X(Y,tt,et){tt[et]=Y>>>24,tt[et+1]=Y>>>16&255,tt[et+2]=Y>>>8&255,tt[et+3]=255&Y}function K(Y,tt){return(Y[tt]|Y[tt+1]<<8|Y[tt+2]<<16|Y[tt+3]<<24)>>>0}function Q(Y,tt){return(Y[tt]<<24|Y[tt+1]<<16|Y[tt+2]<<8|Y[tt+3])>>>0}it.exports=F(F)},7199:module=>{function inquire(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(it){}return null}module.exports=inquire},6662:it=>{it.exports=function(F,W,X){var K=X||8192,Q=K>>>1,Y=null,tt=K;return function(et){if(et<1||et>Q)return F(et);tt+et>K&&(Y=F(K),tt=0);var q=W.call(Y,tt,tt+=et);return 7&tt&&(tt=1+(7|tt)),q}}},4997:(it,F)=>{var W=F;W.length=function(X){for(var K=0,Q=0,Y=0;Y<X.length;++Y)(Q=X.charCodeAt(Y))<128?K+=1:Q<2048?K+=2:(64512&Q)==55296&&(64512&X.charCodeAt(Y+1))==56320?(++Y,K+=4):K+=3;return K},W.read=function(X,K,Q){if(Q-K<1)return"";for(var Y,tt=null,et=[],q=0;K<Q;)(Y=X[K++])<128?et[q++]=Y:Y>191&&Y<224?et[q++]=(31&Y)<<6|63&X[K++]:Y>239&&Y<365?(Y=((7&Y)<<18|(63&X[K++])<<12|(63&X[K++])<<6|63&X[K++])-65536,et[q++]=55296+(Y>>10),et[q++]=56320+(1023&Y)):et[q++]=(15&Y)<<12|(63&X[K++])<<6|63&X[K++],q>8191&&((tt||(tt=[])).push(String.fromCharCode.apply(String,et)),q=0);return tt?(q&&tt.push(String.fromCharCode.apply(String,et.slice(0,q))),tt.join("")):String.fromCharCode.apply(String,et.slice(0,q))},W.write=function(X,K,Q){for(var Y,tt,et=Q,q=0;q<X.length;++q)(Y=X.charCodeAt(q))<128?K[Q++]=Y:Y<2048?(K[Q++]=Y>>6|192,K[Q++]=63&Y|128):(64512&Y)==55296&&(64512&(tt=X.charCodeAt(q+1)))==56320?(Y=65536+((1023&Y)<<10)+(1023&tt),++q,K[Q++]=Y>>18|240,K[Q++]=Y>>12&63|128,K[Q++]=Y>>6&63|128,K[Q++]=63&Y|128):(K[Q++]=Y>>12|224,K[Q++]=Y>>6&63|128,K[Q++]=63&Y|128);return Q-et}},3442:(it,F)=>{F.__esModule=!0;var W=function(){function X(K){if(!K)throw new TypeError("Invalid argument; `value` has no value.");this.value=X.EMPTY,K&&X.isGuid(K)&&(this.value=K)}return X.isGuid=function(K){var Q=K.toString();return K&&(K instanceof X||X.validator.test(Q))},X.create=function(){return new X([X.gen(2),X.gen(1),X.gen(1),X.gen(1),X.gen(3)].join("-"))},X.createEmpty=function(){return new X("emptyguid")},X.parse=function(K){return new X(K)},X.raw=function(){return[X.gen(2),X.gen(1),X.gen(1),X.gen(1),X.gen(3)].join("-")},X.gen=function(K){for(var Q="",Y=0;Y<K;Y++)Q+=(65536*(1+Math.random())|0).toString(16).substring(1);return Q},X.prototype.equals=function(K){return X.isGuid(K)&&this.value===K.toString()},X.prototype.isEmpty=function(){return this.value===X.EMPTY},X.prototype.toString=function(){return this.value},X.prototype.toJSON=function(){return{value:this.value}},X.validator=new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$","i"),X.EMPTY="00000000-0000-0000-0000-000000000000",X}();F.Guid=W},3720:it=>{it.exports=W;var F=null;try{F=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function W(lt,ft,gt){this.low=0|lt,this.high=0|ft,this.unsigned=!!gt}function X(lt){return(lt&&lt.__isLong__)===!0}W.prototype.__isLong__,Object.defineProperty(W.prototype,"__isLong__",{value:!0}),W.isLong=X;var K={},Q={};function Y(lt,ft){var gt,_t,wt;return ft?(wt=0<=(lt>>>=0)&&lt<256)&&(_t=Q[lt])?_t:(gt=et(lt,(0|lt)<0?-1:0,!0),wt&&(Q[lt]=gt),gt):(wt=-128<=(lt|=0)&&lt<128)&&(_t=K[lt])?_t:(gt=et(lt,lt<0?-1:0,!1),wt&&(K[lt]=gt),gt)}function tt(lt,ft){if(isNaN(lt))return ft?rt:nt;if(ft){if(lt<0)return rt;if(lt>=j)return ct}else{if(lt<=-U)return dt;if(lt+1>=U)return st}return lt<0?tt(-lt,ft).neg():et(lt%b|0,lt/b|0,ft)}function et(lt,ft,gt){return new W(lt,ft,gt)}W.fromInt=Y,W.fromNumber=tt,W.fromBits=et;var q=Math.pow;function G(lt,ft,gt){if(lt.length===0)throw Error("empty string");if(lt==="NaN"||lt==="Infinity"||lt==="+Infinity"||lt==="-Infinity")return nt;if(typeof ft=="number"?(gt=ft,ft=!1):ft=!!ft,(gt=gt||10)<2||36<gt)throw RangeError("radix");var _t;if((_t=lt.indexOf("-"))>0)throw Error("interior hyphen");if(_t===0)return G(lt.substring(1),ft,gt).neg();for(var wt=tt(q(gt,8)),bt=nt,Ot=0;Ot<lt.length;Ot+=8){var vt=Math.min(8,lt.length-Ot),xt=parseInt(lt.substring(Ot,Ot+vt),gt);if(vt<8){var Rt=tt(q(gt,vt));bt=bt.mul(Rt).add(tt(xt))}else bt=(bt=bt.mul(wt)).add(tt(xt))}return bt.unsigned=ft,bt}function O(lt,ft){return typeof lt=="number"?tt(lt,ft):typeof lt=="string"?G(lt,ft):et(lt.low,lt.high,typeof ft=="boolean"?ft:lt.unsigned)}W.fromString=G,W.fromValue=O;var b=4294967296,j=b*b,U=j/2,J=Y(1<<24),nt=Y(0);W.ZERO=nt;var rt=Y(0,!0);W.UZERO=rt;var ot=Y(1);W.ONE=ot;var at=Y(1,!0);W.UONE=at;var ut=Y(-1);W.NEG_ONE=ut;var st=et(-1,2147483647,!1);W.MAX_VALUE=st;var ct=et(-1,-1,!0);W.MAX_UNSIGNED_VALUE=ct;var dt=et(0,-2147483648,!1);W.MIN_VALUE=dt;var pt=W.prototype;pt.toInt=function(){return this.unsigned?this.low>>>0:this.low},pt.toNumber=function(){return this.unsigned?(this.high>>>0)*b+(this.low>>>0):this.high*b+(this.low>>>0)},pt.toString=function(lt){if((lt=lt||10)<2||36<lt)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(dt)){var ft=tt(lt),gt=this.div(ft),_t=gt.mul(ft).sub(this);return gt.toString(lt)+_t.toInt().toString(lt)}return"-"+this.neg().toString(lt)}for(var wt=tt(q(lt,6),this.unsigned),bt=this,Ot="";;){var vt=bt.div(wt),xt=(bt.sub(vt.mul(wt)).toInt()>>>0).toString(lt);if((bt=vt).isZero())return xt+Ot;for(;xt.length<6;)xt="0"+xt;Ot=""+xt+Ot}},pt.getHighBits=function(){return this.high},pt.getHighBitsUnsigned=function(){return this.high>>>0},pt.getLowBits=function(){return this.low},pt.getLowBitsUnsigned=function(){return this.low>>>0},pt.getNumBitsAbs=function(){if(this.isNegative())return this.eq(dt)?64:this.neg().getNumBitsAbs();for(var lt=this.high!=0?this.high:this.low,ft=31;ft>0&&!(lt&1<<ft);ft--);return this.high!=0?ft+33:ft+1},pt.isZero=function(){return this.high===0&&this.low===0},pt.eqz=pt.isZero,pt.isNegative=function(){return!this.unsigned&&this.high<0},pt.isPositive=function(){return this.unsigned||this.high>=0},pt.isOdd=function(){return(1&this.low)==1},pt.isEven=function(){return(1&this.low)==0},pt.equals=function(lt){return X(lt)||(lt=O(lt)),(this.unsigned===lt.unsigned||this.high>>>31!=1||lt.high>>>31!=1)&&this.high===lt.high&&this.low===lt.low},pt.eq=pt.equals,pt.notEquals=function(lt){return!this.eq(lt)},pt.neq=pt.notEquals,pt.ne=pt.notEquals,pt.lessThan=function(lt){return this.comp(lt)<0},pt.lt=pt.lessThan,pt.lessThanOrEqual=function(lt){return this.comp(lt)<=0},pt.lte=pt.lessThanOrEqual,pt.le=pt.lessThanOrEqual,pt.greaterThan=function(lt){return this.comp(lt)>0},pt.gt=pt.greaterThan,pt.greaterThanOrEqual=function(lt){return this.comp(lt)>=0},pt.gte=pt.greaterThanOrEqual,pt.ge=pt.greaterThanOrEqual,pt.compare=function(lt){if(X(lt)||(lt=O(lt)),this.eq(lt))return 0;var ft=this.isNegative(),gt=lt.isNegative();return ft&&!gt?-1:!ft&&gt?1:this.unsigned?lt.high>>>0>this.high>>>0||lt.high===this.high&&lt.low>>>0>this.low>>>0?-1:1:this.sub(lt).isNegative()?-1:1},pt.comp=pt.compare,pt.negate=function(){return!this.unsigned&&this.eq(dt)?dt:this.not().add(ot)},pt.neg=pt.negate,pt.add=function(lt){X(lt)||(lt=O(lt));var ft=this.high>>>16,gt=65535&this.high,_t=this.low>>>16,wt=65535&this.low,bt=lt.high>>>16,Ot=65535&lt.high,vt=lt.low>>>16,xt=0,Rt=0,kt=0,Ht=0;return kt+=(Ht+=wt+(65535&lt.low))>>>16,Rt+=(kt+=_t+vt)>>>16,xt+=(Rt+=gt+Ot)>>>16,xt+=ft+bt,et((kt&=65535)<<16|(Ht&=65535),(xt&=65535)<<16|(Rt&=65535),this.unsigned)},pt.subtract=function(lt){return X(lt)||(lt=O(lt)),this.add(lt.neg())},pt.sub=pt.subtract,pt.multiply=function(lt){if(this.isZero())return nt;if(X(lt)||(lt=O(lt)),F)return et(F.mul(this.low,this.high,lt.low,lt.high),F.get_high(),this.unsigned);if(lt.isZero())return nt;if(this.eq(dt))return lt.isOdd()?dt:nt;if(lt.eq(dt))return this.isOdd()?dt:nt;if(this.isNegative())return lt.isNegative()?this.neg().mul(lt.neg()):this.neg().mul(lt).neg();if(lt.isNegative())return this.mul(lt.neg()).neg();if(this.lt(J)&&lt.lt(J))return tt(this.toNumber()*lt.toNumber(),this.unsigned);var ft=this.high>>>16,gt=65535&this.high,_t=this.low>>>16,wt=65535&this.low,bt=lt.high>>>16,Ot=65535&lt.high,vt=lt.low>>>16,xt=65535&lt.low,Rt=0,kt=0,Ht=0,Mt=0;return Ht+=(Mt+=wt*xt)>>>16,kt+=(Ht+=_t*xt)>>>16,Ht&=65535,kt+=(Ht+=wt*vt)>>>16,Rt+=(kt+=gt*xt)>>>16,kt&=65535,Rt+=(kt+=_t*vt)>>>16,kt&=65535,Rt+=(kt+=wt*Ot)>>>16,Rt+=ft*xt+gt*vt+_t*Ot+wt*bt,et((Ht&=65535)<<16|(Mt&=65535),(Rt&=65535)<<16|(kt&=65535),this.unsigned)},pt.mul=pt.multiply,pt.divide=function(lt){if(X(lt)||(lt=O(lt)),lt.isZero())throw Error("division by zero");var ft,gt,_t;if(F)return this.unsigned||this.high!==-2147483648||lt.low!==-1||lt.high!==-1?et((this.unsigned?F.div_u:F.div_s)(this.low,this.high,lt.low,lt.high),F.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?rt:nt;if(this.unsigned){if(lt.unsigned||(lt=lt.toUnsigned()),lt.gt(this))return rt;if(lt.gt(this.shru(1)))return at;_t=rt}else{if(this.eq(dt))return lt.eq(ot)||lt.eq(ut)?dt:lt.eq(dt)?ot:(ft=this.shr(1).div(lt).shl(1)).eq(nt)?lt.isNegative()?ot:ut:(gt=this.sub(lt.mul(ft)),_t=ft.add(gt.div(lt)));if(lt.eq(dt))return this.unsigned?rt:nt;if(this.isNegative())return lt.isNegative()?this.neg().div(lt.neg()):this.neg().div(lt).neg();if(lt.isNegative())return this.div(lt.neg()).neg();_t=nt}for(gt=this;gt.gte(lt);){ft=Math.max(1,Math.floor(gt.toNumber()/lt.toNumber()));for(var wt=Math.ceil(Math.log(ft)/Math.LN2),bt=wt<=48?1:q(2,wt-48),Ot=tt(ft),vt=Ot.mul(lt);vt.isNegative()||vt.gt(gt);)vt=(Ot=tt(ft-=bt,this.unsigned)).mul(lt);Ot.isZero()&&(Ot=ot),_t=_t.add(Ot),gt=gt.sub(vt)}return _t},pt.div=pt.divide,pt.modulo=function(lt){return X(lt)||(lt=O(lt)),F?et((this.unsigned?F.rem_u:F.rem_s)(this.low,this.high,lt.low,lt.high),F.get_high(),this.unsigned):this.sub(this.div(lt).mul(lt))},pt.mod=pt.modulo,pt.rem=pt.modulo,pt.not=function(){return et(~this.low,~this.high,this.unsigned)},pt.and=function(lt){return X(lt)||(lt=O(lt)),et(this.low&lt.low,this.high&lt.high,this.unsigned)},pt.or=function(lt){return X(lt)||(lt=O(lt)),et(this.low|lt.low,this.high|lt.high,this.unsigned)},pt.xor=function(lt){return X(lt)||(lt=O(lt)),et(this.low^lt.low,this.high^lt.high,this.unsigned)},pt.shiftLeft=function(lt){return X(lt)&&(lt=lt.toInt()),(lt&=63)==0?this:lt<32?et(this.low<<lt,this.high<<lt|this.low>>>32-lt,this.unsigned):et(0,this.low<<lt-32,this.unsigned)},pt.shl=pt.shiftLeft,pt.shiftRight=function(lt){return X(lt)&&(lt=lt.toInt()),(lt&=63)==0?this:lt<32?et(this.low>>>lt|this.high<<32-lt,this.high>>lt,this.unsigned):et(this.high>>lt-32,this.high>=0?0:-1,this.unsigned)},pt.shr=pt.shiftRight,pt.shiftRightUnsigned=function(lt){if(X(lt)&&(lt=lt.toInt()),(lt&=63)==0)return this;var ft=this.high;return lt<32?et(this.low>>>lt|ft<<32-lt,ft>>>lt,this.unsigned):et(lt===32?ft:ft>>>lt-32,0,this.unsigned)},pt.shru=pt.shiftRightUnsigned,pt.shr_u=pt.shiftRightUnsigned,pt.toSigned=function(){return this.unsigned?et(this.low,this.high,!1):this},pt.toUnsigned=function(){return this.unsigned?this:et(this.low,this.high,!0)},pt.toBytes=function(lt){return lt?this.toBytesLE():this.toBytesBE()},pt.toBytesLE=function(){var lt=this.high,ft=this.low;return[255&ft,ft>>>8&255,ft>>>16&255,ft>>>24,255&lt,lt>>>8&255,lt>>>16&255,lt>>>24]},pt.toBytesBE=function(){var lt=this.high,ft=this.low;return[lt>>>24,lt>>>16&255,lt>>>8&255,255&lt,ft>>>24,ft>>>16&255,ft>>>8&255,255&ft]},W.fromBytes=function(lt,ft,gt){return gt?W.fromBytesLE(lt,ft):W.fromBytesBE(lt,ft)},W.fromBytesLE=function(lt,ft){return new W(lt[0]|lt[1]<<8|lt[2]<<16|lt[3]<<24,lt[4]|lt[5]<<8|lt[6]<<16|lt[7]<<24,ft)},W.fromBytesBE=function(lt,ft){return new W(lt[4]<<24|lt[5]<<16|lt[6]<<8|lt[7],lt[0]<<24|lt[1]<<16|lt[2]<<8|lt[3],ft)}},1446:(it,F,W)=>{var X,K,Q,Y=W(2100),tt=Y.Reader,et=Y.Writer,q=Y.util,G=Y.roots.default||(Y.roots.default={});G.onnx=((Q={}).Version=(X={},(K=Object.create(X))[X[0]="_START_VERSION"]=0,K[X[1]="IR_VERSION_2017_10_10"]=1,K[X[2]="IR_VERSION_2017_10_30"]=2,K[X[3]="IR_VERSION_2017_11_3"]=3,K[X[4]="IR_VERSION_2019_1_22"]=4,K[X[5]="IR_VERSION"]=5,K),Q.AttributeProto=function(){function O(b){if(this.floats=[],this.ints=[],this.strings=[],this.tensors=[],this.graphs=[],b)for(var j=Object.keys(b),U=0;U<j.length;++U)b[j[U]]!=null&&(this[j[U]]=b[j[U]])}return O.prototype.name="",O.prototype.refAttrName="",O.prototype.docString="",O.prototype.type=0,O.prototype.f=0,O.prototype.i=q.Long?q.Long.fromBits(0,0,!1):0,O.prototype.s=q.newBuffer([]),O.prototype.t=null,O.prototype.g=null,O.prototype.floats=q.emptyArray,O.prototype.ints=q.emptyArray,O.prototype.strings=q.emptyArray,O.prototype.tensors=q.emptyArray,O.prototype.graphs=q.emptyArray,O.create=function(b){return new O(b)},O.encode=function(b,j){if(j||(j=et.create()),b.name!=null&&b.hasOwnProperty("name")&&j.uint32(10).string(b.name),b.f!=null&&b.hasOwnProperty("f")&&j.uint32(21).float(b.f),b.i!=null&&b.hasOwnProperty("i")&&j.uint32(24).int64(b.i),b.s!=null&&b.hasOwnProperty("s")&&j.uint32(34).bytes(b.s),b.t!=null&&b.hasOwnProperty("t")&&G.onnx.TensorProto.encode(b.t,j.uint32(42).fork()).ldelim(),b.g!=null&&b.hasOwnProperty("g")&&G.onnx.GraphProto.encode(b.g,j.uint32(50).fork()).ldelim(),b.floats!=null&&b.floats.length){j.uint32(58).fork();for(var U=0;U<b.floats.length;++U)j.float(b.floats[U]);j.ldelim()}if(b.ints!=null&&b.ints.length){for(j.uint32(66).fork(),U=0;U<b.ints.length;++U)j.int64(b.ints[U]);j.ldelim()}if(b.strings!=null&&b.strings.length)for(U=0;U<b.strings.length;++U)j.uint32(74).bytes(b.strings[U]);if(b.tensors!=null&&b.tensors.length)for(U=0;U<b.tensors.length;++U)G.onnx.TensorProto.encode(b.tensors[U],j.uint32(82).fork()).ldelim();if(b.graphs!=null&&b.graphs.length)for(U=0;U<b.graphs.length;++U)G.onnx.GraphProto.encode(b.graphs[U],j.uint32(90).fork()).ldelim();return b.docString!=null&&b.hasOwnProperty("docString")&&j.uint32(106).string(b.docString),b.type!=null&&b.hasOwnProperty("type")&&j.uint32(160).int32(b.type),b.refAttrName!=null&&b.hasOwnProperty("refAttrName")&&j.uint32(170).string(b.refAttrName),j},O.encodeDelimited=function(b,j){return this.encode(b,j).ldelim()},O.decode=function(b,j){b instanceof tt||(b=tt.create(b));for(var U=j===void 0?b.len:b.pos+j,J=new G.onnx.AttributeProto;b.pos<U;){var nt=b.uint32();switch(nt>>>3){case 1:J.name=b.string();break;case 21:J.refAttrName=b.string();break;case 13:J.docString=b.string();break;case 20:J.type=b.int32();break;case 2:J.f=b.float();break;case 3:J.i=b.int64();break;case 4:J.s=b.bytes();break;case 5:J.t=G.onnx.TensorProto.decode(b,b.uint32());break;case 6:J.g=G.onnx.GraphProto.decode(b,b.uint32());break;case 7:if(J.floats&&J.floats.length||(J.floats=[]),(7&nt)==2)for(var rt=b.uint32()+b.pos;b.pos<rt;)J.floats.push(b.float());else J.floats.push(b.float());break;case 8:if(J.ints&&J.ints.length||(J.ints=[]),(7&nt)==2)for(rt=b.uint32()+b.pos;b.pos<rt;)J.ints.push(b.int64());else J.ints.push(b.int64());break;case 9:J.strings&&J.strings.length||(J.strings=[]),J.strings.push(b.bytes());break;case 10:J.tensors&&J.tensors.length||(J.tensors=[]),J.tensors.push(G.onnx.TensorProto.decode(b,b.uint32()));break;case 11:J.graphs&&J.graphs.length||(J.graphs=[]),J.graphs.push(G.onnx.GraphProto.decode(b,b.uint32()));break;default:b.skipType(7&nt)}}return J},O.decodeDelimited=function(b){return b instanceof tt||(b=new tt(b)),this.decode(b,b.uint32())},O.verify=function(b){if(typeof b!="object"||b===null)return"object expected";if(b.name!=null&&b.hasOwnProperty("name")&&!q.isString(b.name))return"name: string expected";if(b.refAttrName!=null&&b.hasOwnProperty("refAttrName")&&!q.isString(b.refAttrName))return"refAttrName: string expected";if(b.docString!=null&&b.hasOwnProperty("docString")&&!q.isString(b.docString))return"docString: string expected";if(b.type!=null&&b.hasOwnProperty("type"))switch(b.type){default:return"type: enum value expected";case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:}if(b.f!=null&&b.hasOwnProperty("f")&&typeof b.f!="number")return"f: number expected";if(b.i!=null&&b.hasOwnProperty("i")&&!(q.isInteger(b.i)||b.i&&q.isInteger(b.i.low)&&q.isInteger(b.i.high)))return"i: integer|Long expected";if(b.s!=null&&b.hasOwnProperty("s")&&!(b.s&&typeof b.s.length=="number"||q.isString(b.s)))return"s: buffer expected";if(b.t!=null&&b.hasOwnProperty("t")&&(U=G.onnx.TensorProto.verify(b.t)))return"t."+U;if(b.g!=null&&b.hasOwnProperty("g")&&(U=G.onnx.GraphProto.verify(b.g)))return"g."+U;if(b.floats!=null&&b.hasOwnProperty("floats")){if(!Array.isArray(b.floats))return"floats: array expected";for(var j=0;j<b.floats.length;++j)if(typeof b.floats[j]!="number")return"floats: number[] expected"}if(b.ints!=null&&b.hasOwnProperty("ints")){if(!Array.isArray(b.ints))return"ints: array expected";for(j=0;j<b.ints.length;++j)if(!(q.isInteger(b.ints[j])||b.ints[j]&&q.isInteger(b.ints[j].low)&&q.isInteger(b.ints[j].high)))return"ints: integer|Long[] expected"}if(b.strings!=null&&b.hasOwnProperty("strings")){if(!Array.isArray(b.strings))return"strings: array expected";for(j=0;j<b.strings.length;++j)if(!(b.strings[j]&&typeof b.strings[j].length=="number"||q.isString(b.strings[j])))return"strings: buffer[] expected"}if(b.tensors!=null&&b.hasOwnProperty("tensors")){if(!Array.isArray(b.tensors))return"tensors: array expected";for(j=0;j<b.tensors.length;++j)if(U=G.onnx.TensorProto.verify(b.tensors[j]))return"tensors."+U}if(b.graphs!=null&&b.hasOwnProperty("graphs")){if(!Array.isArray(b.graphs))return"graphs: array expected";for(j=0;j<b.graphs.length;++j){var U;if(U=G.onnx.GraphProto.verify(b.graphs[j]))return"graphs."+U}}return null},O.fromObject=function(b){if(b instanceof G.onnx.AttributeProto)return b;var j=new G.onnx.AttributeProto;switch(b.name!=null&&(j.name=String(b.name)),b.refAttrName!=null&&(j.refAttrName=String(b.refAttrName)),b.docString!=null&&(j.docString=String(b.docString)),b.type){case"UNDEFINED":case 0:j.type=0;break;case"FLOAT":case 1:j.type=1;break;case"INT":case 2:j.type=2;break;case"STRING":case 3:j.type=3;break;case"TENSOR":case 4:j.type=4;break;case"GRAPH":case 5:j.type=5;break;case"FLOATS":case 6:j.type=6;break;case"INTS":case 7:j.type=7;break;case"STRINGS":case 8:j.type=8;break;case"TENSORS":case 9:j.type=9;break;case"GRAPHS":case 10:j.type=10}if(b.f!=null&&(j.f=Number(b.f)),b.i!=null&&(q.Long?(j.i=q.Long.fromValue(b.i)).unsigned=!1:typeof b.i=="string"?j.i=parseInt(b.i,10):typeof b.i=="number"?j.i=b.i:typeof b.i=="object"&&(j.i=new q.LongBits(b.i.low>>>0,b.i.high>>>0).toNumber())),b.s!=null&&(typeof b.s=="string"?q.base64.decode(b.s,j.s=q.newBuffer(q.base64.length(b.s)),0):b.s.length&&(j.s=b.s)),b.t!=null){if(typeof b.t!="object")throw TypeError(".onnx.AttributeProto.t: object expected");j.t=G.onnx.TensorProto.fromObject(b.t)}if(b.g!=null){if(typeof b.g!="object")throw TypeError(".onnx.AttributeProto.g: object expected");j.g=G.onnx.GraphProto.fromObject(b.g)}if(b.floats){if(!Array.isArray(b.floats))throw TypeError(".onnx.AttributeProto.floats: array expected");j.floats=[];for(var U=0;U<b.floats.length;++U)j.floats[U]=Number(b.floats[U])}if(b.ints){if(!Array.isArray(b.ints))throw TypeError(".onnx.AttributeProto.ints: array expected");for(j.ints=[],U=0;U<b.ints.length;++U)q.Long?(j.ints[U]=q.Long.fromValue(b.ints[U])).unsigned=!1:typeof b.ints[U]=="string"?j.ints[U]=parseInt(b.ints[U],10):typeof b.ints[U]=="number"?j.ints[U]=b.ints[U]:typeof b.ints[U]=="object"&&(j.ints[U]=new q.LongBits(b.ints[U].low>>>0,b.ints[U].high>>>0).toNumber())}if(b.strings){if(!Array.isArray(b.strings))throw TypeError(".onnx.AttributeProto.strings: array expected");for(j.strings=[],U=0;U<b.strings.length;++U)typeof b.strings[U]=="string"?q.base64.decode(b.strings[U],j.strings[U]=q.newBuffer(q.base64.length(b.strings[U])),0):b.strings[U].length&&(j.strings[U]=b.strings[U])}if(b.tensors){if(!Array.isArray(b.tensors))throw TypeError(".onnx.AttributeProto.tensors: array expected");for(j.tensors=[],U=0;U<b.tensors.length;++U){if(typeof b.tensors[U]!="object")throw TypeError(".onnx.AttributeProto.tensors: object expected");j.tensors[U]=G.onnx.TensorProto.fromObject(b.tensors[U])}}if(b.graphs){if(!Array.isArray(b.graphs))throw TypeError(".onnx.AttributeProto.graphs: array expected");for(j.graphs=[],U=0;U<b.graphs.length;++U){if(typeof b.graphs[U]!="object")throw TypeError(".onnx.AttributeProto.graphs: object expected");j.graphs[U]=G.onnx.GraphProto.fromObject(b.graphs[U])}}return j},O.toObject=function(b,j){j||(j={});var U={};if((j.arrays||j.defaults)&&(U.floats=[],U.ints=[],U.strings=[],U.tensors=[],U.graphs=[]),j.defaults){if(U.name="",U.f=0,q.Long){var J=new q.Long(0,0,!1);U.i=j.longs===String?J.toString():j.longs===Number?J.toNumber():J}else U.i=j.longs===String?"0":0;j.bytes===String?U.s="":(U.s=[],j.bytes!==Array&&(U.s=q.newBuffer(U.s))),U.t=null,U.g=null,U.docString="",U.type=j.enums===String?"UNDEFINED":0,U.refAttrName=""}if(b.name!=null&&b.hasOwnProperty("name")&&(U.name=b.name),b.f!=null&&b.hasOwnProperty("f")&&(U.f=j.json&&!isFinite(b.f)?String(b.f):b.f),b.i!=null&&b.hasOwnProperty("i")&&(typeof b.i=="number"?U.i=j.longs===String?String(b.i):b.i:U.i=j.longs===String?q.Long.prototype.toString.call(b.i):j.longs===Number?new q.LongBits(b.i.low>>>0,b.i.high>>>0).toNumber():b.i),b.s!=null&&b.hasOwnProperty("s")&&(U.s=j.bytes===String?q.base64.encode(b.s,0,b.s.length):j.bytes===Array?Array.prototype.slice.call(b.s):b.s),b.t!=null&&b.hasOwnProperty("t")&&(U.t=G.onnx.TensorProto.toObject(b.t,j)),b.g!=null&&b.hasOwnProperty("g")&&(U.g=G.onnx.GraphProto.toObject(b.g,j)),b.floats&&b.floats.length){U.floats=[];for(var nt=0;nt<b.floats.length;++nt)U.floats[nt]=j.json&&!isFinite(b.floats[nt])?String(b.floats[nt]):b.floats[nt]}if(b.ints&&b.ints.length)for(U.ints=[],nt=0;nt<b.ints.length;++nt)typeof b.ints[nt]=="number"?U.ints[nt]=j.longs===String?String(b.ints[nt]):b.ints[nt]:U.ints[nt]=j.longs===String?q.Long.prototype.toString.call(b.ints[nt]):j.longs===Number?new q.LongBits(b.ints[nt].low>>>0,b.ints[nt].high>>>0).toNumber():b.ints[nt];if(b.strings&&b.strings.length)for(U.strings=[],nt=0;nt<b.strings.length;++nt)U.strings[nt]=j.bytes===String?q.base64.encode(b.strings[nt],0,b.strings[nt].length):j.bytes===Array?Array.prototype.slice.call(b.strings[nt]):b.strings[nt];if(b.tensors&&b.tensors.length)for(U.tensors=[],nt=0;nt<b.tensors.length;++nt)U.tensors[nt]=G.onnx.TensorProto.toObject(b.tensors[nt],j);if(b.graphs&&b.graphs.length)for(U.graphs=[],nt=0;nt<b.graphs.length;++nt)U.graphs[nt]=G.onnx.GraphProto.toObject(b.graphs[nt],j);return b.docString!=null&&b.hasOwnProperty("docString")&&(U.docString=b.docString),b.type!=null&&b.hasOwnProperty("type")&&(U.type=j.enums===String?G.onnx.AttributeProto.AttributeType[b.type]:b.type),b.refAttrName!=null&&b.hasOwnProperty("refAttrName")&&(U.refAttrName=b.refAttrName),U},O.prototype.toJSON=function(){return this.constructor.toObject(this,Y.util.toJSONOptions)},O.AttributeType=function(){var b={},j=Object.create(b);return j[b[0]="UNDEFINED"]=0,j[b[1]="FLOAT"]=1,j[b[2]="INT"]=2,j[b[3]="STRING"]=3,j[b[4]="TENSOR"]=4,j[b[5]="GRAPH"]=5,j[b[6]="FLOATS"]=6,j[b[7]="INTS"]=7,j[b[8]="STRINGS"]=8,j[b[9]="TENSORS"]=9,j[b[10]="GRAPHS"]=10,j}(),O}(),Q.ValueInfoProto=function(){function O(b){if(b)for(var j=Object.keys(b),U=0;U<j.length;++U)b[j[U]]!=null&&(this[j[U]]=b[j[U]])}return O.prototype.name="",O.prototype.type=null,O.prototype.docString="",O.create=function(b){return new O(b)},O.encode=function(b,j){return j||(j=et.create()),b.name!=null&&b.hasOwnProperty("name")&&j.uint32(10).string(b.name),b.type!=null&&b.hasOwnProperty("type")&&G.onnx.TypeProto.encode(b.type,j.uint32(18).fork()).ldelim(),b.docString!=null&&b.hasOwnProperty("docString")&&j.uint32(26).string(b.docString),j},O.encodeDelimited=function(b,j){return this.encode(b,j).ldelim()},O.decode=function(b,j){b instanceof tt||(b=tt.create(b));for(var U=j===void 0?b.len:b.pos+j,J=new G.onnx.ValueInfoProto;b.pos<U;){var nt=b.uint32();switch(nt>>>3){case 1:J.name=b.string();break;case 2:J.type=G.onnx.TypeProto.decode(b,b.uint32());break;case 3:J.docString=b.string();break;default:b.skipType(7&nt)}}return J},O.decodeDelimited=function(b){return b instanceof tt||(b=new tt(b)),this.decode(b,b.uint32())},O.verify=function(b){if(typeof b!="object"||b===null)return"object expected";if(b.name!=null&&b.hasOwnProperty("name")&&!q.isString(b.name))return"name: string expected";if(b.type!=null&&b.hasOwnProperty("type")){var j=G.onnx.TypeProto.verify(b.type);if(j)return"type."+j}return b.docString!=null&&b.hasOwnProperty("docString")&&!q.isString(b.docString)?"docString: string expected":null},O.fromObject=function(b){if(b instanceof G.onnx.ValueInfoProto)return b;var j=new G.onnx.ValueInfoProto;if(b.name!=null&&(j.name=String(b.name)),b.type!=null){if(typeof b.type!="object")throw TypeError(".onnx.ValueInfoProto.type: object expected");j.type=G.onnx.TypeProto.fromObject(b.type)}return b.docString!=null&&(j.docString=String(b.docString)),j},O.toObject=function(b,j){j||(j={});var U={};return j.defaults&&(U.name="",U.type=null,U.docString=""),b.name!=null&&b.hasOwnProperty("name")&&(U.name=b.name),b.type!=null&&b.hasOwnProperty("type")&&(U.type=G.onnx.TypeProto.toObject(b.type,j)),b.docString!=null&&b.hasOwnProperty("docString")&&(U.docString=b.docString),U},O.prototype.toJSON=function(){return this.constructor.toObject(this,Y.util.toJSONOptions)},O}(),Q.NodeProto=function(){function O(b){if(this.input=[],this.output=[],this.attribute=[],b)for(var j=Object.keys(b),U=0;U<j.length;++U)b[j[U]]!=null&&(this[j[U]]=b[j[U]])}return O.prototype.input=q.emptyArray,O.prototype.output=q.emptyArray,O.prototype.name="",O.prototype.opType="",O.prototype.domain="",O.prototype.attribute=q.emptyArray,O.prototype.docString="",O.create=function(b){return new O(b)},O.encode=function(b,j){if(j||(j=et.create()),b.input!=null&&b.input.length)for(var U=0;U<b.input.length;++U)j.uint32(10).string(b.input[U]);if(b.output!=null&&b.output.length)for(U=0;U<b.output.length;++U)j.uint32(18).string(b.output[U]);if(b.name!=null&&b.hasOwnProperty("name")&&j.uint32(26).string(b.name),b.opType!=null&&b.hasOwnProperty("opType")&&j.uint32(34).string(b.opType),b.attribute!=null&&b.attribute.length)for(U=0;U<b.attribute.length;++U)G.onnx.AttributeProto.encode(b.attribute[U],j.uint32(42).fork()).ldelim();return b.docString!=null&&b.hasOwnProperty("docString")&&j.uint32(50).string(b.docString),b.domain!=null&&b.hasOwnProperty("domain")&&j.uint32(58).string(b.domain),j},O.encodeDelimited=function(b,j){return this.encode(b,j).ldelim()},O.decode=function(b,j){b instanceof tt||(b=tt.create(b));for(var U=j===void 0?b.len:b.pos+j,J=new G.onnx.NodeProto;b.pos<U;){var nt=b.uint32();switch(nt>>>3){case 1:J.input&&J.input.length||(J.input=[]),J.input.push(b.string());break;case 2:J.output&&J.output.length||(J.output=[]),J.output.push(b.string());break;case 3:J.name=b.string();break;case 4:J.opType=b.string();break;case 7:J.domain=b.string();break;case 5:J.attribute&&J.attribute.length||(J.attribute=[]),J.attribute.push(G.onnx.AttributeProto.decode(b,b.uint32()));break;case 6:J.docString=b.string();break;default:b.skipType(7&nt)}}return J},O.decodeDelimited=function(b){return b instanceof tt||(b=new tt(b)),this.decode(b,b.uint32())},O.verify=function(b){if(typeof b!="object"||b===null)return"object expected";if(b.input!=null&&b.hasOwnProperty("input")){if(!Array.isArray(b.input))return"input: array expected";for(var j=0;j<b.input.length;++j)if(!q.isString(b.input[j]))return"input: string[] expected"}if(b.output!=null&&b.hasOwnProperty("output")){if(!Array.isArray(b.output))return"output: array expected";for(j=0;j<b.output.length;++j)if(!q.isString(b.output[j]))return"output: string[] expected"}if(b.name!=null&&b.hasOwnProperty("name")&&!q.isString(b.name))return"name: string expected";if(b.opType!=null&&b.hasOwnProperty("opType")&&!q.isString(b.opType))return"opType: string expected";if(b.domain!=null&&b.hasOwnProperty("domain")&&!q.isString(b.domain))return"domain: string expected";if(b.attribute!=null&&b.hasOwnProperty("attribute")){if(!Array.isArray(b.attribute))return"attribute: array expected";for(j=0;j<b.attribute.length;++j){var U=G.onnx.AttributeProto.verify(b.attribute[j]);if(U)return"attribute."+U}}return b.docString!=null&&b.hasOwnProperty("docString")&&!q.isString(b.docString)?"docString: string expected":null},O.fromObject=function(b){if(b instanceof G.onnx.NodeProto)return b;var j=new G.onnx.NodeProto;if(b.input){if(!Array.isArray(b.input))throw TypeError(".onnx.NodeProto.input: array expected");j.input=[];for(var U=0;U<b.input.length;++U)j.input[U]=String(b.input[U])}if(b.output){if(!Array.isArray(b.output))throw TypeError(".onnx.NodeProto.output: array expected");for(j.output=[],U=0;U<b.output.length;++U)j.output[U]=String(b.output[U])}if(b.name!=null&&(j.name=String(b.name)),b.opType!=null&&(j.opType=String(b.opType)),b.domain!=null&&(j.domain=String(b.domain)),b.attribute){if(!Array.isArray(b.attribute))throw TypeError(".onnx.NodeProto.attribute: array expected");for(j.attribute=[],U=0;U<b.attribute.length;++U){if(typeof b.attribute[U]!="object")throw TypeError(".onnx.NodeProto.attribute: object expected");j.attribute[U]=G.onnx.AttributeProto.fromObject(b.attribute[U])}}return b.docString!=null&&(j.docString=String(b.docString)),j},O.toObject=function(b,j){j||(j={});var U={};if((j.arrays||j.defaults)&&(U.input=[],U.output=[],U.attribute=[]),j.defaults&&(U.name="",U.opType="",U.docString="",U.domain=""),b.input&&b.input.length){U.input=[];for(var J=0;J<b.input.length;++J)U.input[J]=b.input[J]}if(b.output&&b.output.length)for(U.output=[],J=0;J<b.output.length;++J)U.output[J]=b.output[J];if(b.name!=null&&b.hasOwnProperty("name")&&(U.name=b.name),b.opType!=null&&b.hasOwnProperty("opType")&&(U.opType=b.opType),b.attribute&&b.attribute.length)for(U.attribute=[],J=0;J<b.attribute.length;++J)U.attribute[J]=G.onnx.AttributeProto.toObject(b.attribute[J],j);return b.docString!=null&&b.hasOwnProperty("docString")&&(U.docString=b.docString),b.domain!=null&&b.hasOwnProperty("domain")&&(U.domain=b.domain),U},O.prototype.toJSON=function(){return this.constructor.toObject(this,Y.util.toJSONOptions)},O}(),Q.ModelProto=function(){function O(b){if(this.opsetImport=[],this.metadataProps=[],b)for(var j=Object.keys(b),U=0;U<j.length;++U)b[j[U]]!=null&&(this[j[U]]=b[j[U]])}return O.prototype.irVersion=q.Long?q.Long.fromBits(0,0,!1):0,O.prototype.opsetImport=q.emptyArray,O.prototype.producerName="",O.prototype.producerVersion="",O.prototype.domain="",O.prototype.modelVersion=q.Long?q.Long.fromBits(0,0,!1):0,O.prototype.docString="",O.prototype.graph=null,O.prototype.metadataProps=q.emptyArray,O.create=function(b){return new O(b)},O.encode=function(b,j){if(j||(j=et.create()),b.irVersion!=null&&b.hasOwnProperty("irVersion")&&j.uint32(8).int64(b.irVersion),b.producerName!=null&&b.hasOwnProperty("producerName")&&j.uint32(18).string(b.producerName),b.producerVersion!=null&&b.hasOwnProperty("producerVersion")&&j.uint32(26).string(b.producerVersion),b.domain!=null&&b.hasOwnProperty("domain")&&j.uint32(34).string(b.domain),b.modelVersion!=null&&b.hasOwnProperty("modelVersion")&&j.uint32(40).int64(b.modelVersion),b.docString!=null&&b.hasOwnProperty("docString")&&j.uint32(50).string(b.docString),b.graph!=null&&b.hasOwnProperty("graph")&&G.onnx.GraphProto.encode(b.graph,j.uint32(58).fork()).ldelim(),b.opsetImport!=null&&b.opsetImport.length)for(var U=0;U<b.opsetImport.length;++U)G.onnx.OperatorSetIdProto.encode(b.opsetImport[U],j.uint32(66).fork()).ldelim();if(b.metadataProps!=null&&b.metadataProps.length)for(U=0;U<b.metadataProps.length;++U)G.onnx.StringStringEntryProto.encode(b.metadataProps[U],j.uint32(114).fork()).ldelim();return j},O.encodeDelimited=function(b,j){return this.encode(b,j).ldelim()},O.decode=function(b,j){b instanceof tt||(b=tt.create(b));for(var U=j===void 0?b.len:b.pos+j,J=new G.onnx.ModelProto;b.pos<U;){var nt=b.uint32();switch(nt>>>3){case 1:J.irVersion=b.int64();break;case 8:J.opsetImport&&J.opsetImport.length||(J.opsetImport=[]),J.opsetImport.push(G.onnx.OperatorSetIdProto.decode(b,b.uint32()));break;case 2:J.producerName=b.string();break;case 3:J.producerVersion=b.string();break;case 4:J.domain=b.string();break;case 5:J.modelVersion=b.int64();break;case 6:J.docString=b.string();break;case 7:J.graph=G.onnx.GraphProto.decode(b,b.uint32());break;case 14:J.metadataProps&&J.metadataProps.length||(J.metadataProps=[]),J.metadataProps.push(G.onnx.StringStringEntryProto.decode(b,b.uint32()));break;default:b.skipType(7&nt)}}return J},O.decodeDelimited=function(b){return b instanceof tt||(b=new tt(b)),this.decode(b,b.uint32())},O.verify=function(b){if(typeof b!="object"||b===null)return"object expected";if(b.irVersion!=null&&b.hasOwnProperty("irVersion")&&!(q.isInteger(b.irVersion)||b.irVersion&&q.isInteger(b.irVersion.low)&&q.isInteger(b.irVersion.high)))return"irVersion: integer|Long expected";if(b.opsetImport!=null&&b.hasOwnProperty("opsetImport")){if(!Array.isArray(b.opsetImport))return"opsetImport: array expected";for(var j=0;j<b.opsetImport.length;++j)if(U=G.onnx.OperatorSetIdProto.verify(b.opsetImport[j]))return"opsetImport."+U}if(b.producerName!=null&&b.hasOwnProperty("producerName")&&!q.isString(b.producerName))return"producerName: string expected";if(b.producerVersion!=null&&b.hasOwnProperty("producerVersion")&&!q.isString(b.producerVersion))return"producerVersion: string expected";if(b.domain!=null&&b.hasOwnProperty("domain")&&!q.isString(b.domain))return"domain: string expected";if(b.modelVersion!=null&&b.hasOwnProperty("modelVersion")&&!(q.isInteger(b.modelVersion)||b.modelVersion&&q.isInteger(b.modelVersion.low)&&q.isInteger(b.modelVersion.high)))return"modelVersion: integer|Long expected";if(b.docString!=null&&b.hasOwnProperty("docString")&&!q.isString(b.docString))return"docString: string expected";if(b.graph!=null&&b.hasOwnProperty("graph")&&(U=G.onnx.GraphProto.verify(b.graph)))return"graph."+U;if(b.metadataProps!=null&&b.hasOwnProperty("metadataProps")){if(!Array.isArray(b.metadataProps))return"metadataProps: array expected";for(j=0;j<b.metadataProps.length;++j){var U;if(U=G.onnx.StringStringEntryProto.verify(b.metadataProps[j]))return"metadataProps."+U}}return null},O.fromObject=function(b){if(b instanceof G.onnx.ModelProto)return b;var j=new G.onnx.ModelProto;if(b.irVersion!=null&&(q.Long?(j.irVersion=q.Long.fromValue(b.irVersion)).unsigned=!1:typeof b.irVersion=="string"?j.irVersion=parseInt(b.irVersion,10):typeof b.irVersion=="number"?j.irVersion=b.irVersion:typeof b.irVersion=="object"&&(j.irVersion=new q.LongBits(b.irVersion.low>>>0,b.irVersion.high>>>0).toNumber())),b.opsetImport){if(!Array.isArray(b.opsetImport))throw TypeError(".onnx.ModelProto.opsetImport: array expected");j.opsetImport=[];for(var U=0;U<b.opsetImport.length;++U){if(typeof b.opsetImport[U]!="object")throw TypeError(".onnx.ModelProto.opsetImport: object expected");j.opsetImport[U]=G.onnx.OperatorSetIdProto.fromObject(b.opsetImport[U])}}if(b.producerName!=null&&(j.producerName=String(b.producerName)),b.producerVersion!=null&&(j.producerVersion=String(b.producerVersion)),b.domain!=null&&(j.domain=String(b.domain)),b.modelVersion!=null&&(q.Long?(j.modelVersion=q.Long.fromValue(b.modelVersion)).unsigned=!1:typeof b.modelVersion=="string"?j.modelVersion=parseInt(b.modelVersion,10):typeof b.modelVersion=="number"?j.modelVersion=b.modelVersion:typeof b.modelVersion=="object"&&(j.modelVersion=new q.LongBits(b.modelVersion.low>>>0,b.modelVersion.high>>>0).toNumber())),b.docString!=null&&(j.docString=String(b.docString)),b.graph!=null){if(typeof b.graph!="object")throw TypeError(".onnx.ModelProto.graph: object expected");j.graph=G.onnx.GraphProto.fromObject(b.graph)}if(b.metadataProps){if(!Array.isArray(b.metadataProps))throw TypeError(".onnx.ModelProto.metadataProps: array expected");for(j.metadataProps=[],U=0;U<b.metadataProps.length;++U){if(typeof b.metadataProps[U]!="object")throw TypeError(".onnx.ModelProto.metadataProps: object expected");j.metadataProps[U]=G.onnx.StringStringEntryProto.fromObject(b.metadataProps[U])}}return j},O.toObject=function(b,j){j||(j={});var U={};if((j.arrays||j.defaults)&&(U.opsetImport=[],U.metadataProps=[]),j.defaults){if(q.Long){var J=new q.Long(0,0,!1);U.irVersion=j.longs===String?J.toString():j.longs===Number?J.toNumber():J}else U.irVersion=j.longs===String?"0":0;U.producerName="",U.producerVersion="",U.domain="",q.Long?(J=new q.Long(0,0,!1),U.modelVersion=j.longs===String?J.toString():j.longs===Number?J.toNumber():J):U.modelVersion=j.longs===String?"0":0,U.docString="",U.graph=null}if(b.irVersion!=null&&b.hasOwnProperty("irVersion")&&(typeof b.irVersion=="number"?U.irVersion=j.longs===String?String(b.irVersion):b.irVersion:U.irVersion=j.longs===String?q.Long.prototype.toString.call(b.irVersion):j.longs===Number?new q.LongBits(b.irVersion.low>>>0,b.irVersion.high>>>0).toNumber():b.irVersion),b.producerName!=null&&b.hasOwnProperty("producerName")&&(U.producerName=b.producerName),b.producerVersion!=null&&b.hasOwnProperty("producerVersion")&&(U.producerVersion=b.producerVersion),b.domain!=null&&b.hasOwnProperty("domain")&&(U.domain=b.domain),b.modelVersion!=null&&b.hasOwnProperty("modelVersion")&&(typeof b.modelVersion=="number"?U.modelVersion=j.longs===String?String(b.modelVersion):b.modelVersion:U.modelVersion=j.longs===String?q.Long.prototype.toString.call(b.modelVersion):j.longs===Number?new q.LongBits(b.modelVersion.low>>>0,b.modelVersion.high>>>0).toNumber():b.modelVersion),b.docString!=null&&b.hasOwnProperty("docString")&&(U.docString=b.docString),b.graph!=null&&b.hasOwnProperty("graph")&&(U.graph=G.onnx.GraphProto.toObject(b.graph,j)),b.opsetImport&&b.opsetImport.length){U.opsetImport=[];for(var nt=0;nt<b.opsetImport.length;++nt)U.opsetImport[nt]=G.onnx.OperatorSetIdProto.toObject(b.opsetImport[nt],j)}if(b.metadataProps&&b.metadataProps.length)for(U.metadataProps=[],nt=0;nt<b.metadataProps.length;++nt)U.metadataProps[nt]=G.onnx.StringStringEntryProto.toObject(b.metadataProps[nt],j);return U},O.prototype.toJSON=function(){return this.constructor.toObject(this,Y.util.toJSONOptions)},O}(),Q.StringStringEntryProto=function(){function O(b){if(b)for(var j=Object.keys(b),U=0;U<j.length;++U)b[j[U]]!=null&&(this[j[U]]=b[j[U]])}return O.prototype.key="",O.prototype.value="",O.create=function(b){return new O(b)},O.encode=function(b,j){return j||(j=et.create()),b.key!=null&&b.hasOwnProperty("key")&&j.uint32(10).string(b.key),b.value!=null&&b.hasOwnProperty("value")&&j.uint32(18).string(b.value),j},O.encodeDelimited=function(b,j){return this.encode(b,j).ldelim()},O.decode=function(b,j){b instanceof tt||(b=tt.create(b));for(var U=j===void 0?b.len:b.pos+j,J=new G.onnx.StringStringEntryProto;b.pos<U;){var nt=b.uint32();switch(nt>>>3){case 1:J.key=b.string();break;case 2:J.value=b.string();break;default:b.skipType(7&nt)}}return J},O.decodeDelimited=function(b){return b instanceof tt||(b=new tt(b)),this.decode(b,b.uint32())},O.verify=function(b){return typeof b!="object"||b===null?"object expected":b.key!=null&&b.hasOwnProperty("key")&&!q.isString(b.key)?"key: string expected":b.value!=null&&b.hasOwnProperty("value")&&!q.isString(b.value)?"value: string expected":null},O.fromObject=function(b){if(b instanceof G.onnx.StringStringEntryProto)return b;var j=new G.onnx.StringStringEntryProto;return b.key!=null&&(j.key=String(b.key)),b.value!=null&&(j.value=String(b.value)),j},O.toObject=function(b,j){j||(j={});var U={};return j.defaults&&(U.key="",U.value=""),b.key!=null&&b.hasOwnProperty("key")&&(U.key=b.key),b.value!=null&&b.hasOwnProperty("value")&&(U.value=b.value),U},O.prototype.toJSON=function(){return this.constructor.toObject(this,Y.util.toJSONOptions)},O}(),Q.TensorAnnotation=function(){function O(b){if(this.quantParameterTensorNames=[],b)for(var j=Object.keys(b),U=0;U<j.length;++U)b[j[U]]!=null&&(this[j[U]]=b[j[U]])}return O.prototype.tensorName="",O.prototype.quantParameterTensorNames=q.emptyArray,O.create=function(b){return new O(b)},O.encode=function(b,j){if(j||(j=et.create()),b.tensorName!=null&&b.hasOwnProperty("tensorName")&&j.uint32(10).string(b.tensorName),b.quantParameterTensorNames!=null&&b.quantParameterTensorNames.length)for(var U=0;U<b.quantParameterTensorNames.length;++U)G.onnx.StringStringEntryProto.encode(b.quantParameterTensorNames[U],j.uint32(18).fork()).ldelim();return j},O.encodeDelimited=function(b,j){return this.encode(b,j).ldelim()},O.decode=function(b,j){b instanceof tt||(b=tt.create(b));for(var U=j===void 0?b.len:b.pos+j,J=new G.onnx.TensorAnnotation;b.pos<U;){var nt=b.uint32();switch(nt>>>3){case 1:J.tensorName=b.string();break;case 2:J.quantParameterTensorNames&&J.quantParameterTensorNames.length||(J.quantParameterTensorNames=[]),J.quantParameterTensorNames.push(G.onnx.StringStringEntryProto.decode(b,b.uint32()));break;default:b.skipType(7&nt)}}return J},O.decodeDelimited=function(b){return b instanceof tt||(b=new tt(b)),this.decode(b,b.uint32())},O.verify=function(b){if(typeof b!="object"||b===null)return"object expected";if(b.tensorName!=null&&b.hasOwnProperty("tensorName")&&!q.isString(b.tensorName))return"tensorName: string expected";if(b.quantParameterTensorNames!=null&&b.hasOwnProperty("quantParameterTensorNames")){if(!Array.isArray(b.quantParameterTensorNames))return"quantParameterTensorNames: array expected";for(var j=0;j<b.quantParameterTensorNames.length;++j){var U=G.onnx.StringStringEntryProto.verify(b.quantParameterTensorNames[j]);if(U)return"quantParameterTensorNames."+U}}return null},O.fromObject=function(b){if(b instanceof G.onnx.TensorAnnotation)return b;var j=new G.onnx.TensorAnnotation;if(b.tensorName!=null&&(j.tensorName=String(b.tensorName)),b.quantParameterTensorNames){if(!Array.isArray(b.quantParameterTensorNames))throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");j.quantParameterTensorNames=[];for(var U=0;U<b.quantParameterTensorNames.length;++U){if(typeof b.quantParameterTensorNames[U]!="object")throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");j.quantParameterTensorNames[U]=G.onnx.StringStringEntryProto.fromObject(b.quantParameterTensorNames[U])}}return j},O.toObject=function(b,j){j||(j={});var U={};if((j.arrays||j.defaults)&&(U.quantParameterTensorNames=[]),j.defaults&&(U.tensorName=""),b.tensorName!=null&&b.hasOwnProperty("tensorName")&&(U.tensorName=b.tensorName),b.quantParameterTensorNames&&b.quantParameterTensorNames.length){U.quantParameterTensorNames=[];for(var J=0;J<b.quantParameterTensorNames.length;++J)U.quantParameterTensorNames[J]=G.onnx.StringStringEntryProto.toObject(b.quantParameterTensorNames[J],j)}return U},O.prototype.toJSON=function(){return this.constructor.toObject(this,Y.util.toJSONOptions)},O}(),Q.GraphProto=function(){function O(b){if(this.node=[],this.initializer=[],this.input=[],this.output=[],this.valueInfo=[],this.quantizationAnnotation=[],b)for(var j=Object.keys(b),U=0;U<j.length;++U)b[j[U]]!=null&&(this[j[U]]=b[j[U]])}return O.prototype.node=q.emptyArray,O.prototype.name="",O.prototype.initializer=q.emptyArray,O.prototype.docString="",O.prototype.input=q.emptyArray,O.prototype.output=q.emptyArray,O.prototype.valueInfo=q.emptyArray,O.prototype.quantizationAnnotation=q.emptyArray,O.create=function(b){return new O(b)},O.encode=function(b,j){if(j||(j=et.create()),b.node!=null&&b.node.length)for(var U=0;U<b.node.length;++U)G.onnx.NodeProto.encode(b.node[U],j.uint32(10).fork()).ldelim();if(b.name!=null&&b.hasOwnProperty("name")&&j.uint32(18).string(b.name),b.initializer!=null&&b.initializer.length)for(U=0;U<b.initializer.length;++U)G.onnx.TensorProto.encode(b.initializer[U],j.uint32(42).fork()).ldelim();if(b.docString!=null&&b.hasOwnProperty("docString")&&j.uint32(82).string(b.docString),b.input!=null&&b.input.length)for(U=0;U<b.input.length;++U)G.onnx.ValueInfoProto.encode(b.input[U],j.uint32(90).fork()).ldelim();if(b.output!=null&&b.output.length)for(U=0;U<b.output.length;++U)G.onnx.ValueInfoProto.encode(b.output[U],j.uint32(98).fork()).ldelim();if(b.valueInfo!=null&&b.valueInfo.length)for(U=0;U<b.valueInfo.length;++U)G.onnx.ValueInfoProto.encode(b.valueInfo[U],j.uint32(106).fork()).ldelim();if(b.quantizationAnnotation!=null&&b.quantizationAnnotation.length)for(U=0;U<b.quantizationAnnotation.length;++U)G.onnx.TensorAnnotation.encode(b.quantizationAnnotation[U],j.uint32(114).fork()).ldelim();return j},O.encodeDelimited=function(b,j){return this.encode(b,j).ldelim()},O.decode=function(b,j){b instanceof tt||(b=tt.create(b));for(var U=j===void 0?b.len:b.pos+j,J=new G.onnx.GraphProto;b.pos<U;){var nt=b.uint32();switch(nt>>>3){case 1:J.node&&J.node.length||(J.node=[]),J.node.push(G.onnx.NodeProto.decode(b,b.uint32()));break;case 2:J.name=b.string();break;case 5:J.initializer&&J.initializer.length||(J.initializer=[]),J.initializer.push(G.onnx.TensorProto.decode(b,b.uint32()));break;case 10:J.docString=b.string();break;case 11:J.input&&J.input.length||(J.input=[]),J.input.push(G.onnx.ValueInfoProto.decode(b,b.uint32()));break;case 12:J.output&&J.output.length||(J.output=[]),J.output.push(G.onnx.ValueInfoProto.decode(b,b.uint32()));break;case 13:J.valueInfo&&J.valueInfo.length||(J.valueInfo=[]),J.valueInfo.push(G.onnx.ValueInfoProto.decode(b,b.uint32()));break;case 14:J.quantizationAnnotation&&J.quantizationAnnotation.length||(J.quantizationAnnotation=[]),J.quantizationAnnotation.push(G.onnx.TensorAnnotation.decode(b,b.uint32()));break;default:b.skipType(7&nt)}}return J},O.decodeDelimited=function(b){return b instanceof tt||(b=new tt(b)),this.decode(b,b.uint32())},O.verify=function(b){if(typeof b!="object"||b===null)return"object expected";if(b.node!=null&&b.hasOwnProperty("node")){if(!Array.isArray(b.node))return"node: array expected";for(var j=0;j<b.node.length;++j)if(U=G.onnx.NodeProto.verify(b.node[j]))return"node."+U}if(b.name!=null&&b.hasOwnProperty("name")&&!q.isString(b.name))return"name: string expected";if(b.initializer!=null&&b.hasOwnProperty("initializer")){if(!Array.isArray(b.initializer))return"initializer: array expected";for(j=0;j<b.initializer.length;++j)if(U=G.onnx.TensorProto.verify(b.initializer[j]))return"initializer."+U}if(b.docString!=null&&b.hasOwnProperty("docString")&&!q.isString(b.docString))return"docString: string expected";if(b.input!=null&&b.hasOwnProperty("input")){if(!Array.isArray(b.input))return"input: array expected";for(j=0;j<b.input.length;++j)if(U=G.onnx.ValueInfoProto.verify(b.input[j]))return"input."+U}if(b.output!=null&&b.hasOwnProperty("output")){if(!Array.isArray(b.output))return"output: array expected";for(j=0;j<b.output.length;++j)if(U=G.onnx.ValueInfoProto.verify(b.output[j]))return"output."+U}if(b.valueInfo!=null&&b.hasOwnProperty("valueInfo")){if(!Array.isArray(b.valueInfo))return"valueInfo: array expected";for(j=0;j<b.valueInfo.length;++j)if(U=G.onnx.ValueInfoProto.verify(b.valueInfo[j]))return"valueInfo."+U}if(b.quantizationAnnotation!=null&&b.hasOwnProperty("quantizationAnnotation")){if(!Array.isArray(b.quantizationAnnotation))return"quantizationAnnotation: array expected";for(j=0;j<b.quantizationAnnotation.length;++j){var U;if(U=G.onnx.TensorAnnotation.verify(b.quantizationAnnotation[j]))return"quantizationAnnotation."+U}}return null},O.fromObject=function(b){if(b instanceof G.onnx.GraphProto)return b;var j=new G.onnx.GraphProto;if(b.node){if(!Array.isArray(b.node))throw TypeError(".onnx.GraphProto.node: array expected");j.node=[];for(var U=0;U<b.node.length;++U){if(typeof b.node[U]!="object")throw TypeError(".onnx.GraphProto.node: object expected");j.node[U]=G.onnx.NodeProto.fromObject(b.node[U])}}if(b.name!=null&&(j.name=String(b.name)),b.initializer){if(!Array.isArray(b.initializer))throw TypeError(".onnx.GraphProto.initializer: array expected");for(j.initializer=[],U=0;U<b.initializer.length;++U){if(typeof b.initializer[U]!="object")throw TypeError(".onnx.GraphProto.initializer: object expected");j.initializer[U]=G.onnx.TensorProto.fromObject(b.initializer[U])}}if(b.docString!=null&&(j.docString=String(b.docString)),b.input){if(!Array.isArray(b.input))throw TypeError(".onnx.GraphProto.input: array expected");for(j.input=[],U=0;U<b.input.length;++U){if(typeof b.input[U]!="object")throw TypeError(".onnx.GraphProto.input: object expected");j.input[U]=G.onnx.ValueInfoProto.fromObject(b.input[U])}}if(b.output){if(!Array.isArray(b.output))throw TypeError(".onnx.GraphProto.output: array expected");for(j.output=[],U=0;U<b.output.length;++U){if(typeof b.output[U]!="object")throw TypeError(".onnx.GraphProto.output: object expected");j.output[U]=G.onnx.ValueInfoProto.fromObject(b.output[U])}}if(b.valueInfo){if(!Array.isArray(b.valueInfo))throw TypeError(".onnx.GraphProto.valueInfo: array expected");for(j.valueInfo=[],U=0;U<b.valueInfo.length;++U){if(typeof b.valueInfo[U]!="object")throw TypeError(".onnx.GraphProto.valueInfo: object expected");j.valueInfo[U]=G.onnx.ValueInfoProto.fromObject(b.valueInfo[U])}}if(b.quantizationAnnotation){if(!Array.isArray(b.quantizationAnnotation))throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");for(j.quantizationAnnotation=[],U=0;U<b.quantizationAnnotation.length;++U){if(typeof b.quantizationAnnotation[U]!="object")throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");j.quantizationAnnotation[U]=G.onnx.TensorAnnotation.fromObject(b.quantizationAnnotation[U])}}return j},O.toObject=function(b,j){j||(j={});var U={};if((j.arrays||j.defaults)&&(U.node=[],U.initializer=[],U.input=[],U.output=[],U.valueInfo=[],U.quantizationAnnotation=[]),j.defaults&&(U.name="",U.docString=""),b.node&&b.node.length){U.node=[];for(var J=0;J<b.node.length;++J)U.node[J]=G.onnx.NodeProto.toObject(b.node[J],j)}if(b.name!=null&&b.hasOwnProperty("name")&&(U.name=b.name),b.initializer&&b.initializer.length)for(U.initializer=[],J=0;J<b.initializer.length;++J)U.initializer[J]=G.onnx.TensorProto.toObject(b.initializer[J],j);if(b.docString!=null&&b.hasOwnProperty("docString")&&(U.docString=b.docString),b.input&&b.input.length)for(U.input=[],J=0;J<b.input.length;++J)U.input[J]=G.onnx.ValueInfoProto.toObject(b.input[J],j);if(b.output&&b.output.length)for(U.output=[],J=0;J<b.output.length;++J)U.output[J]=G.onnx.ValueInfoProto.toObject(b.output[J],j);if(b.valueInfo&&b.valueInfo.length)for(U.valueInfo=[],J=0;J<b.valueInfo.length;++J)U.valueInfo[J]=G.onnx.ValueInfoProto.toObject(b.valueInfo[J],j);if(b.quantizationAnnotation&&b.quantizationAnnotation.length)for(U.quantizationAnnotation=[],J=0;J<b.quantizationAnnotation.length;++J)U.quantizationAnnotation[J]=G.onnx.TensorAnnotation.toObject(b.quantizationAnnotation[J],j);return U},O.prototype.toJSON=function(){return this.constructor.toObject(this,Y.util.toJSONOptions)},O}(),Q.TensorProto=function(){function O(b){if(this.dims=[],this.floatData=[],this.int32Data=[],this.stringData=[],this.int64Data=[],this.externalData=[],this.doubleData=[],this.uint64Data=[],b)for(var j=Object.keys(b),U=0;U<j.length;++U)b[j[U]]!=null&&(this[j[U]]=b[j[U]])}return O.prototype.dims=q.emptyArray,O.prototype.dataType=0,O.prototype.segment=null,O.prototype.floatData=q.emptyArray,O.prototype.int32Data=q.emptyArray,O.prototype.stringData=q.emptyArray,O.prototype.int64Data=q.emptyArray,O.prototype.name="",O.prototype.docString="",O.prototype.rawData=q.newBuffer([]),O.prototype.externalData=q.emptyArray,O.prototype.dataLocation=0,O.prototype.doubleData=q.emptyArray,O.prototype.uint64Data=q.emptyArray,O.create=function(b){return new O(b)},O.encode=function(b,j){if(j||(j=et.create()),b.dims!=null&&b.dims.length){j.uint32(10).fork();for(var U=0;U<b.dims.length;++U)j.int64(b.dims[U]);j.ldelim()}if(b.dataType!=null&&b.hasOwnProperty("dataType")&&j.uint32(16).int32(b.dataType),b.segment!=null&&b.hasOwnProperty("segment")&&G.onnx.TensorProto.Segment.encode(b.segment,j.uint32(26).fork()).ldelim(),b.floatData!=null&&b.floatData.length){for(j.uint32(34).fork(),U=0;U<b.floatData.length;++U)j.float(b.floatData[U]);j.ldelim()}if(b.int32Data!=null&&b.int32Data.length){for(j.uint32(42).fork(),U=0;U<b.int32Data.length;++U)j.int32(b.int32Data[U]);j.ldelim()}if(b.stringData!=null&&b.stringData.length)for(U=0;U<b.stringData.length;++U)j.uint32(50).bytes(b.stringData[U]);if(b.int64Data!=null&&b.int64Data.length){for(j.uint32(58).fork(),U=0;U<b.int64Data.length;++U)j.int64(b.int64Data[U]);j.ldelim()}if(b.name!=null&&b.hasOwnProperty("name")&&j.uint32(66).string(b.name),b.rawData!=null&&b.hasOwnProperty("rawData")&&j.uint32(74).bytes(b.rawData),b.doubleData!=null&&b.doubleData.length){for(j.uint32(82).fork(),U=0;U<b.doubleData.length;++U)j.double(b.doubleData[U]);j.ldelim()}if(b.uint64Data!=null&&b.uint64Data.length){for(j.uint32(90).fork(),U=0;U<b.uint64Data.length;++U)j.uint64(b.uint64Data[U]);j.ldelim()}if(b.docString!=null&&b.hasOwnProperty("docString")&&j.uint32(98).string(b.docString),b.externalData!=null&&b.externalData.length)for(U=0;U<b.externalData.length;++U)G.onnx.StringStringEntryProto.encode(b.externalData[U],j.uint32(106).fork()).ldelim();return b.dataLocation!=null&&b.hasOwnProperty("dataLocation")&&j.uint32(112).int32(b.dataLocation),j},O.encodeDelimited=function(b,j){return this.encode(b,j).ldelim()},O.decode=function(b,j){b instanceof tt||(b=tt.create(b));for(var U=j===void 0?b.len:b.pos+j,J=new G.onnx.TensorProto;b.pos<U;){var nt=b.uint32();switch(nt>>>3){case 1:if(J.dims&&J.dims.length||(J.dims=[]),(7&nt)==2)for(var rt=b.uint32()+b.pos;b.pos<rt;)J.dims.push(b.int64());else J.dims.push(b.int64());break;case 2:J.dataType=b.int32();break;case 3:J.segment=G.onnx.TensorProto.Segment.decode(b,b.uint32());break;case 4:if(J.floatData&&J.floatData.length||(J.floatData=[]),(7&nt)==2)for(rt=b.uint32()+b.pos;b.pos<rt;)J.floatData.push(b.float());else J.floatData.push(b.float());break;case 5:if(J.int32Data&&J.int32Data.length||(J.int32Data=[]),(7&nt)==2)for(rt=b.uint32()+b.pos;b.pos<rt;)J.int32Data.push(b.int32());else J.int32Data.push(b.int32());break;case 6:J.stringData&&J.stringData.length||(J.stringData=[]),J.stringData.push(b.bytes());break;case 7:if(J.int64Data&&J.int64Data.length||(J.int64Data=[]),(7&nt)==2)for(rt=b.uint32()+b.pos;b.pos<rt;)J.int64Data.push(b.int64());else J.int64Data.push(b.int64());break;case 8:J.name=b.string();break;case 12:J.docString=b.string();break;case 9:J.rawData=b.bytes();break;case 13:J.externalData&&J.externalData.length||(J.externalData=[]),J.externalData.push(G.onnx.StringStringEntryProto.decode(b,b.uint32()));break;case 14:J.dataLocation=b.int32();break;case 10:if(J.doubleData&&J.doubleData.length||(J.doubleData=[]),(7&nt)==2)for(rt=b.uint32()+b.pos;b.pos<rt;)J.doubleData.push(b.double());else J.doubleData.push(b.double());break;case 11:if(J.uint64Data&&J.uint64Data.length||(J.uint64Data=[]),(7&nt)==2)for(rt=b.uint32()+b.pos;b.pos<rt;)J.uint64Data.push(b.uint64());else J.uint64Data.push(b.uint64());break;default:b.skipType(7&nt)}}return J},O.decodeDelimited=function(b){return b instanceof tt||(b=new tt(b)),this.decode(b,b.uint32())},O.verify=function(b){if(typeof b!="object"||b===null)return"object expected";if(b.dims!=null&&b.hasOwnProperty("dims")){if(!Array.isArray(b.dims))return"dims: array expected";for(var j=0;j<b.dims.length;++j)if(!(q.isInteger(b.dims[j])||b.dims[j]&&q.isInteger(b.dims[j].low)&&q.isInteger(b.dims[j].high)))return"dims: integer|Long[] expected"}if(b.dataType!=null&&b.hasOwnProperty("dataType")&&!q.isInteger(b.dataType))return"dataType: integer expected";if(b.segment!=null&&b.hasOwnProperty("segment")&&(U=G.onnx.TensorProto.Segment.verify(b.segment)))return"segment."+U;if(b.floatData!=null&&b.hasOwnProperty("floatData")){if(!Array.isArray(b.floatData))return"floatData: array expected";for(j=0;j<b.floatData.length;++j)if(typeof b.floatData[j]!="number")return"floatData: number[] expected"}if(b.int32Data!=null&&b.hasOwnProperty("int32Data")){if(!Array.isArray(b.int32Data))return"int32Data: array expected";for(j=0;j<b.int32Data.length;++j)if(!q.isInteger(b.int32Data[j]))return"int32Data: integer[] expected"}if(b.stringData!=null&&b.hasOwnProperty("stringData")){if(!Array.isArray(b.stringData))return"stringData: array expected";for(j=0;j<b.stringData.length;++j)if(!(b.stringData[j]&&typeof b.stringData[j].length=="number"||q.isString(b.stringData[j])))return"stringData: buffer[] expected"}if(b.int64Data!=null&&b.hasOwnProperty("int64Data")){if(!Array.isArray(b.int64Data))return"int64Data: array expected";for(j=0;j<b.int64Data.length;++j)if(!(q.isInteger(b.int64Data[j])||b.int64Data[j]&&q.isInteger(b.int64Data[j].low)&&q.isInteger(b.int64Data[j].high)))return"int64Data: integer|Long[] expected"}if(b.name!=null&&b.hasOwnProperty("name")&&!q.isString(b.name))return"name: string expected";if(b.docString!=null&&b.hasOwnProperty("docString")&&!q.isString(b.docString))return"docString: string expected";if(b.rawData!=null&&b.hasOwnProperty("rawData")&&!(b.rawData&&typeof b.rawData.length=="number"||q.isString(b.rawData)))return"rawData: buffer expected";if(b.externalData!=null&&b.hasOwnProperty("externalData")){if(!Array.isArray(b.externalData))return"externalData: array expected";for(j=0;j<b.externalData.length;++j){var U;if(U=G.onnx.StringStringEntryProto.verify(b.externalData[j]))return"externalData."+U}}if(b.dataLocation!=null&&b.hasOwnProperty("dataLocation"))switch(b.dataLocation){default:return"dataLocation: enum value expected";case 0:case 1:}if(b.doubleData!=null&&b.hasOwnProperty("doubleData")){if(!Array.isArray(b.doubleData))return"doubleData: array expected";for(j=0;j<b.doubleData.length;++j)if(typeof b.doubleData[j]!="number")return"doubleData: number[] expected"}if(b.uint64Data!=null&&b.hasOwnProperty("uint64Data")){if(!Array.isArray(b.uint64Data))return"uint64Data: array expected";for(j=0;j<b.uint64Data.length;++j)if(!(q.isInteger(b.uint64Data[j])||b.uint64Data[j]&&q.isInteger(b.uint64Data[j].low)&&q.isInteger(b.uint64Data[j].high)))return"uint64Data: integer|Long[] expected"}return null},O.fromObject=function(b){if(b instanceof G.onnx.TensorProto)return b;var j=new G.onnx.TensorProto;if(b.dims){if(!Array.isArray(b.dims))throw TypeError(".onnx.TensorProto.dims: array expected");j.dims=[];for(var U=0;U<b.dims.length;++U)q.Long?(j.dims[U]=q.Long.fromValue(b.dims[U])).unsigned=!1:typeof b.dims[U]=="string"?j.dims[U]=parseInt(b.dims[U],10):typeof b.dims[U]=="number"?j.dims[U]=b.dims[U]:typeof b.dims[U]=="object"&&(j.dims[U]=new q.LongBits(b.dims[U].low>>>0,b.dims[U].high>>>0).toNumber())}if(b.dataType!=null&&(j.dataType=0|b.dataType),b.segment!=null){if(typeof b.segment!="object")throw TypeError(".onnx.TensorProto.segment: object expected");j.segment=G.onnx.TensorProto.Segment.fromObject(b.segment)}if(b.floatData){if(!Array.isArray(b.floatData))throw TypeError(".onnx.TensorProto.floatData: array expected");for(j.floatData=[],U=0;U<b.floatData.length;++U)j.floatData[U]=Number(b.floatData[U])}if(b.int32Data){if(!Array.isArray(b.int32Data))throw TypeError(".onnx.TensorProto.int32Data: array expected");for(j.int32Data=[],U=0;U<b.int32Data.length;++U)j.int32Data[U]=0|b.int32Data[U]}if(b.stringData){if(!Array.isArray(b.stringData))throw TypeError(".onnx.TensorProto.stringData: array expected");for(j.stringData=[],U=0;U<b.stringData.length;++U)typeof b.stringData[U]=="string"?q.base64.decode(b.stringData[U],j.stringData[U]=q.newBuffer(q.base64.length(b.stringData[U])),0):b.stringData[U].length&&(j.stringData[U]=b.stringData[U])}if(b.int64Data){if(!Array.isArray(b.int64Data))throw TypeError(".onnx.TensorProto.int64Data: array expected");for(j.int64Data=[],U=0;U<b.int64Data.length;++U)q.Long?(j.int64Data[U]=q.Long.fromValue(b.int64Data[U])).unsigned=!1:typeof b.int64Data[U]=="string"?j.int64Data[U]=parseInt(b.int64Data[U],10):typeof b.int64Data[U]=="number"?j.int64Data[U]=b.int64Data[U]:typeof b.int64Data[U]=="object"&&(j.int64Data[U]=new q.LongBits(b.int64Data[U].low>>>0,b.int64Data[U].high>>>0).toNumber())}if(b.name!=null&&(j.name=String(b.name)),b.docString!=null&&(j.docString=String(b.docString)),b.rawData!=null&&(typeof b.rawData=="string"?q.base64.decode(b.rawData,j.rawData=q.newBuffer(q.base64.length(b.rawData)),0):b.rawData.length&&(j.rawData=b.rawData)),b.externalData){if(!Array.isArray(b.externalData))throw TypeError(".onnx.TensorProto.externalData: array expected");for(j.externalData=[],U=0;U<b.externalData.length;++U){if(typeof b.externalData[U]!="object")throw TypeError(".onnx.TensorProto.externalData: object expected");j.externalData[U]=G.onnx.StringStringEntryProto.fromObject(b.externalData[U])}}switch(b.dataLocation){case"DEFAULT":case 0:j.dataLocation=0;break;case"EXTERNAL":case 1:j.dataLocation=1}if(b.doubleData){if(!Array.isArray(b.doubleData))throw TypeError(".onnx.TensorProto.doubleData: array expected");for(j.doubleData=[],U=0;U<b.doubleData.length;++U)j.doubleData[U]=Number(b.doubleData[U])}if(b.uint64Data){if(!Array.isArray(b.uint64Data))throw TypeError(".onnx.TensorProto.uint64Data: array expected");for(j.uint64Data=[],U=0;U<b.uint64Data.length;++U)q.Long?(j.uint64Data[U]=q.Long.fromValue(b.uint64Data[U])).unsigned=!0:typeof b.uint64Data[U]=="string"?j.uint64Data[U]=parseInt(b.uint64Data[U],10):typeof b.uint64Data[U]=="number"?j.uint64Data[U]=b.uint64Data[U]:typeof b.uint64Data[U]=="object"&&(j.uint64Data[U]=new q.LongBits(b.uint64Data[U].low>>>0,b.uint64Data[U].high>>>0).toNumber(!0))}return j},O.toObject=function(b,j){j||(j={});var U={};if((j.arrays||j.defaults)&&(U.dims=[],U.floatData=[],U.int32Data=[],U.stringData=[],U.int64Data=[],U.doubleData=[],U.uint64Data=[],U.externalData=[]),j.defaults&&(U.dataType=0,U.segment=null,U.name="",j.bytes===String?U.rawData="":(U.rawData=[],j.bytes!==Array&&(U.rawData=q.newBuffer(U.rawData))),U.docString="",U.dataLocation=j.enums===String?"DEFAULT":0),b.dims&&b.dims.length){U.dims=[];for(var J=0;J<b.dims.length;++J)typeof b.dims[J]=="number"?U.dims[J]=j.longs===String?String(b.dims[J]):b.dims[J]:U.dims[J]=j.longs===String?q.Long.prototype.toString.call(b.dims[J]):j.longs===Number?new q.LongBits(b.dims[J].low>>>0,b.dims[J].high>>>0).toNumber():b.dims[J]}if(b.dataType!=null&&b.hasOwnProperty("dataType")&&(U.dataType=b.dataType),b.segment!=null&&b.hasOwnProperty("segment")&&(U.segment=G.onnx.TensorProto.Segment.toObject(b.segment,j)),b.floatData&&b.floatData.length)for(U.floatData=[],J=0;J<b.floatData.length;++J)U.floatData[J]=j.json&&!isFinite(b.floatData[J])?String(b.floatData[J]):b.floatData[J];if(b.int32Data&&b.int32Data.length)for(U.int32Data=[],J=0;J<b.int32Data.length;++J)U.int32Data[J]=b.int32Data[J];if(b.stringData&&b.stringData.length)for(U.stringData=[],J=0;J<b.stringData.length;++J)U.stringData[J]=j.bytes===String?q.base64.encode(b.stringData[J],0,b.stringData[J].length):j.bytes===Array?Array.prototype.slice.call(b.stringData[J]):b.stringData[J];if(b.int64Data&&b.int64Data.length)for(U.int64Data=[],J=0;J<b.int64Data.length;++J)typeof b.int64Data[J]=="number"?U.int64Data[J]=j.longs===String?String(b.int64Data[J]):b.int64Data[J]:U.int64Data[J]=j.longs===String?q.Long.prototype.toString.call(b.int64Data[J]):j.longs===Number?new q.LongBits(b.int64Data[J].low>>>0,b.int64Data[J].high>>>0).toNumber():b.int64Data[J];if(b.name!=null&&b.hasOwnProperty("name")&&(U.name=b.name),b.rawData!=null&&b.hasOwnProperty("rawData")&&(U.rawData=j.bytes===String?q.base64.encode(b.rawData,0,b.rawData.length):j.bytes===Array?Array.prototype.slice.call(b.rawData):b.rawData),b.doubleData&&b.doubleData.length)for(U.doubleData=[],J=0;J<b.doubleData.length;++J)U.doubleData[J]=j.json&&!isFinite(b.doubleData[J])?String(b.doubleData[J]):b.doubleData[J];if(b.uint64Data&&b.uint64Data.length)for(U.uint64Data=[],J=0;J<b.uint64Data.length;++J)typeof b.uint64Data[J]=="number"?U.uint64Data[J]=j.longs===String?String(b.uint64Data[J]):b.uint64Data[J]:U.uint64Data[J]=j.longs===String?q.Long.prototype.toString.call(b.uint64Data[J]):j.longs===Number?new q.LongBits(b.uint64Data[J].low>>>0,b.uint64Data[J].high>>>0).toNumber(!0):b.uint64Data[J];if(b.docString!=null&&b.hasOwnProperty("docString")&&(U.docString=b.docString),b.externalData&&b.externalData.length)for(U.externalData=[],J=0;J<b.externalData.length;++J)U.externalData[J]=G.onnx.StringStringEntryProto.toObject(b.externalData[J],j);return b.dataLocation!=null&&b.hasOwnProperty("dataLocation")&&(U.dataLocation=j.enums===String?G.onnx.TensorProto.DataLocation[b.dataLocation]:b.dataLocation),U},O.prototype.toJSON=function(){return this.constructor.toObject(this,Y.util.toJSONOptions)},O.DataType=function(){var b={},j=Object.create(b);return j[b[0]="UNDEFINED"]=0,j[b[1]="FLOAT"]=1,j[b[2]="UINT8"]=2,j[b[3]="INT8"]=3,j[b[4]="UINT16"]=4,j[b[5]="INT16"]=5,j[b[6]="INT32"]=6,j[b[7]="INT64"]=7,j[b[8]="STRING"]=8,j[b[9]="BOOL"]=9,j[b[10]="FLOAT16"]=10,j[b[11]="DOUBLE"]=11,j[b[12]="UINT32"]=12,j[b[13]="UINT64"]=13,j[b[14]="COMPLEX64"]=14,j[b[15]="COMPLEX128"]=15,j[b[16]="BFLOAT16"]=16,j}(),O.Segment=function(){function b(j){if(j)for(var U=Object.keys(j),J=0;J<U.length;++J)j[U[J]]!=null&&(this[U[J]]=j[U[J]])}return b.prototype.begin=q.Long?q.Long.fromBits(0,0,!1):0,b.prototype.end=q.Long?q.Long.fromBits(0,0,!1):0,b.create=function(j){return new b(j)},b.encode=function(j,U){return U||(U=et.create()),j.begin!=null&&j.hasOwnProperty("begin")&&U.uint32(8).int64(j.begin),j.end!=null&&j.hasOwnProperty("end")&&U.uint32(16).int64(j.end),U},b.encodeDelimited=function(j,U){return this.encode(j,U).ldelim()},b.decode=function(j,U){j instanceof tt||(j=tt.create(j));for(var J=U===void 0?j.len:j.pos+U,nt=new G.onnx.TensorProto.Segment;j.pos<J;){var rt=j.uint32();switch(rt>>>3){case 1:nt.begin=j.int64();break;case 2:nt.end=j.int64();break;default:j.skipType(7&rt)}}return nt},b.decodeDelimited=function(j){return j instanceof tt||(j=new tt(j)),this.decode(j,j.uint32())},b.verify=function(j){return typeof j!="object"||j===null?"object expected":j.begin!=null&&j.hasOwnProperty("begin")&&!(q.isInteger(j.begin)||j.begin&&q.isInteger(j.begin.low)&&q.isInteger(j.begin.high))?"begin: integer|Long expected":j.end!=null&&j.hasOwnProperty("end")&&!(q.isInteger(j.end)||j.end&&q.isInteger(j.end.low)&&q.isInteger(j.end.high))?"end: integer|Long expected":null},b.fromObject=function(j){if(j instanceof G.onnx.TensorProto.Segment)return j;var U=new G.onnx.TensorProto.Segment;return j.begin!=null&&(q.Long?(U.begin=q.Long.fromValue(j.begin)).unsigned=!1:typeof j.begin=="string"?U.begin=parseInt(j.begin,10):typeof j.begin=="number"?U.begin=j.begin:typeof j.begin=="object"&&(U.begin=new q.LongBits(j.begin.low>>>0,j.begin.high>>>0).toNumber())),j.end!=null&&(q.Long?(U.end=q.Long.fromValue(j.end)).unsigned=!1:typeof j.end=="string"?U.end=parseInt(j.end,10):typeof j.end=="number"?U.end=j.end:typeof j.end=="object"&&(U.end=new q.LongBits(j.end.low>>>0,j.end.high>>>0).toNumber())),U},b.toObject=function(j,U){U||(U={});var J={};if(U.defaults){if(q.Long){var nt=new q.Long(0,0,!1);J.begin=U.longs===String?nt.toString():U.longs===Number?nt.toNumber():nt}else J.begin=U.longs===String?"0":0;q.Long?(nt=new q.Long(0,0,!1),J.end=U.longs===String?nt.toString():U.longs===Number?nt.toNumber():nt):J.end=U.longs===String?"0":0}return j.begin!=null&&j.hasOwnProperty("begin")&&(typeof j.begin=="number"?J.begin=U.longs===String?String(j.begin):j.begin:J.begin=U.longs===String?q.Long.prototype.toString.call(j.begin):U.longs===Number?new q.LongBits(j.begin.low>>>0,j.begin.high>>>0).toNumber():j.begin),j.end!=null&&j.hasOwnProperty("end")&&(typeof j.end=="number"?J.end=U.longs===String?String(j.end):j.end:J.end=U.longs===String?q.Long.prototype.toString.call(j.end):U.longs===Number?new q.LongBits(j.end.low>>>0,j.end.high>>>0).toNumber():j.end),J},b.prototype.toJSON=function(){return this.constructor.toObject(this,Y.util.toJSONOptions)},b}(),O.DataLocation=function(){var b={},j=Object.create(b);return j[b[0]="DEFAULT"]=0,j[b[1]="EXTERNAL"]=1,j}(),O}(),Q.TensorShapeProto=function(){function O(b){if(this.dim=[],b)for(var j=Object.keys(b),U=0;U<j.length;++U)b[j[U]]!=null&&(this[j[U]]=b[j[U]])}return O.prototype.dim=q.emptyArray,O.create=function(b){return new O(b)},O.encode=function(b,j){if(j||(j=et.create()),b.dim!=null&&b.dim.length)for(var U=0;U<b.dim.length;++U)G.onnx.TensorShapeProto.Dimension.encode(b.dim[U],j.uint32(10).fork()).ldelim();return j},O.encodeDelimited=function(b,j){return this.encode(b,j).ldelim()},O.decode=function(b,j){b instanceof tt||(b=tt.create(b));for(var U=j===void 0?b.len:b.pos+j,J=new G.onnx.TensorShapeProto;b.pos<U;){var nt=b.uint32();nt>>>3==1?(J.dim&&J.dim.length||(J.dim=[]),J.dim.push(G.onnx.TensorShapeProto.Dimension.decode(b,b.uint32()))):b.skipType(7&nt)}return J},O.decodeDelimited=function(b){return b instanceof tt||(b=new tt(b)),this.decode(b,b.uint32())},O.verify=function(b){if(typeof b!="object"||b===null)return"object expected";if(b.dim!=null&&b.hasOwnProperty("dim")){if(!Array.isArray(b.dim))return"dim: array expected";for(var j=0;j<b.dim.length;++j){var U=G.onnx.TensorShapeProto.Dimension.verify(b.dim[j]);if(U)return"dim."+U}}return null},O.fromObject=function(b){if(b instanceof G.onnx.TensorShapeProto)return b;var j=new G.onnx.TensorShapeProto;if(b.dim){if(!Array.isArray(b.dim))throw TypeError(".onnx.TensorShapeProto.dim: array expected");j.dim=[];for(var U=0;U<b.dim.length;++U){if(typeof b.dim[U]!="object")throw TypeError(".onnx.TensorShapeProto.dim: object expected");j.dim[U]=G.onnx.TensorShapeProto.Dimension.fromObject(b.dim[U])}}return j},O.toObject=function(b,j){j||(j={});var U={};if((j.arrays||j.defaults)&&(U.dim=[]),b.dim&&b.dim.length){U.dim=[];for(var J=0;J<b.dim.length;++J)U.dim[J]=G.onnx.TensorShapeProto.Dimension.toObject(b.dim[J],j)}return U},O.prototype.toJSON=function(){return this.constructor.toObject(this,Y.util.toJSONOptions)},O.Dimension=function(){function b(U){if(U)for(var J=Object.keys(U),nt=0;nt<J.length;++nt)U[J[nt]]!=null&&(this[J[nt]]=U[J[nt]])}var j;return b.prototype.dimValue=q.Long?q.Long.fromBits(0,0,!1):0,b.prototype.dimParam="",b.prototype.denotation="",Object.defineProperty(b.prototype,"value",{get:q.oneOfGetter(j=["dimValue","dimParam"]),set:q.oneOfSetter(j)}),b.create=function(U){return new b(U)},b.encode=function(U,J){return J||(J=et.create()),U.dimValue!=null&&U.hasOwnProperty("dimValue")&&J.uint32(8).int64(U.dimValue),U.dimParam!=null&&U.hasOwnProperty("dimParam")&&J.uint32(18).string(U.dimParam),U.denotation!=null&&U.hasOwnProperty("denotation")&&J.uint32(26).string(U.denotation),J},b.encodeDelimited=function(U,J){return this.encode(U,J).ldelim()},b.decode=function(U,J){U instanceof tt||(U=tt.create(U));for(var nt=J===void 0?U.len:U.pos+J,rt=new G.onnx.TensorShapeProto.Dimension;U.pos<nt;){var ot=U.uint32();switch(ot>>>3){case 1:rt.dimValue=U.int64();break;case 2:rt.dimParam=U.string();break;case 3:rt.denotation=U.string();break;default:U.skipType(7&ot)}}return rt},b.decodeDelimited=function(U){return U instanceof tt||(U=new tt(U)),this.decode(U,U.uint32())},b.verify=function(U){if(typeof U!="object"||U===null)return"object expected";var J={};if(U.dimValue!=null&&U.hasOwnProperty("dimValue")&&(J.value=1,!(q.isInteger(U.dimValue)||U.dimValue&&q.isInteger(U.dimValue.low)&&q.isInteger(U.dimValue.high))))return"dimValue: integer|Long expected";if(U.dimParam!=null&&U.hasOwnProperty("dimParam")){if(J.value===1)return"value: multiple values";if(J.value=1,!q.isString(U.dimParam))return"dimParam: string expected"}return U.denotation!=null&&U.hasOwnProperty("denotation")&&!q.isString(U.denotation)?"denotation: string expected":null},b.fromObject=function(U){if(U instanceof G.onnx.TensorShapeProto.Dimension)return U;var J=new G.onnx.TensorShapeProto.Dimension;return U.dimValue!=null&&(q.Long?(J.dimValue=q.Long.fromValue(U.dimValue)).unsigned=!1:typeof U.dimValue=="string"?J.dimValue=parseInt(U.dimValue,10):typeof U.dimValue=="number"?J.dimValue=U.dimValue:typeof U.dimValue=="object"&&(J.dimValue=new q.LongBits(U.dimValue.low>>>0,U.dimValue.high>>>0).toNumber())),U.dimParam!=null&&(J.dimParam=String(U.dimParam)),U.denotation!=null&&(J.denotation=String(U.denotation)),J},b.toObject=function(U,J){J||(J={});var nt={};return J.defaults&&(nt.denotation=""),U.dimValue!=null&&U.hasOwnProperty("dimValue")&&(typeof U.dimValue=="number"?nt.dimValue=J.longs===String?String(U.dimValue):U.dimValue:nt.dimValue=J.longs===String?q.Long.prototype.toString.call(U.dimValue):J.longs===Number?new q.LongBits(U.dimValue.low>>>0,U.dimValue.high>>>0).toNumber():U.dimValue,J.oneofs&&(nt.value="dimValue")),U.dimParam!=null&&U.hasOwnProperty("dimParam")&&(nt.dimParam=U.dimParam,J.oneofs&&(nt.value="dimParam")),U.denotation!=null&&U.hasOwnProperty("denotation")&&(nt.denotation=U.denotation),nt},b.prototype.toJSON=function(){return this.constructor.toObject(this,Y.util.toJSONOptions)},b}(),O}(),Q.TypeProto=function(){function O(j){if(j)for(var U=Object.keys(j),J=0;J<U.length;++J)j[U[J]]!=null&&(this[U[J]]=j[U[J]])}var b;return O.prototype.tensorType=null,O.prototype.denotation="",Object.defineProperty(O.prototype,"value",{get:q.oneOfGetter(b=["tensorType"]),set:q.oneOfSetter(b)}),O.create=function(j){return new O(j)},O.encode=function(j,U){return U||(U=et.create()),j.tensorType!=null&&j.hasOwnProperty("tensorType")&&G.onnx.TypeProto.Tensor.encode(j.tensorType,U.uint32(10).fork()).ldelim(),j.denotation!=null&&j.hasOwnProperty("denotation")&&U.uint32(50).string(j.denotation),U},O.encodeDelimited=function(j,U){return this.encode(j,U).ldelim()},O.decode=function(j,U){j instanceof tt||(j=tt.create(j));for(var J=U===void 0?j.len:j.pos+U,nt=new G.onnx.TypeProto;j.pos<J;){var rt=j.uint32();switch(rt>>>3){case 1:nt.tensorType=G.onnx.TypeProto.Tensor.decode(j,j.uint32());break;case 6:nt.denotation=j.string();break;default:j.skipType(7&rt)}}return nt},O.decodeDelimited=function(j){return j instanceof tt||(j=new tt(j)),this.decode(j,j.uint32())},O.verify=function(j){if(typeof j!="object"||j===null)return"object expected";if(j.tensorType!=null&&j.hasOwnProperty("tensorType")){var U=G.onnx.TypeProto.Tensor.verify(j.tensorType);if(U)return"tensorType."+U}return j.denotation!=null&&j.hasOwnProperty("denotation")&&!q.isString(j.denotation)?"denotation: string expected":null},O.fromObject=function(j){if(j instanceof G.onnx.TypeProto)return j;var U=new G.onnx.TypeProto;if(j.tensorType!=null){if(typeof j.tensorType!="object")throw TypeError(".onnx.TypeProto.tensorType: object expected");U.tensorType=G.onnx.TypeProto.Tensor.fromObject(j.tensorType)}return j.denotation!=null&&(U.denotation=String(j.denotation)),U},O.toObject=function(j,U){U||(U={});var J={};return U.defaults&&(J.denotation=""),j.tensorType!=null&&j.hasOwnProperty("tensorType")&&(J.tensorType=G.onnx.TypeProto.Tensor.toObject(j.tensorType,U),U.oneofs&&(J.value="tensorType")),j.denotation!=null&&j.hasOwnProperty("denotation")&&(J.denotation=j.denotation),J},O.prototype.toJSON=function(){return this.constructor.toObject(this,Y.util.toJSONOptions)},O.Tensor=function(){function j(U){if(U)for(var J=Object.keys(U),nt=0;nt<J.length;++nt)U[J[nt]]!=null&&(this[J[nt]]=U[J[nt]])}return j.prototype.elemType=0,j.prototype.shape=null,j.create=function(U){return new j(U)},j.encode=function(U,J){return J||(J=et.create()),U.elemType!=null&&U.hasOwnProperty("elemType")&&J.uint32(8).int32(U.elemType),U.shape!=null&&U.hasOwnProperty("shape")&&G.onnx.TensorShapeProto.encode(U.shape,J.uint32(18).fork()).ldelim(),J},j.encodeDelimited=function(U,J){return this.encode(U,J).ldelim()},j.decode=function(U,J){U instanceof tt||(U=tt.create(U));for(var nt=J===void 0?U.len:U.pos+J,rt=new G.onnx.TypeProto.Tensor;U.pos<nt;){var ot=U.uint32();switch(ot>>>3){case 1:rt.elemType=U.int32();break;case 2:rt.shape=G.onnx.TensorShapeProto.decode(U,U.uint32());break;default:U.skipType(7&ot)}}return rt},j.decodeDelimited=function(U){return U instanceof tt||(U=new tt(U)),this.decode(U,U.uint32())},j.verify=function(U){if(typeof U!="object"||U===null)return"object expected";if(U.elemType!=null&&U.hasOwnProperty("elemType")&&!q.isInteger(U.elemType))return"elemType: integer expected";if(U.shape!=null&&U.hasOwnProperty("shape")){var J=G.onnx.TensorShapeProto.verify(U.shape);if(J)return"shape."+J}return null},j.fromObject=function(U){if(U instanceof G.onnx.TypeProto.Tensor)return U;var J=new G.onnx.TypeProto.Tensor;if(U.elemType!=null&&(J.elemType=0|U.elemType),U.shape!=null){if(typeof U.shape!="object")throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");J.shape=G.onnx.TensorShapeProto.fromObject(U.shape)}return J},j.toObject=function(U,J){J||(J={});var nt={};return J.defaults&&(nt.elemType=0,nt.shape=null),U.elemType!=null&&U.hasOwnProperty("elemType")&&(nt.elemType=U.elemType),U.shape!=null&&U.hasOwnProperty("shape")&&(nt.shape=G.onnx.TensorShapeProto.toObject(U.shape,J)),nt},j.prototype.toJSON=function(){return this.constructor.toObject(this,Y.util.toJSONOptions)},j}(),O}(),Q.OperatorSetIdProto=function(){function O(b){if(b)for(var j=Object.keys(b),U=0;U<j.length;++U)b[j[U]]!=null&&(this[j[U]]=b[j[U]])}return O.prototype.domain="",O.prototype.version=q.Long?q.Long.fromBits(0,0,!1):0,O.create=function(b){return new O(b)},O.encode=function(b,j){return j||(j=et.create()),b.domain!=null&&b.hasOwnProperty("domain")&&j.uint32(10).string(b.domain),b.version!=null&&b.hasOwnProperty("version")&&j.uint32(16).int64(b.version),j},O.encodeDelimited=function(b,j){return this.encode(b,j).ldelim()},O.decode=function(b,j){b instanceof tt||(b=tt.create(b));for(var U=j===void 0?b.len:b.pos+j,J=new G.onnx.OperatorSetIdProto;b.pos<U;){var nt=b.uint32();switch(nt>>>3){case 1:J.domain=b.string();break;case 2:J.version=b.int64();break;default:b.skipType(7&nt)}}return J},O.decodeDelimited=function(b){return b instanceof tt||(b=new tt(b)),this.decode(b,b.uint32())},O.verify=function(b){return typeof b!="object"||b===null?"object expected":b.domain!=null&&b.hasOwnProperty("domain")&&!q.isString(b.domain)?"domain: string expected":b.version!=null&&b.hasOwnProperty("version")&&!(q.isInteger(b.version)||b.version&&q.isInteger(b.version.low)&&q.isInteger(b.version.high))?"version: integer|Long expected":null},O.fromObject=function(b){if(b instanceof G.onnx.OperatorSetIdProto)return b;var j=new G.onnx.OperatorSetIdProto;return b.domain!=null&&(j.domain=String(b.domain)),b.version!=null&&(q.Long?(j.version=q.Long.fromValue(b.version)).unsigned=!1:typeof b.version=="string"?j.version=parseInt(b.version,10):typeof b.version=="number"?j.version=b.version:typeof b.version=="object"&&(j.version=new q.LongBits(b.version.low>>>0,b.version.high>>>0).toNumber())),j},O.toObject=function(b,j){j||(j={});var U={};if(j.defaults)if(U.domain="",q.Long){var J=new q.Long(0,0,!1);U.version=j.longs===String?J.toString():j.longs===Number?J.toNumber():J}else U.version=j.longs===String?"0":0;return b.domain!=null&&b.hasOwnProperty("domain")&&(U.domain=b.domain),b.version!=null&&b.hasOwnProperty("version")&&(typeof b.version=="number"?U.version=j.longs===String?String(b.version):b.version:U.version=j.longs===String?q.Long.prototype.toString.call(b.version):j.longs===Number?new q.LongBits(b.version.low>>>0,b.version.high>>>0).toNumber():b.version),U},O.prototype.toJSON=function(){return this.constructor.toObject(this,Y.util.toJSONOptions)},O}(),Q),it.exports=G},2100:(it,F,W)=>{it.exports=W(9482)},9482:(it,F,W)=>{var X=F;function K(){X.util._configure(),X.Writer._configure(X.BufferWriter),X.Reader._configure(X.BufferReader)}X.build="minimal",X.Writer=W(1173),X.BufferWriter=W(3155),X.Reader=W(1408),X.BufferReader=W(593),X.util=W(9693),X.rpc=W(5994),X.roots=W(5054),X.configure=K,K()},1408:(it,F,W)=>{it.exports=et;var X,K=W(9693),Q=K.LongBits,Y=K.utf8;function tt(J,nt){return RangeError("index out of range: "+J.pos+" + "+(nt||1)+" > "+J.len)}function et(J){this.buf=J,this.pos=0,this.len=J.length}var q,G=typeof Uint8Array<"u"?function(J){if(J instanceof Uint8Array||Array.isArray(J))return new et(J);throw Error("illegal buffer")}:function(J){if(Array.isArray(J))return new et(J);throw Error("illegal buffer")},O=function(){return K.Buffer?function(J){return(et.create=function(nt){return K.Buffer.isBuffer(nt)?new X(nt):G(nt)})(J)}:G};function b(){var J=new Q(0,0),nt=0;if(!(this.len-this.pos>4)){for(;nt<3;++nt){if(this.pos>=this.len)throw tt(this);if(J.lo=(J.lo|(127&this.buf[this.pos])<<7*nt)>>>0,this.buf[this.pos++]<128)return J}return J.lo=(J.lo|(127&this.buf[this.pos++])<<7*nt)>>>0,J}for(;nt<4;++nt)if(J.lo=(J.lo|(127&this.buf[this.pos])<<7*nt)>>>0,this.buf[this.pos++]<128)return J;if(J.lo=(J.lo|(127&this.buf[this.pos])<<28)>>>0,J.hi=(J.hi|(127&this.buf[this.pos])>>4)>>>0,this.buf[this.pos++]<128)return J;if(nt=0,this.len-this.pos>4){for(;nt<5;++nt)if(J.hi=(J.hi|(127&this.buf[this.pos])<<7*nt+3)>>>0,this.buf[this.pos++]<128)return J}else for(;nt<5;++nt){if(this.pos>=this.len)throw tt(this);if(J.hi=(J.hi|(127&this.buf[this.pos])<<7*nt+3)>>>0,this.buf[this.pos++]<128)return J}throw Error("invalid varint encoding")}function j(J,nt){return(J[nt-4]|J[nt-3]<<8|J[nt-2]<<16|J[nt-1]<<24)>>>0}function U(){if(this.pos+8>this.len)throw tt(this,8);return new Q(j(this.buf,this.pos+=4),j(this.buf,this.pos+=4))}et.create=O(),et.prototype._slice=K.Array.prototype.subarray||K.Array.prototype.slice,et.prototype.uint32=(q=4294967295,function(){if(q=(127&this.buf[this.pos])>>>0,this.buf[this.pos++]<128||(q=(q|(127&this.buf[this.pos])<<7)>>>0,this.buf[this.pos++]<128)||(q=(q|(127&this.buf[this.pos])<<14)>>>0,this.buf[this.pos++]<128)||(q=(q|(127&this.buf[this.pos])<<21)>>>0,this.buf[this.pos++]<128)||(q=(q|(15&this.buf[this.pos])<<28)>>>0,this.buf[this.pos++]<128))return q;if((this.pos+=5)>this.len)throw this.pos=this.len,tt(this,10);return q}),et.prototype.int32=function(){return 0|this.uint32()},et.prototype.sint32=function(){var J=this.uint32();return J>>>1^-(1&J)|0},et.prototype.bool=function(){return this.uint32()!==0},et.prototype.fixed32=function(){if(this.pos+4>this.len)throw tt(this,4);return j(this.buf,this.pos+=4)},et.prototype.sfixed32=function(){if(this.pos+4>this.len)throw tt(this,4);return 0|j(this.buf,this.pos+=4)},et.prototype.float=function(){if(this.pos+4>this.len)throw tt(this,4);var J=K.float.readFloatLE(this.buf,this.pos);return this.pos+=4,J},et.prototype.double=function(){if(this.pos+8>this.len)throw tt(this,4);var J=K.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,J},et.prototype.bytes=function(){var J=this.uint32(),nt=this.pos,rt=this.pos+J;if(rt>this.len)throw tt(this,J);return this.pos+=J,Array.isArray(this.buf)?this.buf.slice(nt,rt):nt===rt?new this.buf.constructor(0):this._slice.call(this.buf,nt,rt)},et.prototype.string=function(){var J=this.bytes();return Y.read(J,0,J.length)},et.prototype.skip=function(J){if(typeof J=="number"){if(this.pos+J>this.len)throw tt(this,J);this.pos+=J}else do if(this.pos>=this.len)throw tt(this);while(128&this.buf[this.pos++]);return this},et.prototype.skipType=function(J){switch(J){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(J=7&this.uint32())!=4;)this.skipType(J);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+J+" at offset "+this.pos)}return this},et._configure=function(J){X=J,et.create=O(),X._configure();var nt=K.Long?"toLong":"toNumber";K.merge(et.prototype,{int64:function(){return b.call(this)[nt](!1)},uint64:function(){return b.call(this)[nt](!0)},sint64:function(){return b.call(this).zzDecode()[nt](!1)},fixed64:function(){return U.call(this)[nt](!0)},sfixed64:function(){return U.call(this)[nt](!1)}})}},593:(it,F,W)=>{it.exports=Q;var X=W(1408);(Q.prototype=Object.create(X.prototype)).constructor=Q;var K=W(9693);function Q(Y){X.call(this,Y)}Q._configure=function(){K.Buffer&&(Q.prototype._slice=K.Buffer.prototype.slice)},Q.prototype.string=function(){var Y=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+Y,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+Y,this.len))},Q._configure()},5054:it=>{it.exports={}},5994:(it,F,W)=>{F.Service=W(7948)},7948:(it,F,W)=>{it.exports=K;var X=W(9693);function K(Q,Y,tt){if(typeof Q!="function")throw TypeError("rpcImpl must be a function");X.EventEmitter.call(this),this.rpcImpl=Q,this.requestDelimited=!!Y,this.responseDelimited=!!tt}(K.prototype=Object.create(X.EventEmitter.prototype)).constructor=K,K.prototype.rpcCall=function Q(Y,tt,et,q,G){if(!q)throw TypeError("request must be specified");var O=this;if(!G)return X.asPromise(Q,O,Y,tt,et,q);if(O.rpcImpl)try{return O.rpcImpl(Y,tt[O.requestDelimited?"encodeDelimited":"encode"](q).finish(),function(b,j){if(b)return O.emit("error",b,Y),G(b);if(j!==null){if(!(j instanceof et))try{j=et[O.responseDelimited?"decodeDelimited":"decode"](j)}catch(U){return O.emit("error",U,Y),G(U)}return O.emit("data",j,Y),G(null,j)}O.end(!0)})}catch(b){return O.emit("error",b,Y),void setTimeout(function(){G(b)},0)}else setTimeout(function(){G(Error("already ended"))},0)},K.prototype.end=function(Q){return this.rpcImpl&&(Q||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this}},1945:(it,F,W)=>{it.exports=K;var X=W(9693);function K(et,q){this.lo=et>>>0,this.hi=q>>>0}var Q=K.zero=new K(0,0);Q.toNumber=function(){return 0},Q.zzEncode=Q.zzDecode=function(){return this},Q.length=function(){return 1};var Y=K.zeroHash="\0\0\0\0\0\0\0\0";K.fromNumber=function(et){if(et===0)return Q;var q=et<0;q&&(et=-et);var G=et>>>0,O=(et-G)/4294967296>>>0;return q&&(O=~O>>>0,G=~G>>>0,++G>4294967295&&(G=0,++O>4294967295&&(O=0))),new K(G,O)},K.from=function(et){if(typeof et=="number")return K.fromNumber(et);if(X.isString(et)){if(!X.Long)return K.fromNumber(parseInt(et,10));et=X.Long.fromString(et)}return et.low||et.high?new K(et.low>>>0,et.high>>>0):Q},K.prototype.toNumber=function(et){if(!et&&this.hi>>>31){var q=1+~this.lo>>>0,G=~this.hi>>>0;return q||(G=G+1>>>0),-(q+4294967296*G)}return this.lo+4294967296*this.hi},K.prototype.toLong=function(et){return X.Long?new X.Long(0|this.lo,0|this.hi,!!et):{low:0|this.lo,high:0|this.hi,unsigned:!!et}};var tt=String.prototype.charCodeAt;K.fromHash=function(et){return et===Y?Q:new K((tt.call(et,0)|tt.call(et,1)<<8|tt.call(et,2)<<16|tt.call(et,3)<<24)>>>0,(tt.call(et,4)|tt.call(et,5)<<8|tt.call(et,6)<<16|tt.call(et,7)<<24)>>>0)},K.prototype.toHash=function(){return String.fromCharCode(255&this.lo,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,255&this.hi,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},K.prototype.zzEncode=function(){var et=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^et)>>>0,this.lo=(this.lo<<1^et)>>>0,this},K.prototype.zzDecode=function(){var et=-(1&this.lo);return this.lo=((this.lo>>>1|this.hi<<31)^et)>>>0,this.hi=(this.hi>>>1^et)>>>0,this},K.prototype.length=function(){var et=this.lo,q=(this.lo>>>28|this.hi<<4)>>>0,G=this.hi>>>24;return G===0?q===0?et<16384?et<128?1:2:et<2097152?3:4:q<16384?q<128?5:6:q<2097152?7:8:G<128?9:10}},9693:function(it,F,W){var X=F;function K(Y,tt,et){for(var q=Object.keys(tt),G=0;G<q.length;++G)Y[q[G]]!==void 0&&et||(Y[q[G]]=tt[q[G]]);return Y}function Q(Y){function tt(et,q){if(!(this instanceof tt))return new tt(et,q);Object.defineProperty(this,"message",{get:function(){return et}}),Error.captureStackTrace?Error.captureStackTrace(this,tt):Object.defineProperty(this,"stack",{value:new Error().stack||""}),q&&K(this,q)}return(tt.prototype=Object.create(Error.prototype)).constructor=tt,Object.defineProperty(tt.prototype,"name",{get:function(){return Y}}),tt.prototype.toString=function(){return this.name+": "+this.message},tt}X.asPromise=W(4537),X.base64=W(7419),X.EventEmitter=W(9211),X.float=W(945),X.inquire=W(7199),X.utf8=W(4997),X.pool=W(6662),X.LongBits=W(1945),X.isNode=!!(W.g!==void 0&&W.g&&W.g.process&&W.g.process.versions&&W.g.process.versions.node),X.global=X.isNode&&W.g||typeof window<"u"&&window||typeof self<"u"&&self||this,X.emptyArray=Object.freeze?Object.freeze([]):[],X.emptyObject=Object.freeze?Object.freeze({}):{},X.isInteger=Number.isInteger||function(Y){return typeof Y=="number"&&isFinite(Y)&&Math.floor(Y)===Y},X.isString=function(Y){return typeof Y=="string"||Y instanceof String},X.isObject=function(Y){return Y&&typeof Y=="object"},X.isset=X.isSet=function(Y,tt){var et=Y[tt];return!(et==null||!Y.hasOwnProperty(tt))&&(typeof et!="object"||(Array.isArray(et)?et.length:Object.keys(et).length)>0)},X.Buffer=function(){try{var Y=X.inquire("buffer").Buffer;return Y.prototype.utf8Write?Y:null}catch{return null}}(),X._Buffer_from=null,X._Buffer_allocUnsafe=null,X.newBuffer=function(Y){return typeof Y=="number"?X.Buffer?X._Buffer_allocUnsafe(Y):new X.Array(Y):X.Buffer?X._Buffer_from(Y):typeof Uint8Array>"u"?Y:new Uint8Array(Y)},X.Array=typeof Uint8Array<"u"?Uint8Array:Array,X.Long=X.global.dcodeIO&&X.global.dcodeIO.Long||X.global.Long||X.inquire("long"),X.key2Re=/^true|false|0|1$/,X.key32Re=/^-?(?:0|[1-9][0-9]*)$/,X.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,X.longToHash=function(Y){return Y?X.LongBits.from(Y).toHash():X.LongBits.zeroHash},X.longFromHash=function(Y,tt){var et=X.LongBits.fromHash(Y);return X.Long?X.Long.fromBits(et.lo,et.hi,tt):et.toNumber(!!tt)},X.merge=K,X.lcFirst=function(Y){return Y.charAt(0).toLowerCase()+Y.substring(1)},X.newError=Q,X.ProtocolError=Q("ProtocolError"),X.oneOfGetter=function(Y){for(var tt={},et=0;et<Y.length;++et)tt[Y[et]]=1;return function(){for(var q=Object.keys(this),G=q.length-1;G>-1;--G)if(tt[q[G]]===1&&this[q[G]]!==void 0&&this[q[G]]!==null)return q[G]}},X.oneOfSetter=function(Y){return function(tt){for(var et=0;et<Y.length;++et)Y[et]!==tt&&delete this[Y[et]]}},X.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},X._configure=function(){var Y=X.Buffer;Y?(X._Buffer_from=Y.from!==Uint8Array.from&&Y.from||function(tt,et){return new Y(tt,et)},X._Buffer_allocUnsafe=Y.allocUnsafe||function(tt){return new Y(tt)}):X._Buffer_from=X._Buffer_allocUnsafe=null}},1173:(it,F,W)=>{it.exports=O;var X,K=W(9693),Q=K.LongBits,Y=K.base64,tt=K.utf8;function et(ot,at,ut){this.fn=ot,this.len=at,this.next=void 0,this.val=ut}function q(){}function G(ot){this.head=ot.head,this.tail=ot.tail,this.len=ot.len,this.next=ot.states}function O(){this.len=0,this.head=new et(q,0,0),this.tail=this.head,this.states=null}var b=function(){return K.Buffer?function(){return(O.create=function(){return new X})()}:function(){return new O}};function j(ot,at,ut){at[ut]=255&ot}function U(ot,at){this.len=ot,this.next=void 0,this.val=at}function J(ot,at,ut){for(;ot.hi;)at[ut++]=127&ot.lo|128,ot.lo=(ot.lo>>>7|ot.hi<<25)>>>0,ot.hi>>>=7;for(;ot.lo>127;)at[ut++]=127&ot.lo|128,ot.lo=ot.lo>>>7;at[ut++]=ot.lo}function nt(ot,at,ut){at[ut]=255&ot,at[ut+1]=ot>>>8&255,at[ut+2]=ot>>>16&255,at[ut+3]=ot>>>24}O.create=b(),O.alloc=function(ot){return new K.Array(ot)},K.Array!==Array&&(O.alloc=K.pool(O.alloc,K.Array.prototype.subarray)),O.prototype._push=function(ot,at,ut){return this.tail=this.tail.next=new et(ot,at,ut),this.len+=at,this},U.prototype=Object.create(et.prototype),U.prototype.fn=function(ot,at,ut){for(;ot>127;)at[ut++]=127&ot|128,ot>>>=7;at[ut]=ot},O.prototype.uint32=function(ot){return this.len+=(this.tail=this.tail.next=new U((ot>>>=0)<128?1:ot<16384?2:ot<2097152?3:ot<268435456?4:5,ot)).len,this},O.prototype.int32=function(ot){return ot<0?this._push(J,10,Q.fromNumber(ot)):this.uint32(ot)},O.prototype.sint32=function(ot){return this.uint32((ot<<1^ot>>31)>>>0)},O.prototype.uint64=function(ot){var at=Q.from(ot);return this._push(J,at.length(),at)},O.prototype.int64=O.prototype.uint64,O.prototype.sint64=function(ot){var at=Q.from(ot).zzEncode();return this._push(J,at.length(),at)},O.prototype.bool=function(ot){return this._push(j,1,ot?1:0)},O.prototype.fixed32=function(ot){return this._push(nt,4,ot>>>0)},O.prototype.sfixed32=O.prototype.fixed32,O.prototype.fixed64=function(ot){var at=Q.from(ot);return this._push(nt,4,at.lo)._push(nt,4,at.hi)},O.prototype.sfixed64=O.prototype.fixed64,O.prototype.float=function(ot){return this._push(K.float.writeFloatLE,4,ot)},O.prototype.double=function(ot){return this._push(K.float.writeDoubleLE,8,ot)};var rt=K.Array.prototype.set?function(ot,at,ut){at.set(ot,ut)}:function(ot,at,ut){for(var st=0;st<ot.length;++st)at[ut+st]=ot[st]};O.prototype.bytes=function(ot){var at=ot.length>>>0;if(!at)return this._push(j,1,0);if(K.isString(ot)){var ut=O.alloc(at=Y.length(ot));Y.decode(ot,ut,0),ot=ut}return this.uint32(at)._push(rt,at,ot)},O.prototype.string=function(ot){var at=tt.length(ot);return at?this.uint32(at)._push(tt.write,at,ot):this._push(j,1,0)},O.prototype.fork=function(){return this.states=new G(this),this.head=this.tail=new et(q,0,0),this.len=0,this},O.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new et(q,0,0),this.len=0),this},O.prototype.ldelim=function(){var ot=this.head,at=this.tail,ut=this.len;return this.reset().uint32(ut),ut&&(this.tail.next=ot.next,this.tail=at,this.len+=ut),this},O.prototype.finish=function(){for(var ot=this.head.next,at=this.constructor.alloc(this.len),ut=0;ot;)ot.fn(ot.val,at,ut),ut+=ot.len,ot=ot.next;return at},O._configure=function(ot){X=ot,O.create=b(),X._configure()}},3155:(it,F,W)=>{it.exports=Q;var X=W(1173);(Q.prototype=Object.create(X.prototype)).constructor=Q;var K=W(9693);function Q(){X.call(this)}function Y(tt,et,q){tt.length<40?K.utf8.write(tt,et,q):et.utf8Write?et.utf8Write(tt,q):et.write(tt,q)}Q._configure=function(){Q.alloc=K._Buffer_allocUnsafe,Q.writeBytesBuffer=K.Buffer&&K.Buffer.prototype instanceof Uint8Array&&K.Buffer.prototype.set.name==="set"?function(tt,et,q){et.set(tt,q)}:function(tt,et,q){if(tt.copy)tt.copy(et,q,0,tt.length);else for(var G=0;G<tt.length;)et[q++]=tt[G++]}},Q.prototype.bytes=function(tt){K.isString(tt)&&(tt=K._Buffer_from(tt,"base64"));var et=tt.length>>>0;return this.uint32(et),et&&this._push(Q.writeBytesBuffer,et,tt),this},Q.prototype.string=function(tt){var et=K.Buffer.byteLength(tt);return this.uint32(et),et&&this._push(Y,et,tt),this},Q._configure()},4154:it=>{it.exports=`"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};
`},7067:()=>{},1296:()=>{},760:()=>{},1384:()=>{},3993:()=>{},908:()=>{},6953:()=>{},9925:()=>{},2806:()=>{},6449:()=>{},2850:()=>{},5381:()=>{},5686:(it,F,W)=>{W.r(F),W.d(F,{flatbuffers:()=>X});var X={};X.Offset,X.Table,X.SIZEOF_SHORT=2,X.SIZEOF_INT=4,X.FILE_IDENTIFIER_LENGTH=4,X.SIZE_PREFIX_LENGTH=4,X.Encoding={UTF8_BYTES:1,UTF16_STRING:2},X.int32=new Int32Array(2),X.float32=new Float32Array(X.int32.buffer),X.float64=new Float64Array(X.int32.buffer),X.isLittleEndian=new Uint16Array(new Uint8Array([1,0]).buffer)[0]===1,X.Long=function(K,Q){this.low=0|K,this.high=0|Q},X.Long.create=function(K,Q){return K==0&&Q==0?X.Long.ZERO:new X.Long(K,Q)},X.Long.prototype.toFloat64=function(){return(this.low>>>0)+4294967296*this.high},X.Long.prototype.equals=function(K){return this.low==K.low&&this.high==K.high},X.Long.ZERO=new X.Long(0,0),X.Builder=function(K){if(K)Q=K;else var Q=1024;this.bb=X.ByteBuffer.allocate(Q),this.space=Q,this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},X.Builder.prototype.clear=function(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},X.Builder.prototype.forceDefaults=function(K){this.force_defaults=K},X.Builder.prototype.dataBuffer=function(){return this.bb},X.Builder.prototype.asUint8Array=function(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())},X.Builder.prototype.prep=function(K,Q){K>this.minalign&&(this.minalign=K);for(var Y=1+~(this.bb.capacity()-this.space+Q)&K-1;this.space<Y+K+Q;){var tt=this.bb.capacity();this.bb=X.Builder.growByteBuffer(this.bb),this.space+=this.bb.capacity()-tt}this.pad(Y)},X.Builder.prototype.pad=function(K){for(var Q=0;Q<K;Q++)this.bb.writeInt8(--this.space,0)},X.Builder.prototype.writeInt8=function(K){this.bb.writeInt8(this.space-=1,K)},X.Builder.prototype.writeInt16=function(K){this.bb.writeInt16(this.space-=2,K)},X.Builder.prototype.writeInt32=function(K){this.bb.writeInt32(this.space-=4,K)},X.Builder.prototype.writeInt64=function(K){this.bb.writeInt64(this.space-=8,K)},X.Builder.prototype.writeFloat32=function(K){this.bb.writeFloat32(this.space-=4,K)},X.Builder.prototype.writeFloat64=function(K){this.bb.writeFloat64(this.space-=8,K)},X.Builder.prototype.addInt8=function(K){this.prep(1,0),this.writeInt8(K)},X.Builder.prototype.addInt16=function(K){this.prep(2,0),this.writeInt16(K)},X.Builder.prototype.addInt32=function(K){this.prep(4,0),this.writeInt32(K)},X.Builder.prototype.addInt64=function(K){this.prep(8,0),this.writeInt64(K)},X.Builder.prototype.addFloat32=function(K){this.prep(4,0),this.writeFloat32(K)},X.Builder.prototype.addFloat64=function(K){this.prep(8,0),this.writeFloat64(K)},X.Builder.prototype.addFieldInt8=function(K,Q,Y){(this.force_defaults||Q!=Y)&&(this.addInt8(Q),this.slot(K))},X.Builder.prototype.addFieldInt16=function(K,Q,Y){(this.force_defaults||Q!=Y)&&(this.addInt16(Q),this.slot(K))},X.Builder.prototype.addFieldInt32=function(K,Q,Y){(this.force_defaults||Q!=Y)&&(this.addInt32(Q),this.slot(K))},X.Builder.prototype.addFieldInt64=function(K,Q,Y){!this.force_defaults&&Q.equals(Y)||(this.addInt64(Q),this.slot(K))},X.Builder.prototype.addFieldFloat32=function(K,Q,Y){(this.force_defaults||Q!=Y)&&(this.addFloat32(Q),this.slot(K))},X.Builder.prototype.addFieldFloat64=function(K,Q,Y){(this.force_defaults||Q!=Y)&&(this.addFloat64(Q),this.slot(K))},X.Builder.prototype.addFieldOffset=function(K,Q,Y){(this.force_defaults||Q!=Y)&&(this.addOffset(Q),this.slot(K))},X.Builder.prototype.addFieldStruct=function(K,Q,Y){Q!=Y&&(this.nested(Q),this.slot(K))},X.Builder.prototype.nested=function(K){if(K!=this.offset())throw new Error("FlatBuffers: struct must be serialized inline.")},X.Builder.prototype.notNested=function(){if(this.isNested)throw new Error("FlatBuffers: object serialization must not be nested.")},X.Builder.prototype.slot=function(K){this.vtable[K]=this.offset()},X.Builder.prototype.offset=function(){return this.bb.capacity()-this.space},X.Builder.growByteBuffer=function(K){var Q=K.capacity();if(3221225472&Q)throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");var Y=Q<<1,tt=X.ByteBuffer.allocate(Y);return tt.setPosition(Y-Q),tt.bytes().set(K.bytes(),Y-Q),tt},X.Builder.prototype.addOffset=function(K){this.prep(X.SIZEOF_INT,0),this.writeInt32(this.offset()-K+X.SIZEOF_INT)},X.Builder.prototype.startObject=function(K){this.notNested(),this.vtable==null&&(this.vtable=[]),this.vtable_in_use=K;for(var Q=0;Q<K;Q++)this.vtable[Q]=0;this.isNested=!0,this.object_start=this.offset()},X.Builder.prototype.endObject=function(){if(this.vtable==null||!this.isNested)throw new Error("FlatBuffers: endObject called without startObject");this.addInt32(0);for(var K=this.offset(),Q=this.vtable_in_use-1;Q>=0&&this.vtable[Q]==0;Q--);for(var Y=Q+1;Q>=0;Q--)this.addInt16(this.vtable[Q]!=0?K-this.vtable[Q]:0);this.addInt16(K-this.object_start);var tt=(Y+2)*X.SIZEOF_SHORT;this.addInt16(tt);var et=0,q=this.space;t:for(Q=0;Q<this.vtables.length;Q++){var G=this.bb.capacity()-this.vtables[Q];if(tt==this.bb.readInt16(G)){for(var O=X.SIZEOF_SHORT;O<tt;O+=X.SIZEOF_SHORT)if(this.bb.readInt16(q+O)!=this.bb.readInt16(G+O))continue t;et=this.vtables[Q];break}}return et?(this.space=this.bb.capacity()-K,this.bb.writeInt32(this.space,et-K)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-K,this.offset()-K)),this.isNested=!1,K},X.Builder.prototype.finish=function(K,Q,Y){var tt=Y?X.SIZE_PREFIX_LENGTH:0;if(Q){var et=Q;if(this.prep(this.minalign,X.SIZEOF_INT+X.FILE_IDENTIFIER_LENGTH+tt),et.length!=X.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+X.FILE_IDENTIFIER_LENGTH);for(var q=X.FILE_IDENTIFIER_LENGTH-1;q>=0;q--)this.writeInt8(et.charCodeAt(q))}this.prep(this.minalign,X.SIZEOF_INT+tt),this.addOffset(K),tt&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)},X.Builder.prototype.finishSizePrefixed=function(K,Q){this.finish(K,Q,!0)},X.Builder.prototype.requiredField=function(K,Q){var Y=this.bb.capacity()-K,tt=Y-this.bb.readInt32(Y);if(this.bb.readInt16(tt+Q)==0)throw new Error("FlatBuffers: field "+Q+" must be set")},X.Builder.prototype.startVector=function(K,Q,Y){this.notNested(),this.vector_num_elems=Q,this.prep(X.SIZEOF_INT,K*Q),this.prep(Y,K*Q)},X.Builder.prototype.endVector=function(){return this.writeInt32(this.vector_num_elems),this.offset()},X.Builder.prototype.createString=function(K){if(K instanceof Uint8Array)var Q=K;else{Q=[];for(var Y=0;Y<K.length;){var tt,et=K.charCodeAt(Y++);(tt=et<55296||et>=56320?et:(et<<10)+K.charCodeAt(Y++)+-56613888)<128?Q.push(tt):(tt<2048?Q.push(tt>>6&31|192):(tt<65536?Q.push(tt>>12&15|224):Q.push(tt>>18&7|240,tt>>12&63|128),Q.push(tt>>6&63|128)),Q.push(63&tt|128))}}this.addInt8(0),this.startVector(1,Q.length,1),this.bb.setPosition(this.space-=Q.length),Y=0;for(var q=this.space,G=this.bb.bytes();Y<Q.length;Y++)G[q++]=Q[Y];return this.endVector()},X.Builder.prototype.createLong=function(K,Q){return X.Long.create(K,Q)},X.ByteBuffer=function(K){this.bytes_=K,this.position_=0},X.ByteBuffer.allocate=function(K){return new X.ByteBuffer(new Uint8Array(K))},X.ByteBuffer.prototype.clear=function(){this.position_=0},X.ByteBuffer.prototype.bytes=function(){return this.bytes_},X.ByteBuffer.prototype.position=function(){return this.position_},X.ByteBuffer.prototype.setPosition=function(K){this.position_=K},X.ByteBuffer.prototype.capacity=function(){return this.bytes_.length},X.ByteBuffer.prototype.readInt8=function(K){return this.readUint8(K)<<24>>24},X.ByteBuffer.prototype.readUint8=function(K){return this.bytes_[K]},X.ByteBuffer.prototype.readInt16=function(K){return this.readUint16(K)<<16>>16},X.ByteBuffer.prototype.readUint16=function(K){return this.bytes_[K]|this.bytes_[K+1]<<8},X.ByteBuffer.prototype.readInt32=function(K){return this.bytes_[K]|this.bytes_[K+1]<<8|this.bytes_[K+2]<<16|this.bytes_[K+3]<<24},X.ByteBuffer.prototype.readUint32=function(K){return this.readInt32(K)>>>0},X.ByteBuffer.prototype.readInt64=function(K){return new X.Long(this.readInt32(K),this.readInt32(K+4))},X.ByteBuffer.prototype.readUint64=function(K){return new X.Long(this.readUint32(K),this.readUint32(K+4))},X.ByteBuffer.prototype.readFloat32=function(K){return X.int32[0]=this.readInt32(K),X.float32[0]},X.ByteBuffer.prototype.readFloat64=function(K){return X.int32[X.isLittleEndian?0:1]=this.readInt32(K),X.int32[X.isLittleEndian?1:0]=this.readInt32(K+4),X.float64[0]},X.ByteBuffer.prototype.writeInt8=function(K,Q){this.bytes_[K]=Q},X.ByteBuffer.prototype.writeUint8=function(K,Q){this.bytes_[K]=Q},X.ByteBuffer.prototype.writeInt16=function(K,Q){this.bytes_[K]=Q,this.bytes_[K+1]=Q>>8},X.ByteBuffer.prototype.writeUint16=function(K,Q){this.bytes_[K]=Q,this.bytes_[K+1]=Q>>8},X.ByteBuffer.prototype.writeInt32=function(K,Q){this.bytes_[K]=Q,this.bytes_[K+1]=Q>>8,this.bytes_[K+2]=Q>>16,this.bytes_[K+3]=Q>>24},X.ByteBuffer.prototype.writeUint32=function(K,Q){this.bytes_[K]=Q,this.bytes_[K+1]=Q>>8,this.bytes_[K+2]=Q>>16,this.bytes_[K+3]=Q>>24},X.ByteBuffer.prototype.writeInt64=function(K,Q){this.writeInt32(K,Q.low),this.writeInt32(K+4,Q.high)},X.ByteBuffer.prototype.writeUint64=function(K,Q){this.writeUint32(K,Q.low),this.writeUint32(K+4,Q.high)},X.ByteBuffer.prototype.writeFloat32=function(K,Q){X.float32[0]=Q,this.writeInt32(K,X.int32[0])},X.ByteBuffer.prototype.writeFloat64=function(K,Q){X.float64[0]=Q,this.writeInt32(K,X.int32[X.isLittleEndian?0:1]),this.writeInt32(K+4,X.int32[X.isLittleEndian?1:0])},X.ByteBuffer.prototype.getBufferIdentifier=function(){if(this.bytes_.length<this.position_+X.SIZEOF_INT+X.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");for(var K="",Q=0;Q<X.FILE_IDENTIFIER_LENGTH;Q++)K+=String.fromCharCode(this.readInt8(this.position_+X.SIZEOF_INT+Q));return K},X.ByteBuffer.prototype.__offset=function(K,Q){var Y=K-this.readInt32(K);return Q<this.readInt16(Y)?this.readInt16(Y+Q):0},X.ByteBuffer.prototype.__union=function(K,Q){return K.bb_pos=Q+this.readInt32(Q),K.bb=this,K},X.ByteBuffer.prototype.__string=function(K,Q){K+=this.readInt32(K);var Y=this.readInt32(K),tt="",et=0;if(K+=X.SIZEOF_INT,Q===X.Encoding.UTF8_BYTES)return this.bytes_.subarray(K,K+Y);for(;et<Y;){var q,G=this.readUint8(K+et++);if(G<192)q=G;else{var O=this.readUint8(K+et++);if(G<224)q=(31&G)<<6|63&O;else{var b=this.readUint8(K+et++);q=G<240?(15&G)<<12|(63&O)<<6|63&b:(7&G)<<18|(63&O)<<12|(63&b)<<6|63&this.readUint8(K+et++)}}q<65536?tt+=String.fromCharCode(q):(q-=65536,tt+=String.fromCharCode(55296+(q>>10),56320+(1023&q)))}return tt},X.ByteBuffer.prototype.__indirect=function(K){return K+this.readInt32(K)},X.ByteBuffer.prototype.__vector=function(K){return K+this.readInt32(K)+X.SIZEOF_INT},X.ByteBuffer.prototype.__vector_len=function(K){return this.readInt32(K+this.readInt32(K))},X.ByteBuffer.prototype.__has_identifier=function(K){if(K.length!=X.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+X.FILE_IDENTIFIER_LENGTH);for(var Q=0;Q<X.FILE_IDENTIFIER_LENGTH;Q++)if(K.charCodeAt(Q)!=this.readInt8(this.position_+X.SIZEOF_INT+Q))return!1;return!0},X.ByteBuffer.prototype.createLong=function(K,Q){return X.Long.create(K,Q)}}},__webpack_module_cache__={};function __webpack_require__(it){var F=__webpack_module_cache__[it];if(F!==void 0)return F.exports;var W=__webpack_module_cache__[it]={exports:{}};return __webpack_modules__[it].call(W.exports,W,W.exports,__webpack_require__),W.exports}__webpack_require__.n=it=>{var F=it&&it.__esModule?()=>it.default:()=>it;return __webpack_require__.d(F,{a:F}),F},__webpack_require__.d=(it,F)=>{for(var W in F)__webpack_require__.o(F,W)&&!__webpack_require__.o(it,W)&&Object.defineProperty(it,W,{enumerable:!0,get:F[W]})},__webpack_require__.g=function(){if(typeof globalThis=="object")return globalThis;try{return this||new Function("return this")()}catch{if(typeof window=="object")return window}}(),__webpack_require__.o=(it,F)=>Object.prototype.hasOwnProperty.call(it,F),__webpack_require__.r=it=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(it,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(it,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__(1057);return __webpack_exports__})())})(ort_min);var ort_minExports=ort_min.exports,__defProp$4=Object.defineProperty,__getOwnPropDesc$4=Object.getOwnPropertyDescriptor,__decorateClass$4=(it,F,W,X)=>{for(var K=X>1?void 0:X?__getOwnPropDesc$4(F,W):F,Q=it.length-1,Y;Q>=0;Q--)(Y=it[Q])&&(K=(X?Y(F,W,K):Y(K))||K);return X&&K&&__defProp$4(F,W,K),K};let OnnxModel=class extends s{constructor(){super(...arguments),this.isRunning=!1}firstUpdated(){const{width:it}=document.body.getBoundingClientRect();it<=390?this.scale=it/this.width:this.scale=390/this.width,ort_minExports.env.wasm.wasmPaths="./"}render(){return x`
            ${this.renderInferenceTime()}
            <div class="media">
                <canvas
                    class=${this.isComputed?"":"hidden"}
                    style="width:${this.width}px; height:${this.height}px;transform: scale(${this.scale})"
                >
                </canvas>
                <slot
                    class=${this.isComputed?"hidden":""}
                    name="media"
                >
                </slot>
            </div>
            <wli-onnx-actions
                mode=${this.mode}
                ?disabled=${!this.isReady}
                @wli-onnx-actions-start=${this.handleStart}
                @wli-onnx-actions-stop=${this.handleStop}
                @wli-onnx-actions-back=${this.handleStop}
                @wli-onnx-actions-record=${this.handleRecord}
                @wli-onnx-actions-upload=${this.handleUpload}
            >
            </wli-onnx-actions>
            <input
                class="hidden"
                type="file"
                accept="image/*"
                @change=${this.imageUpdated}
            />
        `}renderInferenceTime(){return this.isRunning?x`
                <div class="inference">
                    <p>${this.inferenceTime} ms</p>
                </div>
            `:x``}connectedCallback(){super.connectedCallback(),this.addEventListener("wli-webcam-stream",this.handleStream)}disconnectedCallback(){super.disconnectedCallback(),this.removeEventListener("wli-webcam-stream",this.handleStream)}handleStream(it){this.isComputed=!1,this.stream=it.detail;const W=this.stream.getVideoTracks()[0];this.imageCapture=new ImageCapture(W),this.initInference()}handleStart(){this.isRunning=!0,this.preRunInference()}async preRunInference(){if(this.mode==="stream"&&this.isRunning){const it=await this.imageCapture.grabFrame();await this.runInference(this.session,it),setTimeout(()=>this.preRunInference(),20)}else if(this.mode==="image"){this.isComputed=!1;const it=await createImageBitmap(this.imageElm);await this.runInference(this.session,it)}this.isComputed=!0}handleStop(){this.isRunning=!1,this.isComputed=!1}handleRecord(){if(this.mode!=="stream"){this.cleanMediaSlot();const it=document.createElement("wli-webcam");it.setAttribute("slot","media"),this.append(it)}this.mode="stream"}handleUpload(){this.mode="image",this.isComputed=!1,this.inputElm.click()}async imageUpdated(){var F,W;const it=(W=(F=this.inputElm)==null?void 0:F.files)==null?void 0:W[0];if(it){this.cleanMediaSlot();const X=document.createElement("img"),K=URL.createObjectURL(it);X.src=K,X.setAttribute("slot","media"),this.imageElm=X,this.append(X),this.initInference()}}cleanMediaSlot(){this.querySelectorAll("[slot=media]").forEach(F=>F.remove())}async initInference(){if(this.mode==="stream"&&!this.stream){console.warn("[OnnxModel] Stream is undefined!");return}else if(this.mode==="image"&&!this.imageElm){console.warn("[OnnxModel] Image is undefined!");return}const it=await this.onnxModelsDbSrv.get(this.uuid);this.session=await ort_minExports.InferenceSession.create(it,{executionProviders:["wasm"]}),this.isReady=!0}async runInference(it,F){const W=new Date;drawCanvas(this.canvasElm,F);const X=this.canvasElm.getContext("2d"),K=X.getImageData(0,0,X.canvas.width,X.canvas.height),Q=preProcess(K),tt={images:new ort_minExports.Tensor(Float32Array.from(Q),[1,3,this.height,this.width])},et=await it.run(tt);console.log("results",et),this.clearRects();const q=await postProcess(et.output0,this.height,this.width,this.classes);console.log("boxes",q),drawBoxes(this.canvasElm,q,this.options);const G=new Date;this.inferenceTime=G.getTime()-W.getTime(),console.log("inferenceTime (ms)",this.inferenceTime)}clearRects(){}};OnnxModel.styles=i$3`
        :host {
            display: block;
            position: relative;
        }

        .inference {
            position: absolute;
            top: 0;
            right: 0;
            width: 90px;
            background: rgba(235, 98, 45, 0.3);
            z-index: 1;
        }

        .inference p {
            margin: 0;
            padding: 4px 8px;
            text-align: right;
            color: white;
        }

        ::slotted(img),
        ::slotted(wli-webcam) {
            max-width: 390px;
            max-height: 100%;
        }

        .rect {
            position: absolute;
            border: solid 1px red;
        }

        .media {
            height: calc(100dvh - 146px);
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: var(--wli-secondary);
            background-image:
                radial-gradient(white, rgba(255,255,255,.2) 2px, transparent 40px),
                radial-gradient(white, rgba(255,255,255,.15) 1px, transparent 30px),
                radial-gradient(white, rgba(255,255,255,.1) 2px, transparent 40px),
                radial-gradient(rgba(255,255,255,.4), rgba(255,255,255,.1) 2px, transparent 30px);
            background-size: 550px 550px, 350px 350px, 250px 250px, 150px 150px;
            background-position: 0 0, 40px 60px, 160px 240px, 120px 100px;
        }

        .hidden {
            display: none;
        }
    `;__decorateClass$4([lazyInject(ONNX_MODELS_DATABASE_SERVICE)],OnnxModel.prototype,"onnxModelsDbSrv",2);__decorateClass$4([n$1({type:String,attribute:!0})],OnnxModel.prototype,"uuid",2);__decorateClass$4([n$1({type:String,attribute:!0})],OnnxModel.prototype,"name",2);__decorateClass$4([n$1({type:String,attribute:!0})],OnnxModel.prototype,"path",2);__decorateClass$4([n$1({type:Array})],OnnxModel.prototype,"classes",2);__decorateClass$4([n$1({type:Number,attribute:!0})],OnnxModel.prototype,"width",2);__decorateClass$4([n$1({type:Number,attribute:!0})],OnnxModel.prototype,"height",2);__decorateClass$4([n$1({type:Object})],OnnxModel.prototype,"options",2);__decorateClass$4([i("canvas")],OnnxModel.prototype,"canvasElm",2);__decorateClass$4([i("input")],OnnxModel.prototype,"inputElm",2);__decorateClass$4([i(".wrapper")],OnnxModel.prototype,"wrapperElm",2);__decorateClass$4([t()],OnnxModel.prototype,"inferenceTime",2);__decorateClass$4([t()],OnnxModel.prototype,"mode",2);__decorateClass$4([t()],OnnxModel.prototype,"isReady",2);__decorateClass$4([t()],OnnxModel.prototype,"isComputed",2);OnnxModel=__decorateClass$4([e$1("wli-onnx-model")],OnnxModel);var __defProp$3=Object.defineProperty,__getOwnPropDesc$3=Object.getOwnPropertyDescriptor,__decorateClass$3=(it,F,W,X)=>{for(var K=X>1?void 0:X?__getOwnPropDesc$3(F,W):F,Q=it.length-1,Y;Q>=0;Q--)(Y=it[Q])&&(K=(X?Y(F,W,K):Y(K))||K);return X&&K&&__defProp$3(F,W,K),K};let Route=class extends s{constructor(){super(...arguments),this.active=!1}render(){return x`
            <slot></slot>
        `}};Route.styles=i$3`
        :host {
        }
    `;__decorateClass$3([n$1()],Route.prototype,"path",2);__decorateClass$3([n$1()],Route.prototype,"propss",2);__decorateClass$3([n$1({type:Boolean,attribute:!0})],Route.prototype,"active",2);Route=__decorateClass$3([e$1("wli-route")],Route);var __defProp$2=Object.defineProperty,__getOwnPropDesc$2=Object.getOwnPropertyDescriptor,__decorateClass$2=(it,F,W,X)=>{for(var K=X>1?void 0:X?__getOwnPropDesc$2(F,W):F,Q=it.length-1,Y;Q>=0;Q--)(Y=it[Q])&&(K=(X?Y(F,W,K):Y(K))||K);return X&&K&&__defProp$2(F,W,K),K};let Router=class extends s{render(){return x`
            <slot></slot>
        `}willUpdate(){const it=this.querySelector(`:scope > wli-route[path="${this.path}"]`),F=this.querySelector(":scope > wli-route[active]");if(F&&(F.removeAttribute("active"),F.innerHTML=""),it){const W=it.getAttribute("component"),X=it.props;if(W){const K=document.createElement(W);it.setAttribute("active","");for(const Q in X)K[Q]=X[Q];it.append(K)}}}};Router.styles=i$3`
        :host {
        }
    `;__decorateClass$2([n$1()],Router.prototype,"path",2);Router=__decorateClass$2([e$1("wli-router")],Router);var __defProp$1=Object.defineProperty,__getOwnPropDesc$1=Object.getOwnPropertyDescriptor,__decorateClass$1=(it,F,W,X)=>{for(var K=X>1?void 0:X?__getOwnPropDesc$1(F,W):F,Q=it.length-1,Y;Q>=0;Q--)(Y=it[Q])&&(K=(X?Y(F,W,K):Y(K))||K);return X&&K&&__defProp$1(F,W,K),K};let Webcam=class extends s{render(){return x`
            <video autoplay laysinline playsinline muted></video>
            <slot />
        `}async firstUpdated(){const it={audio:!1,video:{facingMode:"environment"}};try{this.stream=await navigator.mediaDevices.getUserMedia(it),this.videoElm.srcObject=this.stream;const F=new CustomEvent("wli-webcam-stream",{detail:this.stream,bubbles:!0});this.dispatchEvent(F)}catch(F){console.warn(F),alert("Error - Cannot access webcam")}}disconnectedCallback(){this.stream.getTracks().forEach(F=>F.stop())}};Webcam.styles=i$3`
        :host {
            display: block;
        }

        video {
            width: 100%;
        }
    `;__decorateClass$1([i("video")],Webcam.prototype,"videoElm",2);__decorateClass$1([t()],Webcam.prototype,"stream",2);Webcam=__decorateClass$1([e$1("wli-webcam")],Webcam);container.bind(ONNX_MODELS_DATABASE_SERVICE).to(OnnxModelsDatabaseService);container.bind(AVAILABLE_PUBLIC_MODELS_SERVICE).to(AvailablePublicModelsService);container.bind(USER_AUTHENTIFICATION_SERVICE).to(UserAuthentificationService);container.bind(HASH_SERVICE).to(HashService);container.bind(ACTIVE_SESSION_SERVICE).to(ActiveSessionService);var __defProp=Object.defineProperty,__getOwnPropDesc=Object.getOwnPropertyDescriptor,__decorateClass=(it,F,W,X)=>{for(var K=X>1?void 0:X?__getOwnPropDesc(F,W):F,Q=it.length-1,Y;Q>=0;Q--)(Y=it[Q])&&(K=(X?Y(F,W,K):Y(K))||K);return X&&K&&__defProp(F,W,K),K};let App=class extends s{constructor(){super(...arguments),this.path="/login"}firstUpdated(){const it=this.activeSessionSrv.get();it&&(this.credentials=it,this.path="/home")}handleLogin(it){this.path="/home",this.credentials=it.detail}handleLogout(){this.path="/login",this.activeSessionSrv.remove(),this.credentials=void 0}handleRun(it){this.path="/capture",this.model=it.detail}handleBackHome(){this.path="/home"}render(){return x`
            <wli-main-layout>
                <wli-header
                    .credentials=${this.credentials}
                    @wli-logout=${this.handleLogout}
                >
                </wli-header>
                <wli-router path="${this.path}">
                    <wli-route
                        path="/"
                        redirect=${()=>"/login"}
                    >
                    </wli-route>
                    <wli-route
                        path="/login"
                        component="wli-login"
                        @wli-login=${this.handleLogin}
                    >
                    </wli-route>
                    <wli-route
                        path="/home"
                        component="wli-home"
                        @wli-home-run=${this.handleRun}
                    >
                    </wli-route>
                    <wli-route
                        path="/capture"
                        component="wli-capture"
                        .props=${this.model}
                        @wli-onnx-actions-back=${this.handleBackHome}
                    >
                    </wli-route>
                </wli-router>
            </wli-main-layout>
        `}};App.styles=i$3`
        :host {
        }
    `;__decorateClass([lazyInject(ACTIVE_SESSION_SERVICE)],App.prototype,"activeSessionSrv",2);__decorateClass([t()],App.prototype,"path",2);__decorateClass([t()],App.prototype,"model",2);__decorateClass([t()],App.prototype,"credentials",2);App=__decorateClass([e$1("wli-app")],App);
