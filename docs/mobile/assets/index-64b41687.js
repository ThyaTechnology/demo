(function(){const U=document.createElement("link").relList;if(U&&U.supports&&U.supports("modulepreload"))return;for(const Y of document.querySelectorAll('link[rel="modulepreload"]'))tt(Y);new MutationObserver(Y=>{for(const nt of Y)if(nt.type==="childList")for(const K of nt.addedNodes)K.tagName==="LINK"&&K.rel==="modulepreload"&&tt(K)}).observe(document,{childList:!0,subtree:!0});function rt(Y){const nt={};return Y.integrity&&(nt.integrity=Y.integrity),Y.referrerPolicy&&(nt.referrerPolicy=Y.referrerPolicy),Y.crossOrigin==="use-credentials"?nt.credentials="include":Y.crossOrigin==="anonymous"?nt.credentials="omit":nt.credentials="same-origin",nt}function tt(Y){if(Y.ep)return;Y.ep=!0;const nt=rt(Y);fetch(Y.href,nt)}})();const index="";/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const t$2=window,e$4=t$2.ShadowRoot&&(t$2.ShadyCSS===void 0||t$2.ShadyCSS.nativeShadow)&&"adoptedStyleSheets"in Document.prototype&&"replace"in CSSStyleSheet.prototype,s$3=Symbol(),n$5=new WeakMap;let o$4=class{constructor(U,rt,tt){if(this._$cssResult$=!0,tt!==s$3)throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");this.cssText=U,this.t=rt}get styleSheet(){let U=this.o;const rt=this.t;if(e$4&&U===void 0){const tt=rt!==void 0&&rt.length===1;tt&&(U=n$5.get(rt)),U===void 0&&((this.o=U=new CSSStyleSheet).replaceSync(this.cssText),tt&&n$5.set(rt,U))}return U}toString(){return this.cssText}};const r$2=dt=>new o$4(typeof dt=="string"?dt:dt+"",void 0,s$3),i$3=(dt,...U)=>{const rt=dt.length===1?dt[0]:U.reduce((tt,Y,nt)=>tt+(K=>{if(K._$cssResult$===!0)return K.cssText;if(typeof K=="number")return K;throw Error("Value passed to 'css' function must be a 'css' function result: "+K+". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.")})(Y)+dt[nt+1],dt[0]);return new o$4(rt,dt,s$3)},S$1=(dt,U)=>{e$4?dt.adoptedStyleSheets=U.map(rt=>rt instanceof CSSStyleSheet?rt:rt.styleSheet):U.forEach(rt=>{const tt=document.createElement("style"),Y=t$2.litNonce;Y!==void 0&&tt.setAttribute("nonce",Y),tt.textContent=rt.cssText,dt.appendChild(tt)})},c$1=e$4?dt=>dt:dt=>dt instanceof CSSStyleSheet?(U=>{let rt="";for(const tt of U.cssRules)rt+=tt.cssText;return r$2(rt)})(dt):dt;/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */var s$2;const e$3=window,r$1=e$3.trustedTypes,h$1=r$1?r$1.emptyScript:"",o$3=e$3.reactiveElementPolyfillSupport,n$4={toAttribute(dt,U){switch(U){case Boolean:dt=dt?h$1:null;break;case Object:case Array:dt=dt==null?dt:JSON.stringify(dt)}return dt},fromAttribute(dt,U){let rt=dt;switch(U){case Boolean:rt=dt!==null;break;case Number:rt=dt===null?null:Number(dt);break;case Object:case Array:try{rt=JSON.parse(dt)}catch{rt=null}}return rt}},a$1=(dt,U)=>U!==dt&&(U==U||dt==dt),l$2={attribute:!0,type:String,converter:n$4,reflect:!1,hasChanged:a$1},d$1="finalized";let u$1=class extends HTMLElement{constructor(){super(),this._$Ei=new Map,this.isUpdatePending=!1,this.hasUpdated=!1,this._$El=null,this._$Eu()}static addInitializer(U){var rt;this.finalize(),((rt=this.h)!==null&&rt!==void 0?rt:this.h=[]).push(U)}static get observedAttributes(){this.finalize();const U=[];return this.elementProperties.forEach((rt,tt)=>{const Y=this._$Ep(tt,rt);Y!==void 0&&(this._$Ev.set(Y,tt),U.push(Y))}),U}static createProperty(U,rt=l$2){if(rt.state&&(rt.attribute=!1),this.finalize(),this.elementProperties.set(U,rt),!rt.noAccessor&&!this.prototype.hasOwnProperty(U)){const tt=typeof U=="symbol"?Symbol():"__"+U,Y=this.getPropertyDescriptor(U,tt,rt);Y!==void 0&&Object.defineProperty(this.prototype,U,Y)}}static getPropertyDescriptor(U,rt,tt){return{get(){return this[rt]},set(Y){const nt=this[U];this[rt]=Y,this.requestUpdate(U,nt,tt)},configurable:!0,enumerable:!0}}static getPropertyOptions(U){return this.elementProperties.get(U)||l$2}static finalize(){if(this.hasOwnProperty(d$1))return!1;this[d$1]=!0;const U=Object.getPrototypeOf(this);if(U.finalize(),U.h!==void 0&&(this.h=[...U.h]),this.elementProperties=new Map(U.elementProperties),this._$Ev=new Map,this.hasOwnProperty("properties")){const rt=this.properties,tt=[...Object.getOwnPropertyNames(rt),...Object.getOwnPropertySymbols(rt)];for(const Y of tt)this.createProperty(Y,rt[Y])}return this.elementStyles=this.finalizeStyles(this.styles),!0}static finalizeStyles(U){const rt=[];if(Array.isArray(U)){const tt=new Set(U.flat(1/0).reverse());for(const Y of tt)rt.unshift(c$1(Y))}else U!==void 0&&rt.push(c$1(U));return rt}static _$Ep(U,rt){const tt=rt.attribute;return tt===!1?void 0:typeof tt=="string"?tt:typeof U=="string"?U.toLowerCase():void 0}_$Eu(){var U;this._$E_=new Promise(rt=>this.enableUpdating=rt),this._$AL=new Map,this._$Eg(),this.requestUpdate(),(U=this.constructor.h)===null||U===void 0||U.forEach(rt=>rt(this))}addController(U){var rt,tt;((rt=this._$ES)!==null&&rt!==void 0?rt:this._$ES=[]).push(U),this.renderRoot!==void 0&&this.isConnected&&((tt=U.hostConnected)===null||tt===void 0||tt.call(U))}removeController(U){var rt;(rt=this._$ES)===null||rt===void 0||rt.splice(this._$ES.indexOf(U)>>>0,1)}_$Eg(){this.constructor.elementProperties.forEach((U,rt)=>{this.hasOwnProperty(rt)&&(this._$Ei.set(rt,this[rt]),delete this[rt])})}createRenderRoot(){var U;const rt=(U=this.shadowRoot)!==null&&U!==void 0?U:this.attachShadow(this.constructor.shadowRootOptions);return S$1(rt,this.constructor.elementStyles),rt}connectedCallback(){var U;this.renderRoot===void 0&&(this.renderRoot=this.createRenderRoot()),this.enableUpdating(!0),(U=this._$ES)===null||U===void 0||U.forEach(rt=>{var tt;return(tt=rt.hostConnected)===null||tt===void 0?void 0:tt.call(rt)})}enableUpdating(U){}disconnectedCallback(){var U;(U=this._$ES)===null||U===void 0||U.forEach(rt=>{var tt;return(tt=rt.hostDisconnected)===null||tt===void 0?void 0:tt.call(rt)})}attributeChangedCallback(U,rt,tt){this._$AK(U,tt)}_$EO(U,rt,tt=l$2){var Y;const nt=this.constructor._$Ep(U,tt);if(nt!==void 0&&tt.reflect===!0){const K=(((Y=tt.converter)===null||Y===void 0?void 0:Y.toAttribute)!==void 0?tt.converter:n$4).toAttribute(rt,tt.type);this._$El=U,K==null?this.removeAttribute(nt):this.setAttribute(nt,K),this._$El=null}}_$AK(U,rt){var tt;const Y=this.constructor,nt=Y._$Ev.get(U);if(nt!==void 0&&this._$El!==nt){const K=Y.getPropertyOptions(nt),X=typeof K.converter=="function"?{fromAttribute:K.converter}:((tt=K.converter)===null||tt===void 0?void 0:tt.fromAttribute)!==void 0?K.converter:n$4;this._$El=nt,this[nt]=X.fromAttribute(rt,K.type),this._$El=null}}requestUpdate(U,rt,tt){let Y=!0;U!==void 0&&(((tt=tt||this.constructor.getPropertyOptions(U)).hasChanged||a$1)(this[U],rt)?(this._$AL.has(U)||this._$AL.set(U,rt),tt.reflect===!0&&this._$El!==U&&(this._$EC===void 0&&(this._$EC=new Map),this._$EC.set(U,tt))):Y=!1),!this.isUpdatePending&&Y&&(this._$E_=this._$Ej())}async _$Ej(){this.isUpdatePending=!0;try{await this._$E_}catch(rt){Promise.reject(rt)}const U=this.scheduleUpdate();return U!=null&&await U,!this.isUpdatePending}scheduleUpdate(){return this.performUpdate()}performUpdate(){var U;if(!this.isUpdatePending)return;this.hasUpdated,this._$Ei&&(this._$Ei.forEach((Y,nt)=>this[nt]=Y),this._$Ei=void 0);let rt=!1;const tt=this._$AL;try{rt=this.shouldUpdate(tt),rt?(this.willUpdate(tt),(U=this._$ES)===null||U===void 0||U.forEach(Y=>{var nt;return(nt=Y.hostUpdate)===null||nt===void 0?void 0:nt.call(Y)}),this.update(tt)):this._$Ek()}catch(Y){throw rt=!1,this._$Ek(),Y}rt&&this._$AE(tt)}willUpdate(U){}_$AE(U){var rt;(rt=this._$ES)===null||rt===void 0||rt.forEach(tt=>{var Y;return(Y=tt.hostUpdated)===null||Y===void 0?void 0:Y.call(tt)}),this.hasUpdated||(this.hasUpdated=!0,this.firstUpdated(U)),this.updated(U)}_$Ek(){this._$AL=new Map,this.isUpdatePending=!1}get updateComplete(){return this.getUpdateComplete()}getUpdateComplete(){return this._$E_}shouldUpdate(U){return!0}update(U){this._$EC!==void 0&&(this._$EC.forEach((rt,tt)=>this._$EO(tt,this[tt],rt)),this._$EC=void 0),this._$Ek()}updated(U){}firstUpdated(U){}};u$1[d$1]=!0,u$1.elementProperties=new Map,u$1.elementStyles=[],u$1.shadowRootOptions={mode:"open"},o$3==null||o$3({ReactiveElement:u$1}),((s$2=e$3.reactiveElementVersions)!==null&&s$2!==void 0?s$2:e$3.reactiveElementVersions=[]).push("1.6.3");/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */var t$1;const i$2=window,s$1=i$2.trustedTypes,e$2=s$1?s$1.createPolicy("lit-html",{createHTML:dt=>dt}):void 0,o$2="$lit$",n$3=`lit$${(Math.random()+"").slice(9)}$`,l$1="?"+n$3,h=`<${l$1}>`,r=document,u=()=>r.createComment(""),d=dt=>dt===null||typeof dt!="object"&&typeof dt!="function",c=Array.isArray,v=dt=>c(dt)||typeof(dt==null?void 0:dt[Symbol.iterator])=="function",a=`[ 	
\f\r]`,f=/<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,_=/-->/g,m=/>/g,p=RegExp(`>|${a}(?:([^\\s"'>=/]+)(${a}*=${a}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`,"g"),g=/'/g,$=/"/g,y=/^(?:script|style|textarea|title)$/i,w=dt=>(U,...rt)=>({_$litType$:dt,strings:U,values:rt}),x=w(1),T=Symbol.for("lit-noChange"),A=Symbol.for("lit-nothing"),E=new WeakMap,C=r.createTreeWalker(r,129,null,!1);function P(dt,U){if(!Array.isArray(dt)||!dt.hasOwnProperty("raw"))throw Error("invalid template strings array");return e$2!==void 0?e$2.createHTML(U):U}const V=(dt,U)=>{const rt=dt.length-1,tt=[];let Y,nt=U===2?"<svg>":"",K=f;for(let X=0;X<rt;X++){const Q=dt[X];let q,G,O=-1,b=0;for(;b<Q.length&&(K.lastIndex=b,G=K.exec(Q),G!==null);)b=K.lastIndex,K===f?G[1]==="!--"?K=_:G[1]!==void 0?K=m:G[2]!==void 0?(y.test(G[2])&&(Y=RegExp("</"+G[2],"g")),K=p):G[3]!==void 0&&(K=p):K===p?G[0]===">"?(K=Y??f,O=-1):G[1]===void 0?O=-2:(O=K.lastIndex-G[2].length,q=G[1],K=G[3]===void 0?p:G[3]==='"'?$:g):K===$||K===g?K=p:K===_||K===m?K=f:(K=p,Y=void 0);const F=K===p&&dt[X+1].startsWith("/>")?" ":"";nt+=K===f?Q+h:O>=0?(tt.push(q),Q.slice(0,O)+o$2+Q.slice(O)+n$3+F):Q+n$3+(O===-2?(tt.push(void 0),X):F)}return[P(dt,nt+(dt[rt]||"<?>")+(U===2?"</svg>":"")),tt]};class N{constructor({strings:U,_$litType$:rt},tt){let Y;this.parts=[];let nt=0,K=0;const X=U.length-1,Q=this.parts,[q,G]=V(U,rt);if(this.el=N.createElement(q,tt),C.currentNode=this.el.content,rt===2){const O=this.el.content,b=O.firstChild;b.remove(),O.append(...b.childNodes)}for(;(Y=C.nextNode())!==null&&Q.length<X;){if(Y.nodeType===1){if(Y.hasAttributes()){const O=[];for(const b of Y.getAttributeNames())if(b.endsWith(o$2)||b.startsWith(n$3)){const F=G[K++];if(O.push(b),F!==void 0){const j=Y.getAttribute(F.toLowerCase()+o$2).split(n$3),W=/([.?@])?(.*)/.exec(F);Q.push({type:1,index:nt,name:W[2],strings:j,ctor:W[1]==="."?H:W[1]==="?"?L:W[1]==="@"?z:k})}else Q.push({type:6,index:nt})}for(const b of O)Y.removeAttribute(b)}if(y.test(Y.tagName)){const O=Y.textContent.split(n$3),b=O.length-1;if(b>0){Y.textContent=s$1?s$1.emptyScript:"";for(let F=0;F<b;F++)Y.append(O[F],u()),C.nextNode(),Q.push({type:2,index:++nt});Y.append(O[b],u())}}}else if(Y.nodeType===8)if(Y.data===l$1)Q.push({type:2,index:nt});else{let O=-1;for(;(O=Y.data.indexOf(n$3,O+1))!==-1;)Q.push({type:7,index:nt}),O+=n$3.length-1}nt++}}static createElement(U,rt){const tt=r.createElement("template");return tt.innerHTML=U,tt}}function S(dt,U,rt=dt,tt){var Y,nt,K,X;if(U===T)return U;let Q=tt!==void 0?(Y=rt._$Co)===null||Y===void 0?void 0:Y[tt]:rt._$Cl;const q=d(U)?void 0:U._$litDirective$;return(Q==null?void 0:Q.constructor)!==q&&((nt=Q==null?void 0:Q._$AO)===null||nt===void 0||nt.call(Q,!1),q===void 0?Q=void 0:(Q=new q(dt),Q._$AT(dt,rt,tt)),tt!==void 0?((K=(X=rt)._$Co)!==null&&K!==void 0?K:X._$Co=[])[tt]=Q:rt._$Cl=Q),Q!==void 0&&(U=S(dt,Q._$AS(dt,U.values),Q,tt)),U}class M{constructor(U,rt){this._$AV=[],this._$AN=void 0,this._$AD=U,this._$AM=rt}get parentNode(){return this._$AM.parentNode}get _$AU(){return this._$AM._$AU}u(U){var rt;const{el:{content:tt},parts:Y}=this._$AD,nt=((rt=U==null?void 0:U.creationScope)!==null&&rt!==void 0?rt:r).importNode(tt,!0);C.currentNode=nt;let K=C.nextNode(),X=0,Q=0,q=Y[0];for(;q!==void 0;){if(X===q.index){let G;q.type===2?G=new R(K,K.nextSibling,this,U):q.type===1?G=new q.ctor(K,q.name,q.strings,this,U):q.type===6&&(G=new Z(K,this,U)),this._$AV.push(G),q=Y[++Q]}X!==(q==null?void 0:q.index)&&(K=C.nextNode(),X++)}return C.currentNode=r,nt}v(U){let rt=0;for(const tt of this._$AV)tt!==void 0&&(tt.strings!==void 0?(tt._$AI(U,tt,rt),rt+=tt.strings.length-2):tt._$AI(U[rt])),rt++}}class R{constructor(U,rt,tt,Y){var nt;this.type=2,this._$AH=A,this._$AN=void 0,this._$AA=U,this._$AB=rt,this._$AM=tt,this.options=Y,this._$Cp=(nt=Y==null?void 0:Y.isConnected)===null||nt===void 0||nt}get _$AU(){var U,rt;return(rt=(U=this._$AM)===null||U===void 0?void 0:U._$AU)!==null&&rt!==void 0?rt:this._$Cp}get parentNode(){let U=this._$AA.parentNode;const rt=this._$AM;return rt!==void 0&&(U==null?void 0:U.nodeType)===11&&(U=rt.parentNode),U}get startNode(){return this._$AA}get endNode(){return this._$AB}_$AI(U,rt=this){U=S(this,U,rt),d(U)?U===A||U==null||U===""?(this._$AH!==A&&this._$AR(),this._$AH=A):U!==this._$AH&&U!==T&&this._(U):U._$litType$!==void 0?this.g(U):U.nodeType!==void 0?this.$(U):v(U)?this.T(U):this._(U)}k(U){return this._$AA.parentNode.insertBefore(U,this._$AB)}$(U){this._$AH!==U&&(this._$AR(),this._$AH=this.k(U))}_(U){this._$AH!==A&&d(this._$AH)?this._$AA.nextSibling.data=U:this.$(r.createTextNode(U)),this._$AH=U}g(U){var rt;const{values:tt,_$litType$:Y}=U,nt=typeof Y=="number"?this._$AC(U):(Y.el===void 0&&(Y.el=N.createElement(P(Y.h,Y.h[0]),this.options)),Y);if(((rt=this._$AH)===null||rt===void 0?void 0:rt._$AD)===nt)this._$AH.v(tt);else{const K=new M(nt,this),X=K.u(this.options);K.v(tt),this.$(X),this._$AH=K}}_$AC(U){let rt=E.get(U.strings);return rt===void 0&&E.set(U.strings,rt=new N(U)),rt}T(U){c(this._$AH)||(this._$AH=[],this._$AR());const rt=this._$AH;let tt,Y=0;for(const nt of U)Y===rt.length?rt.push(tt=new R(this.k(u()),this.k(u()),this,this.options)):tt=rt[Y],tt._$AI(nt),Y++;Y<rt.length&&(this._$AR(tt&&tt._$AB.nextSibling,Y),rt.length=Y)}_$AR(U=this._$AA.nextSibling,rt){var tt;for((tt=this._$AP)===null||tt===void 0||tt.call(this,!1,!0,rt);U&&U!==this._$AB;){const Y=U.nextSibling;U.remove(),U=Y}}setConnected(U){var rt;this._$AM===void 0&&(this._$Cp=U,(rt=this._$AP)===null||rt===void 0||rt.call(this,U))}}class k{constructor(U,rt,tt,Y,nt){this.type=1,this._$AH=A,this._$AN=void 0,this.element=U,this.name=rt,this._$AM=Y,this.options=nt,tt.length>2||tt[0]!==""||tt[1]!==""?(this._$AH=Array(tt.length-1).fill(new String),this.strings=tt):this._$AH=A}get tagName(){return this.element.tagName}get _$AU(){return this._$AM._$AU}_$AI(U,rt=this,tt,Y){const nt=this.strings;let K=!1;if(nt===void 0)U=S(this,U,rt,0),K=!d(U)||U!==this._$AH&&U!==T,K&&(this._$AH=U);else{const X=U;let Q,q;for(U=nt[0],Q=0;Q<nt.length-1;Q++)q=S(this,X[tt+Q],rt,Q),q===T&&(q=this._$AH[Q]),K||(K=!d(q)||q!==this._$AH[Q]),q===A?U=A:U!==A&&(U+=(q??"")+nt[Q+1]),this._$AH[Q]=q}K&&!Y&&this.j(U)}j(U){U===A?this.element.removeAttribute(this.name):this.element.setAttribute(this.name,U??"")}}class H extends k{constructor(){super(...arguments),this.type=3}j(U){this.element[this.name]=U===A?void 0:U}}const I=s$1?s$1.emptyScript:"";class L extends k{constructor(){super(...arguments),this.type=4}j(U){U&&U!==A?this.element.setAttribute(this.name,I):this.element.removeAttribute(this.name)}}class z extends k{constructor(U,rt,tt,Y,nt){super(U,rt,tt,Y,nt),this.type=5}_$AI(U,rt=this){var tt;if((U=(tt=S(this,U,rt,0))!==null&&tt!==void 0?tt:A)===T)return;const Y=this._$AH,nt=U===A&&Y!==A||U.capture!==Y.capture||U.once!==Y.once||U.passive!==Y.passive,K=U!==A&&(Y===A||nt);nt&&this.element.removeEventListener(this.name,this,Y),K&&this.element.addEventListener(this.name,this,U),this._$AH=U}handleEvent(U){var rt,tt;typeof this._$AH=="function"?this._$AH.call((tt=(rt=this.options)===null||rt===void 0?void 0:rt.host)!==null&&tt!==void 0?tt:this.element,U):this._$AH.handleEvent(U)}}class Z{constructor(U,rt,tt){this.element=U,this.type=6,this._$AN=void 0,this._$AM=rt,this.options=tt}get _$AU(){return this._$AM._$AU}_$AI(U){S(this,U)}}const B=i$2.litHtmlPolyfillSupport;B==null||B(N,R),((t$1=i$2.litHtmlVersions)!==null&&t$1!==void 0?t$1:i$2.litHtmlVersions=[]).push("2.8.0");const D=(dt,U,rt)=>{var tt,Y;const nt=(tt=rt==null?void 0:rt.renderBefore)!==null&&tt!==void 0?tt:U;let K=nt._$litPart$;if(K===void 0){const X=(Y=rt==null?void 0:rt.renderBefore)!==null&&Y!==void 0?Y:null;nt._$litPart$=K=new R(U.insertBefore(u(),X),X,void 0,rt??{})}return K._$AI(dt),K};/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */var l,o$1;class s extends u$1{constructor(){super(...arguments),this.renderOptions={host:this},this._$Do=void 0}createRenderRoot(){var U,rt;const tt=super.createRenderRoot();return(U=(rt=this.renderOptions).renderBefore)!==null&&U!==void 0||(rt.renderBefore=tt.firstChild),tt}update(U){const rt=this.render();this.hasUpdated||(this.renderOptions.isConnected=this.isConnected),super.update(U),this._$Do=D(rt,this.renderRoot,this.renderOptions)}connectedCallback(){var U;super.connectedCallback(),(U=this._$Do)===null||U===void 0||U.setConnected(!0)}disconnectedCallback(){var U;super.disconnectedCallback(),(U=this._$Do)===null||U===void 0||U.setConnected(!1)}render(){return T}}s.finalized=!0,s._$litElement$=!0,(l=globalThis.litElementHydrateSupport)===null||l===void 0||l.call(globalThis,{LitElement:s});const n$2=globalThis.litElementPolyfillSupport;n$2==null||n$2({LitElement:s});((o$1=globalThis.litElementVersions)!==null&&o$1!==void 0?o$1:globalThis.litElementVersions=[]).push("3.3.3");/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const e$1=dt=>U=>typeof U=="function"?((rt,tt)=>(customElements.define(rt,tt),tt))(dt,U):((rt,tt)=>{const{kind:Y,elements:nt}=tt;return{kind:Y,elements:nt,finisher(K){customElements.define(rt,K)}}})(dt,U);/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const i$1=(dt,U)=>U.kind==="method"&&U.descriptor&&!("value"in U.descriptor)?{...U,finisher(rt){rt.createProperty(U.key,dt)}}:{kind:"field",key:Symbol(),placement:"own",descriptor:{},originalKey:U.key,initializer(){typeof U.initializer=="function"&&(this[U.key]=U.initializer.call(this))},finisher(rt){rt.createProperty(U.key,dt)}},e=(dt,U,rt)=>{U.constructor.createProperty(rt,dt)};function n$1(dt){return(U,rt)=>rt!==void 0?e(dt,U,rt):i$1(dt,U)}/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */function t(dt){return n$1({...dt,state:!0})}/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */const o=({finisher:dt,descriptor:U})=>(rt,tt)=>{var Y;if(tt===void 0){const nt=(Y=rt.originalKey)!==null&&Y!==void 0?Y:rt.key,K=U!=null?{kind:"method",placement:"prototype",key:nt,descriptor:U(rt.key)}:{...rt,key:nt};return dt!=null&&(K.finisher=function(X){dt(X,nt)}),K}{const nt=rt.constructor;U!==void 0&&Object.defineProperty(rt,tt,U(tt)),dt==null||dt(nt,tt)}};/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */function i(dt,U){return o({descriptor:rt=>{const tt={get(){var Y,nt;return(nt=(Y=this.renderRoot)===null||Y===void 0?void 0:Y.querySelector(dt))!==null&&nt!==void 0?nt:null},enumerable:!0,configurable:!0};if(U){const Y=typeof rt=="symbol"?Symbol():"__"+rt;tt.get=function(){var nt,K;return this[Y]===void 0&&(this[Y]=(K=(nt=this.renderRoot)===null||nt===void 0?void 0:nt.querySelector(dt))!==null&&K!==void 0?K:null),this[Y]}}return tt}})}/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */var n;((n=window.HTMLSlotElement)===null||n===void 0?void 0:n.prototype.assignedElements)!=null;var __defProp$c=Object.defineProperty,__getOwnPropDesc$c=Object.getOwnPropertyDescriptor,__decorateClass$c=(dt,U,rt,tt)=>{for(var Y=tt>1?void 0:tt?__getOwnPropDesc$c(U,rt):U,nt=dt.length-1,K;nt>=0;nt--)(K=dt[nt])&&(Y=(tt?K(U,rt,Y):K(Y))||Y);return tt&&Y&&__defProp$c(U,rt,Y),Y};let Box=class extends s{constructor(){super(...arguments),this.top=0,this.left=0,this.width=0,this.height=0}render(){return x`
            <div
                class="wrapper"
                style="top: ${this.top-24}px; left: ${this.left}px;"
            >
                <p>${this.name}</p>
                <div
                    class="box"
                    style="width: ${this.width}px; height: ${this.height}px;"
                ></div>
            </div>
        `}};Box.styles=i$3`
        .wrapper {
            position: absolute;
        }

        p {
            margin: 0;
            padding: 0 6px;
            background: white;
            width: fit-content;
        }

        .box {
            border: 2px solid white;
        }
    `;__decorateClass$c([n$1()],Box.prototype,"name",2);__decorateClass$c([n$1({type:Number})],Box.prototype,"top",2);__decorateClass$c([n$1({type:Number})],Box.prototype,"left",2);__decorateClass$c([n$1({type:Number})],Box.prototype,"width",2);__decorateClass$c([n$1({type:Number})],Box.prototype,"height",2);Box=__decorateClass$c([e$1("wli-box")],Box);var __defProp$b=Object.defineProperty,__getOwnPropDesc$b=Object.getOwnPropertyDescriptor,__decorateClass$b=(dt,U,rt,tt)=>{for(var Y=tt>1?void 0:tt?__getOwnPropDesc$b(U,rt):U,nt=dt.length-1,K;nt>=0;nt--)(K=dt[nt])&&(Y=(tt?K(U,rt,Y):K(Y))||Y);return tt&&Y&&__defProp$b(U,rt,Y),Y};let Capture=class extends s{render(){return x`
            <wli-onnx-model
                name=${this.name}
                path=${this.path}
                .classes=${this.classes}
                width=${this.width}
                height=${this.height}
                .options=${this.options}
            >
                <wli-media-placeholder slot="media">
                </wli-media-placeholder>
            </wli-onnx-model>
        `}};Capture.styles=i$3`
        :host {
        }
    `;__decorateClass$b([n$1({type:String,attribute:!0})],Capture.prototype,"name",2);__decorateClass$b([n$1({type:String,attribute:!0})],Capture.prototype,"path",2);__decorateClass$b([n$1({type:Array})],Capture.prototype,"classes",2);__decorateClass$b([n$1({type:Number,attribute:!0})],Capture.prototype,"width",2);__decorateClass$b([n$1({type:Number,attribute:!0})],Capture.prototype,"height",2);__decorateClass$b([n$1({type:Object})],Capture.prototype,"options",2);Capture=__decorateClass$b([e$1("wli-capture")],Capture);const thyaTechLogo=""+new URL("logo-name-dark-7f755255.png",import.meta.url).href;var __defProp$a=Object.defineProperty,__getOwnPropDesc$a=Object.getOwnPropertyDescriptor,__decorateClass$a=(dt,U,rt,tt)=>{for(var Y=tt>1?void 0:tt?__getOwnPropDesc$a(U,rt):U,nt=dt.length-1,K;nt>=0;nt--)(K=dt[nt])&&(Y=(tt?K(U,rt,Y):K(Y))||Y);return tt&&Y&&__defProp$a(U,rt,Y),Y};let Header=class extends s{render(){return x`
            <img
                src="${thyaTechLogo}"
                alt="Thya Technologie Logo"
            />
        `}};Header.styles=i$3`
        :host {
            display: flex;
            justify-content: center;
            padding: 24px 12px;
            background-color: #020d29;
        }

        img {
            width: 150px;
        }
    `;Header=__decorateClass$a([e$1("wli-header")],Header);const classesForCoco128=["person","bicycle","car","motorcycle","airplane","bus","train","truck","boat","traffic light","fire hydrant","stop sign","parking meter","bench","bird","cat","dog","horse","sheep","cow","elephant","bear","zebra","giraffe","backpack","umbrella","handbag","tie","suitcase","frisbee","skis","snowboard","sports ball","kite","baseball bat","baseball glove","skateboard","surfboard","tennis racket","bottle","wine glass","cup","fork","knife","spoon","bowl","banana","apple","sandwich","orange","broccoli","carrot","hot dog","pizza","donut","cake","chair","couch","potted plant","bed","dining table","toilet","tv","laptop","mouse","remote","keyboard","cell phone","microwave","oven","toaster","sink","refrigerator","book","clock","vase","scissors","teddy bear","hair drier","toothbrush"],classesForStriga=["radicle","seed"];var __defProp$9=Object.defineProperty,__getOwnPropDesc$9=Object.getOwnPropertyDescriptor,__decorateClass$9=(dt,U,rt,tt)=>{for(var Y=tt>1?void 0:tt?__getOwnPropDesc$9(U,rt):U,nt=dt.length-1,K;nt>=0;nt--)(K=dt[nt])&&(Y=(tt?K(U,rt,Y):K(Y))||Y);return tt&&Y&&__defProp$9(U,rt,Y),Y};const OPTIONS_FOR_COCO_128={lineWidth:3,textFillStyle:"white",textBackgroundFillStyle:"#EB622D"},OPTIONS_FOR_STRIGA={lineWidth:1,textFillStyle:"#EB622D",textBackgroundFillStyle:"transparent"},DATA=[{name:"Yolo v5n coco 128",path:"data/yolov5n_coco128.onnx",classes:classesForCoco128,width:640,height:640,options:OPTIONS_FOR_COCO_128},{name:"Yolo v5n striga",path:"data/yolov5n_striga.onnx",classes:classesForStriga,width:640,height:640,options:OPTIONS_FOR_STRIGA},{name:"Yolo v5s coco 128",path:"data/yolov5s_coco128.onnx",classes:classesForCoco128,width:640,height:640,options:OPTIONS_FOR_COCO_128},{name:"Yolo v5s striga",path:"data/yolov5s_striga.onnx",classes:classesForStriga,width:64,height:64,options:OPTIONS_FOR_STRIGA},{name:"Yolo v8n coco 128",path:"data/yolov8n_coco128.onnx",classes:classesForCoco128,width:640,height:640,options:OPTIONS_FOR_COCO_128},{name:"Yolo v8n coco 128 256",path:"data/yolov8n_coco128_256.onnx",classes:classesForCoco128,width:256,height:256,options:OPTIONS_FOR_COCO_128},{name:"Yolo v8n striga",path:"data/yolov8n_striga.onnx",classes:classesForStriga,width:640,height:640,options:OPTIONS_FOR_STRIGA},{name:"Yolo v8n striga 256",path:"data/yolov8n_striga_256.onnx",classes:classesForStriga,width:256,height:256,options:OPTIONS_FOR_STRIGA},{name:"Yolo v8s coco 128",path:"data/yolov8s_coco128.onnx",classes:classesForCoco128,width:640,height:640,options:OPTIONS_FOR_COCO_128},{name:"Yolo v8s striga",path:"data/yolov8s_striga.onnx",classes:classesForStriga,width:640,height:640,options:OPTIONS_FOR_STRIGA}];let Home=class extends s{constructor(){super(...arguments),this.handleClick=dt=>()=>{const U=new CustomEvent("wli-home-run",{detail:dt,bubbles:!0,composed:!0});this.dispatchEvent(U)}}renderItem(dt){return x`
            <li>
                <p>${dt.name}</p>
                <button
                    @click=${this.handleClick(dt)}
                >
                    Run
                </button>
            </li>
        `}render(){return x`
            <input
                disabled
                placeholder="Search model"
            ></input>
            <ul>
                ${DATA.map(this.renderItem.bind(this))}
            </ul>
        `}};Home.styles=i$3`
        :host {
            display: flex;
            flex-direction: column;
            margin: 24px;
            gap: 10px;
        }

        p {
            margin: 0;
        }

        ul {
            list-style: none;
            padding: 0;
        }

        li {
            display: flex;
            margin-bottom: 24px;
            justify-content: space-between;
            align-items: center;
        }
    `;Home=__decorateClass$9([e$1("wli-home")],Home);var __defProp$8=Object.defineProperty,__getOwnPropDesc$8=Object.getOwnPropertyDescriptor,__decorateClass$8=(dt,U,rt,tt)=>{for(var Y=tt>1?void 0:tt?__getOwnPropDesc$8(U,rt):U,nt=dt.length-1,K;nt>=0;nt--)(K=dt[nt])&&(Y=(tt?K(U,rt,Y):K(Y))||Y);return tt&&Y&&__defProp$8(U,rt,Y),Y};let Login=class extends s{render(){return x`
            <h2>Welcome back</h2>
            <p class="warning">
                ⚠️ This login is <strong>factice</strong> (simply click on the login
                button) and is only here to <strong>mock the user journey</strong>.
            </p>
            <input
                disabled
                placeholder="Email *"
            ></input>
            <input
                disabled
                type="password"
                placeholder="Password *"
            ></input>
            <button @click=${this.handleClick}>Login</button>
        `}handleClick(){const dt=new Event("wli-login",{bubbles:!0,composed:!0});this.dispatchEvent(dt)}};Login.styles=i$3`
        :host {
            display: flex;
            flex-direction: column;
            margin: 24px;
            gap: 10px;
        }

        .warning {
            margin: 0;
            margin-bottom: 24px;
            color: #A7001E;
        }
    `;Login=__decorateClass$8([e$1("wli-login")],Login);var __defProp$7=Object.defineProperty,__getOwnPropDesc$7=Object.getOwnPropertyDescriptor,__decorateClass$7=(dt,U,rt,tt)=>{for(var Y=tt>1?void 0:tt?__getOwnPropDesc$7(U,rt):U,nt=dt.length-1,K;nt>=0;nt--)(K=dt[nt])&&(Y=(tt?K(U,rt,Y):K(Y))||Y);return tt&&Y&&__defProp$7(U,rt,Y),Y};let MainLayout=class extends s{render(){return x`
            <slot />
        `}};MainLayout.styles=i$3`
        :host {
            display: block;
            margin: 0 auto;
            max-width: 390px;
        }
    `;MainLayout=__decorateClass$7([e$1("wli-main-layout")],MainLayout);var __defProp$6=Object.defineProperty,__getOwnPropDesc$6=Object.getOwnPropertyDescriptor,__decorateClass$6=(dt,U,rt,tt)=>{for(var Y=tt>1?void 0:tt?__getOwnPropDesc$6(U,rt):U,nt=dt.length-1,K;nt>=0;nt--)(K=dt[nt])&&(Y=(tt?K(U,rt,Y):K(Y))||Y);return tt&&Y&&__defProp$6(U,rt,Y),Y};let MediaPlaceholder=class extends s{render(){return x`
            <svg
                xmlns="http://www.w3.org/2000/svg"
                height="96px"
                width="96px"
                viewBox="0 0 24 24"
                fill="#808080"
            >
                <path
                    d="M0 0h24v24H0V0z"
                    fill="none"
                />
                <path d="M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-4.86 8.86l-3 3.87L9 13.14 6 17h12l-3.86-5.14z"/>
            </svg>
        `}};MediaPlaceholder.styles=i$3`
        :host {
            display: block;
        }

        svg {
            display: block;
        }
    `;MediaPlaceholder=__decorateClass$6([e$1("wli-media-placeholder")],MediaPlaceholder);var __defProp$5=Object.defineProperty,__getOwnPropDesc$5=Object.getOwnPropertyDescriptor,__decorateClass$5=(dt,U,rt,tt)=>{for(var Y=tt>1?void 0:tt?__getOwnPropDesc$5(U,rt):U,nt=dt.length-1,K;nt>=0;nt--)(K=dt[nt])&&(Y=(tt?K(U,rt,Y):K(Y))||Y);return tt&&Y&&__defProp$5(U,rt,Y),Y};let OnnxActions=class extends s{constructor(){super(...arguments),this.disabled=!1,this.isStarted=!1}render(){return x`
            <hr />
            <div class="actions">
                <button
                    @click=${this.handleBack}
                >
                    Back
                </button>
                <button
                    ?disabled=${this.mode==="stream"}
                    @click=${this.handleRecord}
                >
                    Record
                </button>
                <button
                    @click=${this.handleUpload}
                >
                    Upload
                </button>
                <button
                    ?disabled=${this.disabled}
                    @click=${this.handleCapture}
                >
                    ${this.isStarted?"Stop":"Capture"}
                </button>
            </div>
        `}handleCapture(){let dt;this.isStarted?dt=new Event("wli-onnx-actions-stop",{bubbles:!0,composed:!0}):dt=new Event("wli-onnx-actions-start",{bubbles:!0,composed:!0}),this.dispatchEvent(dt),this.mode==="stream"&&(this.isStarted=!this.isStarted)}handleBack(){const dt=new Event("wli-onnx-actions-back",{bubbles:!0,composed:!0});this.dispatchEvent(dt)}handleRecord(){const dt=new Event("wli-onnx-actions-record",{bubbles:!0,composed:!0});this.dispatchEvent(dt)}handleUpload(){const dt=new Event("wli-onnx-actions-upload",{bubbles:!0,composed:!0});this.dispatchEvent(dt)}};OnnxActions.styles=i$3`
        :host {
            display: block;
            background-color: #020d29;
            height: 72px;
        }

        hr {
            margin: 0;
            border-color: black;
        }

        .actions {
            display: flex;
            justify-content: center;
            gap: 24px;
            margin: 24px 0;
        }
    `;__decorateClass$5([i("button")],OnnxActions.prototype,"buttonElm",2);__decorateClass$5([n$1({type:Boolean,attribute:"disabled"})],OnnxActions.prototype,"disabled",2);__decorateClass$5([n$1({type:String,attribute:"mode"})],OnnxActions.prototype,"mode",2);__decorateClass$5([t()],OnnxActions.prototype,"isStarted",2);OnnxActions=__decorateClass$5([e$1("wli-onnx-actions")],OnnxActions);/**
 * MediaStream ImageCapture polyfill
 *
 * @license
 * Copyright 2018 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */let ImageCapture$1=window.ImageCapture;typeof ImageCapture$1>"u"&&(ImageCapture$1=class{constructor(dt){if(dt.kind!=="video")throw new DOMException("NotSupportedError");this._videoStreamTrack=dt,"readyState"in this._videoStreamTrack||(this._videoStreamTrack.readyState="live"),this._previewStream=new MediaStream([dt]),this.videoElement=document.createElement("video"),this.videoElementPlaying=new Promise(U=>{this.videoElement.addEventListener("playing",U)}),HTMLMediaElement?this.videoElement.srcObject=this._previewStream:this.videoElement.src=URL.createObjectURL(this._previewStream),this.videoElement.muted=!0,this.videoElement.setAttribute("playsinline",""),this.videoElement.play(),this.canvasElement=document.createElement("canvas"),this.canvas2dContext=this.canvasElement.getContext("2d")}get videoStreamTrack(){return this._videoStreamTrack}getPhotoCapabilities(){return new Promise(function(U,rt){const tt={current:0,min:0,max:0};U({exposureCompensation:tt,exposureMode:"none",fillLightMode:"none",focusMode:"none",imageHeight:tt,imageWidth:tt,iso:tt,redEyeReduction:!1,whiteBalanceMode:"none",zoom:tt}),rt(new DOMException("OperationError"))})}setOptions(dt={}){return new Promise(function(rt,tt){})}takePhoto(){const dt=this;return new Promise(function(rt,tt){if(dt._videoStreamTrack.readyState!=="live")return tt(new DOMException("InvalidStateError"));dt.videoElementPlaying.then(()=>{try{dt.canvasElement.width=dt.videoElement.videoWidth,dt.canvasElement.height=dt.videoElement.videoHeight,dt.canvas2dContext.drawImage(dt.videoElement,0,0),dt.canvasElement.toBlob(rt)}catch{tt(new DOMException("UnknownError"))}})})}grabFrame(){const dt=this;return new Promise(function(rt,tt){if(dt._videoStreamTrack.readyState!=="live")return tt(new DOMException("InvalidStateError"));dt.videoElementPlaying.then(()=>{try{dt.canvasElement.width=dt.videoElement.videoWidth,dt.canvasElement.height=dt.videoElement.videoHeight,dt.canvas2dContext.drawImage(dt.videoElement,0,0),rt(window.createImageBitmap(dt.canvasElement))}catch{tt(new DOMException("UnknownError"))}})})}});window.ImageCapture=ImageCapture$1;function drawCanvas(dt,U){dt.width=Number(getComputedStyle(dt).width.split("px")[0]),dt.height=Number(getComputedStyle(dt).height.split("px")[0]);let rt=Math.min(dt.width/U.width,dt.height/U.height),tt=(dt.width-U.width*rt)/2,Y=(dt.height-U.height*rt)/2;dt.getContext("2d").clearRect(0,0,dt.width,dt.height),dt.getContext("2d").drawImage(U,0,0,U.width,U.height,tt,Y,U.width*rt,U.height*rt)}function preProcess({data:dt}){const U=[],rt=[],tt=[];for(let Y=0;Y<dt.length;Y+=4)U.push(dt[Y]/255),rt.push(dt[Y+1]/255),tt.push(dt[Y+2]/255);return[...U,...rt,...tt]}function postProcess(dt,U,rt,tt){const{data:Y,dims:nt}=dt,K=nt[2];let X=[];for(let q=0;q<K;q++){const[G,O]=[...Array(tt.length).keys()].map(st=>[st,Y[K*(st+4)+q]]).reduce((st,lt)=>lt[1]>st[1]?lt:st,[0,0]);if(O<.3)continue;const b=tt[G],F=Y[q],j=Y[K+q],W=Y[2*K+q],J=Y[3*K+q],et=(F-W/2)/U*U,ot=(j-J/2)/rt*rt,it=(F+W/2)/U*U,at=(j+J/2)/rt*rt;X.push([et,ot,it,at,b,O])}X=X.sort((q,G)=>G[5]-q[5]);const Q=[];for(;X.length>0;)Q.push(X[0]),X=X.filter(q=>iou(X[0],q)<.7||X[0][4]!==q[4]);return Q}function iou(dt,U){return intersection(dt,U)/union(dt,U)}function union(dt,U){const[rt,tt,Y,nt]=dt,[K,X,Q,q]=U,G=(Y-rt)*(nt-tt),O=(Q-K)*(q-X);return G+O-intersection(dt,U)}function intersection(dt,U){const[rt,tt,Y,nt]=dt,[K,X,Q,q]=U,G=Math.max(rt,K),O=Math.max(tt,X),b=Math.min(Y,Q),F=Math.min(nt,q);return(b-G)*(F-O)}function drawBoxes(dt,U,rt){const tt=dt.getContext("2d");tt.strokeStyle="#EB622D",tt.lineWidth=rt.lineWidth,tt.font="18px serif",U.forEach(([Y,nt,K,X,Q,q])=>{const G=[Q,q.toPrecision(2)].join(" ");tt.strokeRect(Y,nt,K-Y,X-nt),tt.fillStyle=rt.textBackgroundFillStyle;const O=tt.measureText(G).width;tt.fillRect(Y-2,nt-24,O+10,24),tt.fillStyle=rt.textFillStyle,tt.fillText(G,Y+1,nt-6)})}var ort_min={exports:{}};/*!
* ONNX Runtime Web v1.15.1
* Copyright (c) Microsoft Corporation. All rights reserved.
* Licensed under the MIT License.
*/(function(module,exports){(function(dt,U){module.exports=U()})(self,()=>(()=>{var __webpack_modules__={8453:(dt,U,rt)=>{rt.r(U),rt.d(U,{InferenceSession:()=>F,Tensor:()=>O,env:()=>K,registerBackend:()=>nt});const tt={},Y=[],nt=(j,W,J)=>{if(!W||typeof W.init!="function"||typeof W.createSessionHandler!="function")throw new TypeError("not a valid backend");{const et=tt[j];if(et===void 0)tt[j]={backend:W,priority:J};else{if(et.priority>J)return;if(et.priority===J&&et.backend!==W)throw new Error(`cannot register backend "${j}" using priority ${J}`)}if(J>=0){const ot=Y.indexOf(j);ot!==-1&&Y.splice(ot,1);for(let it=0;it<Y.length;it++)if(tt[Y[it]].priority<=J)return void Y.splice(it,0,j);Y.push(j)}}},K=new class{constructor(){this.wasm={},this.webgl={},this.webgpu={},this.logLevelInternal="warning"}set logLevel(j){if(j!==void 0){if(typeof j!="string"||["verbose","info","warning","error","fatal"].indexOf(j)===-1)throw new Error(`Unsupported logging level: ${j}`);this.logLevelInternal=j}}get logLevel(){return this.logLevelInternal}},X=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),Q=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]);let q=!1;class G{constructor(W,J,et){let ot,it,at;if((()=>{if(!q){q=!0;const lt=typeof BigInt64Array<"u"&&typeof BigInt64Array.from=="function",ct=typeof BigUint64Array<"u"&&typeof BigUint64Array.from=="function";lt&&(X.set("int64",BigInt64Array),Q.set(BigInt64Array,"int64")),ct&&(X.set("uint64",BigUint64Array),Q.set(BigUint64Array,"uint64"))}})(),typeof W=="string")if(ot=W,at=et,W==="string"){if(!Array.isArray(J))throw new TypeError("A string tensor's data must be a string array.");it=J}else{const lt=X.get(W);if(lt===void 0)throw new TypeError(`Unsupported tensor type: ${W}.`);if(Array.isArray(J))it=lt.from(J);else{if(!(J instanceof lt))throw new TypeError(`A ${ot} tensor's data must be type of ${lt}`);it=J}}else if(at=J,Array.isArray(W)){if(W.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");const lt=typeof W[0];if(lt==="string")ot="string",it=W;else{if(lt!=="boolean")throw new TypeError(`Invalid element type of data array: ${lt}.`);ot="bool",it=Uint8Array.from(W)}}else{const lt=Q.get(W.constructor);if(lt===void 0)throw new TypeError(`Unsupported type for tensor data: ${W.constructor}.`);ot=lt,it=W}if(at===void 0)at=[it.length];else if(!Array.isArray(at))throw new TypeError("A tensor's dims must be a number array");const st=(lt=>{let ct=1;for(let pt=0;pt<lt.length;pt++){const ut=lt[pt];if(typeof ut!="number"||!Number.isSafeInteger(ut))throw new TypeError(`dims[${pt}] must be an integer, got: ${ut}`);if(ut<0)throw new RangeError(`dims[${pt}] must be a non-negative integer, got: ${ut}`);ct*=ut}return ct})(at);if(st!==it.length)throw new Error(`Tensor's size(${st}) does not match data length(${it.length}).`);this.dims=at,this.type=ot,this.data=it,this.size=st}static bufferToTensor(W,J){if(W===void 0)throw new Error("Image buffer must be defined");if(J.height===void 0||J.width===void 0)throw new Error("Image height and width must be defined");if(J.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");const{height:et,width:ot}=J,it=J.norm??{mean:255,bias:0};let at,st;at=typeof it.mean=="number"?[it.mean,it.mean,it.mean,it.mean]:[it.mean[0],it.mean[1],it.mean[2],it.mean[3]??255],st=typeof it.bias=="number"?[it.bias,it.bias,it.bias,it.bias]:[it.bias[0],it.bias[1],it.bias[2],it.bias[3]??0];const lt=J.bitmapFormat!==void 0?J.bitmapFormat:"RGBA",ct=J.tensorFormat!==void 0&&J.tensorFormat!==void 0?J.tensorFormat:"RGB",pt=et*ot,ut=ct==="RGBA"?new Float32Array(4*pt):new Float32Array(3*pt);let ft=4,gt=0,_t=1,vt=2,bt=3,St=0,yt=pt,wt=2*pt,Dt=-1;lt==="RGB"&&(ft=3,gt=0,_t=1,vt=2,bt=-1),ct==="RGBA"?Dt=3*pt:ct==="RBG"?(St=0,wt=pt,yt=2*pt):ct==="BGR"&&(wt=0,yt=pt,St=2*pt);for(let Pt=0;Pt<pt;Pt++,gt+=ft,vt+=ft,_t+=ft,bt+=ft)ut[St++]=(W[gt]+st[0])/at[0],ut[yt++]=(W[_t]+st[1])/at[1],ut[wt++]=(W[vt]+st[2])/at[2],Dt!==-1&&bt!==-1&&(ut[Dt++]=(W[bt]+st[3])/at[3]);return new G("float32",ut,ct==="RGBA"?[1,4,et,ot]:[1,3,et,ot])}static async fromImage(W,J){const et=typeof HTMLImageElement<"u"&&W instanceof HTMLImageElement,ot=typeof ImageData<"u"&&W instanceof ImageData,it=typeof ImageBitmap<"u"&&W instanceof ImageBitmap,at=typeof W=="string";let st,lt=J??{};if(et){const ct=document.createElement("canvas");ct.width=W.width,ct.height=W.height;const pt=ct.getContext("2d");if(pt==null)throw new Error("Can not access image data");{let ut=W.height,ft=W.width;if(J!==void 0&&J.resizedHeight!==void 0&&J.resizedWidth!==void 0&&(ut=J.resizedHeight,ft=J.resizedWidth),J!==void 0){if(lt=J,J.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");if(lt.tensorFormat="RGBA",J.height!==void 0&&J.height!==ut)throw new Error("Image input config height doesn't match HTMLImageElement height");if(lt.height=ut,J.width!==void 0&&J.width!==ft)throw new Error("Image input config width doesn't match HTMLImageElement width");lt.width=ft}else lt.tensorFormat="RGBA",lt.height=ut,lt.width=ft;pt.drawImage(W,0,0),st=pt.getImageData(0,0,ft,ut).data}}else{if(!ot){if(it){if(J===void 0)throw new Error("Please provide image config with format for Imagebitmap");if(J.bitmapFormat!==void 0)throw new Error("Image input config format must be defined for ImageBitmap");const ct=document.createElement("canvas").getContext("2d");if(ct!=null){const pt=W.height,ut=W.width;if(ct.drawImage(W,0,0,ut,pt),st=ct.getImageData(0,0,ut,pt).data,J!==void 0){if(J.height!==void 0&&J.height!==pt)throw new Error("Image input config height doesn't match ImageBitmap height");if(lt.height=pt,J.width!==void 0&&J.width!==ut)throw new Error("Image input config width doesn't match ImageBitmap width");lt.width=ut}else lt.height=pt,lt.width=ut;return G.bufferToTensor(st,lt)}throw new Error("Can not access image data")}if(at)return new Promise((ct,pt)=>{const ut=document.createElement("canvas"),ft=ut.getContext("2d");if(!W||!ft)return pt();const gt=new Image;gt.crossOrigin="Anonymous",gt.src=W,gt.onload=()=>{ut.width=gt.width,ut.height=gt.height,ft.drawImage(gt,0,0,ut.width,ut.height);const _t=ft.getImageData(0,0,ut.width,ut.height);if(J!==void 0){if(J.height!==void 0&&J.height!==ut.height)throw new Error("Image input config height doesn't match height");if(lt.height=ut.height,J.width!==void 0&&J.width!==ut.width)throw new Error("Image input config width doesn't match width");lt.width=ut.width}else lt.height=ut.height,lt.width=ut.width;ct(G.bufferToTensor(_t.data,lt))}});throw new Error("Input data provided is not supported - aborted tensor creation")}{const ct="RGBA";let pt,ut;if(J!==void 0&&J.resizedWidth!==void 0&&J.resizedHeight!==void 0?(pt=J.resizedHeight,ut=J.resizedWidth):(pt=W.height,ut=W.width),J!==void 0){if(lt=J,J.bitmapFormat!==void 0&&J.bitmapFormat!==ct)throw new Error("Image input config format must be RGBA for ImageData");lt.bitmapFormat="RGBA"}else lt.bitmapFormat="RGBA";if(lt.height=pt,lt.width=ut,J!==void 0){const ft=document.createElement("canvas");ft.width=ut,ft.height=pt;const gt=ft.getContext("2d");if(gt==null)throw new Error("Can not access image data");gt.putImageData(W,0,0),st=gt.getImageData(0,0,ut,pt).data}else st=W.data}}if(st!==void 0)return G.bufferToTensor(st,lt);throw new Error("Input data provided is not supported - aborted tensor creation")}toDataURL(W){const J=document.createElement("canvas");J.width=this.dims[3],J.height=this.dims[2];const et=J.getContext("2d");if(et!=null){let ot,it;(W==null?void 0:W.tensorLayout)!==void 0&&W.tensorLayout==="NHWC"?(ot=this.dims[2],it=this.dims[3]):(ot=this.dims[3],it=this.dims[2]);const at=(W==null?void 0:W.format)!==void 0?W.format:"RGB",st=W==null?void 0:W.norm;let lt,ct;st===void 0||st.mean===void 0?lt=[255,255,255,255]:typeof st.mean=="number"?lt=[st.mean,st.mean,st.mean,st.mean]:(lt=[st.mean[0],st.mean[1],st.mean[2],0],st.mean[3]!==void 0&&(lt[3]=st.mean[3])),st===void 0||st.bias===void 0?ct=[0,0,0,0]:typeof st.bias=="number"?ct=[st.bias,st.bias,st.bias,st.bias]:(ct=[st.bias[0],st.bias[1],st.bias[2],0],st.bias[3]!==void 0&&(ct[3]=st.bias[3]));const pt=it*ot;let ut=0,ft=pt,gt=2*pt,_t=-1;at==="RGBA"?(ut=0,ft=pt,gt=2*pt,_t=3*pt):at==="RGB"?(ut=0,ft=pt,gt=2*pt):at==="RBG"&&(ut=0,gt=pt,ft=2*pt);for(let vt=0;vt<it;vt++)for(let bt=0;bt<ot;bt++){const St=(this.data[ut++]-ct[0])*lt[0],yt=(this.data[ft++]-ct[1])*lt[1],wt=(this.data[gt++]-ct[2])*lt[2],Dt=_t===-1?255:(this.data[_t++]-ct[3])*lt[3];et.fillStyle="rgba("+St+","+yt+","+wt+","+Dt+")",et.fillRect(bt,vt,1,1)}return J.toDataURL()}throw new Error("Can not access image data")}toImageData(W){const J=document.createElement("canvas").getContext("2d");let et;if(J==null)throw new Error("Can not access image data");{let ot,it,at;(W==null?void 0:W.tensorLayout)!==void 0&&W.tensorLayout==="NHWC"?(ot=this.dims[2],it=this.dims[1],at=this.dims[3]):(ot=this.dims[3],it=this.dims[2],at=this.dims[1]);const st=W!==void 0&&W.format!==void 0?W.format:"RGB",lt=W==null?void 0:W.norm;let ct,pt;lt===void 0||lt.mean===void 0?ct=[255,255,255,255]:typeof lt.mean=="number"?ct=[lt.mean,lt.mean,lt.mean,lt.mean]:(ct=[lt.mean[0],lt.mean[1],lt.mean[2],255],lt.mean[3]!==void 0&&(ct[3]=lt.mean[3])),lt===void 0||lt.bias===void 0?pt=[0,0,0,0]:typeof lt.bias=="number"?pt=[lt.bias,lt.bias,lt.bias,lt.bias]:(pt=[lt.bias[0],lt.bias[1],lt.bias[2],0],lt.bias[3]!==void 0&&(pt[3]=lt.bias[3]));const ut=it*ot;if(W!==void 0){if(W.height!==void 0&&W.height!==it)throw new Error("Image output config height doesn't match tensor height");if(W.width!==void 0&&W.width!==ot)throw new Error("Image output config width doesn't match tensor width");if(W.format!==void 0&&at===4&&W.format!=="RGBA"||at===3&&W.format!=="RGB"&&W.format!=="BGR")throw new Error("Tensor format doesn't match input tensor dims")}const ft=4;let gt=0,_t=1,vt=2,bt=3,St=0,yt=ut,wt=2*ut,Dt=-1;st==="RGBA"?(St=0,yt=ut,wt=2*ut,Dt=3*ut):st==="RGB"?(St=0,yt=ut,wt=2*ut):st==="RBG"&&(St=0,wt=ut,yt=2*ut),et=J.createImageData(ot,it);for(let Pt=0;Pt<it*ot;gt+=ft,_t+=ft,vt+=ft,bt+=ft,Pt++)et.data[gt]=(this.data[St++]-pt[0])*ct[0],et.data[_t]=(this.data[yt++]-pt[1])*ct[1],et.data[vt]=(this.data[wt++]-pt[2])*ct[2],et.data[bt]=Dt===-1?255:(this.data[Dt++]-pt[3])*ct[3]}return et}reshape(W){return new G(this.type,this.data,W)}}const O=G;class b{constructor(W){this.handler=W}async run(W,J,et){const ot={};let it={};if(typeof W!="object"||W===null||W instanceof O||Array.isArray(W))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let at=!0;if(typeof J=="object"){if(J===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(J instanceof O)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(J)){if(J.length===0)throw new TypeError("'fetches' cannot be an empty array.");at=!1;for(const ct of J){if(typeof ct!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(ct)===-1)throw new RangeError(`'fetches' contains invalid output name: ${ct}.`);ot[ct]=null}if(typeof et=="object"&&et!==null)it=et;else if(et!==void 0)throw new TypeError("'options' must be an object.")}else{let ct=!1;const pt=Object.getOwnPropertyNames(J);for(const ut of this.outputNames)if(pt.indexOf(ut)!==-1){const ft=J[ut];(ft===null||ft instanceof O)&&(ct=!0,at=!1,ot[ut]=ft)}if(ct){if(typeof et=="object"&&et!==null)it=et;else if(et!==void 0)throw new TypeError("'options' must be an object.")}else it=J}}else if(J!==void 0)throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const ct of this.inputNames)if(W[ct]===void 0)throw new Error(`input '${ct}' is missing in 'feeds'.`);if(at)for(const ct of this.outputNames)ot[ct]=null;const st=await this.handler.run(W,ot,it),lt={};for(const ct in st)Object.hasOwnProperty.call(st,ct)&&(lt[ct]=new O(st[ct].type,st[ct].data,st[ct].dims));return lt}static async create(W,J,et,ot){let it,at={};if(typeof W=="string"){if(it=W,typeof J=="object"&&J!==null)at=J;else if(J!==void 0)throw new TypeError("'options' must be an object.")}else if(W instanceof Uint8Array){if(it=W,typeof J=="object"&&J!==null)at=J;else if(J!==void 0)throw new TypeError("'options' must be an object.")}else{if(!(W instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&W instanceof SharedArrayBuffer))throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");{const pt=W;let ut=0,ft=W.byteLength;if(typeof J=="object"&&J!==null)at=J;else if(typeof J=="number"){if(ut=J,!Number.isSafeInteger(ut))throw new RangeError("'byteOffset' must be an integer.");if(ut<0||ut>=pt.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${pt.byteLength}).`);if(ft=W.byteLength-ut,typeof et=="number"){if(ft=et,!Number.isSafeInteger(ft))throw new RangeError("'byteLength' must be an integer.");if(ft<=0||ut+ft>pt.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${pt.byteLength-ut}].`);if(typeof ot=="object"&&ot!==null)at=ot;else if(ot!==void 0)throw new TypeError("'options' must be an object.")}else if(et!==void 0)throw new TypeError("'byteLength' must be a number.")}else if(J!==void 0)throw new TypeError("'options' must be an object.");it=new Uint8Array(pt,ut,ft)}}const st=(at.executionProviders||[]).map(pt=>typeof pt=="string"?pt:pt.name),lt=await(async pt=>{const ut=pt.length===0?Y:pt,ft=[];for(const gt of ut){const _t=tt[gt];if(_t){if(_t.initialized)return _t.backend;if(_t.aborted)continue;const vt=!!_t.initPromise;try{return vt||(_t.initPromise=_t.backend.init()),await _t.initPromise,_t.initialized=!0,_t.backend}catch(bt){vt||ft.push({name:gt,err:bt}),_t.aborted=!0}finally{delete _t.initPromise}}}throw new Error(`no available backend found. ERR: ${ft.map(gt=>`[${gt.name}] ${gt.err}`).join(", ")}`)})(st),ct=await lt.createSessionHandler(it,at);return new b(ct)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}const F=b},5716:(dt,U,rt)=>{U.R=void 0;const tt=rt(6027),Y=rt(1723);U.R=new class{async init(){}async createSessionHandler(nt,K){const X=new tt.Session(K);return await X.loadModel(nt),new Y.OnnxjsSessionHandler(X)}}},2818:(dt,U,rt)=>{U.c8=U.rX=void 0;const tt=rt(8453),Y=rt(5381),nt=rt(9544),K=rt(6640);U.rX=()=>{if((typeof tt.env.wasm.initTimeout!="number"||tt.env.wasm.initTimeout<0)&&(tt.env.wasm.initTimeout=0),typeof tt.env.wasm.simd!="boolean"&&(tt.env.wasm.simd=!0),typeof tt.env.wasm.proxy!="boolean"&&(tt.env.wasm.proxy=!1),typeof tt.env.wasm.numThreads!="number"||!Number.isInteger(tt.env.wasm.numThreads)||tt.env.wasm.numThreads<=0){const X=typeof navigator>"u"?(0,Y.cpus)().length:navigator.hardwareConcurrency;tt.env.wasm.numThreads=Math.min(4,Math.ceil((X||1)/2))}},U.c8=new class{async init(){(0,U.rX)(),await(0,nt.initWasm)()}async createSessionHandler(X,Q){const q=new K.OnnxruntimeWebAssemblySessionHandler;return await q.loadModel(X,Q),Promise.resolve(q)}}},1057:function(dt,U,rt){var tt=this&&this.__createBinding||(Object.create?function(K,X,Q,q){q===void 0&&(q=Q);var G=Object.getOwnPropertyDescriptor(X,Q);G&&!("get"in G?!X.__esModule:G.writable||G.configurable)||(G={enumerable:!0,get:function(){return X[Q]}}),Object.defineProperty(K,q,G)}:function(K,X,Q,q){q===void 0&&(q=Q),K[q]=X[Q]}),Y=this&&this.__exportStar||function(K,X){for(var Q in K)Q==="default"||Object.prototype.hasOwnProperty.call(X,Q)||tt(X,K,Q)};Object.defineProperty(U,"__esModule",{value:!0}),Y(rt(8453),U);const nt=rt(8453);{const K=rt(5716).R;(0,nt.registerBackend)("webgl",K,-10)}{const K=rt(2818).c8;(0,nt.registerBackend)("cpu",K,10),(0,nt.registerBackend)("wasm",K,10),(0,nt.registerBackend)("xnnpack",K,9)}},4910:(dt,U)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.createAttributeWithCacheKey=void 0;class rt{constructor(Y){Object.assign(this,Y)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map(Y=>`${this[Y]}`).join(";")),this._cacheKey}}U.createAttributeWithCacheKey=tt=>new rt(tt)},6874:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.Attribute=void 0;const tt=rt(1446),Y=rt(1287),nt=rt(9240),K=rt(7273);var X=Y.onnxruntime.experimental.fbs;class Q{constructor(G){if(this._attributes=new Map,G!=null){for(const O of G)O instanceof tt.onnx.AttributeProto?this._attributes.set(O.name,[Q.getValue(O),Q.getType(O)]):O instanceof X.Attribute&&this._attributes.set(O.name(),[Q.getValue(O),Q.getType(O)]);if(this._attributes.size<G.length)throw new Error("duplicated attribute names")}}set(G,O,b){this._attributes.set(G,[b,O])}delete(G){this._attributes.delete(G)}getFloat(G,O){return this.get(G,"float",O)}getInt(G,O){return this.get(G,"int",O)}getString(G,O){return this.get(G,"string",O)}getTensor(G,O){return this.get(G,"tensor",O)}getFloats(G,O){return this.get(G,"floats",O)}getInts(G,O){return this.get(G,"ints",O)}getStrings(G,O){return this.get(G,"strings",O)}getTensors(G,O){return this.get(G,"tensors",O)}get(G,O,b){const F=this._attributes.get(G);if(F===void 0){if(b!==void 0)return b;throw new Error(`required attribute not found: ${G}`)}if(F[1]!==O)throw new Error(`type mismatch: expected ${O} but got ${F[1]}`);return F[0]}static getType(G){const O=G instanceof tt.onnx.AttributeProto?G.type:G.type();switch(O){case tt.onnx.AttributeProto.AttributeType.FLOAT:return"float";case tt.onnx.AttributeProto.AttributeType.INT:return"int";case tt.onnx.AttributeProto.AttributeType.STRING:return"string";case tt.onnx.AttributeProto.AttributeType.TENSOR:return"tensor";case tt.onnx.AttributeProto.AttributeType.FLOATS:return"floats";case tt.onnx.AttributeProto.AttributeType.INTS:return"ints";case tt.onnx.AttributeProto.AttributeType.STRINGS:return"strings";case tt.onnx.AttributeProto.AttributeType.TENSORS:return"tensors";default:throw new Error(`attribute type is not supported yet: ${tt.onnx.AttributeProto.AttributeType[O]}`)}}static getValue(G){const O=G instanceof tt.onnx.AttributeProto?G.type:G.type();if(O===tt.onnx.AttributeProto.AttributeType.GRAPH||O===tt.onnx.AttributeProto.AttributeType.GRAPHS)throw new Error("graph attribute is not supported yet");const b=this.getValueNoCheck(G);if(O===tt.onnx.AttributeProto.AttributeType.INT&&K.LongUtil.isLong(b))return K.LongUtil.longToNumber(b);if(O===tt.onnx.AttributeProto.AttributeType.INTS){const F=b,j=new Array(F.length);for(let W=0;W<F.length;W++){const J=F[W];j[W]=K.LongUtil.longToNumber(J)}return j}if(O===tt.onnx.AttributeProto.AttributeType.TENSOR)return G instanceof tt.onnx.AttributeProto?nt.Tensor.fromProto(b):nt.Tensor.fromOrtTensor(b);if(O===tt.onnx.AttributeProto.AttributeType.TENSORS){if(G instanceof tt.onnx.AttributeProto)return b.map(F=>nt.Tensor.fromProto(F));if(G instanceof X.Attribute)return b.map(F=>nt.Tensor.fromOrtTensor(F))}if(O===tt.onnx.AttributeProto.AttributeType.STRING&&G instanceof tt.onnx.AttributeProto){const F=b;return(0,K.decodeUtf8String)(F)}return O===tt.onnx.AttributeProto.AttributeType.STRINGS&&G instanceof tt.onnx.AttributeProto?b.map(K.decodeUtf8String):b}static getValueNoCheck(G){return G instanceof tt.onnx.AttributeProto?this.getValueNoCheckFromOnnxFormat(G):this.getValueNoCheckFromOrtFormat(G)}static getValueNoCheckFromOnnxFormat(G){switch(G.type){case tt.onnx.AttributeProto.AttributeType.FLOAT:return G.f;case tt.onnx.AttributeProto.AttributeType.INT:return G.i;case tt.onnx.AttributeProto.AttributeType.STRING:return G.s;case tt.onnx.AttributeProto.AttributeType.TENSOR:return G.t;case tt.onnx.AttributeProto.AttributeType.GRAPH:return G.g;case tt.onnx.AttributeProto.AttributeType.FLOATS:return G.floats;case tt.onnx.AttributeProto.AttributeType.INTS:return G.ints;case tt.onnx.AttributeProto.AttributeType.STRINGS:return G.strings;case tt.onnx.AttributeProto.AttributeType.TENSORS:return G.tensors;case tt.onnx.AttributeProto.AttributeType.GRAPHS:return G.graphs;default:throw new Error(`unsupported attribute type: ${tt.onnx.AttributeProto.AttributeType[G.type]}`)}}static getValueNoCheckFromOrtFormat(G){switch(G.type()){case X.AttributeType.FLOAT:return G.f();case X.AttributeType.INT:return G.i();case X.AttributeType.STRING:return G.s();case X.AttributeType.TENSOR:return G.t();case X.AttributeType.GRAPH:return G.g();case X.AttributeType.FLOATS:return G.floatsArray();case X.AttributeType.INTS:{const O=[];for(let b=0;b<G.intsLength();b++)O.push(G.ints(b));return O}case X.AttributeType.STRINGS:{const O=[];for(let b=0;b<G.stringsLength();b++)O.push(G.strings(b));return O}case X.AttributeType.TENSORS:{const O=[];for(let b=0;b<G.tensorsLength();b++)O.push(G.tensors(b));return O}default:throw new Error(`unsupported attribute type: ${X.AttributeType[G.type()]}`)}}}U.Attribute=Q},1975:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.resolveBackend=U.backend=void 0;const tt=rt(4418),Y=new Map;async function nt(K){const X=U.backend;if(X[K]!==void 0&&function(Q){const q=Q;return"initialize"in q&&typeof q.initialize=="function"&&"createSessionHandler"in q&&typeof q.createSessionHandler=="function"&&"dispose"in q&&typeof q.dispose=="function"}(X[K])){const Q=X[K];let q=Q.initialize();if(typeof q=="object"&&"then"in q&&(q=await q),q)return Y.set(K,Q),Q}}U.backend={webgl:new tt.WebGLBackend},U.resolveBackend=async function K(X){if(!X)return K(["webgl"]);{const Q=typeof X=="string"?[X]:X;for(const q of Q){const G=Y.get(q);if(G)return G;const O=await nt(q);if(O)return O}}throw new Error("no available backend to use")}},4418:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.WebGLBackend=void 0;const tt=rt(8453),Y=rt(1315),nt=rt(2171),K=rt(3389);U.WebGLBackend=class{get contextId(){return tt.env.webgl.contextId}set contextId(X){tt.env.webgl.contextId=X}get matmulMaxBatchSize(){return tt.env.webgl.matmulMaxBatchSize}set matmulMaxBatchSize(X){tt.env.webgl.matmulMaxBatchSize=X}get textureCacheMode(){return tt.env.webgl.textureCacheMode}set textureCacheMode(X){tt.env.webgl.textureCacheMode=X}get pack(){return tt.env.webgl.pack}set pack(X){tt.env.webgl.pack=X}get async(){return tt.env.webgl.async}set async(X){tt.env.webgl.async=X}initialize(){try{return this.glContext=(0,K.createWebGLContext)(this.contextId),typeof this.matmulMaxBatchSize!="number"&&(this.matmulMaxBatchSize=16),typeof this.textureCacheMode!="string"&&(this.textureCacheMode="full"),typeof this.pack!="boolean"&&(this.pack=!1),typeof this.async!="boolean"&&(this.async=!1),Y.Logger.setWithEnv(tt.env),Y.Logger.verbose("WebGLBackend",`Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`),!0}catch(X){return Y.Logger.warning("WebGLBackend",`Unable to initialize WebGLBackend. ${X}`),!1}}createSessionHandler(X){return new nt.WebGLSessionHandler(this,X)}dispose(){this.glContext.dispose()}}},6859:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.CoordsGlslLib=void 0;const tt=rt(7273),Y=rt(1997),nt=rt(6757),K=rt(7618),X=rt(432);class Q extends Y.GlslLib{constructor(G){super(G)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.offsetToCoords()),this.coordsToOffset()),this.toVec()),this.valueFrom()),this.getCommonUtilFuncs()),this.getInputsSamplingSnippets()),this.getOutputSamplingSnippet())}getCustomTypes(){return{}}offsetToCoords(){return{offsetToCoords:new Y.GlslLibRoutine(`
      vec2 offsetToCoords(int offset, int width, int height) {
        int t = offset / width;
        int s = offset - t*width;
        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);
        return coords;
      }
      `)}}coordsToOffset(){return{coordsToOffset:new Y.GlslLibRoutine(`
      int coordsToOffset(vec2 coords, int width, int height) {
        float s = coords.s * float(width);
        float t = coords.t * float(height);
        int offset = int(t) * width + int(s);
        return offset;
      }
      `)}}getOutputSamplingSnippet(){const G=this.context.outputTextureLayout;return G.isPacked?this.getPackedOutputSamplingSnippet(G):this.getUnpackedOutputSamplingSnippet(G)}getPackedOutputSamplingSnippet(G){const O=G.unpackedShape,b=[G.width,G.height],F={},j="getOutputCoords";switch(O.length){case 0:F[j]=this.getOutputScalarCoords();break;case 1:F[j]=this.getOutputPacked1DCoords(O,b);break;case 2:F[j]=this.getOutputPacked2DCoords(O,b);break;case 3:F[j]=this.getOutputPacked3DCoords(O,b);break;default:F[j]=this.getOutputPackedNDCoords(O,b)}const W=`
      void setOutput(vec4 val) {
        ${(0,nt.getGlsl)(this.context.glContext.version).output} = val;
      }
    `;return F.floatTextureSetRGBA=new Y.GlslLibRoutine(W),F}getUnpackedOutputSamplingSnippet(G){const O=G.unpackedShape,b=[G.width,G.height],F={},j="getOutputCoords";switch(O.length){case 0:F[j]=this.getOutputScalarCoords();break;case 1:F[j]=this.getOutputUnpacked1DCoords(O,b);break;case 2:F[j]=this.getOutputUnpacked2DCoords(O,b);break;case 3:F[j]=this.getOutputUnpacked3DCoords(O,b);break;case 4:F[j]=this.getOutputUnpacked4DCoords(O,b);break;case 5:F[j]=this.getOutputUnpacked5DCoords(O,b);break;case 6:F[j]=this.getOutputUnpacked6DCoords(O,b);break;default:throw new Error(`Unsupported output dimensionality: ${O.length}`)}const W=`
        void setOutput(float val) {
          ${(0,nt.getGlsl)(this.context.glContext.version).output} = vec4(val, 0, 0, 0);
        }
    `;return F.floatTextureSetR=new Y.GlslLibRoutine(W),F}getOutputScalarCoords(){return new Y.GlslLibRoutine(`
      int getOutputCoords() {
        return 0;
      }
    `)}getOutputPacked1DCoords(G,O){const b=O;let F="";return b[0]===1?(F=`
          int getOutputCoords() {
            return 2 * int(TexCoords.y * ${b[1]}.0);
          }
        `,new Y.GlslLibRoutine(F)):b[1]===1?(F=`
          int getOutputCoords() {
            return 2 * int(TexCoords.x * ${b[0]}.0);
          }
        `,new Y.GlslLibRoutine(F)):(F=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                 vec2(${b[0]}, ${b[1]}));
          return 2 * (resTexRC.y * ${b[0]} + resTexRC.x);
        }
      `,new Y.GlslLibRoutine(F))}getOutputPacked2DCoords(G,O){let b="";if(tt.ArrayUtil.arraysEqual(G,O))return b=`
        ivec2 getOutputCoords() {
          return 2 * ivec2(TexCoords.xy * vec2(${O[0]}, ${O[1]}));
        }
      `,new Y.GlslLibRoutine(b);const F=O,j=Math.ceil(G[1]/2);return b=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${F[0]}, ${F[1]}));

          int index = resTexRC.y * ${F[0]} + resTexRC.x;

          // reverse r and c order for packed texture
          int r = imod(index, ${j}) * 2;
          int c = 2 * (index / ${j});

          return ivec2(r, c);
        }
      `,new Y.GlslLibRoutine(b)}getOutputPacked3DCoords(G,O){const b=[O[0],O[1]],F=Math.ceil(G[2]/2),j=F*Math.ceil(G[1]/2),W=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${b[0]}, ${b[1]}));
          int index = resTexRC.y * ${b[0]} + resTexRC.x;

          int b = index / ${j};
          index -= b * ${j};

          // reverse r and c order for packed texture
          int r = imod(index, ${F}) * 2;
          int c = 2 * (index / ${F});

          return ivec3(b, r, c);
        }
      `;return new Y.GlslLibRoutine(W)}getOutputPackedNDCoords(G,O){const b=[O[0],O[1]],F=Math.ceil(G[G.length-1]/2),j=F*Math.ceil(G[G.length-2]/2);let W=j,J="",et="b, r, c";for(let it=2;it<G.length-1;it++)W*=G[G.length-it-1],J=`
      int b${it} = index / ${W};
      index -= b${it} * ${W};
    `+J,et=`b${it}, `+et;const ot=`
      ivec${G.length} getOutputCoords() {
        ivec2 resTexRC = ivec2(TexCoords.xy *
                              vec2(${b[0]}, ${b[1]}));
        int index = resTexRC.y * ${b[0]} + resTexRC.x;

        ${J}

        int b = index / ${j};
        index -= b * ${j};

        // reverse r and c order for packed texture
        int r = imod(index, ${F}) * 2;
        int c = 2 * (index / ${F});

        return ivec${G.length}(${et});
      }
    `;return new Y.GlslLibRoutine(ot)}getOutputUnpacked1DCoords(G,O){const b=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${O[0]}, ${O[1]}));
          return resTexRC.y * ${O[0]} + resTexRC.x;
        }
      `;return new Y.GlslLibRoutine(b)}getOutputUnpacked2DCoords(G,O){const b=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${O[0]}, ${O[1]}));
          int index = resTexRC.y * ${O[0]} + resTexRC.x;
          int r = index / ${G[1]};
          int c = index - r * ${G[1]};
          return ivec2(r, c);
        }
      `;return new Y.GlslLibRoutine(b)}getOutputUnpacked3DCoords(G,O){let b="";const F=G.length;let j=null;F<2&&(j=[]),j=new Array(F-1),j[F-2]=G[F-1];for(let et=F-3;et>=0;--et)j[et]=j[et+1]*G[et+1];const W=["r","c","d"],J=j.map((et,ot)=>`int ${W[ot]} = index / ${et}; ${ot===j.length-1?`int ${W[ot+1]} = index - ${W[ot]} * ${et}`:`index -= ${W[ot]} * ${et}`};`).join("");return b=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${O[0]}, ${O[1]}));
          int index = resTexRC.y * ${O[0]} + resTexRC.x;
          ${J}
          return ivec3(r, c, d);
        }
      `,new Y.GlslLibRoutine(b)}getOutputUnpacked4DCoords(G,O){let b="";const F=G.length;let j=null;F<2&&(j=[]),j=new Array(F-1),j[F-2]=G[F-1];for(let et=F-3;et>=0;--et)j[et]=j[et+1]*G[et+1];const W=["r","c","d","d2"],J=j.map((et,ot)=>`int ${W[ot]} = index / ${et}; ${ot===j.length-1?`int ${W[ot+1]} = index - ${W[ot]} * ${et}`:`index -= ${W[ot]} * ${et}`};`).join("");return b=`
      ivec4 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${O[0]}, ${O[1]}));
          int index = resTexRC.y * ${O[0]} + resTexRC.x;
          ${J}
          return ivec4(r, c, d, d2);
        }
      `,new Y.GlslLibRoutine(b)}getOutputUnpacked5DCoords(G,O){let b="";const F=G.length;let j=null;F<2&&(j=[]),j=new Array(F-1),j[F-2]=G[F-1];for(let et=F-3;et>=0;--et)j[et]=j[et+1]*G[et+1];const W=["r","c","d","d2","d3"],J=j.map((et,ot)=>`int ${W[ot]} = index / ${et}; ${ot===j.length-1?`int ${W[ot+1]} = index - ${W[ot]} * ${et}`:`index -= ${W[ot]} * ${et}`};`).join("");return b=`
      ivec5 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${O[0]}, ${O[1]}));
          int index = resTexRC.y * ${O[0]} + resTexRC.x;
          ${J}
          return ivec5(r, c, d, d2, d3);
        }
      `,new Y.GlslLibRoutine(b)}getOutputUnpacked6DCoords(G,O){let b="";const F=G.length;let j=null;F<2&&(j=[]),j=new Array(F-1),j[F-2]=G[F-1];for(let et=F-3;et>=0;--et)j[et]=j[et+1]*G[et+1];const W=["r","c","d","d2","d3","d4"],J=j.map((et,ot)=>`int ${W[ot]} = index / ${et}; ${ot===j.length-1?`int ${W[ot+1]} = index - ${W[ot]} * ${et}`:`index -= ${W[ot]} * ${et}`};`).join("");return b=`
     ivec6 getOutputCoords() {
         ivec2 resTexRC = ivec2(TexCoords.xy *
                               vec2(${O[0]}, ${O[1]}));
         int index = resTexRC.y * ${O[0]} + resTexRC.x;
         ${J}
         return ivec6(r, c, d, d2, d3, d4);
       }
     `,new Y.GlslLibRoutine(b)}getCommonUtilFuncs(){const G={};let O="uvFromFlat";G[O]=new Y.GlslLibRoutine(`
    vec2 uvFromFlat(int texNumR, int texNumC, int index) {
      int texC = index / texNumR;
      int texR = index - texC * texNumR;
      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to
      //       v.
      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);
    }
    `),O="packedUVfrom1D",G[O]=new Y.GlslLibRoutine(`
      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
        int texelIndex = index / 2;
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),O="packedUVfrom2D",G[O]=new Y.GlslLibRoutine(`
      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {
        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),O="packedUVfrom3D",G[O]=new Y.GlslLibRoutine(`
      vec2 packedUVfrom3D(int texNumR, int texNumC,
          int texelsInBatch, int texelsInLogicalRow, int b,
          int row, int col) {
        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = index / texNumC;
        int texC = index - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),O="sampleTexture";const b=(0,nt.getGlsl)(this.context.glContext.version);return G[O]=new Y.GlslLibRoutine(`
        float sampleTexture(sampler2D textureSampler, vec2 uv) {
            return ${b.texture2D}(textureSampler, uv).r;
        }`),G}getInputsSamplingSnippets(){const G={},O=this.context.outputTextureLayout;return this.context.programInfo.inputNames.forEach((b,F)=>{const j=this.context.inputTextureLayouts[F],W=(0,X.generateShaderFuncNameFromInputSamplerName)(b);j.isPacked?G[W]=this.getPackedSamplerFromInput(W,b,j):G[W]=this.getUnpackedSamplerFromInput(W,b,j);const J=(0,X.generateShaderFuncNameFromInputSamplerNameAtOutCoords)(b);j.unpackedShape.length<=O.unpackedShape.length&&(j.isPacked?G[J]=this.getPackedSamplerAtOutputCoords(J,j,O,b):G[J]=this.getUnpackedSamplerAtOutputCoords(J,j,O,b))}),G}getPackedSamplerAtOutputCoords(G,O,b,F){const j=O.unpackedShape,W=b.unpackedShape,J=F,et=(0,X.generateShaderFuncNameFromInputSamplerName)(J),ot=j.length,it=W.length,at=tt.BroadcastUtil.getBroadcastDims(j,W),st=(0,X.getCoordsDataType)(it),lt=it-ot;let ct;const pt=(0,X.getGlChannels)();ct=ot===0?"":it<2&&at.length>=1?"coords = 0;":at.map(bt=>`coords.${pt[bt+lt]} = 0;`).join(`
`);let ut="";ut=it<2&&ot>0?"coords":j.map((bt,St)=>`coords.${pt[St+lt]}`).join(", ");let ft="return outputValue;";const gt=tt.ShapeUtil.size(j)===1,_t=tt.ShapeUtil.size(W)===1;if(ot!==1||gt||_t){if(gt&&!_t)ft=it===1?`
          return vec4(outputValue.x, outputValue.x, 0., 0.);
        `:`
          return vec4(outputValue.x);
        `;else if(at.length){const bt=ot-2,St=ot-1;at.indexOf(bt)>-1&&at.indexOf(St)>-1?ft="return vec4(outputValue.x);":at.indexOf(bt)>-1?ft="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":at.indexOf(St)>-1&&(ft="return vec4(outputValue.xx, outputValue.zz);")}}else ft=`
        return vec4(outputValue.xy, outputValue.xy);
      `;const vt=`
      vec4 ${G}() {
        ${st} coords = getOutputCoords();
        
        int lastDim = coords.${pt[it-1]};
        coords.${pt[it-1]} = coords.${pt[it-2]};
        coords.${pt[it-2]} = lastDim;
      
        ${ct}
        vec4 outputValue = ${et}(${ut});
        ${ft}
      }
    `;return new Y.GlslLibRoutine(vt,["coordinates.getOutputCoords"])}getUnpackedSamplerAtOutputCoords(G,O,b,F){const j=[b.width,b.height],W=[O.width,O.height],J=O.unpackedShape.length,et=b.unpackedShape.length,ot=O.unpackedShape,it=b.unpackedShape,at=(0,X.generateShaderFuncNameFromInputSamplerName)(F);if(J===et&&tt.ArrayUtil.arraysEqual(W,j)){const _t=`
          float ${G}() {
            return sampleTexture(${F}, TexCoords);
          }
        `;return new Y.GlslLibRoutine(_t,["coordinates.sampleTexture"])}const st=(0,X.getCoordsDataType)(et),lt=tt.BroadcastUtil.getBroadcastDims(ot,it),ct=et-J;let pt;const ut=(0,X.getGlChannels)();pt=J===0?"":et<2&&lt.length>=1?"coords = 0;":lt.map(_t=>`coords.${ut[_t+ct]} = 0;`).join(`
`);let ft="";ft=et<2&&J>0?"coords":O.unpackedShape.map((_t,vt)=>`coords.${ut[vt+ct]}`).join(", ");const gt=`
        float ${G}() {
          ${st} coords = getOutputCoords();
          ${pt}
          return ${at}(${ft});
        }
      `;return new Y.GlslLibRoutine(gt,["coordinates.getOutputCoords"])}getPackedSamplerFromInput(G,O,b){switch(b.unpackedShape.length){case 0:return this.getPackedSamplerScalar(G,O);case 1:return this.getPackedSampler1D(G,O,b);case 2:return this.getPackedSampler2D(G,O,b);case 3:return this.getPackedSampler3D(G,O,b);default:return this.getPackedSamplerND(G,O,b)}}getUnpackedSamplerFromInput(G,O,b){const F=b.unpackedShape;switch(F.length){case 0:return this.getUnpackedSamplerScalar(G,O,b);case 1:return this.getUnpackedSampler1D(G,O,b);case 2:return this.getUnpackedSampler2D(G,O,b);case 3:return this.getUnpackedSampler3D(G,O,b);case 4:return this.getUnpackedSampler4D(G,O,b);case 5:return this.getUnpackedSampler5D(G,O,b);case 6:return this.getUnpackedSampler6D(G,O,b);default:throw new Error(`Unsupported dimension ${F.length}-D`)}}getPackedSamplerScalar(G,O){const b=`
          vec4 ${G}() {
            return ${(0,nt.getGlsl)(this.context.glContext.version).texture2D}(${O}, halfCR);
          }
        `;return new Y.GlslLibRoutine(b)}getPackedSampler1D(G,O,b){const F=[b.width,b.height],j=[F[1],F[0]],W=(0,nt.getGlsl)(this.context.glContext.version),J=`vec4 ${G}(int index) {
      vec2 uv = packedUVfrom1D(
      ${j[0]}, ${j[1]}, index);
      return ${W.texture2D}(${O}, uv);
    }`;return new Y.GlslLibRoutine(J,["coordinates.packedUVfrom1D"])}getPackedSampler2D(G,O,b){const F=b.unpackedShape,j=[b.width,b.height],W=(0,nt.getGlsl)(this.context.glContext.version),J=j[0],et=j[1];if(j!=null&&tt.ArrayUtil.arraysEqual(F,j)){const st=`vec4 ${G}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${et}.0, ${J}.0);
        return ${W.texture2D}(${O}, uv);
      }`;return new Y.GlslLibRoutine(st)}const ot=j,it=Math.ceil(F[1]/2),at=`vec4 ${G}(int row, int col) {
      vec2 uv = packedUVfrom2D(${ot[1]}, ${ot[0]}, ${it}, row, col);
      return ${W.texture2D}(${O}, uv);
    }`;return new Y.GlslLibRoutine(at,["coordinates.packedUVfrom2D"])}getPackedSampler3D(G,O,b){const F=b.unpackedShape,j=[b.width,b.height],W=[j[0],j[1]],J=(0,nt.getGlsl)(this.context.glContext.version);if(F[0]===1){const st=F.slice(1),lt=[1,2],ct=(0,X.squeezeInputShape)(F,st),pt=["b","row","col"],ut=JSON.parse(JSON.stringify(b));ut.unpackedShape=ct;const ft=this.getPackedSamplerFromInput(G,O,ut),gt=`${ft.routineBody}
      vec4 ${G}(int b, int row, int col) {
        return ${G}(${(0,X.getSqueezedParams)(pt,lt)});
      } `;return new Y.GlslLibRoutine(gt,ft.dependencies)}const et=W[0],ot=W[1],it=Math.ceil(F[2]/2),at=`vec4 ${G}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${ot}, ${et}, ${it*Math.ceil(F[1]/2)}, ${it}, b, row, col);
      return ${J.texture2D}(${O}, uv);}`;return new Y.GlslLibRoutine(at,["coordinates.packedUVfrom3D"])}getPackedSamplerND(G,O,b){const F=b.unpackedShape,j=F.length,W=[b.width,b.height],J=(0,nt.getGlsl)(this.context.glContext.version),et=[W[0],W[1]],ot=et[1],it=et[0],at=Math.ceil(F[j-1]/2);let st=at*Math.ceil(F[j-2]/2),lt="int b, int row, int col",ct=`b * ${st} + (row / 2) * ${at} + (col / 2)`;for(let ut=2;ut<j-1;ut++)lt=`int b${ut}, `+lt,st*=F[j-ut-1],ct=`b${ut} * ${st} + `+ct;const pt=`vec4 ${G}(${lt}) {
      int index = ${ct};
      int texR = index / ${it};
      int texC = index - texR * ${it};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${it}, ${ot});
      return ${J.texture2D}(${O}, uv);
    }`;return new Y.GlslLibRoutine(pt)}getUnpackedSamplerScalar(G,O,b){const[F,j]=[b.width,b.height];if(F===1&&j===1){const J=`
          float ${G}() {
            return sampleTexture(${O}, halfCR);
          }
        `;return new Y.GlslLibRoutine(J,["coordinates.sampleTexture"])}const W=`
        float ${G}() {
          int offset_${O} = coordsToOffset(TexCoords, ${F}, ${j});
          vec2 uv = uvFromFlat(${F}, ${j}, offset_${O});
          return sampleTexture(${O}, uv);
        }
      `;return new Y.GlslLibRoutine(W,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler1D(G,O,b){const F=b.width,j=b.height;if(j===1&&F===1){const J=`
        float ${G}(int index) {
          return sampleTexture(${O}, halfCR);
        }
      `;return new Y.GlslLibRoutine(J,["coordinates.sampleTexture"])}if(j===1){const J=`
          float ${G}(int index) {
            vec2 uv = vec2((float(index) + 0.5) / ${F}.0, 0.5);
            return sampleTexture(${O}, uv);
          }
        `;return new Y.GlslLibRoutine(J,["coordinates.sampleTexture"])}if(F===1){const J=`
          float ${G}(int index) {
            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${j}.0);
            return sampleTexture(${O}, uv);
          }
        `;return new Y.GlslLibRoutine(J,["coordinates.sampleTexture"])}const W=`
        float ${G}(int index) {
          vec2 uv = uvFromFlat(${F}, ${j}, index);
          return sampleTexture(${O}, uv);
        }
      `;return new Y.GlslLibRoutine(W,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler2D(G,O,b){const F=b.unpackedShape,j=[b.height,b.width];if(j!=null&&tt.ArrayUtil.arraysEqual(F,j)){const st=`
          float ${G}(int row, int col) {
            vec2 uv = (vec2(row, col) + halfCR) / vec2(${j[1]}.0, ${j[0]}.0);
            return sampleTexture(${O}, uv);
          }
        `;return new Y.GlslLibRoutine(st,["coordinates.sampleTexture"])}const{newShape:W,keptDims:J}=(0,K.squeezeShape)(F),et=W;if(et.length<F.length){const st=(0,X.squeezeInputShape)(F,et),lt=JSON.parse(JSON.stringify(b));lt.unpackedShape=st;const ct=["col","row"],pt=`
          ${this.getUnpackedSamplerFromInput(G,O,lt).routineBody}
          float ${G}(int row, int col) {
            return ${G}(${(0,X.getSqueezedParams)(ct,J)});
          }
        `;return new Y.GlslLibRoutine(pt,["coordinates.sampleTexture"])}const ot=j[1],it=j[0];if(it===1){const st=`
          float ${G}(int row, int col) {
            int offset_${O} = coordsToOffset(TexCoords, ${ot}, ${it});
            float index = dot(vec3(row, col, offset_${O}), vec3(${F[1]}, 1, 1));
            vec2 uv = vec2(0.5, (index + 0.5) / ${ot}.0);
            return sampleTexture(${O}, uv);
          }
        `;return new Y.GlslLibRoutine(st,["coordinates.sampleTexture","coordinates.coordsToOffset"])}if(ot===1){const st=`
          float ${G}(int row, int col) {
            int offset_${O} = coordsToOffset(TexCoords, ${ot}, ${it});
            float index = dot(vec3(row, col, offset_${O}), vec3(${F[1]}, 1, 1));
            vec2 uv = vec2((index + 0.5) / ${it}.0, 0.5);
            return sampleTexture(${O}, uv);
          }
        `;return new Y.GlslLibRoutine(st,["coordinates.sampleTexture","coordinates.coordsToOffset"])}const at=`
        float ${G}(int row, int col) {
          int index = col * ${F[1]} + row;
          vec2 uv = uvFromFlat(${ot}, ${it}, index);
          return sampleTexture(${O}, uv);
        }
      `;return new Y.GlslLibRoutine(at,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler3D(G,O,b){const F=b.unpackedShape,j=F[1]*F[2],W=F[2],{newShape:J,keptDims:et}=(0,K.squeezeShape)(F),ot=J;if(ot.length<F.length){const at=(0,X.squeezeInputShape)(F,ot),st=["batch","col","row"],lt=JSON.parse(JSON.stringify(b));lt.unpackedShape=at;const ct=this.getUnpackedSamplerFromInput(G,O,lt),pt=et.reverse(),ut=`
          ${ct.routineBody}
          float ${G}(int batch, int row, int col) {
            return ${G}(${(0,X.getSqueezedParams)(st,pt)});
          }
        `;return new Y.GlslLibRoutine(ut,ct.dependencies)}const it=`
          float ${G}(int depth, int row, int col) {
            // Explicitly use integer operations as dot() only works on floats.
            int index = depth * ${j} + col * ${W} + row;
            vec2 uv = uvFromFlat(${b.width}, ${b.height}, index);
            return sampleTexture(${O}, uv);
          }
      `;return new Y.GlslLibRoutine(it,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler4D(G,O,b){const F=b.unpackedShape,j=F[3],W=F[2]*j,J=`
        float ${G}(int row, int col, int depth, int depth2) {
          int index = row * ${F[1]*W} + col * ${W} +
              depth2 * ${j} + depth;
          vec2 uv = uvFromFlat(${b.width}, ${b.height}, index);
          return sampleTexture(${O}, uv);
        }
      `;return new Y.GlslLibRoutine(J,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler5D(G,O,b){const F=b.unpackedShape,j=F[4],W=F[3]*j,J=F[2]*W,et=F[1]*J,{newShape:ot,keptDims:it}=(0,K.squeezeShape)(F);if(ot.length<F.length){const st=(0,X.squeezeInputShape)(F,ot),lt=["row","col","depth","depth2","depth3"],ct=JSON.parse(JSON.stringify(b));ct.unpackedShape=st;const pt=`
          ${this.getUnpackedSamplerFromInput(G,O,ct).routineBody}
          float ${G}(int row, int col, int depth, int depth2, int depth3) {
            return ${G}(${(0,X.getSqueezedParams)(lt,it)});
          }
        `;return new Y.GlslLibRoutine(pt,["coordinates.sampleTexture","coordinates.uvFromFlat"])}const at=`
        float ${G}(int row, int col, int depth, int depth2, int depth3) {
          int index = row * ${et} + col * ${J} + depth * ${W} +
          depth3 * ${j} + depth2;
          vec2 uv = uvFromFlat(${b.width}, ${b.height}, index);
          return sampleTexture(${O}, uv);
        }
      `;return new Y.GlslLibRoutine(at,["coordinates.sampleTexture","coordinates.uvFromFlat"])}getUnpackedSampler6D(G,O,b){const F=b.unpackedShape,j=F[5],W=F[4]*j,J=F[3]*W,et=F[2]*J,ot=F[1]*et,{newShape:it,keptDims:at}=(0,K.squeezeShape)(F);if(it.length<F.length){const lt=(0,X.squeezeInputShape)(F,it),ct=["row","col","depth","depth2","depth3","depth4"],pt=JSON.parse(JSON.stringify(b));pt.unpackedShape=lt;const ut=`
            ${this.getUnpackedSamplerFromInput(G,O,pt).routineBody}
            float ${G}(int row, int col, int depth,
              int depth2, int depth3, int depth4) {
              return ${G}(${(0,X.getSqueezedParams)(ct,at)});
            }
          `;return new Y.GlslLibRoutine(ut,["coordinates.sampleTexture","coordinates.uvFromFlat"])}const st=`
          float ${G}(int row, int col, int depth,
            int depth2, int depth3, int depth4) {
            int index = row * ${ot} + col * ${et} + depth * ${J} +
            depth2 * ${W} + depth3 * ${j} + depth4;
            vec2 uv = uvFromFlat(${b.width}, ${b.height}, index);
            return sampleTexture(${O}, uv);
          }
        `;return new Y.GlslLibRoutine(st,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}toVec(){const G=this.context.outputTextureLayout,O=G.shape.length,b=G.strides,F=G.width,j=G.height,W=[];for(let et=0;et<O-1;++et)W.push(`
        c[${et}] = offset / ${b[et]};`),W.push(`
        offset -= c[${et}] * ${b[et]};`);W.push(`
        c[${O-1}] = offset;`);const J=`
      void toVec(vec2 texCoords, out int c[${O}]) {
        int offset = coordsToOffset(texCoords, ${F}, ${j});
        ${W.join("")}
      }
      void toVec(int offset, out int c[${O}]) {
        ${W.join("")}
      }
    `;return{toVec:new Y.GlslLibRoutine(J,["coordinates.coordsToOffset"])}}valueFrom(){const G={};return this.context.programInfo.inputNames.forEach((O,b)=>{const F=this.context.inputTextureLayouts[b],j=(F.unpackedShape.length>0?F.unpackedShape:F.shape).length;let W=`_${O}`;G[W]=new Y.GlslLibRoutine(this.getValueFromSingle(O,j,F.width,F.height,!1),[`shapeUtils.indicesToOffset${W}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"]),W+="_T",G[W]=new Y.GlslLibRoutine(this.getValueFromSingle(O,j,F.width,F.height,!0),[`shapeUtils.indicesToOffset${W}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"])}),G}getValueFromSingle(G,O,b,F,j){let W=`_${G}`;return j&&(W+="_T"),`
        float ${W}(int m[${O}]) {
          int offset = indicesToOffset${W}(m);
          vec2 coords = offsetToCoords(offset, ${b}, ${F});
          float value = getColorAsFloat(${(0,nt.getGlsl)(this.context.glContext.version).texture2D}(${G}, coords));
          return value;
        }
        `}getPackedValueFrom(G,O,b,F,j){let W=`_${G}_Pack`;return j&&(W+="_T"),`
        vec4 ${W}(int m[${O}]) {
          int offset = indicesToOffset_${G}(m);
          vec2 coords = offsetToCoords(offset, ${b}, ${F});
          return ${(0,nt.getGlsl)(this.context.glContext.version).texture2D}(${G}, coords);
        }
        `}}U.CoordsGlslLib=Q},1997:(dt,U)=>{var rt;Object.defineProperty(U,"__esModule",{value:!0}),U.TopologicalSortGlslRoutines=U.GlslLibRoutineNode=U.GlslLibRoutine=U.GlslLib=U.GlslContext=U.FunctionType=void 0,(rt=U.FunctionType||(U.FunctionType={}))[rt.ValueBased=0]="ValueBased",rt[rt.Positional=1]="Positional",U.GlslContext=class{constructor(tt,Y,nt,K){this.glContext=tt,this.programInfo=Y,this.inputTextureLayouts=nt,this.outputTextureLayout=K}},U.GlslLib=class{constructor(tt){this.context=tt}},U.GlslLibRoutine=class{constructor(tt,Y){this.routineBody=tt,this.dependencies=Y}},U.GlslLibRoutineNode=class{constructor(tt,Y,nt){this.name=tt,this.dependencies=nt||[],Y&&(this.routineBody=Y)}addDependency(tt){tt&&this.dependencies.push(tt)}},U.TopologicalSortGlslRoutines=class{static returnOrderedNodes(tt){if(!tt||tt.length===0)return[];if(tt.length===1)return tt;const Y=new Set,nt=new Set,K=new Array;return this.createOrderedNodes(tt,Y,nt,K),K}static createOrderedNodes(tt,Y,nt,K){for(let X=0;X<tt.length;++X)this.dfsTraverse(tt[X],Y,nt,K)}static dfsTraverse(tt,Y,nt,K){if(!tt||nt.has(tt.name))return;if(Y.has(tt.name))throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");Y.add(tt.name);const X=tt.dependencies;if(X&&X.length>0)for(let Q=0;Q<X.length;++Q)this.dfsTraverse(X[Q],Y,nt,K);K.push(tt),nt.add(tt.name),Y.delete(tt.name)}}},1371:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.EncodingGlslLib=void 0;const tt=rt(1997);class Y extends tt.GlslLib{constructor(K){super(K)}getFunctions(){return Object.assign(Object.assign({},this.encodeFloat32()),this.decodeFloat32())}getCustomTypes(){return{}}encodeFloat32(){return{encode:new tt.GlslLibRoutine(`highp vec4 encode(highp float f) {
        return vec4(f, 0.0, 0.0, 0.0);
      }
        `)}}decodeFloat32(){return{decode:new tt.GlslLibRoutine(`highp float decode(highp vec4 rgba) {
        return rgba.r;
      }
        `)}}encodeUint8(){const K=Y.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{encode:new tt.GlslLibRoutine(`
      highp vec4 encode(highp float f) {
        highp float F = abs(f);
        highp float Sign = step(0.0,-f);
        highp float Exponent = floor(log2(F));
        highp float Mantissa = (exp2(- Exponent) * F);
        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));
        highp vec4 rgba;
        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));
        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);
        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));
        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));
        ${K}
        rgba = rgba / 255.0; // values need to be normalized to [0,1]
        return rgba;
    }
        `)}}decodeUint8(){const K=Y.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{decode:new tt.GlslLibRoutine(`
        highp float decode(highp vec4 rgba) {
          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]
          ${K}
          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;
          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;
          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);
          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));
          return Result;
      }
        `)}}static isLittleEndian(){const K=new ArrayBuffer(4),X=new Uint32Array(K),Q=new Uint8Array(K);if(X[0]=3735928559,Q[0]===239)return!0;if(Q[0]===222)return!1;throw new Error("unknown endianness")}}U.EncodingGlslLib=Y},2691:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.FragColorGlslLib=void 0;const tt=rt(1997),Y=rt(6757);class nt extends tt.GlslLib{constructor(X){super(X)}getFunctions(){return Object.assign(Object.assign({},this.setFragColor()),this.getColorAsFloat())}getCustomTypes(){return{}}setFragColor(){const X=(0,Y.getGlsl)(this.context.glContext.version);return{setFragColor:new tt.GlslLibRoutine(`
        void setFragColor(float value) {
            ${X.output} = encode(value);
        }
        `,["encoding.encode"])}}getColorAsFloat(){return{getColorAsFloat:new tt.GlslLibRoutine(`
        float getColorAsFloat(vec4 color) {
            return decode(color);
        }
        `,["encoding.decode"])}}}U.FragColorGlslLib=nt},3878:(dt,U)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.replaceInlines=void 0;const rt=/@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm;U.replaceInlines=function(tt){const Y={};let nt;for(;(nt=rt.exec(tt))!==null;){const K=nt[3].split(",").map(X=>{const Q=X.trim().split(" ");return Q&&Q.length===2?{type:Q[0],name:Q[1]}:null}).filter(X=>X!==null);Y[nt[2]]={params:K,body:nt[4]}}for(const K in Y){const X="(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;".replace("__FUNC__",K),Q=new RegExp(X,"gm");for(;(nt=Q.exec(tt))!==null;){const q=nt[1],G=nt[2],O=nt[3].split(","),b=q?`${q} ${G};`:"";let F=Y[K].body,j="";Y[K].params.forEach((J,et)=>{J&&(j+=`${J.type} ${J.name} = ${O[et]};
`)}),F=`${j}
 ${F}`,F=F.replace("return",`${G} = `);const W=`
      ${b}
      {
        ${F}
      }
      `;tt=tt.replace(nt[0],W)}}return tt.replace(rt,"")}},8897:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.GlslPreprocessor=void 0;const tt=rt(1997),Y=rt(3878),nt=rt(1248),K=rt(6757);U.GlslPreprocessor=class{constructor(X,Q,q,G){this.libs={},this.glslLibRoutineDependencyGraph={},this.context=new tt.GlslContext(X,Q,q,G),Object.keys(nt.glslRegistry).forEach(b=>{const F=new nt.glslRegistry[b](this.context);this.libs[b]=F});const O=this.glslLibRoutineDependencyGraph;for(const b in this.libs){const F=this.libs[b].getFunctions();for(const j in F){const W=b+"."+j;let J;O[W]?(J=O[W],J.routineBody=F[j].routineBody):(J=new tt.GlslLibRoutineNode(W,F[j].routineBody),O[W]=J);const et=F[j].dependencies;if(et)for(let ot=0;ot<et.length;++ot)if(O[et[ot]])J.addDependency(O[et[ot]]);else{const it=new tt.GlslLibRoutineNode(et[ot]);O[et[ot]]=it,J.addDependency(it)}}}}preprocess(){const X=this.context.programInfo;let Q=X.shaderSource;return this.context.programInfo.hasMain||(Q=`${Q}
      ${(0,K.getDefaultFragShaderMain)(this.context.glContext.version,this.context.outputTextureLayout.shape.length)}`),Q=(0,Y.replaceInlines)(Q),`${(0,K.getFragShaderPreamble)(this.context.glContext.version)}
    ${this.getUniforms(X.inputNames,X.variables)}
    ${this.getImports(Q)}
    ${Q}`}getImports(X){const Q=this.selectGlslLibRoutinesToBeIncluded(X);if(Q.length===0)return"";let q="";for(let G=0;G<Q.length;++G){if(!Q[G].routineBody)throw new Error(`Missing body for the Glsl Library routine: ${Q[G].name}`);q+=Q[G].routineBody+`
`}return q}selectGlslLibRoutinesToBeIncluded(X){const Q=[];return Object.keys(this.glslLibRoutineDependencyGraph).forEach(q=>{const G=q.split(".")[1];X.indexOf(G)!==-1&&Q.push(this.glslLibRoutineDependencyGraph[q])}),tt.TopologicalSortGlslRoutines.returnOrderedNodes(Q)}getUniforms(X,Q){const q=[];if(X)for(const G of X)q.push(`uniform sampler2D ${G};`);if(Q)for(const G of Q)q.push(`uniform ${G.type} ${G.name}${G.arrayLength?`[${G.arrayLength}]`:""};`);return q.join(`
`)}}},1248:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.glslRegistry=void 0;const tt=rt(6859),Y=rt(1371),nt=rt(2691),K=rt(9183),X=rt(9314);U.glslRegistry={encoding:Y.EncodingGlslLib,fragcolor:nt.FragColorGlslLib,vec:X.VecGlslLib,shapeUtils:K.ShapeUtilsGlslLib,coordinates:tt.CoordsGlslLib}},9183:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.ShapeUtilsGlslLib=void 0;const tt=rt(1997);class Y extends tt.GlslLib{constructor(K){super(K)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.bcastIndex()),this.bcastMatmulIndex()),this.offsetToIndices()),this.indicesToOffset()),this.incrementIndices())}getCustomTypes(){return{}}bcastIndex(){const K=this.context.outputTextureLayout.shape.length,X={};return this.context.programInfo.inputNames.forEach((Q,q)=>{const G=this.context.inputTextureLayouts[q].unpackedShape;if(G.length<=K){const O=G.length,b=K-O,F=`bcastIndices_${Q}`;let j="";for(let J=0;J<O;++J)j+=`
          realIndices[${J}] = int( mod(float(bcastedIndices[${b+J}]), ${G[J]}.0) );
          `;const W=`
        void ${F} (int bcastedIndices[${K}], out int realIndices[${O}]) {
          ${j}
        }
        `;X[F]=new tt.GlslLibRoutine(W)}}),X}bcastMatmulIndex(){const K=this.context.outputTextureLayout.shape.length,X={};return this.context.programInfo.inputNames.forEach((Q,q)=>{const G=this.context.inputTextureLayouts[q].shape;if(!(G.length<2||G.length>K)){const O=G.length,b=K-O,F=`bcastMatmulIndices_${Q}`;let j="";for(let J=0;J<O-2;++J)j+=`
          realIndices[${J}] = int( mod(float(bcastedIndices[${b+J}]), ${G[J]}.0) );
          `;const W=`
        void ${F}(int bcastedIndices[${K}], out int realIndices[${O}]) {
          ${j}
          realIndices[${O-1}] = bcastedIndices[${K-1}];
          realIndices[${O-2}] = bcastedIndices[${K-2}];
        }
        `;X[F]=new tt.GlslLibRoutine(W)}}),X}indicesToOffset(){const K={};return this.context.programInfo.inputNames.forEach((X,Q)=>{const q=this.context.inputTextureLayouts[Q].shape,G=this.context.inputTextureLayouts[Q].strides,O=q.length;let b=`indicesToOffset_${X}`;K[b]=new tt.GlslLibRoutine(Y.indexToOffsetSingle(b,O,G)),b=`indicesToOffset_${X}_T`,K[b]=new tt.GlslLibRoutine(Y.indexToOffsetSingle(b,O,G.slice().reverse()))}),K}static indexToOffsetSingle(K,X,Q){let q="";for(let G=X-1;G>=0;--G)q+=`
        offset += indices[${G}] * ${Q[G]};
        `;return`
      int ${K}(int indices[${X}]) {
        int offset = 0;
        ${q}
        return offset;
      }
      `}offsetToIndices(){const K={};return this.context.programInfo.inputNames.forEach((X,Q)=>{const q=this.context.inputTextureLayouts[Q].shape,G=this.context.inputTextureLayouts[Q].strides,O=q.length;let b=`offsetToIndices_${X}`;K[b]=new tt.GlslLibRoutine(Y.offsetToIndicesSingle(b,O,G)),b=`offsetToIndices_${X}_T`,K[b]=new tt.GlslLibRoutine(Y.offsetToIndicesSingle(b,O,G.slice().reverse()))}),K}static offsetToIndicesSingle(K,X,Q){const q=[];for(let G=0;G<X-1;++G)q.push(`
      indices[${G}] = offset / ${Q[G]};`),q.push(`
        offset -= indices[${G}] * ${Q[G]};`);return q.push(`
      indices[${X-1}] = offset;`),`
      void ${K}(int offset, out int indices[${X}]) {
        ${q.join("")}
      }
      `}incrementIndices(){const K={};return this.context.programInfo.inputNames.forEach((X,Q)=>{const q=this.context.inputTextureLayouts[Q].shape,G=q.length,O=`incrementIndices_${X}`;let b="";for(let j=0;j<G;++j)b+=`
        shape[${j}] = ${q[j]};`;const F=`
        void ${O}(int axis, out int indices[${G}]) {
          int shape[${G}];
          ${b};
          for(int i = ${G} -1 ; i >= 0; --i) {
            if(i > axis) continue;
            indices[i] += 1;
            if(indices[i] < shape[i]) {
              break;
            }
            indices[i] = 0;
          }
        }
        `;K[O]=new tt.GlslLibRoutine(F)}),K}}U.ShapeUtilsGlslLib=Y},6757:(dt,U)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.getDefaultFragShaderMain=U.getFragShaderPreamble=U.getVertexShaderSource=U.getGlsl=void 0;const rt={version:"",attribute:"attribute",varyingVertex:"varying",varyingFrag:"varying",texture2D:"texture2D",output:"gl_FragColor",outputDeclaration:""},tt={version:"#version 300 es",attribute:"in",varyingVertex:"out",varyingFrag:"in",texture2D:"texture",output:"outputColor",outputDeclaration:"out vec4 outputColor;"};function Y(nt){return nt===1?rt:tt}U.getGlsl=Y,U.getVertexShaderSource=function(nt){const K=Y(nt);return`${K.version}
      precision highp float;
      ${K.attribute} vec3 position;
      ${K.attribute} vec2 textureCoord;

      ${K.varyingVertex} vec2 TexCoords;

      void main()
      {
          gl_Position = vec4(position, 1.0);
          TexCoords = textureCoord;
      }`},U.getFragShaderPreamble=function(nt){const K=Y(nt);return`${K.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${K.varyingFrag} vec2 TexCoords;
    ${K.outputDeclaration}
    const vec2 halfCR = vec2(0.5, 0.5);

    // Custom vector types to handle higher dimenalities.
    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    `},U.getDefaultFragShaderMain=function(nt,K){return`
  void main() {
    int indices[${K}];
    toVec(TexCoords, indices);
    vec4 result = vec4(process(indices));
    ${Y(nt).output} = result;
  }
  `}},9314:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.VecGlslLib=void 0;const tt=rt(1997);class Y extends tt.GlslLib{constructor(K){super(K)}getCustomTypes(){return{}}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign({},this.binaryVecFunctions()),this.copyVec()),this.setVecItem()),this.getVecItem())}binaryVecFunctions(){const K=this.context.outputTextureLayout.shape.length,X={add:"+=",sub:"-=",mul:"*=",div:"/="},Q={};for(const q in X){const G=`${q}Vec`;let O="";for(let F=0;F<K;++F)O+=`
          dest[${F}] ${X[q]} src[${F}];
          `;const b=`
        void ${G}(int src[${K}], out int dest[${K}]) {
          ${O}
        }
        `;Q[G]=new tt.GlslLibRoutine(b)}return Q}copyVec(){const K=this.context.outputTextureLayout.shape.length;let X="";for(let q=0;q<K;++q)X+=`
        dest[${q}] = src[${q}];
        `;const Q=`
      void copyVec(int src[${K}], out int dest[${K}]) {
        ${X}
      }
      `;return{copyVec:new tt.GlslLibRoutine(Q)}}setVecItem(){const K=this.context.outputTextureLayout.shape.length;let X=`
        if(index < 0)
            index =${K} + index;
        if (index == 0)
            m[0] = value;
        `;for(let q=1;q<K-1;++q)X+=`
        else if (index == ${q})
            m[${q}] = value;
            `;X+=`
        else
            m[${K-1}] = value;
        `;const Q=`
      void setVecItem(out int m[${K}], int index, int value) {
        ${X}
      }
        `;return{setVecItem:new tt.GlslLibRoutine(Q)}}getVecItem(){const K=this.context.outputTextureLayout.shape.length;let X=`
        if(index < 0)
            index = ${K} + index;
        if (index == 0)
            return m[0];
      `;for(let q=1;q<K-1;++q)X+=`
        else if (index == ${q})
            return m[${q}];
      `;X+=`
        else
            return m[${K-1}];
        `;const Q=`
      int getVecItem(int m[${K}], int index) {
        ${X}
      }
    `;return{getVecItem:new tt.GlslLibRoutine(Q)}}}U.VecGlslLib=Y},7860:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.WebGLInferenceHandler=void 0;const tt=rt(1315),Y=rt(9240),nt=rt(7273),K=rt(9),X=rt(7379),Q=rt(2488),q=rt(540),G=rt(3314),O=rt(5639);U.WebGLInferenceHandler=class{constructor(b){this.session=b,this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map}calculateTextureWidthAndHeight(b,F){return(0,G.calculateTextureWidthAndHeight)(this.session.layoutStrategy,b,F)}executeProgram(b,F){if(F.length<b.inputNames.length)throw new Error(`Input size mustn't be less than ${b.inputNames.length}.`);if(b.inputNames.length!==b.inputTypes.length)throw new Error("input names size does not match input types");const j=[];for(let at=0;at<b.inputNames.length;++at)j[at]=this.getOrCreateTextureData(F[at],b.inputTypes[at]);const W=((at,st)=>{const lt=st.map(pt=>`${pt.unpackedShape.join(",")};${pt.width}x${pt.height}`).join("_");let ct=at.name;return at.cacheHint&&(ct+="["+at.cacheHint+"]"),ct+=":"+lt,ct})(b,j);let J=this.session.programManager.getArtifact(W);const et=J?J.programInfo:typeof b.get=="function"?b.get():b,ot=(0,G.createTextureLayoutFromTextureType)(this.session.layoutStrategy,et.output.dims,et.output.textureType),it=this.createTextureData(ot,et.output.type);return J||(J=this.session.programManager.build(et,j,it),this.session.programManager.setArtifact(W,J)),this.runProgram(J,j,it),it}run(b,F){return this.executeProgram(b,F).tensor}runProgram(b,F,j){for(let W=0;W<F.length;++W)if(!!F[W].isPacked!=(b.programInfo.inputTypes[W]===O.TextureType.packed))throw new Error(`input[${W}] property packed inconsistent`);if(!!j.isPacked!=(b.programInfo.output.textureType===O.TextureType.packed))throw new Error("output property packed inconsistent");this.session.programManager.run(b,F,j)}getOrCreateTextureData(b,F){let j=this.getTextureData(b.dataId,F===O.TextureType.packed);if(!j&&(j=this.getTextureData(b.dataId,F!==O.TextureType.packed),j))return F===O.TextureType.packed?this.pack(j):this.unpack(j);if(!j){const W=(0,G.createTextureLayoutFromTextureType)(this.session.layoutStrategy,b.dims,F);if(F===O.TextureType.packedLastDimension){const ot=b.dims;if(ot.length===4){const it=[ot[0],Math.ceil(ot[1]*ot[2]*ot[3]/4)],at=(0,G.createTextureLayoutFromTextureType)(this.session.layoutStrategy,it,F);let st=b.numberData;if(ot[1]*ot[2]*ot[3]%4!=0){const lt=ot[0],ct=ot[1]*ot[2]*ot[3],pt=Math.ceil(ct*1/4)*4;st=new Float32Array(lt*pt);for(let ut=0;ut<lt;++ut){const ft=ut*ct,gt=ut*pt+ut%1*ct;st.set(b.numberData.subarray(ft,ft+ct),gt)}}return this.createTextureData(at,b.type,st,b,1)}}if(F===O.TextureType.packed){const J=(0,G.createTextureLayoutFromShape)(this.session.layoutStrategy,b.dims,1,[],{reverseWH:!0}),et=this.createTextureData(J,b.type,b.numberData,b,1);j=this.pack(et)}else j=this.createTextureData(W,b.type,b.numberData,b,1)}return j}createTextureDataFromLayoutBindTensor(b,F,j,W){return this.createTextureData(b,F,j,W,1)}createTextureData(b,F,j,W,J){tt.Logger.verbose("InferenceHandler",`Creating TextureData: layout:[${JSON.stringify(b)}]`);const et=this.session.textureManager.createTextureFromLayout(F,b,j,J);return this.createTextureDataFromTexture(b,F,et,W)}reshapeUnpacked(b,F){const j=this.getOrCreateTextureData(b,O.TextureType.unpacked),W={channels:j.channels,height:j.height,width:j.width,shape:F.length!==0?F:[1],strides:nt.ShapeUtil.computeStrides(F),unpackedShape:F};return this.createTextureDataFromTexture(W,b.type,j.texture).tensor}reshapePacked(b,F){const j=this.getOrCreateTextureData(b,O.TextureType.packed);if((0,X.isReshapeCheap)(b.dims,F)){const it={channels:j.channels,height:j.height,width:j.width,shape:F.length!==0?F:[1],strides:nt.ShapeUtil.computeStrides(F),unpackedShape:F,isPacked:!0};return this.createTextureDataFromTexture(it,b.type,j.texture).tensor}const W=(0,X.processDims3D)(b.dims),J=(0,X.processDims3D)(F),et=this.reshapePacked(b,W),ot=this.run((0,X.createPackedReshape3DProgramInfoLoader)(this,et,J),[et]);return this.reshapePacked(ot,F)}cast(b,F){const j=this.getOrCreateTextureData(b,O.TextureType.unpacked);return this.createTextureDataFromTexture(j,F,j.texture).tensor}createTextureDataFromTexture(b,F,j,W,J){const et=Object.assign(Object.assign({},b),{tensor:W||new Y.Tensor(b.unpackedShape,F,ot=>this.readTexture(et),async ot=>this.readTextureAsync(et),void 0,J),texture:j});return this.setTextureData(et.tensor.dataId,et,b.isPacked),et}getTextureData(b,F=!1){return this.session.isInitializer(b)?this.session.getTextureData(b,F):F?this.packedTextureDataCache.get(b):this.unpackedTextureDataCache.get(b)}setTextureData(b,F,j=!1){this.session.isInitializer(b)?this.session.setTextureData(b,F,j):(j?this.packedTextureDataCache:this.unpackedTextureDataCache).set(b,F)}isTextureLayoutCached(b,F=!1){return!!this.getTextureData(b.dataId,F)}dispose(){this.session.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(b=>this.session.textureManager.releaseTexture(b)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(b=>this.session.textureManager.releaseTexture(b)),this.unpackedTextureDataCache=new Map}readTexture(b){return b.isPacked?this.readTexture(this.unpack(b)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTexture(b,b.tensor.type,b.channels):this.session.textureManager.readUint8TextureAsFloat((0,Q.encodeAsUint8)(this,b))}async readTextureAsync(b){return b.isPacked?this.readTextureAsync(this.unpack(b)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTextureAsync(b,b.tensor.type,b.channels):this.session.textureManager.readUint8TextureAsFloat((0,Q.encodeAsUint8)(this,b))}pack(b){return this.executeProgram((0,K.createPackProgramInfoLoader)(this,b.tensor),[b.tensor])}unpack(b){return this.executeProgram((0,q.createUnpackProgramInfoLoader)(this,b.tensor),[b.tensor])}}},4110:function(dt,U,rt){var tt=this&&this.__createBinding||(Object.create?function(Ft,Rt,Bt,Vt){Vt===void 0&&(Vt=Bt);var jt=Object.getOwnPropertyDescriptor(Rt,Bt);jt&&!("get"in jt?!Rt.__esModule:jt.writable||jt.configurable)||(jt={enumerable:!0,get:function(){return Rt[Bt]}}),Object.defineProperty(Ft,Vt,jt)}:function(Ft,Rt,Bt,Vt){Vt===void 0&&(Vt=Bt),Ft[Vt]=Rt[Bt]}),Y=this&&this.__setModuleDefault||(Object.create?function(Ft,Rt){Object.defineProperty(Ft,"default",{enumerable:!0,value:Rt})}:function(Ft,Rt){Ft.default=Rt}),nt=this&&this.__importStar||function(Ft){if(Ft&&Ft.__esModule)return Ft;var Rt={};if(Ft!=null)for(var Bt in Ft)Bt!=="default"&&Object.prototype.hasOwnProperty.call(Ft,Bt)&&tt(Rt,Ft,Bt);return Y(Rt,Ft),Rt};Object.defineProperty(U,"__esModule",{value:!0}),U.WEBGL_OP_RESOLVE_RULES=void 0;const K=rt(8817),X=nt(rt(5194)),Q=rt(4752),q=rt(6668),G=rt(9754),O=rt(5042),b=rt(6742),F=rt(4125),j=rt(6149),W=rt(5378),J=rt(6981),et=rt(7413),ot=rt(7006),it=rt(8276),at=rt(5565),st=rt(2834),lt=rt(1010),ct=rt(8126),pt=rt(2801),ut=rt(565),ft=rt(2444),gt=rt(815),_t=rt(564),vt=rt(5416),bt=rt(1240),St=rt(5944),yt=rt(5707),wt=nt(rt(9087)),Dt=rt(7862),Pt=rt(3980);U.WEBGL_OP_RESOLVE_RULES=[["Abs","","6+",wt.abs],["Acos","","7+",wt.acos],["Add","","7+",X.add],["And","","7+",X.and],["Asin","","7+",wt.asin],["Atan","","7+",wt.atan],["AveragePool","","7+",st.averagePool,st.parseAveragePoolAttributes],["BatchNormalization","","7+",K.batchNormalization,K.parseBatchNormalizationAttributes],["Cast","","6+",Q.cast,Q.parseCastAttributes],["Ceil","","6+",wt.ceil],["Clip","","6-10",wt.clip,wt.parseClipAttributes],["Clip","","11+",wt.clipV11],["Concat","","4+",q.concat,q.parseConcatAttributes],["Conv","","1+",G.conv,G.parseConvAttributes],["ConvTranspose","","1+",O.convTranspose,O.parseConvTransposeAttributes],["Cos","","7+",wt.cos],["Div","","7+",X.div],["Dropout","","7+",wt.identity],["DepthToSpace","","1+",b.depthToSpace,b.parseDepthToSpaceAttributes],["Equal","","7+",X.equal],["Elu","","6+",wt.elu,wt.parseEluAttributes],["Exp","","6+",wt.exp],["Flatten","","1+",F.flatten,F.parseFlattenAttributes],["Floor","","6+",wt.floor],["FusedConv","com.microsoft","1+",G.conv,G.parseConvAttributes],["Gather","","1+",j.gather,j.parseGatherAttributes],["Gemm","","7-10",W.gemm,W.parseGemmAttributesV7],["Gemm","","11+",W.gemm,W.parseGemmAttributesV11],["GlobalAveragePool","","1+",st.globalAveragePool,st.parseGlobalAveragePoolAttributes],["GlobalMaxPool","","1+",st.globalMaxPool],["Greater","","7+",X.greater],["Identity","","1+",wt.identity],["ImageScaler","","1+",J.imageScaler,J.parseImageScalerAttributes],["InstanceNormalization","","6+",et.instanceNormalization,et.parseInstanceNormalizationAttributes],["LeakyRelu","","6+",wt.leakyRelu,wt.parseLeakyReluAttributes],["Less","","7+",X.less],["LRN","","1+",ot.lrn,ot.parseLrnAttributes],["Log","","6+",wt.log],["MatMul","","1+",it.matMul,it.parseMatMulAttributes],["MaxPool","","1+",st.maxPool,st.parseMaxPoolAttributes],["Mul","","7+",X.mul],["Neg","","6+",wt.neg],["Not","","1+",wt.not],["Or","","7+",X.or],["Pad","","2-10",at.padV2,at.parsePadAttributesV2],["Pad","","11+",at.padV11,at.parsePadAttributesV11],["Pow","","7+",X.pow],["PRelu","","7+",X.pRelu],["ReduceLogSum","","1+",lt.reduceLogSum,lt.parseReduceAttributes],["ReduceMax","","1+",lt.reduceMax,lt.parseReduceAttributes],["ReduceMean","","1+",lt.reduceMean,lt.parseReduceAttributes],["ReduceMin","","1+",lt.reduceMin,lt.parseReduceAttributes],["ReduceProd","","1+",lt.reduceProd,lt.parseReduceAttributes],["ReduceSum","","1-12",lt.reduceSum,lt.parseReduceAttributes],["ReduceSumSquare","","1+",lt.reduceLogSumSquare,lt.parseReduceAttributes],["Relu","","6+",wt.relu],["Reshape","","5+",ct.reshape],["Resize","","10",pt.resize,pt.parseResizeAttributesV10],["Resize","","11+",pt.resize,pt.parseResizeAttributesV11],["Shape","","1+",ut.shape],["Sigmoid","","6+",wt.sigmoid],["Sin","","7+",wt.sin],["Slice","","10+",ft.sliceV10],["Slice","","1-9",ft.slice,ft.parseSliceAttributes],["Softmax","","1-12",gt.softmax,gt.parseSoftmaxAttributes],["Softmax","","13+",gt.softmaxV13,gt.parseSoftmaxAttributesV13],["Split","","2-12",_t.split,_t.parseSplitAttributes],["Sqrt","","6+",wt.sqrt],["Squeeze","","1-12",vt.squeeze,vt.parseSqueezeAttributes],["Squeeze","","13+",vt.squeezeV13],["Sub","","7+",X.sub],["Sum","","6+",bt.sum],["Tan","","7+",wt.tan],["Tanh","","6+",wt.tanh],["Tile","","6+",St.tile],["Transpose","","1+",yt.transpose,yt.parseTransposeAttributes],["Upsample","","7-8",Pt.upsample,Pt.parseUpsampleAttributesV7],["Upsample","","9",Pt.upsample,Pt.parseUpsampleAttributesV9],["Unsqueeze","","1-12",Dt.unsqueeze,Dt.parseUnsqueezeAttributes],["Unsqueeze","","13+",Dt.unsqueezeV13],["Xor","","7+",X.xor]]},8817:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.parseBatchNormalizationAttributes=U.batchNormalization=void 0;const tt=rt(4910),Y=rt(6757),nt=rt(5639),K={name:"BatchNormalization",inputNames:["A","Scale","B","Mean","Variance"],inputTypes:[nt.TextureType.unpacked,nt.TextureType.unpacked,nt.TextureType.unpacked,nt.TextureType.unpacked,nt.TextureType.unpacked]};U.batchNormalization=(q,G,O)=>(Q(G),[q.run(Object.assign(Object.assign({},K),{cacheHint:O.cacheKey,get:()=>X(q,G,O)}),G)]),U.parseBatchNormalizationAttributes=q=>{const G=q.attributes.getFloat("epsilon",1e-5),O=q.attributes.getFloat("momentum",.9),b=q.attributes.getInt("spatial",1);return(0,tt.createAttributeWithCacheKey)({epsilon:G,momentum:O,spatial:b})};const X=(q,G,O)=>{const b=(0,Y.getGlsl)(q.session.backend.glContext.version),F=G[0].dims.length,[j,W]=q.calculateTextureWidthAndHeight(G[1].dims,nt.TextureType.unpacked),J=`
  float process(int[${F}] indices) {
    vec2 position = offsetToCoords(indices[1], ${j}, ${W});
    float scale = getColorAsFloat(${b.texture2D}(Scale, position));
    float mean = getColorAsFloat(${b.texture2D}(Mean, position));
    float variance = getColorAsFloat(${b.texture2D}(Variance, position));
    float b = getColorAsFloat(${b.texture2D}(B, position));

    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${O.epsilon})) ) + b;
  }`;return Object.assign(Object.assign({},K),{output:{dims:G[0].dims,type:G[0].type,textureType:nt.TextureType.unpacked},shaderSource:J})},Q=q=>{if(!q||q.length!==5)throw new Error("BatchNormalization requires 5 inputs.");const G=q[0],O=q[1],b=q[2],F=q[3],j=q[4];if(G.dims.length<3||O.dims.length!==1||b.dims.length!==1||F.dims.length!==1||j.dims.length!==1)throw new Error("invalid input shape.");if(O.dims[0]!==G.dims[1]||b.dims[0]!==G.dims[1]||F.dims[0]!==G.dims[1]||j.dims[0]!==G.dims[1])throw new Error("invalid input shape.");if(G.type!=="float32"&&G.type!=="float64"||O.type!=="float32"&&O.type!=="float64"||b.type!=="float32"&&b.type!=="float64"||F.type!=="float32"&&F.type!=="float64"||j.type!=="float32"&&j.type!=="float64")throw new Error("invalid input tensor types.")}},5194:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.xor=U.sub=U.pRelu=U.pow=U.or=U.mul=U.less=U.greater=U.equal=U.div=U.and=U.add=U.glslPRelu=U.glslPow=U.glslXor=U.glslOr=U.glslAnd=U.glslLess=U.glslGreater=U.glslEqual=U.glslSub=U.glslMul=U.glslDiv=U.glslAdd=void 0;const tt=rt(7273),Y=rt(1997),nt=rt(6757),K=rt(5639);function X(){const st="add_";return{body:`
  float ${st}(float a, float b) {
    return a + b;
  }
  vec4 ${st}(vec4 v1, vec4 v2) {
    return v1 + v2;
  }
  `,name:st,type:Y.FunctionType.ValueBased}}function Q(){const st="div_";return{body:`
  float ${st}(float a, float b) {
    return a / b;
  }
  vec4 ${st}(vec4 v1, vec4 v2) {
    return v1 / v2;
  }
  `,name:st,type:Y.FunctionType.ValueBased}}function q(){const st="mul_";return{body:`
  float ${st}(float a, float b) {
    return a * b;
  }
  vec4 ${st}(vec4 v1, vec4 v2) {
    return v1 * v2;
  }
  `,name:st,type:Y.FunctionType.ValueBased}}function G(){const st="sub_";return{body:`
  float ${st}(float a, float b) {
    return a - b;
  }
  vec4 ${st}(vec4 v1, vec4 v2) {
    return v1 - v2;
  }
  `,name:st,type:Y.FunctionType.ValueBased}}function O(){const st="equal_";return{body:`
  float ${st}(float a, float b) {
    return float(a == b);
  }
  vec4 ${st}(vec4 v1, vec4 v2) {
    return vec4(equal(v1, v2));
  }
  `,name:st,type:Y.FunctionType.ValueBased}}function b(){const st="greater_";return{body:`
  float ${st}(float a, float b) {
    return float(a > b);
  }
  vec4 ${st}(vec4 v1, vec4 v2) {
    return vec4( v1.r > v2.r ,
      v1.g > v2.g,
      v1.b > v2.b,
      v1.a > v2.a );
  }
  `,name:st,type:Y.FunctionType.ValueBased}}function F(){const st="less_";return{body:`
  float ${st}(float a, float b) {
    return float(a < b);
  }
  vec4 ${st}(vec4 v1, vec4 v2) {
    return vec4( v1.r < v2.r ,
                v1.g < v2.g,
                v1.b < v2.b,
                v1.a < v2.a );
  }
  `,name:st,type:Y.FunctionType.ValueBased}}function j(){const st="and_";return{body:`
  float ${st}(float a, float b) {
    return float( bool(a) && bool(b) );
  }
  vec4 ${st}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r && b2.r ,
                b1.g && b2.g,
                b1.b && b2.b,
                b1.a && b2.a );
  }
  `,name:st,type:Y.FunctionType.ValueBased}}function W(){const st="or_";return{body:`
  float ${st}(float a, float b) {
    return float( bool(a) || bool(b) );
  }
  vec4 ${st}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r || b2.r ,
                b1.g || b2.g,
                b1.b || b2.b,
                b1.a || b2.a );
  }
  `,name:st,type:Y.FunctionType.ValueBased}}function J(){const st="xor_";return{body:`
  float ${st}(float a, float b) {
    return float( bool(a) ^^ bool(b) );
  }
  vec4 ${st}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r ^^ b2.r ,
                b1.g ^^ b2.g,
                b1.b ^^ b2.b,
                b1.a ^^ b2.a );
  }
  `,name:st,type:Y.FunctionType.ValueBased}}function et(){return function(st){const lt=`${st}_`;return{body:`
  float ${lt}(float a, float b) {
    return ${st}(a, b);
  }
  vec4 ${lt}(vec4 v1, vec4 v2) {
    return ${st}(v1, v2);
  }
  `,name:lt,type:Y.FunctionType.ValueBased}}("pow")}function ot(){const st="prelu_";return{body:`
  float ${st}(float a, float b) {
    return a < 0.0 ? a * b: a;
  }
  vec4 ${st}(vec4 v1, vec4 v2) {
    return vec4(
      v1.r < 0.0 ? v1.r * v2.r: v1.r,
      v1.g < 0.0 ? v1.g * v2.g: v1.g,
      v1.b < 0.0 ? v1.b * v2.b: v1.b,
      v1.a < 0.0 ? v1.a * v2.a: v1.a
      );
  }
  `,name:st,type:Y.FunctionType.ValueBased}}U.glslAdd=X,U.glslDiv=Q,U.glslMul=q,U.glslSub=G,U.glslEqual=O,U.glslGreater=b,U.glslLess=F,U.glslAnd=j,U.glslOr=W,U.glslXor=J,U.glslPow=et,U.glslPRelu=ot;const it=(st,lt,ct,pt=lt[0].type,ut)=>{const ft=st.session.pack?K.TextureType.packed:K.TextureType.unpacked;return{name:ct.name,inputNames:["A","B"],inputTypes:[ft,ft],cacheHint:ut,get:()=>at(st,lt,ct,pt)}},at=(st,lt,ct,pt=lt[0].type)=>{const ut=st.session.pack?K.TextureType.packed:K.TextureType.unpacked,ft=!tt.ShapeUtil.areEqual(lt[0].dims,lt[1].dims);let gt=lt[0].dims;const _t=st.session.pack;if(ft){const St=tt.BroadcastUtil.calcShape(lt[0].dims,lt[1].dims,!1);if(!St)throw new Error("Can't perform binary op on the given tensors");gt=St;const yt=gt.length,wt=lt[0].dims.length!==0?lt[0].dims.length:1,Dt=lt[1].dims.length!==0?lt[1].dims.length:1,Pt=lt[0].dims.length!==0?"bcastIndices_A(indices, aindices);":"aindices[0] = 0;",Ft=lt[1].dims.length!==0?"bcastIndices_B(indices, bindices);":"bindices[0] = 0;",Rt=(0,nt.getGlsl)(st.session.backend.glContext.version),Bt=_t?`
      ${ct.body}
      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();
        vec4 result = ${ct.name}(a, b);
        ${Rt.output} = result;
      }`:`
      ${ct.body}
      float process(int indices[${yt}]) {
        int aindices[${wt}];
        int bindices[${Dt}];
        ${Pt}
        ${Ft}
        return ${ct.name}(_A(aindices), _B(bindices));
      }`;return{name:ct.name,inputNames:["A","B"],inputTypes:[ut,ut],output:{dims:gt,type:pt,textureType:ut},shaderSource:Bt,hasMain:_t}}const vt=(0,nt.getGlsl)(st.session.backend.glContext.version),bt=`
    ${ct.body}
    void main() {
      vec4 v1 = ${vt.texture2D}(A, TexCoords);
      vec4 v2 = ${vt.texture2D}(B, TexCoords);
      vec4 result = ${ct.name}(v1, v2);
      ${vt.output} = result;
    }
    `;return{name:ct.name,inputNames:["A","B"],inputTypes:[ut,ut],output:{dims:lt[0].dims,type:pt,textureType:ut},shaderSource:bt,hasMain:!0}};U.add=(st,lt)=>[st.run(it(st,lt,X()),lt)],U.and=(st,lt)=>[st.run(it(st,lt,j(),"bool"),lt)],U.div=(st,lt)=>[st.run(it(st,lt,Q()),lt)],U.equal=(st,lt)=>[st.run(it(st,lt,O(),"bool"),lt)],U.greater=(st,lt)=>[st.run(it(st,lt,b(),"bool"),lt)],U.less=(st,lt)=>[st.run(it(st,lt,F(),"bool"),lt)],U.mul=(st,lt)=>[st.run(it(st,lt,q()),lt)],U.or=(st,lt)=>[st.run(it(st,lt,W(),"bool"),lt)],U.pow=(st,lt)=>[st.run(it(st,lt,et()),lt)],U.pRelu=(st,lt)=>[st.run(it(st,lt,ot()),lt)],U.sub=(st,lt)=>[st.run(it(st,lt,G()),lt)],U.xor=(st,lt)=>[st.run(it(st,lt,J(),"bool"),lt)]},4752:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.parseCastAttributes=U.cast=void 0;const tt=rt(7273);U.cast=(nt,K,X)=>(Y(K),[nt.cast(K[0],X)]),U.parseCastAttributes=nt=>tt.ProtoUtil.tensorDataTypeFromProto(nt.attributes.getInt("to"));const Y=nt=>{if(!nt||nt.length!==1)throw new Error("Cast requires 1 input.");if(nt[0].type==="string")throw new Error("Invalid input type.")}},4595:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.createPackedConcatProgramInfoLoader=void 0;const tt=rt(6757),Y=rt(5639),nt=rt(432),K=rt(5614);U.createPackedConcatProgramInfoLoader=(Q,q,G)=>{const O=(b=q.length,F=G.cacheKey,{name:"Concat (packed)",inputNames:Array.from({length:b},(j,W)=>`X${W}`),inputTypes:Array(b).fill(Y.TextureType.packed),cacheHint:F});var b,F;return Object.assign(Object.assign({},O),{get:()=>((j,W,J,et)=>{const ot=J[0].dims.slice();if(et>=ot.length||et<-1*ot.length)throw new Error("axis specified for concat doesn't match input dimensionality");et<0&&(et=ot.length+et);const it=ot.slice(0);for(let Pt=1;Pt<J.length;Pt++){const Ft=J[Pt].dims.slice();for(let Rt=0;Rt<ot.length;Rt++)if(Rt===et)it[et]+=Ft[Rt];else if(ot[Rt]!==Ft[Rt])throw new Error("non concat dimensions must match")}const at=it.length,st=(0,K.getChannels)("coords",at),lt=(0,nt.getCoordsDataType)(at),ct=(0,K.unpackFromChannel)(),pt=J.map(Pt=>Pt.dims),ut=(0,nt.getGlChannels)(at),ft=new Array(pt.length-1);ft[0]=pt[0][et];for(let Pt=1;Pt<ft.length;Pt++)ft[Pt]=ft[Pt-1]+pt[Pt][et];const gt=ut[et],_t=ut.slice(-2),vt=ut.join();let bt=`if (${gt} < ${ft[0]}) {
        return getChannel(
            getX0(${vt}), vec2(${_t.join()}));
        }`;for(let Pt=1;Pt<ft.length;Pt++){const Ft=ft[Pt-1];bt+=`
            if (${gt} < ${ft[Pt]}  && ${gt} >= ${ft[Pt-1]}) {
              return getChannel(
                getX${Pt}(${X(ut,gt,Ft)}),
                vec2(${X(_t,gt,Ft)}));
            }`}const St=ft.length,yt=ft[ft.length-1];bt+=`
            return getChannel(
              getX${St}(${X(ut,gt,yt)}),
              vec2(${X(_t,gt,yt)}));`;const wt=(0,tt.getGlsl)(j.session.backend.glContext.version),Dt=`
          ${ct}
          float getValue(${ut.map(Pt=>"int "+Pt)}) {
            ${bt}
          }

          void main() {
            ${lt} coords = getOutputCoords();
            int lastDim = coords.${ut[at-1]};
            coords.${ut[at-1]} = coords.${ut[at-2]};
            coords.${ut[at-2]} = lastDim;

            vec4 result = vec4(getValue(${st}), 0., 0., 0.);

            ${st[at-1]} = ${st[at-1]} + 1;
            if (${st[at-1]} < ${it[at-1]}) {
              result.g = getValue(${st});
            }

            ${st[at-2]} = ${st[at-2]} + 1;
            if (${st[at-2]} < ${it[at-2]}) {
              result.a = getValue(${st});
            }

            ${st[at-1]} = ${st[at-1]} - 1;
            if (${st[at-2]} < ${it[at-2]} &&
                ${st[at-1]} < ${it[at-1]}) {
              result.b = getValue(${st});
            }
            ${wt.output} = result;
          }
        `;return Object.assign(Object.assign({},W),{output:{dims:it,type:J[0].type,textureType:Y.TextureType.packed},shaderSource:Dt,hasMain:!0})})(Q,O,q,G.axis)})};const X=(Q,q,G)=>{const O=Q.indexOf(q);return Q.map((b,F)=>F===O?`${b} - ${G}`:b).join()}},6668:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.parseConcatAttributes=U.concat=void 0;const tt=rt(4910),Y=rt(5639),nt=rt(4595);U.concat=(b,F,j)=>(O(F),b.session.pack&&F[0].dims.length>1?[b.run((0,nt.createPackedConcatProgramInfoLoader)(b,F,j),F)]:[b.run(K(b,F,j),F)]);const K=(b,F,j)=>{const W=(J=F.length,et=j.cacheKey,{name:"Concat",inputNames:Array.from({length:J},(ot,it)=>`X${it}`),inputTypes:Array(J).fill(Y.TextureType.unpacked),cacheHint:et});var J,et;return Object.assign(Object.assign({},W),{get:()=>((ot,it,at,st)=>{const lt=at[0].dims.slice();if(st>=lt.length||st<-1*lt.length)throw new Error("axis specified for concat doesn't match input dimensionality");st<0&&(st=lt.length+st);const ct=lt.slice(0);for(let vt=1;vt<at.length;vt++){const bt=at[vt].dims.slice();for(let St=0;St<lt.length;St++)if(St===st)ct[st]+=bt[St];else if(lt[St]!==bt[St])throw new Error("non concat dimensions must match")}const pt=ct.length,ut=new Array(at.length);let ft=0;for(let vt=0;vt<ut.length;++vt)ft+=at[vt].dims[st],ut[vt]=ft;let gt="";gt=at.length<5?X(ut):Q(ut);const _t=`
        ${q(at.length,pt)}
        ${G(ut)}
        ${gt}
        float process(int indices[${pt}]) {
          int textureIndex = getTextureWhereDataResides (indices[${st}]);

          if(textureIndex != 0) {
            indices[${st}] = indices[${st}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));
          }

          return fetchDataFromCorrectTexture(textureIndex, indices);
        }`;return Object.assign(Object.assign({},it),{output:{dims:ct,type:at[0].type,textureType:Y.TextureType.unpacked},shaderSource:_t})})(0,W,F,j.axis)})},X=b=>`int getTextureWhereDataResides(int index) {
      ${b.map((F,j)=>`if(index<${F}) {return ${j};}
`).join("")}
    }`,Q=b=>X(b),q=(b,F)=>{const j=[`float fetchDataFromCorrectTexture(int textureIndex, int indices[${F}]) {`];for(let W=0;W<b;++W)W===0?j.push(`	if (textureIndex == ${W}) { return _X${W}(indices); }`):W===b-1?j.push(`	else { return _X${W}(indices); }`):j.push(`	else if (textureIndex == ${W}) { return _X${W}(indices); }`);return j.push("	}"),j.join(`
`)},G=b=>{const F=["int getSizeInConcatAxisValueFromIndex(int index) {"];for(let j=0;j<b.length;++j)j===0?F.push(`	if (index == ${j}) { return ${b[j]}; }`):j===b.length-1?F.push(`	else { return ${b[j]}; }`):F.push(`	else if (index == ${j}) { return ${b[j]}; }`);return F.push("	}"),F.join(`
`)};U.parseConcatAttributes=b=>(0,tt.createAttributeWithCacheKey)({axis:b.attributes.getInt("axis")});const O=b=>{if(!b||b.length<1)throw new Error("too few inputs");const F=b[0].type,j=b[0].dims.length;if(F==="string")throw new Error("string tensor is not supported yet");for(const W of b){if(W.type!==F)throw new Error("input tensors should be one type");if(W.dims.length!==j)throw new Error("input tensors should have the same shape")}}},7825:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.createUnpackedGroupedConvProgramInfoLoader=void 0;const tt=rt(1315),Y=rt(6757),nt=rt(5639),K=rt(9754),X=rt(2150);U.createUnpackedGroupedConvProgramInfoLoader=(Q,q,G)=>{const O=(b=q.length>2,F=G.cacheKey,{name:"GroupedConv",inputNames:b?["X","W","Bias"]:["X","W"],inputTypes:b?[nt.TextureType.unpacked,nt.TextureType.unpacked,nt.TextureType.unpacked]:[nt.TextureType.unpacked,nt.TextureType.unpacked],cacheHint:F});var b,F;return Object.assign(Object.assign({},O),{get:()=>((j,W,J,et)=>{const ot=W.length>2?"value += getBias(output_channel);":"",it=W[0].dims.slice(),at=W[1].dims.slice(),st=at[0]/et.group;tt.Logger.verbose("GroupedConv",`autpPad:${et.autoPad}, dilations:${et.dilations}, group:${et.group}, kernelShape:${et.kernelShape}, pads:${et.pads}, strides:${et.strides}`);const lt=(0,K.calculateOutputShape)(it,at,et.dilations,et.pads,et.strides),ct=(0,Y.getGlsl)(j.session.backend.glContext.version),{activationFunction:pt,applyActivation:ut}=(0,X.getActivationSnippet)(et),ft=`
  const ivec2 strides = ivec2(${et.strides[0]}, ${et.strides[1]});
  const ivec2 pads = ivec2(${et.pads[0]}, ${et.pads[1]});
  ${pt}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;
    ivec2 xRCCorner = coords.zw * strides - pads;
    int group_id = output_channel / ${st};

    float value = 0.0;
    for (int wInChannel = 0; wInChannel < ${at[1]}; wInChannel++) {
      int input_channel = group_id * ${at[1]} + wInChannel;
      for (int wHeight = 0; wHeight < ${at[2]}; wHeight++) {
        int xHeight = xRCCorner.x + wHeight * ${et.dilations[0]};

        if (xHeight < 0 || xHeight >= ${it[2]}) {
          continue;
        }

        for (int wWidth = 0; wWidth < ${at[3]}; wWidth++) {
          int xWidth = xRCCorner.y + wWidth * ${et.dilations[1]};
          if (xWidth < 0 || xWidth >= ${it[3]}) {
            continue;
          }

          float xVal = getX(batch, input_channel, xWidth, xHeight);
          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);
          value += xVal*wVal;
        }
      }
    }
    ${ot}
    ${ut}
    ${ct.output} = vec4(value, .0, .0, .0);
  }
`;return Object.assign(Object.assign({},J),{output:{dims:lt,type:W[0].type,textureType:nt.TextureType.unpacked},shaderSource:ft,hasMain:!0})})(Q,q,O,G)})}},7708:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.conv2DPacked=U.conv2DPackedPointwise=void 0;const tt=rt(9754),Y=rt(5950),nt=rt(5632);U.conv2DPackedPointwise=(K,X,Q)=>{const q=X[0].dims,G=X[1].dims,O=(0,tt.calculateOutputShape)(q,G,Q.dilations,Q.pads,Q.strides),b=K.reshapePacked(X[0],[q[1],q[2]*q[3]]),F=K.reshapePacked(X[1],[G[0],G[1]]),j=X.length>2?[F,b,X[2]]:[F,b],W=K.run((0,nt.createPackedMatmulProgramInfoLoader)(K,j,Q),j);return K.reshapePacked(W,O)},U.conv2DPacked=(K,X,Q)=>{const q=X[0].dims,G=X[1].dims,O=(0,tt.calculateOutputShape)(q,G,Q.dilations,Q.pads,Q.strides),b=K.run((0,Y.createPackedIm2ColProgramInfoLoader)(K,X[0],X[1],O,Q),[X[0]]),F=K.reshapePacked(X[1],[G[0],G[1]*G[2]*G[3]]),j=X.length===3?[F,b,X[2]]:[F,b],W=K.run((0,nt.createPackedMatmulProgramInfoLoader)(K,j,Q),j);return K.reshapePacked(W,O)}},5042:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.parseConvTransposeAttributes=U.convTranspose=void 0;const tt=rt(4910),Y=rt(6757),nt=rt(5639),K=rt(2150),X=(F,j,W,J,et,ot)=>(F-1)*j+W+(J-1)*et+1-ot,Q=(F,j,W,J,et)=>{const ot=Math.floor(F/2);j==="SAME_UPPER"?(W[J]=ot,W[et]=F-ot):j==="SAME_LOWER"&&(W[J]=F-ot,W[et]=ot)};U.convTranspose=(F,j,W)=>(b(j,W),q(F,j,W));const q=(F,j,W)=>{const J=O(W,j);return[G(F,j,J)]},G=(F,j,W)=>F.run(((J,et,ot)=>{const it=(at=et.length>2,st=ot.cacheKey,{name:"ConvTranspose",inputNames:at?["X","W","B"]:["X","W"],inputTypes:at?[nt.TextureType.unpacked,nt.TextureType.unpacked,nt.TextureType.unpacked]:[nt.TextureType.unpacked,nt.TextureType.unpacked],cacheHint:st});var at,st;return Object.assign(Object.assign({},it),{get:()=>((lt,ct,pt,ut)=>{const ft=ct.length>2?"getB(output_channel)":"0.0",gt=ct[0].dims,_t=ct[1].dims,vt=_t[1],bt=_t[0]/ut.group,St=[ct[0].dims[0],ct[1].dims[1]*ut.group,...ut.outputShape],yt=(0,Y.getGlsl)(lt.session.backend.glContext.version),{activationFunction:wt,applyActivation:Dt}=(0,K.getActivationSnippet)(ut),Pt=`
  const ivec2 strides = ivec2(${ut.strides[0]}, ${ut.strides[1]});
  const ivec2 pads = ivec2(${ut.pads[0]}, ${ut.pads[1]});
  ${wt}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;

    ivec2 loc = coords.zw + pads;

    int group_id = output_channel / ${vt};
    int wOutChannel = output_channel - group_id * ${vt};

    float value = ${ft};
    for (int inChannelOffset = 0; inChannelOffset < ${bt}; inChannelOffset++) {
      int input_channel = group_id * ${bt} + inChannelOffset;
      for (int wWOff = 0; wWOff < ${_t[2]}; wWOff++) {
        for (int wHOff = 0; wHOff < ${_t[3]}; wHOff++) {
          ivec2 wOff = ivec2(wWOff * ${ut.dilations[0]}, wHOff * ${ut.dilations[1]});
          ivec2 wLoc = loc - wOff;
          ivec2 wLocIn = wLoc / strides;
          if (
            wLocIn * strides == wLoc &&
            wLocIn.x >= 0 && wLocIn.x < ${gt[2]} &&
            wLocIn.y >= 0 && wLocIn.y < ${gt[3]}
          ) {
            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);
            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);
            value += xVal * wVal;
          }
        }
      }
    }
    ${Dt}
    ${yt.output} = vec4(value, .0, .0, .0);
  }
`;return Object.assign(Object.assign({},pt),{output:{dims:St,type:ct[0].type,textureType:nt.TextureType.unpacked},shaderSource:Pt,hasMain:!0})})(J,et,it,ot)})})(F,j,W),j),O=(F,j)=>{const W=F.kernelShape.slice();if(F.kernelShape.length===0)for(let it=2;it<j[1].dims.length;++it)W.push(j[1].dims[it]);const J=F.pads.slice(),et=F.outputShape.slice();((it,at,st,lt,ct,pt,ut,ft)=>{const gt=it.length-2,_t=ft.length===0;for(let vt=0;vt<gt;++vt){const bt=_t?it[vt+2]*pt[vt]:ft[vt],St=X(it[vt+2],pt[vt],ct[vt],at[vt],st[vt],bt);Q(St,lt,ct,vt,vt+gt),_t&&ft.push(pt[vt]*(it[vt+2]-1)+ut[vt]+(at[vt]-1)*st[vt]+1-ct[vt]-ct[vt+gt])}})(j[0].dims,W,F.dilations,F.autoPad,J,F.strides,F.outputPadding,et);const ot=Object.assign({},F);return Object.assign(ot,{kernelShape:W,pads:J,outputShape:et,cacheKey:F.cacheKey}),ot};U.parseConvTransposeAttributes=F=>{const j=F.attributes,W=(0,K.parseInternalActivationAttributes)(j),J=j.getString("auto_pad","NOTSET"),et=j.getInts("dilations",[1,1]),ot=j.getInt("group",1),it=j.getInts("kernel_shape",[]),at=j.getInts("output_padding",[0,0]),st=j.getInts("output_shape",[]),lt=j.getInts("pads",[0,0,0,0]),ct=j.getInts("strides",[1,1]);return(0,tt.createAttributeWithCacheKey)(Object.assign({autoPad:J,dilations:et,group:ot,kernelShape:it,outputPadding:at,outputShape:st,pads:lt,strides:ct},W))};const b=(F,j)=>{if(!F||F.length!==2&&F.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(F[0].dims.length!==4||F[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");if(F[0].dims[1]!==F[1].dims[0])throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");const W=F[1].dims[1]*j.group;if(F.length===3&&(F[2].dims.length!==1||F[2].dims[0]!==W))throw new Error("invalid bias");const J=F[0].dims.length-2;if(j.dilations.length!==J)throw new Error(`dilations should be ${J}D`);if(j.strides.length!==J)throw new Error(`strides should be ${J}D`);if(j.pads.length!==2*J)throw new Error(`pads should be ${2*J}D`);if(j.outputPadding.length!==J)throw new Error(`output_padding should be ${J}D`);if(j.kernelShape.length!==0&&j.kernelShape.length!==F[1].dims.length-2)throw new Error("invalid kernel shape");if(j.outputShape.length!==0&&j.outputShape.length!==F[0].dims.length-2)throw new Error("invalid output shape");if(F[0].type!=="float32"||F[1].type!=="float32")throw new Error("ConvTranspose input(X,W) should be float tensor");if(F.length===3&&F[2].type!=="float32")throw new Error("ConvTranspose input(bias) should be float tensor")}},9754:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.parseConvAttributes=U.conv=U.calculateOutputShape=void 0;const tt=rt(4910),Y=rt(7273),nt=rt(7825),K=rt(7708),X=rt(3281),Q=rt(2150),q=rt(1625),G=rt(8276);U.calculateOutputShape=(J,et,ot,it,at)=>{const st=J[0],lt=J.slice(2),ct=lt.length,pt=et[0],ut=et.slice(2).map((gt,_t)=>gt+(gt-1)*(ot[_t]-1)),ft=lt.map((gt,_t)=>gt+it[_t]+it[_t+ct]).map((gt,_t)=>Math.floor((gt-ut[_t]+at[_t])/at[_t]));return[st,pt].concat(...ft)},U.conv=(J,et,ot)=>(W(et,ot),O(J,et,ot));const O=(J,et,ot)=>{const it=j(ot,et),at=J.session.pack,st=it.kernelShape[0]===1&&it.kernelShape[1]===1;return it.group>1?[J.run((0,nt.createUnpackedGroupedConvProgramInfoLoader)(J,et,it),et)]:st&&at?[b(J,et,it)]:at&&et[0].dims.length===4&&et[0].dims[0]===1&&!st?[(0,K.conv2DPacked)(J,et,it)]:[F(J,et,it)]},b=(J,et,ot)=>{const it=et[0].dims,at=et[1].dims,st=(0,U.calculateOutputShape)(it,at,ot.dilations,ot.pads,ot.strides),lt=J.reshapeUnpacked(et[0],[it[1],it[2]*it[3]]),ct=J.reshapeUnpacked(et[1],[at[0],at[1]]),pt=et.length>2?[ct,lt,et[2]]:[ct,lt],ut=J.run((0,G.createMatmulProgramInfoLoader)(pt,ot),pt);return J.reshapeUnpacked(ut,st)},F=(J,et,ot)=>{const it=et[0].dims,at=et[1].dims,st=(0,U.calculateOutputShape)(it,at,ot.dilations,ot.pads,ot.strides),lt=J.run((0,q.createIm2ColProgramInfoLoader)(J,et[0],et[1],st,ot),[et[0]]),ct=et.length===3?[lt,et[1],et[2]]:[lt,et[1]];return J.run((0,X.createDotProductProgramInfoLoader)(J,et,st,ot),ct)},j=(J,et)=>{const ot=J.kernelShape.slice();if(J.kernelShape.length===0)for(let st=2;st<et[1].dims.length;++st)ot.push(et[1].dims[st]);const it=J.pads.slice();Y.PoolConvUtil.adjustPadsBasedOnAutoPad(et[0].dims,J.strides,J.dilations,ot,it,J.autoPad);const at=Object.assign({},J);return Object.assign(at,{kernelShape:ot,pads:it,cacheKey:J.cacheKey}),at};U.parseConvAttributes=J=>{const et=J.attributes,ot=(0,Q.parseInternalActivationAttributes)(et),it=et.getString("auto_pad","NOTSET"),at=et.getInts("dilations",[1,1]),st=et.getInt("group",1),lt=et.getInts("kernel_shape",[]),ct=et.getInts("pads",[0,0,0,0]),pt=et.getInts("strides",[1,1]);return(0,tt.createAttributeWithCacheKey)(Object.assign({autoPad:it,dilations:at,group:st,kernelShape:lt,pads:ct,strides:pt},ot))};const W=(J,et)=>{if(!J||J.length!==2&&J.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(J[0].dims.length!==4||J[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");if(J[0].dims[1]!==J[1].dims[1]*et.group)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(J.length===3&&(J[2].dims.length!==1||J[1].dims[0]!==J[2].dims[0]))throw new Error("invalid bias");const ot=J[0].dims.length-2;if(et.dilations.length!==ot)throw new Error(`dilations should be ${ot}D`);if(et.strides.length!==ot)throw new Error(`strides should be ${ot}D`);if(et.pads.length!==2*ot)throw new Error(`pads should be ${2*ot}D`);if(et.kernelShape.length!==0&&et.kernelShape.length!==J[1].dims.length-2)throw new Error("invalid kernel shape");if(J[0].type!=="float32"||J[1].type!=="float32")throw new Error("Conv input(X,W) should be float tensor");if(J.length===3&&J[2].type!=="float32")throw new Error("Conv input(bias) should be float tensor")}},6742:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.parseDepthToSpaceAttributes=U.depthToSpace=void 0;const tt=rt(5707);U.depthToSpace=(nt,K,X)=>{Y(K);const Q=X.blocksize,q=Q*Q,G=X.mode==="DCR"?[0,3,4,1,5,2]:[0,1,4,2,5,3],O=X.mode==="DCR"?[K[0].dims[0],Q,Q,K[0].dims[1]/q,K[0].dims[2],K[0].dims[3]]:[K[0].dims[0],K[0].dims[1]/q,Q,Q,K[0].dims[2],K[0].dims[3]],b=nt.reshapeUnpacked(K[0],O),F={perm:G,cacheKey:`${G}`},[j]=(0,tt.transpose)(nt,[b],F),W=[K[0].dims[0],K[0].dims[1]/q,K[0].dims[2]*Q,K[0].dims[3]*Q];return[nt.reshapeUnpacked(j,W)]},U.parseDepthToSpaceAttributes=nt=>{const K=nt.attributes.getInt("blocksize");if(K<1)throw new Error(`blocksize must be >= 1, but got : ${K} for DepthToSpace`);const X=nt.attributes.getString("mode","DCR");if(X!=="DCR"&&X!=="CRD")throw new Error(`unrecognized mode: ${X} for DepthToSpace`);return{mode:X,blocksize:K}};const Y=nt=>{if(nt.length!==1)throw new Error(`DepthToSpace expect 1 inputs, but got ${nt.length}`);if(nt[0].type==="string"||nt[0].dims.length!==4)throw new TypeError("DepthToSpace input should be a 4-D numeric tensor")}},3281:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.createDotProductProgramInfoLoader=void 0;const tt=rt(7273),Y=rt(6757),nt=rt(5639),K=rt(2150),X=rt(1625);U.createDotProductProgramInfoLoader=(Q,q,G,O)=>{const b=((F,j)=>({name:"ConvDotProduct",inputNames:F?["Im2Col","K","B"]:["Im2Col","K"],inputTypes:F?[nt.TextureType.unpacked,nt.TextureType.packedLastDimension,nt.TextureType.unpacked]:[nt.TextureType.unpacked,nt.TextureType.packedLastDimension],cacheKey:j.activationCacheKey}))(q.length>2,O);return Object.assign(Object.assign({},b),{get:()=>((F,j,W,J,et)=>{const ot=W[0].dims,it=W[1].dims,at=[it[0],Math.ceil(ot[1]*it[2]*it[3]/4)],st=(0,X.calculateIm2ColDims)(ot,it,J),[lt,ct]=F.calculateTextureWidthAndHeight(at,nt.TextureType.packedLastDimension),pt=tt.ShapeUtil.computeStrides(st),[ut,ft]=F.calculateTextureWidthAndHeight(st,nt.TextureType.packedLastDimension),gt=J.length,_t=W.length<3?"0.0":"_B(b)",vt=Math.ceil(ot[1]*it[2]*it[3]/4),{activationFunction:bt,applyActivation:St}=(0,K.getActivationSnippet)(et),yt=(0,Y.getGlsl)(F.session.backend.glContext.version),wt=`
${bt}
float process(int indices[${gt}]) {
  int b[1];
  b[0] = indices[1];
  int im2col[4];
  im2col[0] = indices[0];
  im2col[1] = indices[2];
  im2col[2] = indices[3];
  int im2colOffset = im2col[0] * ${pt[0]} + im2col[1] * ${pt[1]} + im2col[2] * ${pt[2]};
  int kernelOffset = indices[1] * ${at[1]};
  float value = ${_t};
  for (int i = 0; i < ${vt}; ++i) {
    vec2 im2colCoords = offsetToCoords(im2colOffset, ${ut}, ${ft});
    vec2 kernelCoords = offsetToCoords(kernelOffset, ${lt}, ${ct});
    value += dot(${yt.texture2D}(Im2Col, im2colCoords), ${yt.texture2D}(K, kernelCoords));
    ++im2colOffset;
    ++kernelOffset;
  }
  ${St}
  return value;
}`;return Object.assign(Object.assign({},j),{output:{dims:J,type:W[0].type,textureType:nt.TextureType.unpacked},shaderSource:wt})})(Q,b,q,G,O)})}},4125:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.parseFlattenAttributes=U.flatten=void 0;const tt=rt(7273);U.flatten=(nt,K,X)=>{Y(K,X);const Q=tt.ShapeUtil.flattenShape(K[0].dims,X);return[nt.reshapeUnpacked(K[0],Q)]},U.parseFlattenAttributes=nt=>nt.attributes.getInt("axis",1);const Y=(nt,K)=>{if(!nt||nt.length!==1)throw new Error("Flatten requires 1 input.");const X=nt[0].dims.length;if(X===0)throw new Error("scalar tensor is not supported.");if(K<-X||K>X)throw new Error("Invalid axis");if(nt[0].type==="string")throw new Error("string tensor is not supported.")}},2150:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.parseInternalActivationAttributes=U.getActivationSnippet=void 0;const tt=rt(7273),Y=rt(9087);U.getActivationSnippet=function(nt){let K;switch(nt.activation){case"Relu":K=(0,Y.glslRelu)();break;case"Sigmoid":K=(0,Y.glslSigmoid)();break;case"Clip":K=(0,Y.glslClip)(nt.clipMin,nt.clipMax);break;default:return{activationFunction:"",applyActivation:""}}const X=K.name;return{activationFunction:K.body,applyActivation:`value = ${X}_(value);`}},U.parseInternalActivationAttributes=nt=>{const K=nt.getString("activation","");if(K==="Clip"){const[X,Q]=nt.getFloats("activation_params",[tt.MIN_CLIP,tt.MAX_CLIP]);return{activation:K,clipMax:Q,clipMin:X,activationCacheKey:`${K}:${X},${Q}`}}return{activation:K,activationCacheKey:K}}},6149:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.parseGatherAttributes=U.gather=void 0;const tt=rt(4910),Y=rt(6145),nt=rt(7273),K=rt(5639);U.gather=(G,O,b)=>(q(O,b.axis),[G.run(Q(G,O,b),O)]),U.parseGatherAttributes=G=>(0,tt.createAttributeWithCacheKey)({axis:G.attributes.getInt("axis",0)});const X={name:"Gather",inputNames:["A","B"],inputTypes:[K.TextureType.unpacked,K.TextureType.unpacked]},Q=(G,O,b)=>{const F=Object.assign(Object.assign({},X),{cacheHint:b.cacheKey});return Object.assign(Object.assign({},F),{get:()=>((j,W,J,et)=>{const ot=J[0].dims.slice(),it=J[1].dims.slice(),at=new Array(ot.length+it.length-1);et=nt.ShapeUtil.normalizeAxis(et,ot.length);const st=[];for(let ct=0;ct<at.length;ct++)ct<et?(at[ct]=ot[ct],st.push(`inputIdx[${ct}] = outputIdx[${ct}];`)):ct<et+it.length?(at[ct]=it[ct-et],st.push(`indexDataIdx[${ct-et}] = outputIdx[${ct}];`)):(at[ct]=ot[ct-it.length+1],st.push(`inputIdx[${ct-it.length+1}] = outputIdx[${ct}];`));const lt=`
      float process(int outputIdx[${at.length||1}]) {
        int inputIdx[${ot.length}];
        int indexDataIdx[${it.length||1}];
        indexDataIdx[0] = 0;
        ${st.join(`
        `)}
        int idx = int(_B(indexDataIdx));
        inputIdx[${et}] = idx < 0 ? idx + ${ot[et]} : idx;
        return _A(inputIdx);
      }`;return Object.assign(Object.assign({},W),{output:{dims:at,type:J[0].type,textureType:K.TextureType.unpacked},shaderSource:lt})})(0,F,O,b.axis)})},q=(G,O)=>{if(!G||G.length!==2)throw new Error("Gather requires 2 inputs.");const b=G[0].dims.length;if(b<1)throw new Error("Invalid input shape.");if(O<-b||O>b-1)throw new Error("Invalid axis.");if(Y.NUMBER_TYPES.indexOf(G[0].type)===-1)throw new Error("Invaid input type.");if(G[1].type!=="int32"&&G[1].type!=="int16")throw new Error("Invaid input type.")}},5378:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.parseGemmAttributesV11=U.parseGemmAttributesV7=U.gemm=void 0;const tt=rt(4910),Y=rt(7273),nt=rt(5639);U.gemm=(G,O,b)=>(q(O,b),[G.run(X(O,b),O)]);const K=(G,O)=>{const b=G.attributes.getInt("transA",0)!==0,F=G.attributes.getInt("transB",0)!==0,j=G.attributes.getFloat("alpha",1),W=G.attributes.getFloat("beta",1);return(0,tt.createAttributeWithCacheKey)({transA:b,transB:F,alpha:j,beta:W,isOptionalC:O})};U.parseGemmAttributesV7=G=>K(G,!1),U.parseGemmAttributesV11=G=>K(G,!0);const X=(G,O)=>{const b={name:"Gemm",inputNames:G.length===3?["A","B","C"]:["A","B"],inputTypes:G.length===3?[nt.TextureType.unpacked,nt.TextureType.unpacked,nt.TextureType.unpacked]:[nt.TextureType.unpacked,nt.TextureType.unpacked],key:O.cacheKey};return Object.assign(Object.assign({},b),{get:()=>Q(b,G,O)})},Q=(G,O,b)=>{const F=O[0].dims.slice(),j=O[1].dims.slice(),[W,J]=Y.GemmUtil.getShapeOfGemmResult(F,b.transA,j,b.transB,O.length===3?O[2].dims:void 0),et=[W,J];if(!et)throw new Error("Can't use gemm on the given tensors");let ot=F[F.length-1],it="";b.transA&&(ot=F[0]),b.transA&&b.transB?it="value += _A_T(a) * _B_T(b);":b.transA&&!b.transB?it="value += _A_T(a) * _B(b);":!b.transA&&b.transB?it="value += _A(a) * _B_T(b);":b.transA||b.transB||(it="value += _A(a) * _B(b);");const at=et.length,st=`
      float process(int indices[${at}]) {
          int a[${at}];
          int b[${at}];
          ${O.length===3?`int c[${O[2].dims.length}];`:""}

          copyVec(indices, a);
          copyVec(indices, b);
          ${O.length===3?"bcastIndices_C(indices, c);":""}

          float value = 0.0;
          for (int k=0; k<${ot}; ++k) {
              a[${at-1}] = k;
              b[${at-2}] = k;
              ${it}
          }

          value = value * alpha;
          ${O.length===3?"value += beta * _C(c);":""}
          return value;
      }`;return Object.assign(Object.assign({},G),{output:{dims:et,type:O[0].type,textureType:nt.TextureType.unpacked},variables:[{name:"alpha",type:"float",data:b.alpha},{name:"beta",type:"float",data:b.beta}],shaderSource:st})},q=(G,O)=>{if(!G)throw new Error("Input is missing");if(O.isOptionalC&&(G.length<2||G.length>3))throw new Error("Invaid input shape.");if(!O.isOptionalC&&G.length!==3)throw new Error("Gemm requires 3 inputs");if(G.length===3&&G[2].dims.length!==1&&G[2].dims.length!==2)throw new Error("Invalid input shape of C");if(G[0].type!=="float32"&&G[0].type!=="float64"||G[1].type!=="float32"&&G[1].type!=="float64"||G.length===3&&G[2].type!=="float32"&&G[2].type!=="float64")throw new Error("Invalid input type.");if(G[0].type!==G[1].type||G.length===3&&G[0].type!==G[2].type)throw new Error("Input types are mismatched")}},5950:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.createPackedIm2ColProgramInfoLoader=void 0;const tt=rt(6757),Y=rt(5639),nt=rt(5614);U.createPackedIm2ColProgramInfoLoader=(K,X,Q,q,G)=>{const O=(b=G.cacheKey,{name:"Im2Col (packed)",inputNames:["A"],inputTypes:[Y.TextureType.packed],cacheHint:b});var b;return Object.assign(Object.assign({},O),{get:()=>((F,j,W,J,et,ot)=>{const it=W.dims,at=J.dims,st=et.length,lt=[at[1]*at[2]*at[3],et[2]*et[3]],ct=at[2]*at[3],pt=(0,nt.unpackFromChannel)(),ut=(0,tt.getGlsl)(F.session.backend.glContext.version);let ft="";for(let _t=0;_t<=1;_t++)for(let vt=0;vt<=1;vt++)ft+=`
            blockIndex = rc.x + ${vt};
            pos = rc.y + ${_t};

            if(blockIndex < ${lt[1]} && pos < ${lt[0]}) {
              offsetY = int(blockIndex / (${et[st-1]})) * ${ot.strides[0]} -
                ${ot.pads[0]};
              d0 = offsetY + ${ot.dilations[0]} * (imod(pos, ${ct}) / ${at[2]});

              if(d0 < ${it[2]} && d0 >= 0) {
                offsetX = imod(blockIndex, ${et[st-1]}) * ${ot.strides[1]} -
                  ${ot.pads[1]};
                d1 = offsetX + ${ot.dilations[1]} * imod(imod(pos, ${ct}), ${at[2]});

                if(d1 < ${it[3]} && d1 >= 0) {

                  ch = int(float(pos)/ ${ct}.);
                    innerDims = vec2(d0, d1);
                    result[${2*_t+vt}] = getChannel(
                      getA(0, ch, int(innerDims.x),
                      int(innerDims.y)), innerDims);
                }
              }
            }

          `;const gt=`
      ${pt}

      void main() {
        ivec2 rc = getOutputCoords();
          vec4 result = vec4(0.0);
          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
          vec2 innerDims;
          ${ft}
          ${ut.output} = result;
      }
            `;return Object.assign(Object.assign({},j),{output:{dims:lt,type:W.type,textureType:Y.TextureType.packed},shaderSource:gt,hasMain:!0})})(K,O,X,Q,q,G)})}},1625:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.calculateIm2ColDims=U.createIm2ColProgramInfoLoader=void 0;const tt=rt(5639);U.createIm2ColProgramInfoLoader=(Y,nt,K,X,Q)=>{const q=(G=Q.cacheKey,{name:"Im2Col",inputNames:["X"],inputTypes:[tt.TextureType.unpacked],cacheHint:G});var G;return Object.assign(Object.assign({},q),{get:()=>((O,b,F,j,W,J)=>{const et=F.dims,ot=j.dims,it=W.length,at=(0,U.calculateIm2ColDims)(et,ot,W,4),st=`
        const int XC = ${et[1]};
        const int XH = ${et[2]};
        const int XW = ${et[3]};
        const int KH = ${J.kernelShape[0]};
        const int KW = ${J.kernelShape[1]};
        const int dilationH = ${J.dilations[0]};
        const int dilationW = ${J.dilations[1]};
        const int strideH = ${J.strides[0]};
        const int strideW = ${J.strides[1]};
        const int padH = ${J.pads[0]};
        const int padW = ${J.pads[1]};
        const int KHKW = KH*KW;
        const int XCKHKW = XC * KHKW;
        const int outputChannels = 4;
        vec4 process(int indices[${it}]) {
          int b  = indices[0]; // batch size
          int oh = indices[1] * strideH - padH; //output height
          int ow = indices[2] * strideW - padW; //output width
          int p = indices[3] * outputChannels; //patch
          vec4 value = vec4(0.0);
          for(int i=0; i < outputChannels; ++i) {
            if(p < XCKHKW) {
              int patchC = p / KHKW;
              int patchH = (p - patchC*KHKW) / KW;
              int patchW = (p - patchC*KHKW) - patchH * KW;
              int xh2 = oh + patchH * dilationH;
              int xw2 = ow + patchW * dilationW;
              int x[${et.length}];
              x[0] = b;
              x[1] = patchC;
              x[2] = xh2;
              x[3] = xw2;
              if(xh2 >= 0 &&
                  xh2 < XH &&
                  xw2 >= 0 &&
                  xw2 < XW) {
                value[i] = _X(x);
              }
            }
            ++p;
          }
          return value;
        }
        `;return Object.assign(Object.assign({},b),{output:{dims:at,type:F.type,textureType:tt.TextureType.packedLastDimension},shaderSource:st})})(0,q,nt,K,X,Q)})},U.calculateIm2ColDims=(Y,nt,K,X=4)=>[K[0],K[2],K[3],Math.ceil(Y[1]*nt[2]*nt[3]/X)]},6981:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.parseImageScalerAttributes=U.imageScaler=void 0;const tt=rt(4910),Y=rt(5639);U.imageScaler=(q,G,O)=>(Q(G),[q.run(K(q,G,O),G)]),U.parseImageScalerAttributes=q=>{const G=q.attributes.getFloat("scale"),O=q.attributes.getFloats("bias");return(0,tt.createAttributeWithCacheKey)({scale:G,bias:O})};const nt={name:"ImageScaler",inputNames:["X"],inputTypes:[Y.TextureType.unpacked]},K=(q,G,O)=>{const b=Object.assign(Object.assign({},nt),{cacheHint:O.cacheKey});return Object.assign(Object.assign({},b),{get:()=>((F,j,W,J)=>{const et=W[0].dims.slice(),ot=et.length,it=`
      ${X(J.bias.length)}
      float process(int indices[${ot}]) {
        return _X(indices) * scale + getBias(bias, indices[1]);
      }`;return Object.assign(Object.assign({},j),{output:{dims:et,type:W[0].type,textureType:Y.TextureType.unpacked},variables:[{name:"bias",type:"float",arrayLength:J.bias.length,data:J.bias},{name:"scale",type:"float",data:J.scale}],shaderSource:it})})(0,b,G,O)})},X=q=>{const G=[`float getBias(float bias[${q}], int channel) {`];for(let O=0;O<q;++O)O===0?G.push(`	if (channel == ${O}) { return bias[${O}]; }`):O===q-1?G.push(`	else { return bias[${O}]; }`):G.push(`	else if (channel == ${O}) { return bias[${O}]; }`);return G.push("	}"),G.join(`
`)},Q=q=>{if(!q||q.length!==1)throw new Error("ImageScaler requires 1 input.");if(q[0].dims.length!==4)throw new Error("Invalid input shape.");if(q[0].type!=="float32"&&q[0].type!=="float64")throw new Error("Invalid input type.")}},7413:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.parseInstanceNormalizationAttributes=U.instanceNormalization=void 0;const tt=rt(6757),Y=rt(5639);U.instanceNormalization=(G,O,b)=>{q(O);const F=G.run(K(O[0]),O);return[G.run(Q(G,O[0],b,F.dims),[O[0],F,O[1],O[2]])]},U.parseInstanceNormalizationAttributes=G=>G.attributes.getFloat("epsilon",1e-5);const nt={name:"InstanceNormalization_MeanAndVariance",inputNames:["X"],inputTypes:[Y.TextureType.unpacked]},K=G=>Object.assign(Object.assign({},nt),{get:()=>((O,b)=>{const F=b.dims.slice(),j=F[1],W=F[2]*F[3],J=[F[0],j],et=`
      vec4 process(int[2] indices) {
        vec4 v = vec4(0.0);
        int a[4];
        a[0] = indices[0];
        a[1] = indices[1];
        float temp = 0.0;
        for(int a2=0; a2<${F[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${F[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += x;
          }
        }
        float mean = temp / float(${W});
        temp = 0.0;
        for(int a2=0; a2<${F[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${F[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += (x - mean) * (x - mean);
          }
        }
        v.r = mean;
        v.g = temp / float(${W});

        return v;
      }`;return Object.assign(Object.assign({},O),{output:{dims:J,type:b.type,textureType:Y.TextureType.packedLastDimension},shaderSource:et})})(nt,G)}),X={name:"InstanceNormalization_ComputeOutput",inputNames:["X","MeanAndVariance","Scale","B"],inputTypes:[Y.TextureType.unpacked,Y.TextureType.packedLastDimension,Y.TextureType.unpacked,Y.TextureType.unpacked]},Q=(G,O,b,F)=>{const j=Object.assign(Object.assign({},X),{cacheHint:`${b}`});return Object.assign(Object.assign({},j),{get:()=>((W,J,et,ot,it)=>{const at=(0,tt.getGlsl)(W.session.backend.glContext.version),[st,lt]=W.calculateTextureWidthAndHeight(it,Y.TextureType.packedLastDimension),[ct,pt]=[st/4,lt],ut=`
      vec4 get_MeanAndVariance(int[2] mv) {
        int offset = indicesToOffset_MeanAndVariance(mv);
        vec2 coords = offsetToCoords(offset, ${ct}, ${pt});
        return ${at.texture2D}(MeanAndVariance, coords);
      }

      float process(int[4] indices) {
        int mv[2];
        mv[0] = indices[0];
        mv[1] = indices[1];
        vec4 mean_and_variance = get_MeanAndVariance(mv);
        float mean = mean_and_variance.r;
        float variance = mean_and_variance.g;

        int sb[1];
        sb[0] = indices[1];
        float scale = _Scale(sb);
        float b = _B(sb);

        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;
      }`;return Object.assign(Object.assign({},J),{output:{dims:et.dims,type:et.type,textureType:Y.TextureType.unpacked},variables:[{name:"epsilon",type:"float",data:ot}],shaderSource:ut})})(G,j,O,b,F)})},q=G=>{if(!G||G.length!==3)throw new Error("InstanceNormalization requires 3 inputs.");const O=G[0],b=G[1],F=G[2];if(O.dims.length<3||b.dims.length!==1||F.dims.length!==1)throw new Error("Invalid input shape.");if(b.dims[0]!==O.dims[1]||F.dims[0]!==O.dims[1])throw new Error("Input shapes are mismatched.");if(O.type!=="float32"&&O.type!=="float64"||b.type!=="float32"&&b.type!=="float64"||F.type!=="float32"&&F.type!=="float64")throw new Error("Invalid input type.");if(G[0].dims.length!==4)throw new Error("Only support 4-D input shape.")}},7006:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.createLrnProgramInfoLoader=U.parseLrnAttributes=U.lrn=void 0;const tt=rt(4910),Y=rt(5639);U.lrn=(Q,q,G)=>(X(q),[Q.run(K(q,G),q)]),U.parseLrnAttributes=Q=>{const q=Q.attributes.getFloat("alpha",1e-4),G=Q.attributes.getFloat("beta",.75),O=Q.attributes.getFloat("bias",1),b=Q.attributes.getInt("size");return(0,tt.createAttributeWithCacheKey)({alpha:q,beta:G,bias:O,size:b})};const nt={name:"LRN",inputNames:["X"],inputTypes:[Y.TextureType.unpacked]};function K(Q,q){return Object.assign(Object.assign({},nt),{cacheHint:q.cacheKey,get:()=>function(G,O){const b=G[0].dims[1],F=G[0].dims.length,j=-Math.floor((O.size-1)/2),W=Math.ceil((O.size-1)/2),J=`float(${O.alpha}) / float(${O.size})`,et=`
    float process(int indices[${F}]) {
        int c = indices[1];
        float x = _X(indices);
        float square_sum = 0.0;

        for (int i = ${j}; i <= ${W}; i++) {
          int idx = c + i;
          if (c >= 0 && c < ${b}) {
            indices[1] = idx;
            float j = _X(indices);
            square_sum += j * j;
          }
        }
        return x / pow(float(${O.bias}) + ${J} * square_sum, float(${O.beta}));
    }`;return Object.assign(Object.assign({},nt),{cacheHint:O.cacheKey,output:{dims:G[0].dims,type:G[0].type,textureType:Y.TextureType.unpacked},shaderSource:et})}(Q,q)})}U.createLrnProgramInfoLoader=K;const X=Q=>{if(!Q||Q.length!==1)throw new Error("LRN requires 1 input.");if(Q[0].dims.length!==4)throw new Error('currently only support LRN for input with "NCHW" format');if(Q[0].type!=="float32")throw new Error("input should be float type")}},5632:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.createPackedMatmulProgramInfoLoader=void 0;const tt=rt(7273),Y=rt(6757),nt=rt(5639),K=rt(432),X=rt(2150),Q=rt(8276);U.createPackedMatmulProgramInfoLoader=(q,G,O)=>{const b=(F=G.length>2,j=O.activationCacheKey,{name:"MatMul (packed)",inputNames:F?["A","B","Bias"]:["A","B"],inputTypes:F?[nt.TextureType.packed,nt.TextureType.packed,nt.TextureType.packed]:[nt.TextureType.packed,nt.TextureType.packed],cacheHint:j});var F,j;return Object.assign(Object.assign({},b),{get:()=>((W,J,et,ot)=>{const it=et.length>2,at=it?"value += getBiasForMatmul();":"",st=et[0].dims,lt=et[1].dims,ct=tt.BroadcastUtil.calcShape(st,lt,!0),pt=!tt.ShapeUtil.areEqual(et[0].dims,et[1].dims);if(!ct)throw new Error("Can't use matmul on the given tensors");const ut=st[st.length-1],ft=Math.ceil(ut/2),gt=st.length,_t=lt.length,vt=(0,Y.getGlsl)(W.session.backend.glContext.version),bt=(0,K.getCoordsDataType)(ct.length),St=ct.length,yt=(0,K.getGlChannels)(),{activationFunction:wt,applyActivation:Dt}=(0,X.getActivationSnippet)(ot),Pt=it?`${(0,Q.getBiasForMatmul)(bt,yt,et[2].dims,ct,!0)}`:"",Ft=pt?`${function(jt,qt,Kt,Gt){let Qt=[],zt=[];const ne=Kt[0].dims,Zt=Kt[1].dims,re=ne.length,Xt=Zt.length,se=Gt.length,fe=se-re,ye=se-Xt;Qt=ne.map((ue,le)=>`coords.${qt[le+fe]}`),Qt[re-1]="i*2",Qt.join(", "),zt=Zt.map((ue,le)=>`coords.${qt[le+ye]}`),zt[Xt-2]="i*2",zt.join(", ");const ve=tt.BroadcastUtil.getBroadcastDims(ne,Gt),we=tt.BroadcastUtil.getBroadcastDims(Zt,Gt),_e=ve.map(ue=>`coords.${qt[ue+fe]} = 0;`).join(`
`),oe=we.map(ue=>`coords.${qt[ue+ye]} = 0;`).join(`
`),ge=`int lastDim = coords.${qt[se-1]};
  coords.${qt[se-1]} = coords.${qt[se-2]};
  coords.${qt[se-2]} = lastDim;`;return`
vec4 getAAtOutCoordsMatmul(int i) {
  ${jt} coords = getOutputCoords();
  ${ge}
  ${_e}
  vec4 outputValue = getA(${Qt});
  return outputValue;
}

vec4 getBAtOutCoordsMatmul(int i) {
  ${jt} coords = getOutputCoords();
  ${ge}
  ${oe}
  vec4 outputValue = getB(${zt});
  return outputValue;
}`}(bt,yt,et,ct)}`:"",Rt=pt?"getAAtOutCoordsMatmul(i)":`getA(${function(jt,qt){let Kt="";for(let Gt=0;Gt<qt-2;Gt++)Kt+=`rc.${jt[Gt]}, `;return Kt+=`rc.${jt[qt-2]}, i*2`,Kt}(yt,gt)})`,Bt=pt?"getBAtOutCoordsMatmul(i)":`getB(${function(jt,qt){let Kt="";for(let Gt=0;Gt<qt-2;Gt++)Kt+=`rc.${jt[Gt]}, `;return Kt+=`i*2, rc.${jt[qt-1]}`,Kt}(yt,_t)})`,Vt=`
            ${Ft}
            ${Pt}
            ${wt}
            void main() {
              ${pt?"":`${bt} rc =
          getOutputCoords(); int lastDim = rc.${yt[St-1]}; rc.${yt[St-1]} =
          rc.${yt[St-2]}; rc.${yt[St-2]} = lastDim;
      `}

              vec4 value = vec4(0);
              for (int i = 0; i < ${ft}; i++) {
                vec4 a = ${Rt};
                vec4 b = ${Bt};

                value += (a.rrbb * b.rgrg);
                value += (a.ggaa * b.baba);
              }
              ${at}
              ${Dt}
              ${vt.output} = value;
            }`;return Object.assign(Object.assign({},J),{output:{dims:ct,type:et[0].type,textureType:nt.TextureType.packed},shaderSource:Vt,hasMain:!0})})(q,b,G,O)})}},8276:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.getBiasForMatmul=U.createMatmulProgramInfoLoader=U.parseMatMulAttributes=U.matMul=void 0;const tt=rt(7273),Y=rt(5639),nt=rt(432),K=rt(2150),X=rt(5632);U.matMul=(b,F,j)=>(G(F),b.session.pack?[b.run((0,X.createPackedMatmulProgramInfoLoader)(b,F,j),F)]:[b.run(q(F,j),F)]),U.parseMatMulAttributes=b=>(0,K.parseInternalActivationAttributes)(b.attributes);const Q=(b,F)=>({name:"MatMul",inputNames:b?["A","B","Bias"]:["A","B"],inputTypes:b?[Y.TextureType.unpacked,Y.TextureType.unpacked,Y.TextureType.unpacked]:[Y.TextureType.unpacked,Y.TextureType.unpacked],cacheHint:F});function q(b,F){const j=Q(b.length>2,F.activationCacheKey);return Object.assign(Object.assign({},j),{get:()=>function(W,J,et){const ot=J[0].dims,it=J[1].dims,at=tt.BroadcastUtil.calcShape(ot,it,!0);if(!at)throw new Error("Can't use matmul on the given tensors");const st=(0,nt.getCoordsDataType)(at.length),lt=(0,nt.getGlChannels)(),{activationFunction:ct,applyActivation:pt}=(0,K.getActivationSnippet)(et),ut=J.length>2,ft=ut?"value += getBiasForMatmul();":"",gt=ut?`${O(st,lt,J[2].dims,at,!1)}`:"",_t=at.length,vt=ot.length,bt=it.length,St=`
    ${ct}
    ${gt}
    float process(int indices[${_t}]) {
        int a[${vt}];
        int b[${bt}];
        bcastMatmulIndices_A(indices, a);
        bcastMatmulIndices_B(indices, b);

        float value;
        for (int k=0; k<${ot[ot.length-1]}; ++k) {
            a[${vt-1}] = k;
            b[${bt-2}] = k;
            value += _A(a) * _B(b);
        }
        ${ft}
        ${pt}
        return value;
    }`;return Object.assign(Object.assign({},W),{output:{dims:at,type:J[0].type,textureType:Y.TextureType.unpacked},shaderSource:St})}(j,b,F)})}U.createMatmulProgramInfoLoader=q;const G=b=>{if(!b||b.length!==2)throw new Error("MatMul requires 2 inputs.");if(b[0].dims[b[0].dims.length-1]!==b[1].dims[b[1].dims.length-2])throw new Error("shared dimension does not match.");if(b[0].type!=="float32"&&b[0].type!=="float64"||b[1].type!=="float32"&&b[1].type!=="float64")throw new Error("inputs should be float type");if(b[0].type!==b[1].type)throw new Error("inputs types should match")};function O(b,F,j,W,J){let et="";const ot=j.length,it=W.length,at=it-ot;et=it<2&&ot>0?"coords":j.map((ct,pt)=>`coords.${F[pt+at]}`).join(", ");const st=tt.BroadcastUtil.getBroadcastDims(j,W).map(ct=>`coords.${F[ct+at]} = 0;`).join(`
`);let lt="vec4(outputValue.xx, outputValue.yy)";return tt.ShapeUtil.size(j)===1&&(lt="vec4(outputValue.x)"),J?`
vec4 getBiasForMatmul() {
  ${b} coords = getOutputCoords();
  ${st}
  vec4 outputValue = getBias(${et});
  return ${lt};
}`:`
float getBiasForMatmul() {
  ${b} coords = getOutputCoords();
  ${st}
  return getBias(coords.x);
}`}U.getBiasForMatmul=O},9:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.createPackProgramInfoLoader=void 0;const tt=rt(6757),Y=rt(5639),nt=rt(432),K=rt(5614),X={name:"pack",inputNames:["A"],inputTypes:[Y.TextureType.unpackedReversed]};U.createPackProgramInfoLoader=(Q,q)=>Object.assign(Object.assign({},X),{get:()=>((G,O)=>{const b=(0,tt.getGlsl)(G.session.backend.glContext.version),F=O.dims,j=F.length,W=O.dims.length,J=(0,nt.getCoordsDataType)(W),et=(0,K.getChannels)("rc",W),ot=(it=W,at=et,st=F[F.length-2],lt=F[F.length-1],it===0||it===1?"":`
    int r = ${at[it-2]};
    int c = ${at[it-1]};
    int rp1 = ${at[it-2]} + 1;
    int cp1 = ${at[it-1]} + 1;
    bool rEdge = rp1 >= ${lt};
    bool cEdge = cp1 >= ${st};
    `);var it,at,st,lt;let ct;ct=j===0?[1,1]:j===1?[F[0],1]:[F[W-1],F[W-2]];const pt=function(gt,_t,vt){if(gt===0)return"false";if(gt===1)return`rc > ${_t[0]}`;let bt="";for(let St=gt-2;St<gt;St++)bt+=`${vt[St]} >= ${_t[St-gt+2]}`,St<gt-1&&(bt+="||");return bt}(W,ct,et),ut=function(gt,_t){const vt=gt.length;if(vt===0)return"getA(), 0, 0, 0";if(vt===1)return`getA(rc),
            rc + 1 >= ${gt[0]} ? 0. : getA(rc + 1),
            0, 0`;let bt="";if(vt>2)for(let St=0;St<vt-2;++St)bt+=`${_t[St]},`;return`getA(${bt}r, c),
          rEdge ? 0. : getA(${bt}rp1, c),
          cEdge ? 0. : getA(${bt}r, cp1),
          rEdge || cEdge ? 0. : getA(${bt}rp1, cp1)`}(F,et),ft=`
        void main() {
          ${J} rc = getOutputCoords();

          if(${pt}) {
            ${b.output} = vec4(0);
          } else {
            ${ot}

            ${b.output} = vec4(${ut});
          }
        }
      `;return Object.assign(Object.assign({},X),{hasMain:!0,output:{dims:O.dims,type:O.type,textureType:Y.TextureType.packed},shaderSource:ft})})(Q,q)})},5614:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.unpackFromChannel=U.getChannels=U.getVecChannels=void 0;const tt=rt(432);function Y(nt,K){return(0,tt.getGlChannels)(K).map(X=>`${nt}.${X}`)}U.getVecChannels=Y,U.getChannels=function(nt,K){return K===1?[nt]:Y(nt,K)},U.unpackFromChannel=function(){return`
    float getChannel(vec4 frag, int dim) {
      int modCoord = imod(dim, 2);
      return modCoord == 0 ? frag.r : frag.g;
    }

    float getChannel(vec4 frag, vec2 innerDims) {
      vec2 modCoord = mod(innerDims, 2.);
      return modCoord.x == 0. ?
        (modCoord.y == 0. ? frag.r : frag.g) :
        (modCoord.y == 0. ? frag.b : frag.a);
    }
  `}},5565:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.parsePadAttributesV11=U.padV11=U.parsePadAttributesV2=U.padV2=void 0;const tt=rt(4910),Y=rt(7273),nt=rt(6757),K=rt(5639),X={name:"Pad",inputNames:["A"],inputTypes:[K.TextureType.unpacked]};U.padV2=(J,et,ot)=>(G(et),[J.run(Object.assign(Object.assign({},X),{cacheHint:ot.cacheKey,get:()=>q(J,et[0],ot)}),et)]),U.parsePadAttributesV2=J=>{const et=J.attributes.getString("mode","constant"),ot=J.attributes.getFloat("value",0),it=J.attributes.getInts("pads");return(0,tt.createAttributeWithCacheKey)({mode:et,value:ot,pads:it})},U.padV11=(J,et,ot)=>{O(et);const it=Q(J,et,ot);return(0,U.padV2)(J,[et[0]],it)},U.parsePadAttributesV11=J=>J.attributes.getString("mode","constant");const Q=(J,et,ot)=>{if(!J.session.isInitializer(et[1].dataId)||et.length>=3&&!J.session.isInitializer(et[2].dataId))throw new Error("dynamic pad attributes are not allowed");const it=Array.from(et[1].integerData),at=et.length>=3?et[2].floatData[0]:0;return(0,tt.createAttributeWithCacheKey)({mode:ot,pads:it,value:at})},q=(J,et,ot)=>{const it=Y.ShapeUtil.padShape(et.dims.slice(),ot.pads),at=it.length,st=`
      ${b(J,et,ot)}
      float process(int[${at}] indices) {
          return padA(indices);
      }`;return{name:"Pad",inputNames:["A"],inputTypes:[K.TextureType.unpacked],output:{dims:it,type:et.type,textureType:K.TextureType.unpacked},shaderSource:st}},G=J=>{if(!J||J.length!==1)throw new Error("Pad requires 1 input");if(J[0].type!=="float32"&&J[0].type!=="float64")throw new Error("Invalid input type.")},O=J=>{if(!J||J.length!==2&&J.length!==3)throw new Error("Pad requires 2 or 3 inputs");if(J[1].type!=="int32")throw new Error("Invalid input type.");if(J.length>=3&&J[2].type==="string")throw new Error("Invalid input type.")},b=(J,et,ot)=>{const it=(0,nt.getGlsl)(J.session.backend.glContext.version),[at,st]=J.calculateTextureWidthAndHeight(et.dims,K.TextureType.unpacked),lt=Y.ShapeUtil.computeStrides(et.dims);switch(ot.mode){case"constant":return F(it,et.dims,lt,at,st,ot.pads,ot.value);case"reflect":return j(it,et.dims,lt,at,st,ot.pads);case"edge":return W(it,et.dims,lt,at,st,ot.pads);default:throw new Error("Invalid mode")}},F=(J,et,ot,it,at,st,lt)=>{const ct=et.length;let pt="";for(let ut=ct-1;ut>=0;--ut)pt+=`
        k = m[${ut}] - ${st[ut]};
        if (k < 0)  return constant;
        if (k >= ${et[ut]}) return constant;
        offset += k * ${ot[ut]};
        `;return`
      float padA(int m[${ct}]) {
        const float constant = float(${lt});
        int offset = 0;
        int k = 0;
        ${pt}
        vec2 coords = offsetToCoords(offset, ${it}, ${at});
        float value = getColorAsFloat(${J.texture2D}(A, coords));
        return value;
      }
      `},j=(J,et,ot,it,at,st)=>{const lt=et.length;let ct="";for(let pt=lt-1;pt>=0;--pt)ct+=`
        k = m[${pt}] - ${st[pt]};
        if (k < 0) { k = -k; }
        {
          const int _2n_1 = ${2*(et[pt]-1)};
          k = int( mod( float(k), float(_2n_1) ) ) ;
          if(k >= ${et[pt]}) { k = _2n_1 - k; }
        }
        offset += k * ${ot[pt]};
        `;return`
      float padA(int m[${lt}]) {
        int offset = 0;
        int k = 0;
        ${ct}
        vec2 coords = offsetToCoords(offset, ${it}, ${at});
        float value = getColorAsFloat(${J.texture2D}(A, coords));
        return value;
      }
      `},W=(J,et,ot,it,at,st)=>{const lt=et.length;let ct="";for(let pt=lt-1;pt>=0;--pt)ct+=`
        k = m[${pt}] - ${st[pt]};
        if (k < 0)  k = 0;
        if (k >= ${et[pt]}) k = ${et[pt]-1};
        offset += k * ${ot[pt]};
      `;return`
      float padA(int m[${lt}]) {
        int offset = 0;
        int k = 0;
        ${ct}
        vec2 coords = offsetToCoords(offset, ${it}, ${at});
        float value = getColorAsFloat(${J.texture2D}(A, coords));
        return value;
      }
      `}},2834:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.globalMaxPool=U.parseMaxPoolAttributes=U.maxPool=U.parseGlobalAveragePoolAttributes=U.globalAveragePool=U.parseAveragePoolAttributes=U.averagePool=void 0;const tt=rt(4910),Y=rt(7273),nt=rt(5639);U.averagePool=(W,J,et)=>{O(J);const ot={name:"AveragePool",inputNames:["X"],inputTypes:[nt.TextureType.unpacked],cacheHint:et.cacheKey};return[W.run(Object.assign(Object.assign({},ot),{get:()=>K(J,ot,!1,et)}),J)]},U.parseAveragePoolAttributes=W=>{const J=W.attributes.getString("auto_pad","NOTSET"),et=W.attributes.getInt("ceil_mode",0),ot=W.attributes.getInt("count_include_pad",0)!==0,it=W.attributes.getInts("kernel_shape"),at=W.attributes.getInts("strides",[]),st=W.attributes.getInts("pads",[]);if(et!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return(0,tt.createAttributeWithCacheKey)({autoPad:J,ceilMode:et,countIncludePad:ot,kernelShape:it,strides:at,pads:st})};const K=(W,J,et,ot)=>{const[it,at]=Q(W,ot,et),st=Y.ShapeUtil.size(it.kernelShape);let lt="";it.countIncludePad?lt+=`value /= float(${st});`:lt+=`value /= float(${st} - pad);`;const ct=`
        ${b(W[0].dims,it,"value += _X(x);",lt,"0.0")}
      `;return Object.assign(Object.assign({},J),{output:{dims:at,type:W[0].type,textureType:nt.TextureType.unpacked},shaderSource:ct})};U.globalAveragePool=(W,J,et)=>{O(J);const ot={name:"GlobalAveragePool",inputNames:["X"],inputTypes:[nt.TextureType.unpacked],cacheHint:`${et.countIncludePad}`};return[W.run(Object.assign(Object.assign({},ot),{get:()=>K(J,ot,!0,et)}),J)]},U.parseGlobalAveragePoolAttributes=W=>{const J=W.attributes.getInt("count_include_pad",0)!==0;return(0,tt.createAttributeWithCacheKey)({autoPad:"",ceilMode:0,countIncludePad:J,kernelShape:[],strides:[],pads:[]})},U.maxPool=(W,J,et)=>{O(J);const ot={name:"MaxPool",inputNames:["X"],inputTypes:[nt.TextureType.unpacked],cacheHint:et.cacheKey};return[W.run(Object.assign(Object.assign({},ot),{get:()=>X(J,ot,!1,et)}),J)]},U.parseMaxPoolAttributes=W=>{const J=W.attributes.getString("auto_pad","NOTSET"),et=W.attributes.getInt("ceil_mode",0),ot=W.attributes.getInts("kernel_shape"),it=W.attributes.getInts("strides",[]),at=W.attributes.getInts("pads",[]),st=W.attributes.getInt("storage_order",0),lt=W.attributes.getInts("dilations",[]);if(st!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(et!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return(0,tt.createAttributeWithCacheKey)({autoPad:J,ceilMode:et,countIncludePad:!1,kernelShape:ot,strides:it,pads:at,storageOrder:st,dilations:lt})};const X=(W,J,et,ot)=>{const[it,at]=Q(W,ot,et),st=`
      ${b(W[0].dims,it,`
      value = max(_X(x), value);
    `,"","-1e5")}
    `;return Object.assign(Object.assign({},J),{output:{dims:at,type:W[0].type,textureType:nt.TextureType.unpacked},shaderSource:st})},Q=(W,J,et)=>{const ot=W[0].dims.slice(),it=Object.hasOwnProperty.call(J,"dilations"),at=J.kernelShape.slice(),st=J.strides.slice(),lt=it?J.dilations.slice():[],ct=J.pads.slice();Y.PoolConvUtil.adjustPoolAttributes(et,ot,at,st,lt,ct);const pt=Y.PoolConvUtil.computePoolOutputShape(et,ot,st,lt,at,ct,J.autoPad),ut=Object.assign({},J);return it?Object.assign(ut,{kernelShape:at,strides:st,pads:ct,dilations:lt,cacheKey:J.cacheKey}):Object.assign(ut,{kernelShape:at,strides:st,pads:ct,cacheKey:J.cacheKey}),[ut,pt]},q={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},G={name:"GlobalMaxPool",inputNames:["X"],inputTypes:[nt.TextureType.unpacked]};U.globalMaxPool=(W,J)=>(O(J),[W.run(Object.assign(Object.assign({},G),{get:()=>X(J,G,!0,q)}),J)]);const O=W=>{if(!W||W.length!==1)throw new Error("Pool ops requires 1 input.");if(W[0].type!=="float32"&&W[0].type!=="float64")throw new Error("Invalid input type.")},b=(W,J,et,ot,it)=>{const at=W.length;if(J.kernelShape.length<=2){const st=J.kernelShape[J.kernelShape.length-1],lt=J.strides[J.strides.length-1],ct=J.pads[J.pads.length/2-1],pt=J.pads[J.pads.length-1],ut=W[at-1];let ft="",gt="",_t="";if(ft=ct+pt!==0?`
          for (int i = 0; i < ${st}; i++) {
            x[${at} - 1] = indices[${at} - 1] * ${lt} - ${ct} + i;
            if (x[${at} - 1] < 0 || x[${at} - 1] >= ${ut}) {
              pad++;
              continue;
            }
            ${et}
          }`:`
          for (int i = 0; i < ${st}; i++) {
            x[${at} - 1] = indices[${at} - 1] * ${lt} - ${ct} + i;
            ${et}
          }`,J.kernelShape.length===2){const vt=J.kernelShape[J.kernelShape.length-2],bt=J.strides[J.strides.length-2],St=J.pads[J.pads.length/2-2],yt=J.pads[J.pads.length-2],wt=W[at-2];gt=St+yt!==0?`
            for (int j = 0; j < ${vt}; j++) {
              x[${at} - 2] = indices[${at} - 2] * ${bt} - ${St} + j;
              if (x[${at} - 2] < 0 || x[${at} - 2] >= ${wt}) {
                pad+= ${st};
                continue;
              }
          `:`
            for (int j = 0; j < ${vt}; j++) {
              x[${at} - 2] = indices[${at} - 2] * ${bt} - ${St} + j;
            `,_t=`
          }
        `}return`
        float process(int indices[${at}]) {
          int x[${at}];
          copyVec(indices, x);

          float value = ${it};
          int pad = 0;
          ${gt}
          ${ft}
          ${_t}
          ${ot}
          return value;
        }
      `}{const st=Y.ShapeUtil.size(J.kernelShape),lt=Y.ShapeUtil.computeStrides(J.kernelShape),ct=lt.length,pt=J.pads.length,ut=j(ct),ft=F(W,"inputDims"),gt=F(J.pads,"pads"),_t=F(lt,"kernelStrides"),vt=F(J.strides,"strides");let bt="";return bt=J.pads.reduce((St,yt)=>St+yt)?`
            if (x[j] >= inputDims[j] || x[j] < 0) {
              pad++;
              isPad = true;
              break;
            }
          }
          if (!isPad) {
            ${et}
          }`:`
          }
          ${et}
        `,`
        ${ut}
        float process(int indices[${at}]) {
          int x[${at}];
          copyVec(indices, x);
          int offset[${ct}];
          int pads[${pt}];
          int inputDims[${at}];
          int kernelStrides[${ct}];
          int strides[${ct}];
          ${gt}
          ${ft}
          ${vt}
          ${_t}

          float value = ${it};
          int pad = 0;
          bool isPad = false;
          for (int i = 0; i < ${st}; i++) {
            offsetToIndices(i, kernelStrides, offset);
            isPad = false;
            for (int j = ${at} - ${ct}; j < ${at}; j++) {
              x[j] = indices[j] * strides[j - ${at} + ${ct}]
                + offset[j - ${at} + ${ct}] - pads[j - 2];
              ${bt}
          }
          ${ot}

          return value;
        }
      `}},F=(W,J)=>{let et="";for(let ot=0;ot<W.length;ot++)et+=`
      ${J}[${ot}] = ${W[ot]};
    `;return et},j=W=>`
  void offsetToIndices(int offset, int[${W}] strides, out int[${W}] indices) {
    if (${W} == 0) {
      return;
    }
    for (int i = 0; i < ${W} - 1; ++i) {
      indices[i] = offset / strides[i];
      offset -= indices[i] * strides[i];
    }
    indices[${W} - 1] = offset;
  }`},1010:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.reduceLogSumSquare=U.reduceLogSum=U.reduceProd=U.reduceMin=U.reduceMax=U.reduceMean=U.reduceSum=U.parseReduceAttributes=void 0;const tt=rt(4910),Y=rt(6145),nt=rt(7273),K=rt(5639),X=(G,O,b,F,j)=>{q(O);const W={name:F,inputNames:["A"],inputTypes:[K.TextureType.unpacked]};return[G.run(Object.assign(Object.assign({},W),{cacheHint:b.cacheKey,get:()=>Q(G,O,b,F,j,W)}),O)]};U.parseReduceAttributes=G=>{const O=G.attributes.getInts("axes",[]),b=G.attributes.getInt("keepdims",1)===1;return(0,tt.createAttributeWithCacheKey)({axes:O,keepDims:b})};const Q=(G,O,b,F,j,W)=>{const J=[],et=O[0].dims.length||1,ot=[],it=nt.ShapeUtil.normalizeAxes(b.axes,O[0].dims.length),at=j(O,it);let st=at[1];for(let ct=0;ct<O[0].dims.length;ct++)it.indexOf(ct)>=0||it.length===0?(b.keepDims&&J.push(1),st=`
          for(int j${ct} = 0; j${ct} < ${O[0].dims[ct]}; j${ct}++) {
            inputIdx[${ct}] = j${ct};
            ${st}
          }`):(ot.push(`inputIdx[${ct}] = outputIdx[${J.length}];`),J.push(O[0].dims[ct]));const lt=`
      float process(int outputIdx[${J.length||1}]) {
        float value;                 // final result
        int inputIdx[${et}];      // addressing input data
        ${ot.join(`
`)}
        ${at[0]}       // init ops for reduce max/min
        ${st}
        ${at[2]}       // final computation for reduce mean
        return value;
      }`;return Object.assign(Object.assign({},W),{output:{dims:J,type:O[0].type,textureType:K.TextureType.unpacked},shaderSource:lt})},q=G=>{if(!G||G.length!==1)throw new Error("Reduce op requires 1 input.");if(Y.NUMBER_TYPES.indexOf(G[0].type)===-1)throw new Error("Invalid input type.")};U.reduceSum=(G,O,b)=>X(G,O,b,"ReduceSum",()=>["value = 0.0;","value += _A(inputIdx);",""]),U.reduceMean=(G,O,b)=>X(G,O,b,"ReduceMean",(F,j)=>{let W=1;for(let J=0;J<F[0].dims.length;J++)(j.indexOf(J)>=0||j.length===0)&&(W*=F[0].dims[J]);return["value = 0.0;","value += _A(inputIdx);",`value /= ${W}.;`]}),U.reduceMax=(G,O,b)=>X(G,O,b,"ReduceMax",(F,j)=>{const W=[];for(let J=0;J<F[0].dims.length;J++)(j.indexOf(J)>=0||j.length===0)&&W.push(`inputIdx[${J}] = 0;`);return[`${W.join(`
`)}
value = _A(inputIdx);`,"value = max(value, _A(inputIdx));",""]}),U.reduceMin=(G,O,b)=>X(G,O,b,"ReduceMin",(F,j)=>{const W=[];for(let J=0;J<F[0].dims.length;J++)(j.indexOf(J)>=0||j.length===0)&&W.push(`inputIdx[${J}] = 0;`);return[`${W.join(`
`)}
value = _A(inputIdx);`,"value = min(value, _A(inputIdx));",""]}),U.reduceProd=(G,O,b)=>X(G,O,b,"ReduceProd",()=>["value = 1.0;","value *= _A(inputIdx);",""]),U.reduceLogSum=(G,O,b)=>X(G,O,b,"ReduceLogSum",()=>["value = 0.0;","value += _A(inputIdx);","value = log(value);"]),U.reduceLogSumSquare=(G,O,b)=>X(G,O,b,"ReduceLogSumSquare",()=>["float t; value = 0.0;","t = _A(inputIdx); value += t * t;",""])},7379:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.isReshapeCheap=U.processDims3D=U.createPackedReshape3DProgramInfoLoader=void 0;const tt=rt(7273),Y=rt(6757),nt=rt(5639),K=rt(5614);U.createPackedReshape3DProgramInfoLoader=(X,Q,q)=>{const G=(O=>({name:"Reshape (packed)",inputTypes:[nt.TextureType.packed],inputNames:["A"],cacheHint:`${O}`}))(q);return Object.assign(Object.assign({},G),{get:()=>((O,b,F,j)=>{const W=b.dims,J=j;let et="";for(let at=0;at<4;at++){let st="";switch(at){case 0:st="outputCoords = rc;";break;case 1:st="outputCoords = ivec3(rc.x, rc.y+1, rc.z);";break;case 2:st="outputCoords = ivec3(rc.x, rc.y, rc.z+1);";break;case 3:st="outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";break;default:throw new Error}et+=`
        ${st}
        ${at>0?"if(outputCoords.y < rows && outputCoords.z < cols){":""}
          int flattenedIndex = getFlattenedIndex(outputCoords);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);
          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${at}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);

        ${at>0?"}":""}
      `}const ot=(0,Y.getGlsl)(O.session.backend.glContext.version),it=`
      ${function(at){const st=tt.ShapeUtil.computeStrides(at),lt=["b","r","c"],ct="index";return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${st.map((pt,ut)=>`int ${lt[ut]} = ${ct} / ${pt}; ${ut===st.length-1?`int ${lt[ut+1]} = ${ct} - ${lt[ut]} * ${pt}`:`index -= ${lt[ut]} * ${pt}`};`).join("")}
      return ivec3(b, r, c);
    }
  `}(W)}
      ${function(at){const st=tt.ShapeUtil.computeStrides(at);return`
  int getFlattenedIndex(ivec3 coords) {
    // reverse y, z order
    return coords.x * ${st[0]} + coords.z * ${st[1]} + coords.y;
  }
`}(J)}
      ${(0,K.unpackFromChannel)()}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.0);

        ivec3 outputCoords;
        int rows = ${J[2]};
        int cols = ${J[1]};

        ${et}
        ${ot.output} = result;
      }
    `;return Object.assign(Object.assign({},F),{output:{dims:J,type:b.type,textureType:nt.TextureType.packed},shaderSource:it,hasMain:!0})})(X,Q,G,q)})},U.processDims3D=function(X){if(X.length===0)return[1,1,1];let Q=1;for(let q=0;q<X.length-2;++q)Q*=X[q];return[Q,X.length>1?X[X.length-2]:1,X[X.length-1]]},U.isReshapeCheap=function(X,Q){let q=!1;return q=X.length===0||Q.length===0||(X.length<2||Q.length<2?X[X.length-1]===Q[Q.length-1]:X[X.length-1]===Q[Q.length-1]&&X[X.length-2]===Q[Q.length-2]),q}},8126:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.reshape=void 0;const tt=rt(7273);U.reshape=(Y,nt)=>{const K=tt.ShapeUtil.calculateReshapedDims(nt[0].dims,nt[1].integerData);return Y.session.pack?[Y.reshapePacked(nt[0],K)]:[Y.reshapeUnpacked(nt[0],K)]}},2801:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.parseResizeAttributesV11=U.parseResizeAttributesV10=U.resize=void 0;const tt=rt(6757),Y=rt(5639),nt=rt(432),K=rt(5614),X=rt(3980),Q={name:"Resize",inputNames:["A"],inputTypes:[Y.TextureType.packed]};U.resize=(F,j,W)=>((0,X.validateInputs)(j,W),[F.run(Object.assign(Object.assign({},Q),{cacheHint:W.cacheKey,get:()=>q(F,j,W)}),j)]),U.parseResizeAttributesV10=F=>(0,X.parseUpsampleAttributes)(F,10),U.parseResizeAttributesV11=F=>(0,X.parseUpsampleAttributes)(F,11);const q=(F,j,W)=>{const J=(0,tt.getGlsl)(F.session.backend.glContext.version),[et,ot]=G(j,W);if(et.every(bt=>bt===1)&&W.coordinateTransformMode!=="tf_crop_and_resize")return Object.assign(Object.assign({},Q),{output:{dims:ot,type:j[0].type,textureType:Y.TextureType.packed},hasMain:!0,shaderSource:`void main() {
                    vec4 v = ${J.texture2D}(X, TexCoords);
                    ${J.output} = v;
                }`});const it=ot.length;if(it<2)throw new Error(`output dimension should be at least 2, but got ${it}`);const at=ot[it-2],st=ot[it-1],lt=j[0].dims;if(it!==lt.length)throw new Error(`output dimension should match input ${lt.length}, but got ${it}`);const ct=lt[it-2],pt=lt[it-1],ut=et[it-2],ft=et[it-1];let gt="";if(W.mode!=="linear")throw new Error(`resize (packed) does not support mode: '${W.mode}'`);switch(W.coordinateTransformMode){case"asymmetric":gt=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return vec4(coords) / scaleWHWH;
                    }
                `;break;case"half_pixel":gt=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;
                    }
                `;break;case"pytorch_half_pixel":gt=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 fcoords = vec4(coords);
                        return vec4(
                            ${st}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,
                            ${at}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,
                            ${st}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,
                            ${at}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0
                          );
                    }
                `;break;case"align_corners":gt=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 resized = vec4(${st}.0 - 1.0, ${at}.0 - 1.0, ${st}.0 - 1.0,
                            ${at}.0 - 1.0);
                        vec4 original = vec4(${pt}.0 - 1.0, ${ct}.0 - 1.0, ${pt}.0 - 1.0,
                            ${ct}.0 - 1.0);
                        vec4 new_scale = original / resized;
                        return vec4(coords) * new_scale;
                    }
                `;break;default:throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${W.coordinateTransformMode}'`)}const _t=(0,nt.getCoordsDataType)(it),vt=`
            const vec2 inputWH = vec2(${ct}.0, ${pt}.0);
            const vec4 scaleWHWH = vec4(float(${ut}), float(${ft}), float(${ut}), float(${ft}));
            ${(0,K.unpackFromChannel)()}
            ${gt}
            float getAValue(int x10, int r, int c, int d) {
                return getChannel(getA(x10, r, c, d), vec2(c, d));
            }
            void main() {
                ${_t} rc = getOutputCoords();

                int batch = rc[0];
                int depth = rc[1];

                // retrieve the 4 coordinates that is used in the 4 packed output values.
                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);

                // calculate the source index in fraction
                vec4 sourceFrac = getSourceFracIndex(coords);

                // get the lower and upper bound of the 4 values that will be packed into one texel.
                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));
                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));
                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));
                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));

                bool hasNextRow = rc.w < ${at-1};
                bool hasNextCol = rc.z < ${st-1};

                // pack x00, x01, x10, x11's top-left corner into one vec4 structure
                vec4 topLeft = vec4(
                    getAValue(batch, depth, x00.x, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);

                // pack x00, x01, x10, x11's top-right corner into one vec4 structure
                vec4 topRight = vec4(
                    getAValue(batch, depth, x00.x, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);

                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure
                vec4 bottomLeft = vec4(
                    getAValue(batch, depth, x00.z, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);

                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure
                vec4 bottomRight = vec4(
                    getAValue(batch, depth, x00.z, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);

                // calculate the interpolation fraction on u and v direction
                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);
                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));

                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);
                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);
                vec4 newValue = mix(top, bottom, clampFrac.xxzz);

                ${J.output} = vec4(newValue);
            }
        `;return Object.assign(Object.assign({},Q),{output:{dims:ot,type:j[0].type,textureType:Y.TextureType.packed},hasMain:!0,shaderSource:vt})},G=(F,j)=>{const W=F[0].dims;let J,et=j.scales;if(et.length===0){const it=F[j.scalesInputIdx];if(it&&it.size!==0){if(F[j.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");et=O(it,j.mode,j.isResize)}else{const at=F[j.sizesInputIdx];if(!at||at.size===0)throw new Error("Either scales or sizes MUST be provided as input.");J=Array.from(at.integerData),et=b(J,W,j.mode,j.isResize)}}else if(F[j.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");const ot=J||W.map((it,at)=>Math.floor(it*et[at]));return[et,ot]},O=(F,j,W)=>{const J=Array.from(F.floatData);return(0,X.scalesValidation)(J,j,W),J},b=(F,j,W,J)=>{const et=j.length,ot=new Array(et);for(let it=0,at=et;it<at;it++)if(j[it]===0){if(F[it]!==0)throw new Error("Input dim is zero but required output dim is non-zero.");ot[it]=1}else ot[it]=F[it]/j[it];return(0,X.scalesValidation)(ot,W,J),ot}},565:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.shape=void 0;const tt=rt(9240);U.shape=(nt,K)=>(Y(K),[new tt.Tensor([K[0].dims.length],"int32",void 0,void 0,new Int32Array(K[0].dims))]);const Y=nt=>{if(!nt||nt.length!==1)throw new Error("Shape requires 1 input.")}},2444:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.sliceV10=U.parseSliceAttributes=U.slice=void 0;const tt=rt(4910),Y=rt(6145),nt=rt(7273),K=rt(5639),X={name:"Slice",inputNames:["A"],inputTypes:[K.TextureType.unpacked]};U.slice=(b,F,j)=>(q(F),[b.run(Object.assign(Object.assign({},X),{cacheHint:j.cacheKey,get:()=>Q(b,F[0],j)}),F)]),U.parseSliceAttributes=b=>{const F=b.attributes.getInts("starts"),j=b.attributes.getInts("ends"),W=b.attributes.getInts("axes",[]);return(0,tt.createAttributeWithCacheKey)({starts:F,ends:j,axes:W})};const Q=(b,F,j)=>{const W=j.axes.length===0?F.dims.slice(0).map((lt,ct)=>ct):j.axes,J=nt.ShapeUtil.normalizeAxes(W,F.dims.length),et=j.starts.map((lt,ct)=>lt>F.dims[J[ct]]-1?F.dims[J[ct]]:nt.ShapeUtil.normalizeAxis(lt,F.dims[J[ct]])),ot=j.ends.map((lt,ct)=>lt>F.dims[J[ct]]-1?F.dims[J[ct]]:nt.ShapeUtil.normalizeAxis(lt,F.dims[J[ct]])),it=F.dims.slice(),at=[];for(let lt=0;lt<J.length;lt++)it[J[lt]]=ot[lt]-et[lt],et[lt]>0&&at.push(`outputIdx[${J[lt]}] += ${et[lt]};`);const st=`
      float process(int outputIdx[${it.length}]) {
        ${at.join(`
      `)}
        return _A(outputIdx);
      }`;return Object.assign(Object.assign({},X),{output:{dims:it,type:F.type,textureType:K.TextureType.unpacked},shaderSource:st})},q=b=>{if(!b||b.length!==1)throw new Error("Slice requires 1 input.");if(Y.NUMBER_TYPES.indexOf(b[0].type)===-1)throw new Error("Invalid input type.")};U.sliceV10=(b,F)=>{O(F);const j=G(b,F);return[b.run(Object.assign(Object.assign({},X),{cacheHint:j.cacheKey,get:()=>Q(b,F[0],j)}),[F[0]])]};const G=(b,F)=>{if(!b.session.isInitializer(F[1].dataId)||!b.session.isInitializer(F[2].dataId)||F.length>=4&&!b.session.isInitializer(F[3].dataId)||F.length>=5&&!b.session.isInitializer(F[4].dataId))throw new Error("dynamic slice attributes are not allowed");if(F.length>=5&&F[4].integerData.some(et=>et!==1))throw new Error("currently non-1 steps is not supported for Slice");const j=Array.from(F[1].integerData),W=Array.from(F[2].integerData),J=F.length>=4?Array.from(F[3].integerData):[];return{starts:j,ends:W,axes:J,cacheKey:`${J};${j};${W}`}},O=b=>{if(!b||b.length<3||b.length>5)throw new Error("Invalid input number.");if(b[1].type!=="int32"||b[1].dims.length!==1)throw new Error("Invalid input type.");if(b[2].type!=="int32"||b[2].dims.length!==1)throw new Error("Invalid input type.");if(b.length>=4&&(b[3].type!=="int32"||b[3].dims.length!==1))throw new Error("Invalid input type.");if(b.length>=5&&(b[4].type!=="int32"||b[4].dims.length!==1))throw new Error("Invalid input type.")}},815:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.softmaxV13=U.parseSoftmaxAttributesV13=U.parseSoftmaxAttributes=U.softmax=void 0;const tt=rt(4910),Y=rt(7273),nt=rt(6757),K=rt(5639),X=rt(5707),Q={name:"SoftmaxComputeMax",inputNames:["A"],inputTypes:[K.TextureType.unpacked]},q={name:"SoftmaxComputeScale",inputNames:["A","Max"],inputTypes:[K.TextureType.unpacked,K.TextureType.unpacked]},G={name:"SoftMax",inputNames:["A","Max","Norm"],inputTypes:[K.TextureType.unpacked,K.TextureType.unpacked,K.TextureType.unpacked]};U.softmax=(J,et,ot)=>{W(et);const it=et[0].dims.slice(),at=Y.ShapeUtil.normalizeAxis(ot.axis,it.length),st=Y.ShapeUtil.sizeToDimension(it,at),lt=Y.ShapeUtil.sizeFromDimension(it,at);return O(J,et,ot,st,lt)},U.parseSoftmaxAttributes=J=>(0,tt.createAttributeWithCacheKey)({axis:J.attributes.getInt("axis",1)}),U.parseSoftmaxAttributesV13=J=>(0,tt.createAttributeWithCacheKey)({axis:J.attributes.getInt("axis",-1)}),U.softmaxV13=(J,et,ot)=>{W(et);const it=et[0].dims.slice(),at=Y.ShapeUtil.normalizeAxis(ot.axis,it.length),st=it.length,lt=at!==st-1,ct=[];let pt,ut=[],ft=[];lt&&(ut=Array.from({length:st}).map((bt,St)=>St),ut[at]=st-1,ut[st-1]=at,ut.map(bt=>ct.push(it[bt])),pt=(0,tt.createAttributeWithCacheKey)({perm:ut}),ft=(0,X.transpose)(J,et,pt));const gt=lt?Y.ShapeUtil.sizeToDimension(ct,st-1):Y.ShapeUtil.sizeToDimension(it,st-1),_t=lt?Y.ShapeUtil.sizeFromDimension(ct,st-1):Y.ShapeUtil.sizeFromDimension(it,st-1),vt=O(J,lt?ft:et,ot,gt,_t);return lt?(0,X.transpose)(J,vt,pt):vt};const O=(J,et,ot,it,at)=>{const st=b(J,et[0],it,at,[it]),lt=J.run(Object.assign(Object.assign({},Q),{cacheHint:ot.cacheKey,get:()=>st}),et),ct=F(J,et[0],it,at,st.output.dims,[it]),pt=J.run(Object.assign(Object.assign({},q),{cacheHint:ot.cacheKey,get:()=>ct}),[et[0],lt]),ut=j(J,et[0],it,at,st.output.dims,ct.output.dims);return[J.run(Object.assign(Object.assign({},G),{cacheHint:ot.cacheKey,get:()=>ut}),[et[0],lt,pt])]},b=(J,et,ot,it,at)=>{const[st,lt]=J.calculateTextureWidthAndHeight(et.dims,K.TextureType.unpacked),ct=at.length;if(ot<1||it<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(at.length!==1)throw new Error("Dimensionality of the output should be 1");if(at[0]!==ot)throw new Error("Shape of the output should be equal to logical row count");const pt=(0,nt.getGlsl)(J.session.backend.glContext.version),ut=`
      float process(int[${ct}] indices) {
        int logical_row_start_offset = indices[0] * ${it};

        float max = getColorAsFloat(${pt.texture2D}(A, offsetToCoords(logical_row_start_offset, ${st},
        ${lt} )));
        for(int i=1; i<${it}; ++i)
        {
          float current = getColorAsFloat(${pt.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${st}, ${lt})));
          if(current > max)
          max = current;
        }

        return max;
      }`;return Object.assign(Object.assign({},Q),{output:{dims:at,type:et.type,textureType:K.TextureType.unpacked},shaderSource:ut})},F=(J,et,ot,it,at,st)=>{const[lt,ct]=J.calculateTextureWidthAndHeight(et.dims,K.TextureType.unpacked),pt=st.length;if(ot<1||it<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(st.length!==1)throw new Error("Dimensionality of the output should be 1");if(st[0]!==ot)throw new Error("Shape of the output should be equal to logical row count");if(at.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(at[0]!==ot)throw new Error("Shape of the intermediate results should be equal to logical row count");const ut=`
      float process(int[${pt}] indices) {
        int logical_row_start_offset = indices[0] * ${it};

        float norm_factor = 0.0;
        float max = _Max(indices);
        for(int i=0; i<${it}; ++i)
        {
          norm_factor += exp(getColorAsFloat(${(0,nt.getGlsl)(J.session.backend.glContext.version).texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${lt}, ${ct}))) - max);
        }

        return norm_factor;
      }`;return Object.assign(Object.assign({},q),{output:{dims:st,type:et.type,textureType:K.TextureType.unpacked},shaderSource:ut})},j=(J,et,ot,it,at,st)=>{const[lt,ct]=J.calculateTextureWidthAndHeight(et.dims,K.TextureType.unpacked),pt=et.dims.length;if(ot<1||it<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(at.length!==1||st.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(at[0]!==ot||st[0]!==ot)throw new Error("Shape of the intermediate results should be equal to logical row count");const ut=`
      float process(int[${pt}] indices) {

      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)
      int offset = coordsToOffset(TexCoords, ${lt}, ${ct});

      //determine the logical row for this index
      int logical_row_index[1];
      logical_row_index[0] = offset / ${it};

      float norm_factor = _Norm(logical_row_index);

      // avoid possible division by 0
      // if norm_facor is 0, all elements are zero
      // if so, return 0
      if(norm_factor == 0.0)
        return 0.0;

      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;
    }`;return Object.assign(Object.assign({},G),{output:{dims:et.dims,type:et.type,textureType:K.TextureType.unpacked},shaderSource:ut})},W=J=>{if(!J||J.length!==1)throw new Error("Softmax requires 1 input.");if(J[0].type!=="float32"&&J[0].type!=="float64")throw new Error("Invalid input type")}},564:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.parseSplitAttributes=U.split=void 0;const tt=rt(4910),Y=rt(7273),nt=rt(5639),K={name:"Split",inputNames:["A"],inputTypes:[nt.TextureType.unpacked]};U.split=(G,O,b)=>{q(O);const F=Y.ShapeUtil.normalizeAxis(b.axis,O[0].dims.length),j=X(G,O,F,b),W=[];for(let J=0;J<j;++J)W.push(G.run(Object.assign(Object.assign({},K),{cacheHint:`${b.cacheKey};${J}`,get:()=>Q(G,O[0],b,F,J)}),O));return W},U.parseSplitAttributes=G=>{const O=G.attributes.getInt("axis",0),b=G.attributes.getInts("split",[]),F=G.outputs.length;return(0,tt.createAttributeWithCacheKey)({axis:O,split:b,numOutputs:F})};const X=(G,O,b,F)=>{const[,j]=Y.SplitUtil.splitShape(O[0].dims,b,F.split,F.numOutputs);return j.length},Q=(G,O,b,F,j)=>{const[W,J]=Y.SplitUtil.splitShape(O.dims,F,b.split,b.numOutputs),et=J[j],ot=W[j],it=`
      float process(int indices[${ot.length}]) {
        indices[${F}] += ${et};
        return _A(indices);
      }
    `;return Object.assign(Object.assign({},K),{cacheHint:`${b.cacheKey}:${j}`,output:{dims:ot,type:O.type,textureType:nt.TextureType.unpacked},shaderSource:it})},q=G=>{if(!G||G.length!==1)throw new Error("Split requires one input.");if(G[0].type!=="int8"&&G[0].type!=="uint8"&&G[0].type!=="int16"&&G[0].type!=="uint16"&&G[0].type!=="int32"&&G[0].type!=="uint32"&&G[0].type!=="float32"&&G[0].type!=="float64"&&G[0].type!=="bool")throw new Error("Invalid input type.")}},5416:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.parseSqueezeAttributes=U.squeezeV13=U.squeeze=void 0;const tt=rt(7273);U.squeeze=(K,X,Q)=>{Y(X);const q=tt.ShapeUtil.squeezeShape(X[0].dims,Q);return[K.reshapeUnpacked(X[0],q)]},U.squeezeV13=(K,X)=>(nt(X),(0,U.squeeze)(K,[X[0]],Array.from(X[1].integerData))),U.parseSqueezeAttributes=K=>K.attributes.getInts("axes");const Y=K=>{if(!K||K.length!==1)throw new Error("Squeeze requires 1 input.");if(K[0].type==="string")throw new Error("invalid input tensor types.")},nt=K=>{if(!K||K.length!==2)throw new Error("Squeeze requires 2 inputs.");if(K[1].type!=="int32")throw new Error("Invalid input type.")}},1240:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.sum=void 0;const tt=rt(6757),Y=rt(5639);U.sum=(X,Q)=>{K(Q);const q={name:"Sum",inputNames:Q.map((G,O)=>`X${O}`),inputTypes:new Array(Q.length).fill(Y.TextureType.unpacked)};return[X.run(Object.assign(Object.assign({},q),{get:()=>nt(X,Q,q)}),Q)]};const nt=(X,Q,q)=>{const G=(0,tt.getGlsl)(X.session.backend.glContext.version),O=Q[0].dims.slice(),b=`
      void main() {
        vec4 result = ${Q.map((F,j)=>`${G.texture2D}(X${j},TexCoords)`).join(" + ")};
        ${G.output} = result;
      }
    `;return Object.assign(Object.assign({},q),{output:{dims:O,type:Q[0].type,textureType:Y.TextureType.unpacked},hasMain:!0,shaderSource:b})},K=X=>{if(!X||X.length===0)throw new Error("Sum requires inputs.");const Q=X[0].dims.length;for(let q=1;q<X.length;q++){if(Q!==X[q].dims.length)throw new Error("Input shapes are mismatched.");for(let G=0;G<Q;G++)if(X[0].dims[G]!==X[q].dims[G])throw new Error("Input shapes are not matched.")}if(X[0].type!=="float32"&&X[0].type!=="float64")throw new Error("Invalid input type.");for(let q=1;q<X.length;q++)if(X[0].type!==X[q].type)throw new Error("Input types are not matched.")}},5944:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.tile=void 0;const tt=rt(6145),Y=rt(5639);U.tile=(X,Q)=>{K(Q);const q={name:"Tile",inputNames:["A"],inputTypes:[Y.TextureType.unpacked]};return[X.run(Object.assign(Object.assign({},q),{get:()=>nt(X,Q,q)}),Q)]};const nt=(X,Q,q)=>{const G=Q[0].dims.slice(),O=new Array(G.length),b=[];for(let W=0;W<G.length;W++)O[W]=G[W]*Q[1].numberData[W],b.push(`inputIdx[${W}] = int(mod(float(outputIdx[${W}]), ${G[W]}.));`);const F=O.length,j=`
      float process(int outputIdx[${F}]) {
        int inputIdx[${F}];
        ${b.join(`
`)}
        return _A(inputIdx);
      }
    `;return Object.assign(Object.assign({},q),{output:{dims:O,type:Q[0].type,textureType:Y.TextureType.unpacked},shaderSource:j})},K=X=>{if(!X||X.length!==2)throw new Error("Tile requires 2 input.");if(X[1].dims.length!==1)throw new Error("The second input shape must 1 dimension.");if(X[1].dims[0]!==X[0].dims.length)throw new Error("Invalid input shape.");if(tt.NUMBER_TYPES.indexOf(X[0].type)===-1)throw new Error("Invalid input type.");if(X[1].type!=="int32"&&X[1].type!=="int16")throw new Error("Invalid repeat type.")}},5707:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.parseTransposeAttributes=U.transpose=void 0;const tt=rt(4910),Y=rt(7273),nt=rt(5639),K={name:"Transpose",inputNames:["A"],inputTypes:[nt.TextureType.unpacked]};U.transpose=(b,F,j)=>(O(F),[b.run(Object.assign(Object.assign({},K),{cacheHint:j.cacheKey,get:()=>X(b,F[0],j.perm)}),F)]),U.parseTransposeAttributes=b=>(0,tt.createAttributeWithCacheKey)({perm:b.attributes.getInts("perm",[])});const X=(b,F,j)=>{const W=F.dims;j=Q(W,j);const J=q(W,j),et=W.length,ot=`
      ${G("perm",j,et)}
      float process(int indices[${et}]) {
        int a[${et}];
        perm(a, indices);
        return _A(a);
      }`;return Object.assign(Object.assign({},K),{output:{dims:J,type:F.type,textureType:nt.TextureType.unpacked},shaderSource:ot})},Q=(b,F)=>(F&&F.length!==b.length&&(F=[...b.keys()].reverse()),F),q=(b,F)=>(F=Q(b,F),Y.ShapeUtil.sortBasedOnPerm(b,F)),G=(b,F,j)=>{const W=[];W.push(`void ${b}(out int a[${j}], int src[${j}]) {`);for(let J=0;J<j;++J)W.push(`	a[${F[J]}]=src[${J}];`);return W.push("	}"),W.join(`
`)},O=b=>{if(!b||b.length!==1)throw new Error("Transpose requires 1 input.");if(b[0].type!=="float32"&&b[0].type!=="float64")throw new Error("input should be float tensor")}},2488:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.encodeAsUint8=void 0;const tt=rt(6757),Y=rt(5639);U.encodeAsUint8=(nt,K)=>{const X=K.shape,Q=(0,tt.getGlsl)(nt.session.backend.glContext.version),q=`
    const float FLOAT_MAX = 1.70141184e38;
    const float FLOAT_MIN = 1.17549435e-38;

    bool isNaN(float val) {
      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;
    }

    highp vec4 encodeAsUint8(highp float v) {
      if (isNaN(v)) {
        return vec4(255, 255, 255, 255);
      }

      highp float av = abs(v);

      if(av < FLOAT_MIN) {
        return vec4(0.0, 0.0, 0.0, 0.0);
      } else if(v > FLOAT_MAX) {
        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
      } else if(v < -FLOAT_MAX) {
        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
      }

      highp vec4 c = vec4(0,0,0,0);

      highp float e = floor(log2(av));
      highp float m = exp2(fract(log2(av))) - 1.0;

      c[2] = floor(128.0 * m);
      m -= c[2] / 128.0;
      c[1] = floor(32768.0 * m);
      m -= c[1] / 32768.0;
      c[0] = floor(8388608.0 * m);

      highp float ebias = e + 127.0;
      c[3] = floor(ebias / 2.0);
      ebias -= c[3] * 2.0;
      c[2] += floor(ebias) * 128.0;

      c[3] += 128.0 * step(0.0, -v);

      return c / 255.0;
    }

    void main() {
      float value = ${Q.texture2D}(X,TexCoords).r;
      ${Q.output} = encodeAsUint8(value);
    }`,G={name:"Uint8Encode",inputTypes:[Y.TextureType.unpacked],inputNames:["X"],output:{dims:X,type:K.tensor.type,textureType:Y.TextureType.downloadUint8AsFloat},shaderSource:q,hasMain:!0};return nt.executeProgram(G,[K.tensor])}},9087:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.tanh=U.tan=U.sqrt=U.sin=U.sigmoid=U.relu=U.not=U.neg=U.log=U.parseLeakyReluAttributes=U.leakyRelu=U.identity=U.floor=U.exp=U.parseEluAttributes=U.elu=U.cos=U.ceil=U.clipV11=U.parseClipAttributes=U.clip=U.atan=U.asin=U.acos=U.abs=U.glslTanh=U.glslTan=U.glslSqrt=U.glslSigmoid=U.glslRelu=U.glslSin=U.glslNot=U.glslNeg=U.glslLog=U.glslLeakyRelu=U.glslIdentity=U.glslClip=U.glslFloor=U.glslExp=U.glslElu=U.glslCos=U.glslCeil=U.glslAtan=U.glslAsin=U.glslAcos=U.glslAbs=void 0;const tt=rt(4910),Y=rt(7273),nt=rt(1997),K=rt(6757),X=rt(5639);function Q(){return vt("abs")}function q(){return vt("acos")}function G(){return vt("asin")}function O(){return vt("atan")}function b(){return vt("ceil")}function F(){return vt("cos")}function j(yt){const wt="elu";return{body:`
  const float alpha = float(${yt});

  float ${wt}_(float a) {
    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;
  }
  vec4 ${wt}_(vec4 v) {
    return vec4(${wt}_(v.x), ${wt}_(v.y), ${wt}_(v.z), ${wt}_(v.w));
  }
  `,name:wt,type:nt.FunctionType.ValueBased}}function W(){return vt("exp")}function J(){return vt("floor")}function et(yt,wt){const Dt="clip";return{body:`
  const float min = float(${yt});
  const float max = float(${wt});

  float ${Dt}_(float a) {
    return clamp(a, min, max);
  }
  vec4 ${Dt}_(vec4 v) {
    return clamp(v, min, max);
  }
  `,name:Dt,type:nt.FunctionType.ValueBased}}function ot(){const yt="indentity";return{body:`
  float ${yt}_(float a) {
    return a;
  }
  vec4 ${yt}_(vec4 v) {
    return v;
  }
  `,name:yt,type:nt.FunctionType.ValueBased}}function it(yt){const wt="leakyRelu";return{body:`
  const float alpha = float(${yt});

  float ${wt}_(float a) {
    return a < 0.0 ? a * alpha : a;
  }
  vec4 ${wt}_(vec4 v) {
    return vec4(${wt}_(v.x), ${wt}_(v.y), ${wt}_(v.z), ${wt}_(v.w));
  }
  `,name:wt,type:nt.FunctionType.ValueBased}}function at(){return vt("log")}function st(){const yt="neg";return{body:`
  float ${yt}_(float a) {
    return -a;
  }
  vec4 ${yt}_(vec4 v) {
    return -v;
  }
  `,name:yt,type:nt.FunctionType.ValueBased}}function lt(){const yt="not";return{body:`
  float ${yt}_(float a) {
    return float( ! bool(a) );
  }
  bool ${yt}_(bool a) {
    return !a;
  }
  vec4 ${yt}_(vec4 v) {
    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));
  }
  bvec4 ${yt}_(bvec4 v) {
    return bvec4(!v.x, !v.y, !v.z, !v.w);
  }
  `,name:yt,type:nt.FunctionType.ValueBased}}function ct(){return vt("sin")}function pt(){const yt="relu";return{body:`
  float ${yt}_(float a) {
    return max( a, 0.0 );
  }
  vec4 ${yt}_(vec4 v) {
    return max( v, 0.0 );
  }
  `,name:yt,type:nt.FunctionType.ValueBased}}function ut(){const yt="sigmoid";return{body:`
  float ${yt}_(float a) {
    return 1.0 / (1.0 + exp(-a));
  }
  vec4 ${yt}_(vec4 v) {
    return 1.0 / (1.0 + exp(-v));
  }
  `,name:yt,type:nt.FunctionType.ValueBased}}function ft(){return vt("sqrt")}function gt(){return vt("tan")}function _t(){const yt="tanh";return{body:`
  float ${yt}_(float a) {
    a = clamp(a, -10., 10.);
    a = exp(2.*a);
    return (a - 1.) / (a + 1.);
  }
  vec4 ${yt}_(vec4 v) {
    v = clamp(v, -10., 10.);
    v = exp(2.*v);
    return (v - 1.) / (v + 1.);
  }
  `,name:yt,type:nt.FunctionType.ValueBased}}function vt(yt){return{body:`
  float ${yt}_(float a) {
    return ${yt}(a);
  }
  vec4 ${yt}_(vec4 v) {
    return ${yt}(v);
  }
  `,name:yt,type:nt.FunctionType.ValueBased}}U.glslAbs=Q,U.glslAcos=q,U.glslAsin=G,U.glslAtan=O,U.glslCeil=b,U.glslCos=F,U.glslElu=j,U.glslExp=W,U.glslFloor=J,U.glslClip=et,U.glslIdentity=ot,U.glslLeakyRelu=it,U.glslLog=at,U.glslNeg=st,U.glslNot=lt,U.glslSin=ct,U.glslRelu=pt,U.glslSigmoid=ut,U.glslSqrt=ft,U.glslTan=gt,U.glslTanh=_t;const bt=(yt,wt,Dt,Pt)=>{const Ft=yt.session.pack?X.TextureType.packed:X.TextureType.unpacked,Rt={name:Dt.name,inputTypes:[Ft],inputNames:["A"],cacheHint:Pt};return Object.assign(Object.assign({},Rt),{get:()=>((Bt,Vt,jt,qt)=>{const Kt=Bt.session.pack?X.TextureType.packed:X.TextureType.unpacked,Gt=(0,K.getGlsl)(Bt.session.backend.glContext.version);return Object.assign(Object.assign({},Vt),{output:{dims:jt.dims,type:jt.type,textureType:Kt},shaderSource:`
     ${qt.body}
     void main() {
       vec4 v = ${Gt.texture2D}(A, TexCoords);
       v = ${qt.name}_(v);
       ${Gt.output} = v;
     }
     `,hasMain:!0})})(yt,Rt,wt,Dt)})};U.abs=(yt,wt)=>[yt.run(bt(yt,wt[0],Q()),wt)],U.acos=(yt,wt)=>[yt.run(bt(yt,wt[0],q()),wt)],U.asin=(yt,wt)=>[yt.run(bt(yt,wt[0],G()),wt)],U.atan=(yt,wt)=>[yt.run(bt(yt,wt[0],O()),wt)],U.clip=(yt,wt,Dt)=>[yt.run(bt(yt,wt[0],et(Dt.min,Dt.max),Dt.cacheKey),wt)],U.parseClipAttributes=yt=>(0,tt.createAttributeWithCacheKey)({min:yt.attributes.getFloat("min",Y.MIN_CLIP),max:yt.attributes.getFloat("max",Y.MAX_CLIP)}),U.clipV11=(yt,wt)=>{const Dt=St(yt,wt);return(0,U.clip)(yt,[wt[0]],Dt)};const St=(yt,wt)=>{if(wt.length>=3&&(!yt.session.isInitializer(wt[1].dataId)||!yt.session.isInitializer(wt[2].dataId)))throw new Error("dynamic clip attributes are not allowed");const Dt=wt.length>=3?wt[1].numberData[0]:Y.MIN_CLIP,Pt=wt.length>=3?wt[2].numberData[0]:Y.MAX_CLIP;return(0,tt.createAttributeWithCacheKey)({min:Dt,max:Pt})};U.ceil=(yt,wt)=>[yt.run(bt(yt,wt[0],b()),wt)],U.cos=(yt,wt)=>[yt.run(bt(yt,wt[0],F()),wt)],U.elu=(yt,wt,Dt)=>[yt.run(bt(yt,wt[0],j(Dt.alpha),Dt.cacheKey),wt)],U.parseEluAttributes=yt=>(0,tt.createAttributeWithCacheKey)({alpha:yt.attributes.getFloat("alpha",1)}),U.exp=(yt,wt)=>[yt.run(bt(yt,wt[0],W()),wt)],U.floor=(yt,wt)=>[yt.run(bt(yt,wt[0],J()),wt)],U.identity=(yt,wt)=>[yt.run(bt(yt,wt[0],ot()),wt)],U.leakyRelu=(yt,wt,Dt)=>[yt.run(bt(yt,wt[0],it(Dt.alpha),Dt.cacheKey),wt)],U.parseLeakyReluAttributes=yt=>(0,tt.createAttributeWithCacheKey)({alpha:yt.attributes.getFloat("alpha",.01)}),U.log=(yt,wt)=>[yt.run(bt(yt,wt[0],at()),wt)],U.neg=(yt,wt)=>[yt.run(bt(yt,wt[0],st()),wt)],U.not=(yt,wt)=>[yt.run(bt(yt,wt[0],lt()),wt)],U.relu=(yt,wt)=>[yt.run(bt(yt,wt[0],pt()),wt)],U.sigmoid=(yt,wt)=>[yt.run(bt(yt,wt[0],ut()),wt)],U.sin=(yt,wt)=>[yt.run(bt(yt,wt[0],ct()),wt)],U.sqrt=(yt,wt)=>[yt.run(bt(yt,wt[0],ft()),wt)],U.tan=(yt,wt)=>[yt.run(bt(yt,wt[0],gt()),wt)],U.tanh=(yt,wt)=>[yt.run(bt(yt,wt[0],_t()),wt)]},540:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.createUnpackProgramInfoLoader=U.createUnpackProgramInfo=void 0;const tt=rt(6757),Y=rt(5639),nt=rt(432),K=rt(5614),X={name:"unpack",inputNames:["A"],inputTypes:[Y.TextureType.packed]};U.createUnpackProgramInfo=(Q,q)=>{const G=q.dims.length,O=(0,K.getChannels)("rc",G),b=O.slice(-2),F=(0,nt.getCoordsDataType)(G),j=(0,K.unpackFromChannel)(),W=q.dims.length===0?"":function(ot,it){if(ot===1)return"rc";let at="";for(let st=0;st<ot;st++)at+=it[st],st<ot-1&&(at+=",");return at}(G,O),J=G<=1?"rc":`vec2(${b.join(",")})`,et=`
    ${j}
    void main() {
      ${F} rc = getOutputCoords();

       // Sample the texture with the coords to get the rgba channel value.
       vec4 packedInput = getA(${W});

       ${(0,tt.getGlsl)(Q.session.backend.glContext.version).output} = vec4(getChannel(packedInput, ${J}), 0, 0, 0);
     }
   `;return Object.assign(Object.assign({},X),{hasMain:!0,output:{dims:q.dims,type:q.type,textureType:Y.TextureType.unpacked},shaderSource:et})},U.createUnpackProgramInfoLoader=(Q,q)=>Object.assign(Object.assign({},X),{get:()=>(0,U.createUnpackProgramInfo)(Q,q)})},7862:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.parseUnsqueezeAttributes=U.unsqueezeV13=U.unsqueeze=void 0;const tt=rt(7273);U.unsqueeze=(K,X,Q)=>{Y(X);const q=tt.ShapeUtil.unsqueezeShape(X[0].dims,Q);return[K.reshapeUnpacked(X[0],q)]},U.unsqueezeV13=(K,X)=>(nt(X),(0,U.unsqueeze)(K,[X[0]],Array.from(X[1].integerData))),U.parseUnsqueezeAttributes=K=>K.attributes.getInts("axes");const Y=K=>{if(!K||K.length!==1)throw new Error("Unsqueeze requires 1 input.");if(K[0].type==="string")throw new Error("invalid input tensor types.")},nt=K=>{if(!K||K.length!==2)throw new Error("Unsqueeze requires 2 inputs.");if(K[1].type!=="int32")throw new Error("Invalid input type.")}},3980:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.scalesValidation=U.validateInputs=U.parseUpsampleAttributes=U.parseUpsampleAttributesV9=U.parseUpsampleAttributesV7=U.upsample=void 0;const tt=rt(4910),Y=rt(6757),nt=rt(5639),K={name:"Upsample",inputNames:["X"],inputTypes:[nt.TextureType.unpacked]};U.upsample=(Q,q,G)=>((0,U.validateInputs)(q,G),[Q.run(Object.assign(Object.assign({},K),{cacheHint:G.cacheKey,get:()=>X(Q,q,G)}),q)]),U.parseUpsampleAttributesV7=Q=>(0,U.parseUpsampleAttributes)(Q,7),U.parseUpsampleAttributesV9=Q=>(0,U.parseUpsampleAttributes)(Q,9),U.parseUpsampleAttributes=(Q,q)=>{const G=q>=10,O=Q.attributes.getString("mode","nearest");if(O!=="nearest"&&O!=="linear"&&(q<11||O!=="cubic"))throw new Error(`unrecognized mode: ${O}`);let b=[];q<9&&(b=Q.attributes.getFloats("scales"),(0,U.scalesValidation)(b,O,G));const F=Q.attributes.getFloat("extrapolation_value",0),j=q>10?Q.attributes.getString("coordinate_transformation_mode","half_pixel"):"asymmetric";if(["asymmetric","pytorch_half_pixel","tf_half_pixel_for_nn","align_corners","tf_crop_and_resize","half_pixel"].indexOf(j)===-1)throw new Error(`coordinate_transform_mode '${j}' is not supported`);const W=j==="tf_crop_and_resize",J=W,et=O==="nearest"&&q>=11?Q.attributes.getString("nearest_mode","round_prefer_floor"):"";if(["round_prefer_floor","round_prefer_ceil","floor","ceil",""].indexOf(et)===-1)throw new Error(`nearest_mode '${et}' is not supported`);const ot=Q.attributes.getFloat("cubic_coeff_a",-.75),it=Q.attributes.getInt("exclude_outside",0)!==0;if(it&&O!=="cubic")throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");const at=q<11||O==="nearest"&&j==="asymmetric"&&et==="floor";let st=0,lt=0,ct=0;return q>10?Q.inputs.length>2?(st=1,lt=2,ct=3):(lt=1,ct=2):q===9&&(lt=1),(0,tt.createAttributeWithCacheKey)({opset:q,isResize:G,mode:O,scales:b,extrapolationValue:F,coordinateTransformMode:j,useExtrapolation:J,needRoiInput:W,nearestMode:et,cubicCoefficientA:ot,excludeOutside:it,useNearest2xOptimization:at,roiInputIdx:st,scalesInputIdx:lt,sizesInputIdx:ct})};const X=(Q,q,G)=>{const O=(0,Y.getGlsl)(Q.session.backend.glContext.version),[b,F]=Q.calculateTextureWidthAndHeight(q[0].dims,nt.TextureType.unpacked),j=q[0].dims.map((ct,pt)=>Math.floor(ct*G.scales[pt])),[W,J]=Q.calculateTextureWidthAndHeight(j,nt.TextureType.unpacked),et=j.length,ot=new Array(et),it=new Array(et);let at=`
      int output_pitches[${et}];
      int input_pitches[${et}];
      `;for(let ct=et-1;ct>=0;ct--)ot[ct]=ct===et-1?1:ot[ct+1]*j[ct+1],it[ct]=ct===et-1?1:it[ct+1]*q[0].dims[ct+1],at+=`
        output_pitches[${ct}] = ${ot[ct]};
        input_pitches[${ct}] = ${it[ct]};
        `;const st=`
      float getInputFloat(int index) {
        vec2 coords = offsetToCoords(index, ${b}, ${F});
        float value = getColorAsFloat(${O.texture2D}(X, coords));
        return value;
      }
      `,lt=G.mode==="nearest"?`
    ${st}
    float process(int indices[${et}]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${W}, ${J});

      ${at}

      int d, m;
      for (int dim = 0; dim < ${et}; ++dim) {
        d = output_index / output_pitches[dim];
        m = output_index - d * output_pitches[dim];
        output_index = m;

        if (scales[dim] != 1 && d > 0) {
          int d2 = d / scales[dim];
          m = d - d2 * scales[dim];
          d = d2;
        }
        input_index += input_pitches[dim] * d;
      }

      return getInputFloat(input_index);
    }`:et===4?`
    ${st}
    float process(int indices[4]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${W}, ${J});

      ${at}

      int m;
      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m / output_pitches[1];
      m = m - index_of_dim1 * output_pitches[1];
      index_of_dim2 = m / output_pitches[2];
      m = m - index_of_dim2 * output_pitches[2];
      index_of_dim3 = m;

      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;
      index_of_input_dim2 = index_of_dim2 / scales[2];
      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];
      index_of_input_dim3 = index_of_dim3 / scales[3];
      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];

      input_index = index_of_dim0 * input_pitches[0] +
            index_of_dim1 * input_pitches[1] +
            index_of_input_dim2 * input_pitches[2] +
            index_of_input_dim3;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim2 = false;
      if (index_of_input_dim2 == (${q[0].dims[2]} - 1)) {
        // It's the end in dimension 2
        x01 = x00;
        end_of_dim2 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[2]);
      }

      if (index_of_input_dim3 == (input_pitches[2] - 1)) {
        // It's the end in dimension 3
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);
    }`:`
    ${st}
    float process(int indices[2]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${W}, ${J});

      ${at}

      int m;
      int index_of_dim0, index_of_dim1;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m;

      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;
      index_of_input_dim0 = index_of_dim0 / scales[0];
      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];
      index_of_input_dim1 = index_of_dim1 / scales[1];
      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];

      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim0 = false;
      if (index_of_input_dim0 == (${q[0].dims[0]} - 1)) {
        // It's the end in dimension 0
        x01 = x00;
        end_of_dim0 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[0]);
      }

      if (index_of_input_dim1 == (input_pitches[0] - 1)) {
        // It's the end in dimension 1
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);
    }`;return Object.assign(Object.assign({},K),{output:{dims:j,type:q[0].type,textureType:nt.TextureType.unpacked},shaderSource:lt,variables:[{name:"scales",type:"int",arrayLength:G.scales.length,data:G.scales.map(ct=>Math.ceil(ct))}]})};U.validateInputs=(Q,q)=>{if(!Q||q.opset<9&&Q.length!==1||q.opset>=9&&q.opset<11&&Q.length!==2||q.opset>=11&&Q.length<2)throw new Error("invalid inputs.");if(q.scales.length>0&&Q[0].dims.length!==q.scales.length)throw new Error("Invalid input shape.");if(Q[0].type==="string")throw new Error("Invalid input tensor types.")},U.scalesValidation=(Q,q,G)=>{if(G){for(const O of Q)if(O<=0)throw new Error("Scale value should be greater than 0.")}else for(const O of Q)if(O<1)throw new Error("Scale value should be greater than or equal to 1.");if(!(q!=="linear"&&q!=="cubic"||Q.length===2||Q.length===4&&Q[0]===1&&Q[1]===1))throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${G?"Resize":"Upsample"} opeartor.`)}},2757:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.ProgramManager=void 0;const tt=rt(8453),Y=rt(1315),nt=rt(8897),K=rt(6757);U.ProgramManager=class{constructor(X,Q,q){this.profiler=X,this.glContext=Q,this.textureLayoutStrategy=q,this.repo=new Map,this.attributesBound=!1}getArtifact(X){return this.repo.get(X)}setArtifact(X,Q){this.repo.set(X,Q)}run(X,Q,q){var G;this.profiler.event("op",`ProgramManager.run ${(G=X.programInfo.name)!==null&&G!==void 0?G:"unknown kernel"}`,()=>{var O;const b=this.glContext.gl,F=X.program;b.useProgram(F);try{this.bindOutput(q),this.attributesBound||this.bindAttributes(X.attribLocations),this.bindUniforms(X.uniformLocations,(O=X.programInfo.variables)!==null&&O!==void 0?O:[],Q)}catch(j){throw Y.Logger.error("ProgramManager",X.programInfo.shaderSource),j}this.profiler.event("backend","GlContext.draw()",()=>{this.glContext.draw()})},this.glContext)}dispose(){this.vertexShader&&this.glContext.deleteShader(this.vertexShader),this.repo.forEach(X=>this.glContext.deleteProgram(X.program))}build(X,Q,q){return this.profiler.event("backend","ProgramManager.build",()=>{const G=new nt.GlslPreprocessor(this.glContext,X,Q,q),O=G.preprocess(),b=this.compile(O);return{programInfo:X,program:b,uniformLocations:this.getUniformLocations(b,G.context.programInfo.inputNames,G.context.programInfo.variables),attribLocations:this.getAttribLocations(b)}})}compile(X){if(!this.vertexShader){Y.Logger.verbose("ProrgramManager","Compiling and caching Vertex shader for the first time");const G=(0,K.getVertexShaderSource)(this.glContext.version);this.vertexShader=this.glContext.compileShader(G,this.glContext.gl.VERTEX_SHADER)}tt.env.debug&&Y.Logger.verbose("ProrgramManager",`FragShader:
${X}
`);const Q=this.glContext.compileShader(X,this.glContext.gl.FRAGMENT_SHADER),q=this.glContext.createProgram(this.vertexShader,Q);return this.glContext.deleteShader(Q),q}bindOutput(X){const Q=X.width,q=X.height;Y.Logger.verbose("ProrgramManager",`Binding output texture to Framebuffer: w/h=${Q}/${q}, shape=${X.shape}, type=${X.tensor.type}`),this.glContext.attachFramebuffer(X.texture,Q,q)}bindAttributes(X){const Q=X.position,q=X.textureCoord;this.glContext.setVertexAttributes(Q,q),this.attributesBound=!0}bindUniforms(X,Q,q){var G;const O=this.glContext.gl;let b=0;for(const{name:F,type:j,location:W,arrayLength:J}of X){const et=(G=Q.find(ot=>ot.name===F))===null||G===void 0?void 0:G.data;if(j!=="sampler2D"&&!et)throw new Error(`variable '${F}' does not have data defined in program info`);switch(j){case"sampler2D":this.bindTexture(q[b],W,b),b++;break;case"float":J?O.uniform1fv(W,et):O.uniform1f(W,et);break;case"int":J?O.uniform1iv(W,et):O.uniform1i(W,et);break;default:throw new Error(`Uniform not implemented: ${j}`)}}}bindTexture(X,Q,q){this.glContext.bindTextureToUniform(X.texture,q,Q)}getAttribLocations(X){return{position:this.getAttribLocation(X,"position"),textureCoord:this.getAttribLocation(X,"textureCoord")}}getUniformLocations(X,Q,q){const G=[];if(Q)for(const O of Q)G.push({name:O,type:"sampler2D",location:this.getUniformLocation(X,O)});if(q)for(const O of q)G.push(Object.assign(Object.assign({},O),{location:this.getUniformLocation(X,O.name)}));return G}getUniformLocation(X,Q){const q=this.glContext.gl.getUniformLocation(X,Q);if(q===null)throw new Error(`Uniform ${Q} not found.`);return q}getAttribLocation(X,Q){return this.glContext.gl.getAttribLocation(X,Q)}}},2171:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.WebGLSessionHandler=void 0;const tt=rt(1315),Y=rt(5881),nt=rt(7860),K=rt(4110),X=rt(2757),Q=rt(7618),q=rt(5243);U.WebGLSessionHandler=class{constructor(G,O){this.backend=G,this.context=O,this.layoutStrategy=new Q.PreferLogicalStrategy(G.glContext.maxTextureSize),this.programManager=new X.ProgramManager(this.context.profiler,G.glContext,this.layoutStrategy),this.textureManager=new q.TextureManager(G.glContext,this.layoutStrategy,this.context.profiler,{reuseTextures:G.textureCacheMode==="full"}),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map,this.pack=G.pack,this.pack2unpackMap=new Map,this.unpack2packMap=new Map}createInferenceHandler(){return new nt.WebGLInferenceHandler(this)}onGraphInitialized(G){const O=G.getValues().filter(b=>b.from===-1&&b.tensor).map(b=>b.tensor.dataId);this.initializers=new Set(O)}isInitializer(G){return!!this.initializers&&this.initializers.has(G)}addInitializer(G){this.initializers.add(G)}getTextureData(G,O){return O?this.packedTextureDataCache.get(G):this.unpackedTextureDataCache.get(G)}setTextureData(G,O,b=!1){tt.Logger.verbose("WebGLSessionHandler","Storing Texture data in cache"),b?this.packedTextureDataCache.set(G,O):this.unpackedTextureDataCache.set(G,O)}dispose(){this.programManager.dispose(),this.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(G=>this.textureManager.releaseTexture(G,!0)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(G=>this.textureManager.releaseTexture(G,!0)),this.unpackedTextureDataCache=new Map}resolve(G,O,b){const F=(0,Y.resolveOperator)(G,O,K.WEBGL_OP_RESOLVE_RULES);return{impl:F.opImpl,context:F.opInit?F.opInit(G,b):G}}}},9622:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.Uint8DataEncoder=U.RGBAFloatDataEncoder=U.RedFloat32DataEncoder=void 0;const tt=rt(1315);U.RedFloat32DataEncoder=class{constructor(Y,nt=1){if(nt===1)this.internalFormat=Y.R32F,this.format=Y.RED,this.textureType=Y.FLOAT,this.channelSize=nt;else{if(nt!==4)throw new Error(`Invalid number of channels: ${nt}`);this.internalFormat=Y.RGBA32F,this.format=Y.RGBA,this.textureType=Y.FLOAT,this.channelSize=nt}}encode(Y,nt){let K,X;return Y.constructor!==Float32Array&&(tt.Logger.warning("Encoder","data was not of type Float32; creating new Float32Array"),X=new Float32Array(Y)),nt*this.channelSize>Y.length?(tt.Logger.warning("Encoder","Source data too small. Allocating larger array"),X=Y,K=this.allocate(nt*this.channelSize),X.forEach((Q,q)=>K[q]=Q)):(X=Y,K=X),K}allocate(Y){return new Float32Array(4*Y)}decode(Y,nt){return this.channelSize===1?Y.filter((K,X)=>X%4==0).subarray(0,nt):Y.subarray(0,nt)}},U.RGBAFloatDataEncoder=class{constructor(Y,nt=1,K){if(nt!==1&&nt!==4)throw new Error(`Invalid number of channels: ${nt}`);this.internalFormat=Y.RGBA,this.format=Y.RGBA,this.channelSize=nt,this.textureType=K||Y.FLOAT}encode(Y,nt){let K=Y;return this.channelSize===1&&(tt.Logger.verbose("Encoder","Exploding into a larger array"),K=this.allocate(nt),Y.forEach((X,Q)=>K[4*Q]=X)),K}allocate(Y){return new Float32Array(4*Y)}decode(Y,nt){return this.channelSize===1?Y.filter((K,X)=>X%4==0).subarray(0,nt):Y.subarray(0,nt)}},U.Uint8DataEncoder=class{constructor(Y,nt=1){if(this.channelSize=4,nt===1)this.internalFormat=Y.ALPHA,this.format=Y.ALPHA,this.textureType=Y.UNSIGNED_BYTE,this.channelSize=nt;else{if(nt!==4)throw new Error(`Invalid number of channels: ${nt}`);this.internalFormat=Y.RGBA,this.format=Y.RGBA,this.textureType=Y.UNSIGNED_BYTE,this.channelSize=nt}}encode(Y,nt){return new Uint8Array(Y.buffer,Y.byteOffset,Y.byteLength)}allocate(Y){return new Uint8Array(Y*this.channelSize)}decode(Y,nt){if(Y instanceof Uint8Array)return Y.subarray(0,nt);throw new Error(`Invalid array type: ${Y.constructor}`)}}},7618:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.getBatchDim=U.sizeToSquarishShape=U.getRowsCols=U.sizeFromShape=U.isInt=U.parseAxisParam=U.squeezeShape=U.PreferLogicalStrategy=U.AlwaysKeepOriginalSizeStrategy=void 0;const tt=rt(1315),Y=rt(7273);function nt(G,O){const b=[],F=[],j=O!=null&&Array.isArray(O)&&O.length===0,W=O==null||j?null:K(O,G).sort();let J=0;for(let et=0;et<G.length;++et){if(W!=null){if(W[J]===et&&G[et]!==1)throw new Error(`Can't squeeze axis ${et} since its dim '${G[et]}' is not 1`);(W[J]==null||W[J]>et)&&G[et]===1&&(b.push(G[et]),F.push(et)),W[J]<=et&&J++}G[et]!==1&&(b.push(G[et]),F.push(et))}return{newShape:b,keptDims:F}}function K(G,O){const b=O.length;return G=G==null?O.map((F,j)=>j):[].concat(G),(0,Y.assert)(G.every(F=>F>=-b&&F<b),()=>`All values in axis param must be in range [-${b}, ${b}) but got axis ${G}`),(0,Y.assert)(G.every(X),()=>`All values in axis param must be integers but got axis ${G}`),G.map(F=>F<0?b+F:F)}function X(G){return G%1==0}function Q(G){if(G.length===0)return 1;let O=G[0];for(let b=1;b<G.length;b++)O*=G[b];return O}function q(G){const O=Math.ceil(Math.sqrt(G));return[O,Math.ceil(G/O)]}U.AlwaysKeepOriginalSizeStrategy=class{constructor(G){this.maxTextureSize=G}computeTextureWH(G,O){if(G.length===0)return[1,1];const b=this.maxTextureSize;if(O&&O.breakAxis!==void 0){const W=O.breakAxis>=G.length?1:G.slice(O.breakAxis).reduce((et,ot)=>et*ot),J=O.breakAxis<=0?1:G.slice(0,O.breakAxis).reduce((et,ot)=>et*ot);if(!(W>b||J>b))return[W,J];tt.Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${G}, breakAxis:${O.breakAxis}`)}const F=G.reduce((W,J)=>W*J);let j=Math.floor(Math.sqrt(F));for(;j<b&&j<F&&F%j!=0;j++);if(j>=b||F%j!=0)throw new Error(`The given dimensions are outside this GPU's boundaries: ${G}`);return[j,F/j]}},U.PreferLogicalStrategy=class{constructor(G){this.maxTextureSize=G}computeTextureWH(G,O){const b=this.computeTexture(G,O);return O&&O.isPacked&&(b[0]/=2,b[1]/=2),O&&O.reverseWH?[b[1],b[0]]:b}computeTexture(G,O){const b=O&&O.isPacked;if(G.length===0)return b?[2,2]:[1,1];let F=this.maxTextureSize;if(O&&O.breakAxis!==void 0){const J=O.breakAxis>=G.length?1:G.slice(O.breakAxis).reduce((ot,it)=>ot*it),et=O.breakAxis<=0?1:G.slice(0,O.breakAxis).reduce((ot,it)=>ot*it);if(!(J>F||et>F))return[J,et];tt.Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${G}, breakAxis:${O.breakAxis}`)}let j=G.slice(0);b&&(F*=2,j=j.map((J,et)=>et>=j.length-2?j[et]%2==0?j[et]:j[et]+1:j[et]),j.length===1&&(j=[2,j[0]])),j.length!==2&&(j=nt(j).newShape);const W=Q(j);return j.length<=1&&W<=F?[1,W]:j.length===2&&j[0]<=F&&j[1]<=F?j:j.length===3&&j[0]*j[1]<=F&&j[2]<=F?[j[0]*j[1],j[2]]:j.length===3&&j[0]<=F&&j[1]*j[2]<=F?[j[0],j[1]*j[2]]:j.length===4&&j[0]*j[1]*j[2]<=F&&j[3]<=F?[j[0]*j[1]*j[2],j[3]]:j.length===4&&j[0]<=F&&j[1]*j[2]*j[3]<=F?[j[0],j[1]*j[2]*j[3]]:b?q(W/4).map(J=>2*J):q(W)}},U.squeezeShape=nt,U.parseAxisParam=K,U.isInt=X,U.sizeFromShape=Q,U.getRowsCols=function(G){if(G.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[G.length>1?G[G.length-2]:1,G[G.length-1]]},U.sizeToSquarishShape=q,U.getBatchDim=function(G,O=2){return Q(G.slice(0,G.length-O))}},3314:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.createTextureLayoutFromShape=U.calculateTextureWidthAndHeight=U.createTextureLayoutFromTextureType=void 0;const tt=rt(7273),Y=rt(5639);U.createTextureLayoutFromTextureType=(nt,K,X)=>{const Q=X===Y.TextureType.unpacked||X===Y.TextureType.unpackedReversed?1:4,q=X===Y.TextureType.packed,G=X===Y.TextureType.unpackedReversed||X===Y.TextureType.packed,O=X===Y.TextureType.packedLastDimension?K.length-1:void 0,b=X===Y.TextureType.packedLastDimension?K.map((F,j)=>j===K.length-1?4*F:F):void 0;return(0,U.createTextureLayoutFromShape)(nt,K,Q,b,{isPacked:q,reverseWH:G,breakAxis:O})},U.calculateTextureWidthAndHeight=(nt,K,X)=>{const Q=(0,U.createTextureLayoutFromTextureType)(nt,K,X);return[Q.width,Q.height]},U.createTextureLayoutFromShape=(nt,K,X=1,Q,q)=>{const G=!(!q||!q.isPacked),[O,b]=nt.computeTextureWH(G&&Q||K,q),F=K.length;let j=K.slice(0);if(F===0&&(j=[1]),X===1)Q=K;else if(G){if(X!==4)throw new Error("a packed texture must be 4-channel");Q=K,F>0&&(j[F-1]=Math.ceil(j[F-1]/2)),F>1&&(j[F-2]=Math.ceil(j[F-2]/2))}else if(!Q)throw new Error("Unpacked shape is needed when using channels > 1");return{width:O,height:b,channels:X,isPacked:G,shape:j,strides:tt.ShapeUtil.computeStrides(j),unpackedShape:Q,reversedWH:q&&q.reverseWH}}},5243:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.TextureManager=void 0;const tt=rt(1315);U.TextureManager=class{constructor(Y,nt,K,X){this.glContext=Y,this.layoutStrategy=nt,this.profiler=K,this.config=X,this.pendingRead=new Map,X.reuseTextures&&(this.inUseTextures=new Map,this.idleTextures=new Map,this.textureLookup=new Map)}createTextureFromLayout(Y,nt,K,X){const Q=this.toEncoderType(Y),q=this.glContext.getEncoder(Q,nt.channels||1,X);if(nt.isPacked&&X===1)throw new Error("not implemented");const G=nt.width,O=nt.height;let b,F;if(this.config.reuseTextures){b=`${G}x${O}_${q.format}_${q.internalFormat}_${q.textureType}`,F=this.inUseTextures.get(b),F||(F=[],this.inUseTextures.set(b,F));const W=this.idleTextures.get(b);if(W&&W.length>0){const J=W.pop();return F.push(J),X===1&&this.glContext.updateTexture(J,G,O,q,this.toTextureData(Y,K)),J}}tt.Logger.verbose("TextureManager",`Creating new texture of size ${nt.width}x${nt.height}`);const j=this.glContext.allocateTexture(G,O,q,this.toTextureData(Y,K));return this.config.reuseTextures&&(F.push(j),this.textureLookup.set(j,b)),j}readTexture(Y,nt,K){return K||(K=1),this.profiler.event("backend","TextureManager.readTexture",()=>{const X=Y.shape.reduce((q,G)=>q*G)*K,Q=this.glContext.readTexture(Y.texture,Y.width,Y.height,X,this.toEncoderType(nt),K);return this.toTensorData(nt,Q)})}async readTextureAsync(Y,nt,K){const X=Y.tensor.dataId;if(K||(K=1),this.pendingRead.has(X)){const Q=this.pendingRead.get(X);return new Promise(q=>Q==null?void 0:Q.push(q))}return this.profiler.event("backend","TextureManager.readTextureAsync",async()=>{this.pendingRead.set(X,[]);const Q=Y.shape.reduce((b,F)=>b*F)*K;await this.glContext.createAndWaitForFence();const q=this.glContext.readTexture(Y.texture,Y.width,Y.height,Q,this.toEncoderType(nt),K),G=this.toTensorData(nt,q),O=this.pendingRead.get(X);return this.pendingRead.delete(X),O==null||O.forEach(b=>b(G)),G})}readUint8TextureAsFloat(Y){return this.profiler.event("backend","TextureManager.readUint8TextureAsFloat",()=>{const nt=Y.shape.reduce((X,Q)=>X*Q),K=this.glContext.readTexture(Y.texture,Y.width,Y.height,4*nt,"byte",4);return new Float32Array(K.buffer,K.byteOffset,nt)})}releaseTexture(Y,nt){let K;if(this.config.reuseTextures&&(K=this.textureLookup.get(Y.texture),K)){nt&&this.textureLookup.delete(K);const X=this.inUseTextures.get(K);if(X){const Q=X.indexOf(Y.texture);if(Q!==-1){X.splice(Q,1);let q=this.idleTextures.get(K);q||(q=[],this.idleTextures.set(K,q)),q.push(Y.texture)}}}K&&!nt||(tt.Logger.verbose("TextureManager",`Deleting texture of size ${Y.width}x${Y.height}`),this.glContext.deleteTexture(Y.texture))}toTensorData(Y,nt){switch(Y){case"int16":return nt instanceof Int16Array?nt:Int16Array.from(nt);case"int32":return nt instanceof Int32Array?nt:Int32Array.from(nt);case"int8":return nt instanceof Int8Array?nt:Int8Array.from(nt);case"uint16":return nt instanceof Uint16Array?nt:Uint16Array.from(nt);case"uint32":return nt instanceof Uint32Array?nt:Uint32Array.from(nt);case"uint8":case"bool":return nt instanceof Uint8Array?nt:Uint8Array.from(nt);case"float32":return nt instanceof Float32Array?nt:Float32Array.from(nt);case"float64":return nt instanceof Float64Array?nt:Float64Array.from(nt);default:throw new Error(`TensorData type ${Y} is not supported`)}}toTextureData(Y,nt){if(nt)return nt instanceof Float32Array?nt:new Float32Array(nt)}toEncoderType(Y){return"float"}clearActiveTextures(){this.glContext.clearActiveTextures()}}},5639:(dt,U)=>{var rt;Object.defineProperty(U,"__esModule",{value:!0}),U.TextureType=void 0,(rt=U.TextureType||(U.TextureType={}))[rt.unpacked=0]="unpacked",rt[rt.unpackedReversed=1]="unpackedReversed",rt[rt.packed=2]="packed",rt[rt.downloadUint8AsFloat=3]="downloadUint8AsFloat",rt[rt.packedLastDimension=4]="packedLastDimension"},432:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.getGlChannels=U.getCoordsDataType=U.getSqueezedParams=U.squeezeInputShape=U.generateShaderFuncNameFromInputSamplerNameAtOutCoords=U.generateShaderFuncNameFromInputSamplerName=U.repeatedTry=U.getPackedShape=void 0;const tt=rt(7273);U.getPackedShape=function(Y){const nt=Y.length;return Y.slice(0,nt-1).concat(Y[nt-1]/4)},U.repeatedTry=async function(Y,nt=X=>0,K){return new Promise((X,Q)=>{let q=0;const G=()=>{if(Y())return void X();q++;const O=nt(q);K!=null&&q>=K?Q():setTimeout(G,O)};G()})},U.generateShaderFuncNameFromInputSamplerName=function(Y){return(0,tt.assert)(Y!==void 0&&Y.length!==0,()=>"empty string found for sampler name"),"get"+Y.charAt(0).toUpperCase()+Y.slice(1)},U.generateShaderFuncNameFromInputSamplerNameAtOutCoords=function(Y){return(0,tt.assert)(Y!==void 0&&Y.length!==0,()=>"empty string found for sampler name"),"get"+Y.charAt(0).toUpperCase()+Y.slice(1)+"AtOutCoords"},U.squeezeInputShape=function(Y,nt){let K=JSON.parse(JSON.stringify(Y));return K=nt,K},U.getSqueezedParams=function(Y,nt){return nt.map(K=>Y[K]).join(", ")},U.getCoordsDataType=function(Y){if(Y<=1)return"int";if(Y===2)return"ivec2";if(Y===3)return"ivec3";if(Y===4)return"ivec4";if(Y===5)return"ivec5";if(Y===6)return"ivec6";throw Error(`GPU for rank ${Y} is not yet supported`)},U.getGlChannels=function(Y=6){return["x","y","z","w","u","v"].slice(0,Y)}},3389:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.createNewWebGLContext=U.createWebGLContext=void 0;const tt=rt(1315),Y=rt(3524),nt={};function K(X){const Q=function(){if(typeof document>"u"){if(typeof OffscreenCanvas>"u")throw new TypeError("failed to create canvas: OffscreenCanvas is not supported");return new OffscreenCanvas(1,1)}const O=document.createElement("canvas");return O.width=1,O.height=1,O}();let q;const G={alpha:!1,depth:!1,antialias:!1,stencil:!1,preserveDrawingBuffer:!1,premultipliedAlpha:!1,failIfMajorPerformanceCaveat:!1};if((!X||X==="webgl2")&&(q=Q.getContext("webgl2",G),q))try{return new Y.WebGLContext(q,2)}catch(O){tt.Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl2'. Error: ${O}`)}if((!X||X==="webgl")&&(q=Q.getContext("webgl",G)||Q.getContext("experimental-webgl",G),q))try{return new Y.WebGLContext(q,1)}catch(O){tt.Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${O}`)}throw new Error("WebGL is not supported")}U.createWebGLContext=function X(Q){let q;Q&&Q!=="webgl2"||!("webgl2"in nt)?Q&&Q!=="webgl"||!("webgl"in nt)||(q=nt.webgl):q=nt.webgl2,q=q||K(Q),Q=Q||q.version===1?"webgl":"webgl2";const G=q.gl;return nt[Q]=q,G.isContextLost()?(delete nt[Q],X(Q)):(G.disable(G.DEPTH_TEST),G.disable(G.STENCIL_TEST),G.disable(G.BLEND),G.disable(G.DITHER),G.disable(G.POLYGON_OFFSET_FILL),G.disable(G.SAMPLE_COVERAGE),G.enable(G.SCISSOR_TEST),G.enable(G.CULL_FACE),G.cullFace(G.BACK),q)},U.createNewWebGLContext=K},3524:function(dt,U,rt){var tt=this&&this.__createBinding||(Object.create?function(G,O,b,F){F===void 0&&(F=b);var j=Object.getOwnPropertyDescriptor(O,b);j&&!("get"in j?!O.__esModule:j.writable||j.configurable)||(j={enumerable:!0,get:function(){return O[b]}}),Object.defineProperty(G,F,j)}:function(G,O,b,F){F===void 0&&(F=b),G[F]=O[b]}),Y=this&&this.__setModuleDefault||(Object.create?function(G,O){Object.defineProperty(G,"default",{enumerable:!0,value:O})}:function(G,O){G.default=O}),nt=this&&this.__importStar||function(G){if(G&&G.__esModule)return G;var O={};if(G!=null)for(var b in G)b!=="default"&&Object.prototype.hasOwnProperty.call(G,b)&&tt(O,G,b);return Y(O,G),O};Object.defineProperty(U,"__esModule",{value:!0}),U.WebGLContext=U.linearSearchLastTrue=void 0;const K=rt(8453),X=nt(rt(9622)),Q=rt(432);function q(G){let O=0;for(;O<G.length&&G[O]();++O);return O-1}U.linearSearchLastTrue=q,U.WebGLContext=class{constructor(G,O){this.frameBufferBound=!1,this.itemsToPoll=[],this.gl=G,this.version=O,this.getExtensions(),this.vertexbuffer=this.createVertexbuffer(),this.framebuffer=this.createFramebuffer(),this.queryVitalParameters()}allocateTexture(G,O,b,F){const j=this.gl,W=j.createTexture();j.bindTexture(j.TEXTURE_2D,W),j.texParameteri(j.TEXTURE_2D,j.TEXTURE_MIN_FILTER,j.NEAREST),j.texParameteri(j.TEXTURE_2D,j.TEXTURE_MAG_FILTER,j.NEAREST),j.texParameteri(j.TEXTURE_2D,j.TEXTURE_WRAP_S,j.CLAMP_TO_EDGE),j.texParameteri(j.TEXTURE_2D,j.TEXTURE_WRAP_T,j.CLAMP_TO_EDGE);const J=F?b.encode(F,G*O):null;return j.texImage2D(j.TEXTURE_2D,0,b.internalFormat,G,O,0,b.format,b.textureType,J),this.checkError(),W}updateTexture(G,O,b,F,j){const W=this.gl;W.bindTexture(W.TEXTURE_2D,G);const J=F.encode(j,O*b);W.texSubImage2D(W.TEXTURE_2D,0,0,0,O,b,F.format,F.textureType,J),this.checkError()}attachFramebuffer(G,O,b){const F=this.gl;F.bindTexture(F.TEXTURE_2D,G),F.bindFramebuffer(F.FRAMEBUFFER,this.framebuffer),F.framebufferTexture2D(F.FRAMEBUFFER,F.COLOR_ATTACHMENT0,F.TEXTURE_2D,G,0),this.checkError(),F.viewport(0,0,O,b),F.scissor(0,0,O,b)}readTexture(G,O,b,F,j,W){const J=this.gl;W||(W=1),this.frameBufferBound||this.attachFramebuffer(G,O,b);const et=this.getEncoder(j,W),ot=et.allocate(O*b);return J.bindTexture(J.TEXTURE_2D,G),J.framebufferTexture2D(J.FRAMEBUFFER,J.COLOR_ATTACHMENT0,J.TEXTURE_2D,G,0),J.readPixels(0,0,O,b,J.RGBA,et.textureType,ot),this.checkError(),et.decode(ot,F)}isFramebufferReady(){return!0}getActiveTexture(){const G=this.gl;return"TEXTURE"+(G.getParameter(this.gl.ACTIVE_TEXTURE)-G.TEXTURE0)}getTextureBinding(){return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D)}getFramebufferBinding(){return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING)}setVertexAttributes(G,O){const b=this.gl;b.vertexAttribPointer(G,3,b.FLOAT,!1,20,0),b.enableVertexAttribArray(G),O!==-1&&(b.vertexAttribPointer(O,2,b.FLOAT,!1,20,12),b.enableVertexAttribArray(O)),this.checkError()}createProgram(G,O){const b=this.gl,F=b.createProgram();return b.attachShader(F,G),b.attachShader(F,O),b.linkProgram(F),F}compileShader(G,O){const b=this.gl,F=b.createShader(O);if(!F)throw new Error(`createShader() returned null with type ${O}`);if(b.shaderSource(F,G),b.compileShader(F),b.getShaderParameter(F,b.COMPILE_STATUS)===!1)throw new Error(`Failed to compile shader: ${b.getShaderInfoLog(F)}
Shader source:
${G}`);return F}deleteShader(G){this.gl.deleteShader(G)}bindTextureToUniform(G,O,b){const F=this.gl;F.activeTexture(F.TEXTURE0+O),this.checkError(),F.bindTexture(F.TEXTURE_2D,G),this.checkError(),F.uniform1i(b,O),this.checkError()}draw(){this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.checkError()}checkError(){if(K.env.debug){const G=this.gl,O=G.getError();let b="";switch(O){case G.NO_ERROR:return;case G.INVALID_ENUM:b="INVALID_ENUM";break;case G.INVALID_VALUE:b="INVALID_VALUE";break;case G.INVALID_OPERATION:b="INVALID_OPERATION";break;case G.INVALID_FRAMEBUFFER_OPERATION:b="INVALID_FRAMEBUFFER_OPERATION";break;case G.OUT_OF_MEMORY:b="OUT_OF_MEMORY";break;case G.CONTEXT_LOST_WEBGL:b="CONTEXT_LOST_WEBGL";break;default:b=`Unknown WebGL Error: ${O.toString(16)}`}throw new Error(b)}}deleteTexture(G){this.gl.deleteTexture(G)}deleteProgram(G){this.gl.deleteProgram(G)}getEncoder(G,O,b=0){if(this.version===2)return new X.RedFloat32DataEncoder(this.gl,O);switch(G){case"float":return b===1||this.isRenderFloat32Supported?new X.RGBAFloatDataEncoder(this.gl,O):new X.RGBAFloatDataEncoder(this.gl,O,this.textureHalfFloatExtension.HALF_FLOAT_OES);case"int":throw new Error("not implemented");case"byte":return new X.Uint8DataEncoder(this.gl,O);default:throw new Error(`Invalid dataType: ${G}`)}}clearActiveTextures(){const G=this.gl;for(let O=0;O<this.maxTextureImageUnits;++O)G.activeTexture(G.TEXTURE0+O),G.bindTexture(G.TEXTURE_2D,null)}dispose(){if(this.disposed)return;const G=this.gl;G.bindFramebuffer(G.FRAMEBUFFER,null),G.deleteFramebuffer(this.framebuffer),G.bindBuffer(G.ARRAY_BUFFER,null),G.deleteBuffer(this.vertexbuffer),G.bindBuffer(G.ELEMENT_ARRAY_BUFFER,null),G.finish(),this.disposed=!0}createDefaultGeometry(){return new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0])}createVertexbuffer(){const G=this.gl,O=G.createBuffer();if(!O)throw new Error("createBuffer() returned null");const b=this.createDefaultGeometry();return G.bindBuffer(G.ARRAY_BUFFER,O),G.bufferData(G.ARRAY_BUFFER,b,G.STATIC_DRAW),this.checkError(),O}createFramebuffer(){const G=this.gl.createFramebuffer();if(!G)throw new Error("createFramebuffer returned null");return G}queryVitalParameters(){const G=this.gl;if(this.isFloatTextureAttachableToFrameBuffer=this.checkFloatTextureAttachableToFrameBuffer(),this.isRenderFloat32Supported=this.checkRenderFloat32(),this.isFloat32DownloadSupported=this.checkFloat32Download(),this.version===1&&!this.textureHalfFloatExtension&&!this.isRenderFloat32Supported)throw new Error("both float32 and float16 TextureType are not supported");this.isBlendSupported=!this.isRenderFloat32Supported||this.checkFloat32Blend(),this.maxTextureSize=G.getParameter(G.MAX_TEXTURE_SIZE),this.maxTextureImageUnits=G.getParameter(G.MAX_TEXTURE_IMAGE_UNITS),this.version}getExtensions(){this.version===2?(this.colorBufferFloatExtension=this.gl.getExtension("EXT_color_buffer_float"),this.disjointTimerQueryWebgl2Extension=this.gl.getExtension("EXT_disjoint_timer_query_webgl2")):(this.textureFloatExtension=this.gl.getExtension("OES_texture_float"),this.textureHalfFloatExtension=this.gl.getExtension("OES_texture_half_float"))}checkFloatTextureAttachableToFrameBuffer(){const G=this.gl,O=G.createTexture();G.bindTexture(G.TEXTURE_2D,O);const b=this.version===2?G.RGBA32F:G.RGBA;G.texImage2D(G.TEXTURE_2D,0,b,1,1,0,G.RGBA,G.FLOAT,null);const F=G.createFramebuffer();G.bindFramebuffer(G.FRAMEBUFFER,F),G.framebufferTexture2D(G.FRAMEBUFFER,G.COLOR_ATTACHMENT0,G.TEXTURE_2D,O,0);const j=G.checkFramebufferStatus(G.FRAMEBUFFER)===G.FRAMEBUFFER_COMPLETE;return G.bindTexture(G.TEXTURE_2D,null),G.bindFramebuffer(G.FRAMEBUFFER,null),G.deleteTexture(O),G.deleteFramebuffer(F),j}checkRenderFloat32(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension)return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Download(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension||!this.gl.getExtension("WEBGL_color_buffer_float"))return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Blend(){const G=this.gl;let O,b,F,j,W;try{O=G.createTexture(),b=G.createFramebuffer(),G.bindTexture(G.TEXTURE_2D,O);const J=this.version===2?G.RGBA32F:G.RGBA;return G.texImage2D(G.TEXTURE_2D,0,J,1,1,0,G.RGBA,G.FLOAT,null),G.bindFramebuffer(G.FRAMEBUFFER,b),G.framebufferTexture2D(G.FRAMEBUFFER,G.COLOR_ATTACHMENT0,G.TEXTURE_2D,O,0),G.enable(G.BLEND),F=G.createShader(G.VERTEX_SHADER),!!F&&(G.shaderSource(F,"void main(){}"),G.compileShader(F),j=G.createShader(G.FRAGMENT_SHADER),!!j&&(G.shaderSource(j,"precision highp float;void main(){gl_FragColor=vec4(0.5);}"),G.compileShader(j),W=G.createProgram(),!!W&&(G.attachShader(W,F),G.attachShader(W,j),G.linkProgram(W),G.useProgram(W),G.drawArrays(G.POINTS,0,1),G.getError()===G.NO_ERROR)))}finally{G.disable(G.BLEND),W&&G.deleteProgram(W),F&&G.deleteShader(F),j&&G.deleteShader(j),b&&(G.bindFramebuffer(G.FRAMEBUFFER,null),G.deleteFramebuffer(b)),O&&(G.bindTexture(G.TEXTURE_2D,null),G.deleteTexture(O))}}beginTimer(){if(this.version===2&&this.disjointTimerQueryWebgl2Extension){const G=this.gl,O=this.disjointTimerQueryWebgl2Extension,b=G.createQuery();return G.beginQuery(O.TIME_ELAPSED_EXT,b),b}throw new Error("WebGL1 profiling currently not supported.")}endTimer(){if(this.version!==2||!this.disjointTimerQueryWebgl2Extension)throw new Error("WebGL1 profiling currently not supported");{const G=this.gl,O=this.disjointTimerQueryWebgl2Extension;G.endQuery(O.TIME_ELAPSED_EXT)}}isTimerResultAvailable(G){let O=!1,b=!1;if(this.version!==2||!this.disjointTimerQueryWebgl2Extension)throw new Error("WebGL1 profiling currently not supported");{const F=this.gl,j=this.disjointTimerQueryWebgl2Extension;O=F.getQueryParameter(G,F.QUERY_RESULT_AVAILABLE),b=F.getParameter(j.GPU_DISJOINT_EXT)}return O&&!b}getTimerResult(G){let O=0;if(this.version!==2)throw new Error("WebGL1 profiling currently not supported");{const b=this.gl;O=b.getQueryParameter(G,b.QUERY_RESULT),b.deleteQuery(G)}return O/1e6}async waitForQueryAndGetTime(G){return await(0,Q.repeatedTry)(()=>this.isTimerResultAvailable(G)),this.getTimerResult(G)}async createAndWaitForFence(){const G=this.createFence(this.gl);return this.pollFence(G)}createFence(G){let O;const b=G,F=b.fenceSync(b.SYNC_GPU_COMMANDS_COMPLETE,0);return G.flush(),O=F===null?()=>!0:()=>{const j=b.clientWaitSync(F,0,0);return j===b.ALREADY_SIGNALED||j===b.CONDITION_SATISFIED},{query:F,isFencePassed:O}}async pollFence(G){return new Promise(O=>{this.addItemToPoll(()=>G.isFencePassed(),()=>O())})}pollItems(){const G=q(this.itemsToPoll.map(O=>O.isDoneFn));for(let O=0;O<=G;++O){const{resolveFn:b}=this.itemsToPoll[O];b()}this.itemsToPoll=this.itemsToPoll.slice(G+1)}async addItemToPoll(G,O){this.itemsToPoll.push({isDoneFn:G,resolveFn:O}),this.itemsToPoll.length>1||await(0,Q.repeatedTry)(()=>(this.pollItems(),this.itemsToPoll.length===0))}}},6496:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.ExecutionPlan=void 0;const tt=rt(1315);class Y{constructor(K,X){this.op=K,this.node=X}}U.ExecutionPlan=class{constructor(nt,K,X){this.graph=nt,this.profiler=X,this.initialize(K)}initialize(nt){this.profiler.event("session","ExecutionPlan.initialize",()=>{const K=this.graph.getNodes();if(K.length!==nt.length)throw new Error("The size of nodes and OPs do not match.");this._ops=nt.map((X,Q)=>new Y(X,K[Q])),this.reset(),this._starter=[],this._ops.forEach((X,Q)=>{let q=!0;for(const G of X.node.inputs)if(!this._values[G]&&this.graph.getInputIndices().indexOf(G)===-1){q=!1;break}q&&this._starter.push(Q)})})}reset(){this._values=this.graph.getValues().map(nt=>nt.tensor)}async execute(nt,K){return this.profiler.event("session","ExecutionPlan.execute",async()=>{this.reset();const X=nt.createInferenceHandler(),Q=this.graph.getInputIndices();if(K.length!==Q.length)throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${K.length} expected: ${Q.length}`);K.forEach((j,W)=>{const J=Q[W];this._values[J]=j});const q=this._starter.slice(0),G=this.graph.getValues(),O=this.graph.getNodes();let b=0;for(;b<q.length;){const j=q[b++],W=this._ops[j],J=W.node.inputs.map(at=>this._values[at]);if(J.indexOf(void 0)!==-1)throw new Error(`unresolved input detected: op: ${W.node}`);const et=J;tt.Logger.verbose("ExecPlan",`Runing op:${W.node.name} (${et.map((at,st)=>`'${W.node.inputs[st]}': ${at.type}[${at.dims.join(",")}]`).join(", ")})`);const ot=await this.profiler.event("node",W.node.name,async()=>W.op.impl(X,et,W.op.context));if(ot.length!==W.node.outputs.length)throw new Error("the size of output does not match model definition.");ot.forEach((at,st)=>{const lt=W.node.outputs[st];if(this._values[lt])throw new Error(`output [${lt}] already has value: op:${W.node.name}`);this._values[lt]=at});const it=new Set;ot.forEach((at,st)=>{const lt=W.node.outputs[st];for(const ct of G[lt].to){const pt=O[ct];let ut=!0;for(const ft of pt.inputs)if(!this._values[ft]){ut=!1;break}ut&&it.add(ct)}}),q.push(...it)}const F=[];for(let j=0;j<this.graph.getOutputIndices().length;j++){const W=this.graph.getOutputIndices()[j],J=this._values[W];if(J===void 0)throw new Error(`required output [${W}] does not have value`);W===0?await J.getData():J.data,F.push(J)}return tt.Logger.verbose("ExecPlan","disposing of inferenceHandler"),X.dispose(),F})}}},4662:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.Graph=void 0;const tt=rt(1446),Y=rt(6874),nt=rt(1287),K=rt(9240),X=rt(7273);var Q=nt.onnxruntime.experimental.fbs;U.Graph={from:(b,F)=>new O(b,F)};class q{constructor(F){this._from=void 0,this._to=[],this.tensor=void 0,this.type=void 0,F&&(this.type=X.ProtoUtil.tensorValueTypeFromProto(F.type.tensorType))}get from(){return this._from}get to(){return this._to}}class G{constructor(F,j){F instanceof tt.onnx.NodeProto?(this.name=F.name,this.opType=F.opType,this.attributes=new Y.Attribute(F.attribute)):F instanceof Q.Node&&(this.name=j??F.name(),this.opType=F.opType(),this.attributes=new Y.Attribute(X.ProtoUtil.tensorAttributesFromORTFormat(F))),this.inputs=[],this.outputs=[],this.executeNode=!0}}class O{constructor(F,j){if(!F)throw new TypeError("graph is empty");this.buildGraph(F),this.transformGraph(j),this.checkIsAcyclic()}getInputIndices(){return this._allInputIndices}getInputNames(){return this._allInputNames}getOutputIndices(){return this._allOutputIndices}getOutputNames(){return this._allOutputNames}getValues(){return this._allData}getNodes(){return this._nodes}buildGraph(F){if(F instanceof tt.onnx.GraphProto)this.buildGraphFromOnnxFormat(F);else{if(!(F instanceof Q.Graph))throw new TypeError("Graph type is not supported.");this.buildGraphFromOrtFormat(F)}}buildGraphFromOnnxFormat(F){const j=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];const W=new Map;if(!F.input)throw new Error("missing information in graph: input");const J=[];for(const et of F.input){if(j.has(et.name))throw new Error(`duplicated input name: ${et.name}`);const ot=this._allData.push(new q(et))-1;j.set(et.name,ot),J.push(et.name)}if(!F.initializer)throw new Error("missing information in graph: initializer");for(const et of F.initializer){let ot=j.get(et.name);if(ot===void 0){const it=new q;it.type={shape:{dims:X.ProtoUtil.tensorDimsFromProto(et.dims)},tensorType:X.ProtoUtil.tensorDataTypeFromProto(et.dataType)},ot=this._allData.push(it)-1,j.set(et.name,ot)}this._allData[ot]._from=-1,this._allData[ot].tensor=K.Tensor.fromProto(et)}for(let et=0;et<this._allData.length;et++)this._allData[et].tensor||(this._allInputIndices.push(et),this._allInputNames.push(J[et]));if(!F.output)throw new Error("missing information in graph: output");for(const et of F.output){if(j.has(et.name))throw new Error(`duplicated output name: ${et.name}`);const ot=this._allData.push(new q(et))-1;j.set(et.name,ot),this._allOutputIndices.push(ot),this._allOutputNames.push(et.name)}if(!F.node)throw new Error("missing information in graph: node");for(const et of F.node){if(!et.name)for(let it=0;;it++){const at=`unnamed_${et.opType}_${it}`;if(!W.has(at)){et.name=at;break}}if(W.has(et.name))throw new Error(`duplicated node name: ${et.name}`);const ot=this._nodes.push(new G(et))-1;W.set(et.name,ot)}for(let et=0;et<this._nodes.length;et++){const ot=this._nodes[et],it=F.node[et];if(!it.output)throw new Error(`missing output for node: ${it.name}`);for(const at of it.output){let st=j.get(at);if(st===void 0&&(st=this._allData.push(new q)-1,j.set(at,st)),ot.outputs.push(st),this._allData[st]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${st}`);if(this._allData[st]._from=et,it.opType==="Constant"){if(!it.attribute||it.attribute.length!==1||!it.attribute[0].t)throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(!it.output||it.output.length!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");ot.outputs.pop(),ot.executeNode=!1,this._allData[st]._from=-1,this._allData[st].tensor=K.Tensor.fromProto(it.attribute[0].t)}}}for(let et=0;et<this._nodes.length;et++){const ot=this._nodes[et],it=F.node[et];if(!it.input)throw new Error(`missing input for node: ${it.name}`);for(const at of it.input){const st=j.get(at);if(st===void 0){if(at===""&&it.input.length===3&&it.opType==="Resize")continue;throw new Error(`unrecognized input '${at}' for node: ${it.name}`)}ot.inputs.push(st),this._allData[st]._to.push(et)}}return!0}buildGraphFromOrtFormat(F){var j,W,J;const et=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];const ot=new Map,it=[];for(let at=0;at<F.inputsLength();at++){const st=F.inputs(at);if(et.has(st))throw new Error(`duplicated input name: ${st}`);for(let lt=0;lt<F.nodeArgsLength();lt++)if(((j=F.nodeArgs(lt))===null||j===void 0?void 0:j.name())===st){const ct=new q;if(((J=(W=F.nodeArgs(lt))===null||W===void 0?void 0:W.type())===null||J===void 0?void 0:J.valueType())!==Q.TypeInfoValue.tensor_type)throw new Error("Unexpected value type for the nodeArg.");const pt=F.nodeArgs(lt).type().value(new Q.TensorTypeAndShape),ut=X.ProtoUtil.tensorDataTypeFromProto(pt.elemType()),ft=pt.shape(),gt=[];for(let vt=0;vt<ft.dimLength();vt++)gt.push(X.LongUtil.longToNumber(ft.dim(vt).value().dimValue()));ct.type={shape:{dims:gt},tensorType:ut};const _t=this._allData.push(ct)-1;et.set(st,_t),it.push(st)}}for(let at=0;at<F.initializersLength();at++){const st=F.initializers(at);let lt=et.get(st.name());if(lt===void 0){const ct=new q,pt=X.ProtoUtil.tensorDimsFromORTFormat(st),ut=X.ProtoUtil.tensorDataTypeFromProto(st.dataType());ct.type={shape:{dims:pt},tensorType:ut},lt=this._allData.push(ct)-1,et.set(st.name(),lt)}this._allData[lt]._from=-1,this._allData[lt].tensor=K.Tensor.fromOrtTensor(st)}for(let at=0;at<this._allData.length;at++)this._allData[at].tensor||(this._allInputIndices.push(at),this._allInputNames.push(it[at]));for(let at=0;at<F.outputsLength();at++){const st=F.outputs(at);if(et.has(st))throw new Error(`duplicated output name: ${st}`);const lt=this._allData.push(new q)-1;et.set(st,lt),this._allOutputIndices.push(lt),this._allOutputNames.push(st)}if(!F.nodes)throw new Error("missing information in graph: node");for(let at=0;at<F.nodesLength();at++){const st=F.nodes(at);let lt=st.name();if(!lt)for(let pt=0;lt=`unnamed_${st.opType()}_${pt}`,ot.has(lt);pt++);if(ot.has(lt))throw new Error(`duplicated node name: ${lt}`);const ct=this._nodes.push(new G(st,lt))-1;ot.set(lt,ct)}for(let at=0;at<this._nodes.length;at++){const st=this._nodes[at],lt=F.nodes(at);if(lt==null)throw new Error(`No node exists at index ${at}`);if((lt==null?void 0:lt.outputsLength())===0)throw new Error(`missing output for node: ${lt.name}`);for(let ct=0;ct<(lt==null?void 0:lt.outputsLength());ct++){const pt=lt==null?void 0:lt.outputs(ct);let ut=et.get(pt);if(ut===void 0&&(ut=this._allData.push(new q)-1,et.set(pt,ut)),st.outputs.push(ut),this._allData[ut]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${ut}`);if(this._allData[ut]._from=at,lt.opType()==="Constant"){if(lt.attributesLength()!==1||!lt.attributes(0).t())throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(lt.outputsLength()!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");st.outputs.pop(),st.executeNode=!1,this._allData[ut]._from=-1,this._allData[ut].tensor=K.Tensor.fromOrtTensor(lt.attributes(0).t())}}}for(let at=0;at<this._nodes.length;at++){const st=this._nodes[at],lt=F.nodes(at);if(lt.inputsLength()===0)throw new Error(`missing input for node: ${lt.name}`);for(let ct=0;ct<lt.inputsLength();ct++){const pt=lt.inputs(ct),ut=et.get(pt);if(ut===void 0)throw new Error(`unrecognized input '${pt}' for node: ${lt.name()}`);st.inputs.push(ut),this._allData[ut]._to.push(at)}}}checkIsAcyclic(){const F=new Set;this._allInputIndices.forEach(J=>{this._allData[J]._to.forEach(et=>{F.add(et)})});const j=Array.from(F),W=new Array(this._nodes.length).fill("white");for(;j.length>0;){const J=j.pop();W[J]==="gray"?W[J]="black":(j.push(J),W[J]="gray",this._nodes[J].outputs.forEach(et=>{const ot=this._allData[et];if(ot.tensor!==void 0)throw new Error("node outputs should not be initialized");if(ot._from!==J)throw new Error("from property of the Value object doesn't match index of Node being processed");ot._to.forEach(it=>{if(W[it]==="gray")throw new Error("model graph is cyclic");W[it]==="white"&&j.push(it)})}))}}transformGraph(F){this.removeAllIdentityNodes(),this.removeAllDropoutNodes(),this.fuseConvActivationNodes(),F&&F.transformGraph(this),this.finalizeGraph()}finalizeGraph(){let F=0;const j=new Array(this._nodes.length,0);let W=0;for(let J=0;J<this._nodes.length;J++)j[J]=W,this._nodes[J].executeNode?(W!==J&&(this._nodes[W]=this._nodes[J]),W++):this._nodes[J].outputs.forEach(et=>{this._allData[et]._from=-2});this._nodes.splice(W,this._nodes.length-W);for(let J=0;J<this._allData.length;J++){const et=this._allData[J];et._from!==void 0&&et._from!==-1&&et._from!==-2&&(et._from=j[et._from]);for(let ot=0;ot<et._to.length;ot++){if(!(et._to[ot]>=0))throw new Error("Trying to update a removed node");et._to[ot]=j[et._to[ot]]}}F=0;for(let J=0;J<this._allData.length;J++)if(this._allData[J].from!==-2||this._allOutputIndices.indexOf(J+F)!==-1){if(F>0){let et=-1;this._allData[J].from!==void 0&&this._allData[J].from!==-1?(et=this._nodes[this._allData[J].from].outputs.indexOf(J+F),et!==-1&&(this._nodes[this._allData[J].from].outputs[et]=J)):(et=this._allInputIndices.indexOf(J+F),et!==-1&&(this._allInputIndices[et]=J)),this._allData[J].to.forEach(ot=>{et=this._nodes[ot].inputs.indexOf(J+F),et!==-1&&(this._nodes[ot].inputs[et]=J)}),this._allData[J].to.length===0&&(et=this._allOutputIndices.indexOf(J+F),et!==-1&&(this._allOutputIndices[et]=J))}}else F++,this._allData.splice(J,1),J--}deleteNode(F){const j=this._nodes[F];if(j.outputs.length>1){for(let it=1;it<j.outputs.length;it++)if(this._allData[j.outputs[it]].to.length>0)throw new Error("Node deletion with more than one output connected to other nodes is not supported. ")}j.executeNode=!1;const W=j.inputs[0],J=j.outputs[0],et=this._allData[J].to;for(let it=0;it<j.inputs.length;it++){const at=this._allData[j.inputs[it]].to.indexOf(F);if(at===-1)throw new Error("The Value object doesn't have the current Node in it's 'to' property ");this._allData[j.inputs[it]].to.splice(at,1)}this._allData[J]._to=[];const ot=this._allOutputIndices.indexOf(J);if(ot!==-1&&(this._allOutputIndices[ot]=W),et&&et.length>0)for(const it of et){const at=this._nodes[it].inputs.indexOf(J);if(at===-1)throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");this._nodes[it].inputs[at]=W,this._allData[W].to.push(it)}}removeAllDropoutNodes(){let F=0;for(const j of this._nodes){if(j.opType==="Dropout"){if(j.inputs.length!==1)throw new Error("Dropout nodes should only contain one input. ");if(j.outputs.length!==1&&j.outputs.length!==2)throw new Error("Dropout nodes should contain either 1 or 2 output(s)");if(j.outputs.length===2&&this._allData[j.outputs[1]]._to.length!==0)throw new Error("Dropout nodes's second output should not be referenced by other nodes");this.deleteNode(F)}F++}}removeAllIdentityNodes(){let F=0;for(const j of this._nodes)j.opType==="Identity"&&this.deleteNode(F),F++}isActivation(F){switch(F.opType){case"Relu":case"Sigmoid":case"Clip":return!0;default:return!1}}fuseConvActivationNodes(){for(const F of this._nodes)if(F.opType==="Conv"){const j=this._allData[F.outputs[0]]._to;if(j.length===1&&this.isActivation(this._nodes[j[0]])){const W=this._nodes[j[0]];if(W.opType==="Clip")if(W.inputs.length===1)try{F.attributes.set("activation_params","floats",[W.attributes.getFloat("min"),W.attributes.getFloat("max")])}catch{F.attributes.set("activation_params","floats",[X.MIN_CLIP,X.MAX_CLIP])}else{if(!(W.inputs.length>=3&&this._allData[W.inputs[1]].tensor!==void 0&&this._allData[W.inputs[2]].tensor!==void 0))continue;F.attributes.set("activation_params","floats",[this._allData[W.inputs[1]].tensor.floatData[0],this._allData[W.inputs[2]].tensor.floatData[0]])}F.attributes.set("activation","string",W.opType),this.deleteNode(j[0])}}}}},1315:(dt,U)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.now=U.Profiler=U.Logger=void 0;const rt={verbose:1e3,info:2e3,warning:4e3,error:5e3,fatal:6e3},tt={none:new class{log(G,O,b){}},console:new class{log(G,O,b){console.log(`${this.color(G)} ${b?"\x1B[35m"+b+"\x1B[0m ":""}${O}`)}color(G){switch(G){case"verbose":return"\x1B[34;40mv\x1B[0m";case"info":return"\x1B[32mi\x1B[0m";case"warning":return"\x1B[30;43mw\x1B[0m";case"error":return"\x1B[31;40me\x1B[0m";case"fatal":return"\x1B[101mf\x1B[0m";default:throw new Error(`unsupported severity: ${G}`)}}}},Y={provider:"console",minimalSeverity:"warning",logDateTime:!0,logSourceLocation:!1};let nt={"":Y};function K(G,O,b,F){if(O===void 0)return j=G,{verbose:K.verbose.bind(null,j),info:K.info.bind(null,j),warning:K.warning.bind(null,j),error:K.error.bind(null,j),fatal:K.fatal.bind(null,j)};if(b===void 0)X(G,O);else if(typeof b=="number"&&F===void 0)X(G,O);else if(typeof b=="string"&&F===void 0)X(G,b,0,O);else{if(typeof b!="string"||typeof F!="number")throw new TypeError("input is valid");X(G,b,0,O)}var j}function X(G,O,b,F){const j=nt[F||""]||nt[""];rt[G]<rt[j.minimalSeverity]||(j.logDateTime&&(O=`${new Date().toISOString()}|${O}`),j.logSourceLocation,tt[j.provider].log(G,O,F))}(function(G){function O(F){nt={},b("",F||{})}function b(F,j){if(F==="*")O(j);else{const W=nt[F]||Y;nt[F]={provider:j.provider||W.provider,minimalSeverity:j.minimalSeverity||W.minimalSeverity,logDateTime:j.logDateTime===void 0?W.logDateTime:j.logDateTime,logSourceLocation:j.logSourceLocation===void 0?W.logSourceLocation:j.logSourceLocation}}}G.verbose=function(F,j){G("verbose",F,j)},G.info=function(F,j){G("info",F,j)},G.warning=function(F,j){G("warning",F,j)},G.error=function(F,j){G("error",F,j)},G.fatal=function(F,j){G("fatal",F,j)},G.reset=O,G.set=b,G.setWithEnv=function(F){const j={};F.logLevel&&(j.minimalSeverity=F.logLevel),b("",j)}})(K||(K={})),U.Logger=K;class Q{constructor(O,b,F,j,W,J){this.category=O,this.name=b,this.startTime=F,this.endCallback=j,this.timer=W,this.ctx=J}async end(){return this.endCallback(this)}async checkTimer(){if(this.ctx===void 0||this.timer===void 0)throw new Error("No webgl timer found");return this.ctx.endTimer(),this.ctx.waitForQueryAndGetTime(this.timer)}}class q{constructor(O,b,F,j){this.category=O,this.name=b,this.startTime=F,this.endTime=j}}U.Profiler=class{static create(G){return G===void 0?new this:new this(G.maxNumberEvents,G.flushBatchSize,G.flushIntervalInMilliseconds)}constructor(G,O,b){this._started=!1,this._flushPointer=0,this._started=!1,this._maxNumberEvents=G===void 0?1e4:G,this._flushBatchSize=O===void 0?10:O,this._flushIntervalInMilliseconds=b===void 0?5e3:b}start(){this._started=!0,this._timingEvents=[],this._flushTime=(0,U.now)(),this._flushPointer=0}stop(){for(this._started=!1;this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer])}event(G,O,b,F){const j=this._started?this.begin(G,O,F):void 0;let W=!1;const J=b();if(J&&typeof J.then=="function")return W=!0,new Promise((et,ot)=>{J.then(async it=>{j&&await j.end(),et(it)},async it=>{j&&await j.end(),ot(it)})});if(!W&&j){const et=j.end();if(et&&typeof et.then=="function")return new Promise((ot,it)=>{et.then(()=>{ot(J)},at=>{it(at)})})}return J}begin(G,O,b){if(!this._started)throw new Error("profiler is not started yet");if(b===void 0){const F=(0,U.now)();return this.flush(F),new Q(G,O,F,j=>this.endSync(j))}{const F=b.beginTimer();return new Q(G,O,0,async j=>this.end(j),F,b)}}async end(G){const O=await G.checkTimer();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new q(G.category,G.name,G.startTime,O)),this.flush(O))}endSync(G){const O=(0,U.now)();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new q(G.category,G.name,G.startTime,O)),this.flush(O))}logOneEvent(G){U.Logger.verbose(`Profiler.${G.category}`,`${(G.endTime-G.startTime).toFixed(2)}ms on event '${G.name}' at ${G.endTime.toFixed(2)}`)}flush(G){if(this._timingEvents.length-this._flushPointer>=this._flushBatchSize||G-this._flushTime>=this._flushIntervalInMilliseconds){for(const O=this._flushPointer;this._flushPointer<O+this._flushBatchSize&&this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer]);this._flushTime=(0,U.now)()}}get started(){return this._started}},U.now=typeof performance<"u"&&performance.now?()=>performance.now():Date.now},1745:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.Model=void 0;const tt=rt(5686),Y=rt(1446),nt=rt(4662),K=rt(1287),X=rt(7273);var Q=K.onnxruntime.experimental.fbs;U.Model=class{constructor(){}load(q,G,O){if(!O)try{return void this.loadFromOnnxFormat(q,G)}catch(b){if(O!==void 0)throw b}this.loadFromOrtFormat(q,G)}loadFromOnnxFormat(q,G){const O=Y.onnx.ModelProto.decode(q);if(X.LongUtil.longToNumber(O.irVersion)<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=O.opsetImport.map(b=>({domain:b.domain,version:X.LongUtil.longToNumber(b.version)})),this._graph=nt.Graph.from(O.graph,G)}loadFromOrtFormat(q,G){const O=new tt.flatbuffers.ByteBuffer(q),b=Q.InferenceSession.getRootAsInferenceSession(O).model();if(X.LongUtil.longToNumber(b.irVersion())<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=[];for(let F=0;F<b.opsetImportLength();F++){const j=b.opsetImport(F);this._opsets.push({domain:j==null?void 0:j.domain(),version:X.LongUtil.longToNumber(j.version())})}this._graph=nt.Graph.from(b.graph(),G)}get graph(){return this._graph}get opsets(){return this._opsets}}},6145:(dt,U)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.FLOAT_TYPES=U.INT_TYPES=U.NUMBER_TYPES=void 0,U.NUMBER_TYPES=["float32","float64","int32","int16","int8","uint16","uint32","uint8"],U.INT_TYPES=["int32","int16","int8","uint16","uint32","uint8"],U.FLOAT_TYPES=["float32","float64"]},5881:(dt,U)=>{function rt(tt,Y){if(Y.endsWith("+")){const nt=Number.parseInt(Y.substring(0,Y.length-1),10);return!isNaN(nt)&&nt<=tt}if(Y.split("-").length===2){const nt=Y.split("-"),K=Number.parseInt(nt[0],10),X=Number.parseInt(nt[1],10);return!isNaN(K)&&!isNaN(X)&&K<=tt&&tt<=X}return Number.parseInt(Y,10)===tt}Object.defineProperty(U,"__esModule",{value:!0}),U.resolveOperator=void 0,U.resolveOperator=function(tt,Y,nt){for(const K of nt){const X=K[0],Q=K[1],q=K[2],G=K[3],O=K[4];if(tt.opType===X){for(const b of Y)if((b.domain===Q||b.domain==="ai.onnx"&&Q==="")&&rt(b.version,q))return{opImpl:G,opInit:O}}}throw new TypeError(`cannot resolve operator '${tt.opType}' with opsets: ${Y.map(K=>`${K.domain||"ai.onnx"} v${K.version}`).join(", ")}`)}},1287:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.onnxruntime=void 0;const tt=rt(5686);var Y,nt;Y=U.onnxruntime||(U.onnxruntime={}),function(K){(function(X){X[X.UNDEFINED=0]="UNDEFINED",X[X.FLOAT=1]="FLOAT",X[X.INT=2]="INT",X[X.STRING=3]="STRING",X[X.TENSOR=4]="TENSOR",X[X.GRAPH=5]="GRAPH",X[X.FLOATS=6]="FLOATS",X[X.INTS=7]="INTS",X[X.STRINGS=8]="STRINGS",X[X.TENSORS=9]="TENSORS",X[X.GRAPHS=10]="GRAPHS",X[X.SPARSE_TENSOR=11]="SPARSE_TENSOR",X[X.SPARSE_TENSORS=12]="SPARSE_TENSORS"})(K.AttributeType||(K.AttributeType={}))}((nt=Y.experimental||(Y.experimental={})).fbs||(nt.fbs={})),function(K){(function(X){(function(Q){(function(q){q[q.UNKNOWN=0]="UNKNOWN",q[q.VALUE=1]="VALUE",q[q.PARAM=2]="PARAM"})(Q.DimensionValueType||(Q.DimensionValueType={}))})(X.fbs||(X.fbs={}))})(K.experimental||(K.experimental={}))}(U.onnxruntime||(U.onnxruntime={})),function(K){(function(X){(function(Q){(function(q){q[q.UNDEFINED=0]="UNDEFINED",q[q.FLOAT=1]="FLOAT",q[q.UINT8=2]="UINT8",q[q.INT8=3]="INT8",q[q.UINT16=4]="UINT16",q[q.INT16=5]="INT16",q[q.INT32=6]="INT32",q[q.INT64=7]="INT64",q[q.STRING=8]="STRING",q[q.BOOL=9]="BOOL",q[q.FLOAT16=10]="FLOAT16",q[q.DOUBLE=11]="DOUBLE",q[q.UINT32=12]="UINT32",q[q.UINT64=13]="UINT64",q[q.COMPLEX64=14]="COMPLEX64",q[q.COMPLEX128=15]="COMPLEX128",q[q.BFLOAT16=16]="BFLOAT16"})(Q.TensorDataType||(Q.TensorDataType={}))})(X.fbs||(X.fbs={}))})(K.experimental||(K.experimental={}))}(U.onnxruntime||(U.onnxruntime={})),function(K){(function(X){(function(Q){(function(q){q[q.Primitive=0]="Primitive",q[q.Fused=1]="Fused"})(Q.NodeType||(Q.NodeType={}))})(X.fbs||(X.fbs={}))})(K.experimental||(K.experimental={}))}(U.onnxruntime||(U.onnxruntime={})),function(K){(function(X){(function(Q){(function(q){q[q.NONE=0]="NONE",q[q.tensor_type=1]="tensor_type",q[q.sequence_type=2]="sequence_type",q[q.map_type=3]="map_type"})(Q.TypeInfoValue||(Q.TypeInfoValue={}))})(X.fbs||(X.fbs={}))})(K.experimental||(K.experimental={}))}(U.onnxruntime||(U.onnxruntime={})),function(K){(function(X){(function(Q){class q{constructor(){this.bb=null,this.bb_pos=0}__init(O,b){return this.bb_pos=O,this.bb=b,this}static getRootAsShape(O,b){return(b||new q).__init(O.readInt32(O.position())+O.position(),O)}static getSizePrefixedRootAsShape(O,b){return O.setPosition(O.position()+tt.flatbuffers.SIZE_PREFIX_LENGTH),(b||new q).__init(O.readInt32(O.position())+O.position(),O)}dim(O,b){let F=this.bb.__offset(this.bb_pos,4);return F?(b||new K.experimental.fbs.Dimension).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+F)+4*O),this.bb):null}dimLength(){let O=this.bb.__offset(this.bb_pos,4);return O?this.bb.__vector_len(this.bb_pos+O):0}static startShape(O){O.startObject(1)}static addDim(O,b){O.addFieldOffset(0,b,0)}static createDimVector(O,b){O.startVector(4,b.length,4);for(let F=b.length-1;F>=0;F--)O.addOffset(b[F]);return O.endVector()}static startDimVector(O,b){O.startVector(4,b,4)}static endShape(O){return O.endObject()}static createShape(O,b){return q.startShape(O),q.addDim(O,b),q.endShape(O)}}Q.Shape=q})(X.fbs||(X.fbs={}))})(K.experimental||(K.experimental={}))}(U.onnxruntime||(U.onnxruntime={})),function(K){(function(X){(function(Q){class q{constructor(){this.bb=null,this.bb_pos=0}__init(O,b){return this.bb_pos=O,this.bb=b,this}static getRootAsDimension(O,b){return(b||new q).__init(O.readInt32(O.position())+O.position(),O)}static getSizePrefixedRootAsDimension(O,b){return O.setPosition(O.position()+tt.flatbuffers.SIZE_PREFIX_LENGTH),(b||new q).__init(O.readInt32(O.position())+O.position(),O)}value(O){let b=this.bb.__offset(this.bb_pos,4);return b?(O||new K.experimental.fbs.DimensionValue).__init(this.bb.__indirect(this.bb_pos+b),this.bb):null}denotation(O){let b=this.bb.__offset(this.bb_pos,6);return b?this.bb.__string(this.bb_pos+b,O):null}static startDimension(O){O.startObject(2)}static addValue(O,b){O.addFieldOffset(0,b,0)}static addDenotation(O,b){O.addFieldOffset(1,b,0)}static endDimension(O){return O.endObject()}static createDimension(O,b,F){return q.startDimension(O),q.addValue(O,b),q.addDenotation(O,F),q.endDimension(O)}}Q.Dimension=q})(X.fbs||(X.fbs={}))})(K.experimental||(K.experimental={}))}(U.onnxruntime||(U.onnxruntime={})),function(K){(function(X){(function(Q){class q{constructor(){this.bb=null,this.bb_pos=0}__init(O,b){return this.bb_pos=O,this.bb=b,this}static getRootAsDimensionValue(O,b){return(b||new q).__init(O.readInt32(O.position())+O.position(),O)}static getSizePrefixedRootAsDimensionValue(O,b){return O.setPosition(O.position()+tt.flatbuffers.SIZE_PREFIX_LENGTH),(b||new q).__init(O.readInt32(O.position())+O.position(),O)}dimType(){let O=this.bb.__offset(this.bb_pos,4);return O?this.bb.readInt8(this.bb_pos+O):K.experimental.fbs.DimensionValueType.UNKNOWN}dimValue(){let O=this.bb.__offset(this.bb_pos,6);return O?this.bb.readInt64(this.bb_pos+O):this.bb.createLong(0,0)}dimParam(O){let b=this.bb.__offset(this.bb_pos,8);return b?this.bb.__string(this.bb_pos+b,O):null}static startDimensionValue(O){O.startObject(3)}static addDimType(O,b){O.addFieldInt8(0,b,K.experimental.fbs.DimensionValueType.UNKNOWN)}static addDimValue(O,b){O.addFieldInt64(1,b,O.createLong(0,0))}static addDimParam(O,b){O.addFieldOffset(2,b,0)}static endDimensionValue(O){return O.endObject()}static createDimensionValue(O,b,F,j){return q.startDimensionValue(O),q.addDimType(O,b),q.addDimValue(O,F),q.addDimParam(O,j),q.endDimensionValue(O)}}Q.DimensionValue=q})(X.fbs||(X.fbs={}))})(K.experimental||(K.experimental={}))}(U.onnxruntime||(U.onnxruntime={})),function(K){(function(X){(function(Q){class q{constructor(){this.bb=null,this.bb_pos=0}__init(O,b){return this.bb_pos=O,this.bb=b,this}static getRootAsTensorTypeAndShape(O,b){return(b||new q).__init(O.readInt32(O.position())+O.position(),O)}static getSizePrefixedRootAsTensorTypeAndShape(O,b){return O.setPosition(O.position()+tt.flatbuffers.SIZE_PREFIX_LENGTH),(b||new q).__init(O.readInt32(O.position())+O.position(),O)}elemType(){let O=this.bb.__offset(this.bb_pos,4);return O?this.bb.readInt32(this.bb_pos+O):K.experimental.fbs.TensorDataType.UNDEFINED}shape(O){let b=this.bb.__offset(this.bb_pos,6);return b?(O||new K.experimental.fbs.Shape).__init(this.bb.__indirect(this.bb_pos+b),this.bb):null}static startTensorTypeAndShape(O){O.startObject(2)}static addElemType(O,b){O.addFieldInt32(0,b,K.experimental.fbs.TensorDataType.UNDEFINED)}static addShape(O,b){O.addFieldOffset(1,b,0)}static endTensorTypeAndShape(O){return O.endObject()}static createTensorTypeAndShape(O,b,F){return q.startTensorTypeAndShape(O),q.addElemType(O,b),q.addShape(O,F),q.endTensorTypeAndShape(O)}}Q.TensorTypeAndShape=q})(X.fbs||(X.fbs={}))})(K.experimental||(K.experimental={}))}(U.onnxruntime||(U.onnxruntime={})),function(K){(function(X){(function(Q){class q{constructor(){this.bb=null,this.bb_pos=0}__init(O,b){return this.bb_pos=O,this.bb=b,this}static getRootAsMapType(O,b){return(b||new q).__init(O.readInt32(O.position())+O.position(),O)}static getSizePrefixedRootAsMapType(O,b){return O.setPosition(O.position()+tt.flatbuffers.SIZE_PREFIX_LENGTH),(b||new q).__init(O.readInt32(O.position())+O.position(),O)}keyType(){let O=this.bb.__offset(this.bb_pos,4);return O?this.bb.readInt32(this.bb_pos+O):K.experimental.fbs.TensorDataType.UNDEFINED}valueType(O){let b=this.bb.__offset(this.bb_pos,6);return b?(O||new K.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+b),this.bb):null}static startMapType(O){O.startObject(2)}static addKeyType(O,b){O.addFieldInt32(0,b,K.experimental.fbs.TensorDataType.UNDEFINED)}static addValueType(O,b){O.addFieldOffset(1,b,0)}static endMapType(O){return O.endObject()}static createMapType(O,b,F){return q.startMapType(O),q.addKeyType(O,b),q.addValueType(O,F),q.endMapType(O)}}Q.MapType=q})(X.fbs||(X.fbs={}))})(K.experimental||(K.experimental={}))}(U.onnxruntime||(U.onnxruntime={})),function(K){(function(X){(function(Q){class q{constructor(){this.bb=null,this.bb_pos=0}__init(O,b){return this.bb_pos=O,this.bb=b,this}static getRootAsSequenceType(O,b){return(b||new q).__init(O.readInt32(O.position())+O.position(),O)}static getSizePrefixedRootAsSequenceType(O,b){return O.setPosition(O.position()+tt.flatbuffers.SIZE_PREFIX_LENGTH),(b||new q).__init(O.readInt32(O.position())+O.position(),O)}elemType(O){let b=this.bb.__offset(this.bb_pos,4);return b?(O||new K.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+b),this.bb):null}static startSequenceType(O){O.startObject(1)}static addElemType(O,b){O.addFieldOffset(0,b,0)}static endSequenceType(O){return O.endObject()}static createSequenceType(O,b){return q.startSequenceType(O),q.addElemType(O,b),q.endSequenceType(O)}}Q.SequenceType=q})(X.fbs||(X.fbs={}))})(K.experimental||(K.experimental={}))}(U.onnxruntime||(U.onnxruntime={})),function(K){(function(X){(X.fbs||(X.fbs={})).EdgeEnd=class{constructor(){this.bb=null,this.bb_pos=0}__init(Q,q){return this.bb_pos=Q,this.bb=q,this}nodeIndex(){return this.bb.readUint32(this.bb_pos)}srcArgIndex(){return this.bb.readInt32(this.bb_pos+4)}dstArgIndex(){return this.bb.readInt32(this.bb_pos+8)}static createEdgeEnd(Q,q,G,O){return Q.prep(4,12),Q.writeInt32(O),Q.writeInt32(G),Q.writeInt32(q),Q.offset()}}})(K.experimental||(K.experimental={}))}(U.onnxruntime||(U.onnxruntime={})),function(K){(function(X){(function(Q){class q{constructor(){this.bb=null,this.bb_pos=0}__init(O,b){return this.bb_pos=O,this.bb=b,this}static getRootAsNodeEdge(O,b){return(b||new q).__init(O.readInt32(O.position())+O.position(),O)}static getSizePrefixedRootAsNodeEdge(O,b){return O.setPosition(O.position()+tt.flatbuffers.SIZE_PREFIX_LENGTH),(b||new q).__init(O.readInt32(O.position())+O.position(),O)}nodeIndex(){let O=this.bb.__offset(this.bb_pos,4);return O?this.bb.readUint32(this.bb_pos+O):0}inputEdges(O,b){let F=this.bb.__offset(this.bb_pos,6);return F?(b||new K.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+F)+12*O,this.bb):null}inputEdgesLength(){let O=this.bb.__offset(this.bb_pos,6);return O?this.bb.__vector_len(this.bb_pos+O):0}outputEdges(O,b){let F=this.bb.__offset(this.bb_pos,8);return F?(b||new K.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+F)+12*O,this.bb):null}outputEdgesLength(){let O=this.bb.__offset(this.bb_pos,8);return O?this.bb.__vector_len(this.bb_pos+O):0}static startNodeEdge(O){O.startObject(3)}static addNodeIndex(O,b){O.addFieldInt32(0,b,0)}static addInputEdges(O,b){O.addFieldOffset(1,b,0)}static startInputEdgesVector(O,b){O.startVector(12,b,4)}static addOutputEdges(O,b){O.addFieldOffset(2,b,0)}static startOutputEdgesVector(O,b){O.startVector(12,b,4)}static endNodeEdge(O){return O.endObject()}static createNodeEdge(O,b,F,j){return q.startNodeEdge(O),q.addNodeIndex(O,b),q.addInputEdges(O,F),q.addOutputEdges(O,j),q.endNodeEdge(O)}}Q.NodeEdge=q})(X.fbs||(X.fbs={}))})(K.experimental||(K.experimental={}))}(U.onnxruntime||(U.onnxruntime={})),function(K){(function(X){(function(Q){class q{constructor(){this.bb=null,this.bb_pos=0}__init(O,b){return this.bb_pos=O,this.bb=b,this}static getRootAsNode(O,b){return(b||new q).__init(O.readInt32(O.position())+O.position(),O)}static getSizePrefixedRootAsNode(O,b){return O.setPosition(O.position()+tt.flatbuffers.SIZE_PREFIX_LENGTH),(b||new q).__init(O.readInt32(O.position())+O.position(),O)}name(O){let b=this.bb.__offset(this.bb_pos,4);return b?this.bb.__string(this.bb_pos+b,O):null}docString(O){let b=this.bb.__offset(this.bb_pos,6);return b?this.bb.__string(this.bb_pos+b,O):null}domain(O){let b=this.bb.__offset(this.bb_pos,8);return b?this.bb.__string(this.bb_pos+b,O):null}sinceVersion(){let O=this.bb.__offset(this.bb_pos,10);return O?this.bb.readInt32(this.bb_pos+O):0}index(){let O=this.bb.__offset(this.bb_pos,12);return O?this.bb.readUint32(this.bb_pos+O):0}opType(O){let b=this.bb.__offset(this.bb_pos,14);return b?this.bb.__string(this.bb_pos+b,O):null}type(){let O=this.bb.__offset(this.bb_pos,16);return O?this.bb.readInt32(this.bb_pos+O):K.experimental.fbs.NodeType.Primitive}executionProviderType(O){let b=this.bb.__offset(this.bb_pos,18);return b?this.bb.__string(this.bb_pos+b,O):null}inputs(O,b){let F=this.bb.__offset(this.bb_pos,20);return F?this.bb.__string(this.bb.__vector(this.bb_pos+F)+4*O,b):null}inputsLength(){let O=this.bb.__offset(this.bb_pos,20);return O?this.bb.__vector_len(this.bb_pos+O):0}outputs(O,b){let F=this.bb.__offset(this.bb_pos,22);return F?this.bb.__string(this.bb.__vector(this.bb_pos+F)+4*O,b):null}outputsLength(){let O=this.bb.__offset(this.bb_pos,22);return O?this.bb.__vector_len(this.bb_pos+O):0}attributes(O,b){let F=this.bb.__offset(this.bb_pos,24);return F?(b||new K.experimental.fbs.Attribute).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+F)+4*O),this.bb):null}attributesLength(){let O=this.bb.__offset(this.bb_pos,24);return O?this.bb.__vector_len(this.bb_pos+O):0}inputArgCounts(O){let b=this.bb.__offset(this.bb_pos,26);return b?this.bb.readInt32(this.bb.__vector(this.bb_pos+b)+4*O):0}inputArgCountsLength(){let O=this.bb.__offset(this.bb_pos,26);return O?this.bb.__vector_len(this.bb_pos+O):0}inputArgCountsArray(){let O=this.bb.__offset(this.bb_pos,26);return O?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+O),this.bb.__vector_len(this.bb_pos+O)):null}implicitInputs(O,b){let F=this.bb.__offset(this.bb_pos,28);return F?this.bb.__string(this.bb.__vector(this.bb_pos+F)+4*O,b):null}implicitInputsLength(){let O=this.bb.__offset(this.bb_pos,28);return O?this.bb.__vector_len(this.bb_pos+O):0}static startNode(O){O.startObject(13)}static addName(O,b){O.addFieldOffset(0,b,0)}static addDocString(O,b){O.addFieldOffset(1,b,0)}static addDomain(O,b){O.addFieldOffset(2,b,0)}static addSinceVersion(O,b){O.addFieldInt32(3,b,0)}static addIndex(O,b){O.addFieldInt32(4,b,0)}static addOpType(O,b){O.addFieldOffset(5,b,0)}static addType(O,b){O.addFieldInt32(6,b,K.experimental.fbs.NodeType.Primitive)}static addExecutionProviderType(O,b){O.addFieldOffset(7,b,0)}static addInputs(O,b){O.addFieldOffset(8,b,0)}static createInputsVector(O,b){O.startVector(4,b.length,4);for(let F=b.length-1;F>=0;F--)O.addOffset(b[F]);return O.endVector()}static startInputsVector(O,b){O.startVector(4,b,4)}static addOutputs(O,b){O.addFieldOffset(9,b,0)}static createOutputsVector(O,b){O.startVector(4,b.length,4);for(let F=b.length-1;F>=0;F--)O.addOffset(b[F]);return O.endVector()}static startOutputsVector(O,b){O.startVector(4,b,4)}static addAttributes(O,b){O.addFieldOffset(10,b,0)}static createAttributesVector(O,b){O.startVector(4,b.length,4);for(let F=b.length-1;F>=0;F--)O.addOffset(b[F]);return O.endVector()}static startAttributesVector(O,b){O.startVector(4,b,4)}static addInputArgCounts(O,b){O.addFieldOffset(11,b,0)}static createInputArgCountsVector(O,b){O.startVector(4,b.length,4);for(let F=b.length-1;F>=0;F--)O.addInt32(b[F]);return O.endVector()}static startInputArgCountsVector(O,b){O.startVector(4,b,4)}static addImplicitInputs(O,b){O.addFieldOffset(12,b,0)}static createImplicitInputsVector(O,b){O.startVector(4,b.length,4);for(let F=b.length-1;F>=0;F--)O.addOffset(b[F]);return O.endVector()}static startImplicitInputsVector(O,b){O.startVector(4,b,4)}static endNode(O){return O.endObject()}static createNode(O,b,F,j,W,J,et,ot,it,at,st,lt,ct,pt){return q.startNode(O),q.addName(O,b),q.addDocString(O,F),q.addDomain(O,j),q.addSinceVersion(O,W),q.addIndex(O,J),q.addOpType(O,et),q.addType(O,ot),q.addExecutionProviderType(O,it),q.addInputs(O,at),q.addOutputs(O,st),q.addAttributes(O,lt),q.addInputArgCounts(O,ct),q.addImplicitInputs(O,pt),q.endNode(O)}}Q.Node=q})(X.fbs||(X.fbs={}))})(K.experimental||(K.experimental={}))}(U.onnxruntime||(U.onnxruntime={})),function(K){(function(X){(function(Q){class q{constructor(){this.bb=null,this.bb_pos=0}__init(O,b){return this.bb_pos=O,this.bb=b,this}static getRootAsValueInfo(O,b){return(b||new q).__init(O.readInt32(O.position())+O.position(),O)}static getSizePrefixedRootAsValueInfo(O,b){return O.setPosition(O.position()+tt.flatbuffers.SIZE_PREFIX_LENGTH),(b||new q).__init(O.readInt32(O.position())+O.position(),O)}name(O){let b=this.bb.__offset(this.bb_pos,4);return b?this.bb.__string(this.bb_pos+b,O):null}docString(O){let b=this.bb.__offset(this.bb_pos,6);return b?this.bb.__string(this.bb_pos+b,O):null}type(O){let b=this.bb.__offset(this.bb_pos,8);return b?(O||new K.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+b),this.bb):null}static startValueInfo(O){O.startObject(3)}static addName(O,b){O.addFieldOffset(0,b,0)}static addDocString(O,b){O.addFieldOffset(1,b,0)}static addType(O,b){O.addFieldOffset(2,b,0)}static endValueInfo(O){return O.endObject()}static createValueInfo(O,b,F,j){return q.startValueInfo(O),q.addName(O,b),q.addDocString(O,F),q.addType(O,j),q.endValueInfo(O)}}Q.ValueInfo=q})(X.fbs||(X.fbs={}))})(K.experimental||(K.experimental={}))}(U.onnxruntime||(U.onnxruntime={})),function(K){(function(X){(function(Q){class q{constructor(){this.bb=null,this.bb_pos=0}__init(O,b){return this.bb_pos=O,this.bb=b,this}static getRootAsTypeInfo(O,b){return(b||new q).__init(O.readInt32(O.position())+O.position(),O)}static getSizePrefixedRootAsTypeInfo(O,b){return O.setPosition(O.position()+tt.flatbuffers.SIZE_PREFIX_LENGTH),(b||new q).__init(O.readInt32(O.position())+O.position(),O)}denotation(O){let b=this.bb.__offset(this.bb_pos,4);return b?this.bb.__string(this.bb_pos+b,O):null}valueType(){let O=this.bb.__offset(this.bb_pos,6);return O?this.bb.readUint8(this.bb_pos+O):K.experimental.fbs.TypeInfoValue.NONE}value(O){let b=this.bb.__offset(this.bb_pos,8);return b?this.bb.__union(O,this.bb_pos+b):null}static startTypeInfo(O){O.startObject(3)}static addDenotation(O,b){O.addFieldOffset(0,b,0)}static addValueType(O,b){O.addFieldInt8(1,b,K.experimental.fbs.TypeInfoValue.NONE)}static addValue(O,b){O.addFieldOffset(2,b,0)}static endTypeInfo(O){return O.endObject()}static createTypeInfo(O,b,F,j){return q.startTypeInfo(O),q.addDenotation(O,b),q.addValueType(O,F),q.addValue(O,j),q.endTypeInfo(O)}}Q.TypeInfo=q})(X.fbs||(X.fbs={}))})(K.experimental||(K.experimental={}))}(U.onnxruntime||(U.onnxruntime={})),function(K){(function(X){(function(Q){class q{constructor(){this.bb=null,this.bb_pos=0}__init(O,b){return this.bb_pos=O,this.bb=b,this}static getRootAsOperatorSetId(O,b){return(b||new q).__init(O.readInt32(O.position())+O.position(),O)}static getSizePrefixedRootAsOperatorSetId(O,b){return O.setPosition(O.position()+tt.flatbuffers.SIZE_PREFIX_LENGTH),(b||new q).__init(O.readInt32(O.position())+O.position(),O)}domain(O){let b=this.bb.__offset(this.bb_pos,4);return b?this.bb.__string(this.bb_pos+b,O):null}version(){let O=this.bb.__offset(this.bb_pos,6);return O?this.bb.readInt64(this.bb_pos+O):this.bb.createLong(0,0)}static startOperatorSetId(O){O.startObject(2)}static addDomain(O,b){O.addFieldOffset(0,b,0)}static addVersion(O,b){O.addFieldInt64(1,b,O.createLong(0,0))}static endOperatorSetId(O){return O.endObject()}static createOperatorSetId(O,b,F){return q.startOperatorSetId(O),q.addDomain(O,b),q.addVersion(O,F),q.endOperatorSetId(O)}}Q.OperatorSetId=q})(X.fbs||(X.fbs={}))})(K.experimental||(K.experimental={}))}(U.onnxruntime||(U.onnxruntime={})),function(K){(function(X){(function(Q){class q{constructor(){this.bb=null,this.bb_pos=0}__init(O,b){return this.bb_pos=O,this.bb=b,this}static getRootAsTensor(O,b){return(b||new q).__init(O.readInt32(O.position())+O.position(),O)}static getSizePrefixedRootAsTensor(O,b){return O.setPosition(O.position()+tt.flatbuffers.SIZE_PREFIX_LENGTH),(b||new q).__init(O.readInt32(O.position())+O.position(),O)}name(O){let b=this.bb.__offset(this.bb_pos,4);return b?this.bb.__string(this.bb_pos+b,O):null}docString(O){let b=this.bb.__offset(this.bb_pos,6);return b?this.bb.__string(this.bb_pos+b,O):null}dims(O){let b=this.bb.__offset(this.bb_pos,8);return b?this.bb.readInt64(this.bb.__vector(this.bb_pos+b)+8*O):this.bb.createLong(0,0)}dimsLength(){let O=this.bb.__offset(this.bb_pos,8);return O?this.bb.__vector_len(this.bb_pos+O):0}dataType(){let O=this.bb.__offset(this.bb_pos,10);return O?this.bb.readInt32(this.bb_pos+O):K.experimental.fbs.TensorDataType.UNDEFINED}rawData(O){let b=this.bb.__offset(this.bb_pos,12);return b?this.bb.readUint8(this.bb.__vector(this.bb_pos+b)+O):0}rawDataLength(){let O=this.bb.__offset(this.bb_pos,12);return O?this.bb.__vector_len(this.bb_pos+O):0}rawDataArray(){let O=this.bb.__offset(this.bb_pos,12);return O?new Uint8Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+O),this.bb.__vector_len(this.bb_pos+O)):null}stringData(O,b){let F=this.bb.__offset(this.bb_pos,14);return F?this.bb.__string(this.bb.__vector(this.bb_pos+F)+4*O,b):null}stringDataLength(){let O=this.bb.__offset(this.bb_pos,14);return O?this.bb.__vector_len(this.bb_pos+O):0}static startTensor(O){O.startObject(6)}static addName(O,b){O.addFieldOffset(0,b,0)}static addDocString(O,b){O.addFieldOffset(1,b,0)}static addDims(O,b){O.addFieldOffset(2,b,0)}static createDimsVector(O,b){O.startVector(8,b.length,8);for(let F=b.length-1;F>=0;F--)O.addInt64(b[F]);return O.endVector()}static startDimsVector(O,b){O.startVector(8,b,8)}static addDataType(O,b){O.addFieldInt32(3,b,K.experimental.fbs.TensorDataType.UNDEFINED)}static addRawData(O,b){O.addFieldOffset(4,b,0)}static createRawDataVector(O,b){O.startVector(1,b.length,1);for(let F=b.length-1;F>=0;F--)O.addInt8(b[F]);return O.endVector()}static startRawDataVector(O,b){O.startVector(1,b,1)}static addStringData(O,b){O.addFieldOffset(5,b,0)}static createStringDataVector(O,b){O.startVector(4,b.length,4);for(let F=b.length-1;F>=0;F--)O.addOffset(b[F]);return O.endVector()}static startStringDataVector(O,b){O.startVector(4,b,4)}static endTensor(O){return O.endObject()}static createTensor(O,b,F,j,W,J,et){return q.startTensor(O),q.addName(O,b),q.addDocString(O,F),q.addDims(O,j),q.addDataType(O,W),q.addRawData(O,J),q.addStringData(O,et),q.endTensor(O)}}Q.Tensor=q})(X.fbs||(X.fbs={}))})(K.experimental||(K.experimental={}))}(U.onnxruntime||(U.onnxruntime={})),function(K){(function(X){(function(Q){class q{constructor(){this.bb=null,this.bb_pos=0}__init(O,b){return this.bb_pos=O,this.bb=b,this}static getRootAsSparseTensor(O,b){return(b||new q).__init(O.readInt32(O.position())+O.position(),O)}static getSizePrefixedRootAsSparseTensor(O,b){return O.setPosition(O.position()+tt.flatbuffers.SIZE_PREFIX_LENGTH),(b||new q).__init(O.readInt32(O.position())+O.position(),O)}values(O){let b=this.bb.__offset(this.bb_pos,4);return b?(O||new K.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+b),this.bb):null}indices(O){let b=this.bb.__offset(this.bb_pos,6);return b?(O||new K.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+b),this.bb):null}dims(O){let b=this.bb.__offset(this.bb_pos,8);return b?this.bb.readInt64(this.bb.__vector(this.bb_pos+b)+8*O):this.bb.createLong(0,0)}dimsLength(){let O=this.bb.__offset(this.bb_pos,8);return O?this.bb.__vector_len(this.bb_pos+O):0}static startSparseTensor(O){O.startObject(3)}static addValues(O,b){O.addFieldOffset(0,b,0)}static addIndices(O,b){O.addFieldOffset(1,b,0)}static addDims(O,b){O.addFieldOffset(2,b,0)}static createDimsVector(O,b){O.startVector(8,b.length,8);for(let F=b.length-1;F>=0;F--)O.addInt64(b[F]);return O.endVector()}static startDimsVector(O,b){O.startVector(8,b,8)}static endSparseTensor(O){return O.endObject()}static createSparseTensor(O,b,F,j){return q.startSparseTensor(O),q.addValues(O,b),q.addIndices(O,F),q.addDims(O,j),q.endSparseTensor(O)}}Q.SparseTensor=q})(X.fbs||(X.fbs={}))})(K.experimental||(K.experimental={}))}(U.onnxruntime||(U.onnxruntime={})),function(K){(function(X){(function(Q){class q{constructor(){this.bb=null,this.bb_pos=0}__init(O,b){return this.bb_pos=O,this.bb=b,this}static getRootAsAttribute(O,b){return(b||new q).__init(O.readInt32(O.position())+O.position(),O)}static getSizePrefixedRootAsAttribute(O,b){return O.setPosition(O.position()+tt.flatbuffers.SIZE_PREFIX_LENGTH),(b||new q).__init(O.readInt32(O.position())+O.position(),O)}name(O){let b=this.bb.__offset(this.bb_pos,4);return b?this.bb.__string(this.bb_pos+b,O):null}docString(O){let b=this.bb.__offset(this.bb_pos,6);return b?this.bb.__string(this.bb_pos+b,O):null}type(){let O=this.bb.__offset(this.bb_pos,8);return O?this.bb.readInt32(this.bb_pos+O):K.experimental.fbs.AttributeType.UNDEFINED}f(){let O=this.bb.__offset(this.bb_pos,10);return O?this.bb.readFloat32(this.bb_pos+O):0}i(){let O=this.bb.__offset(this.bb_pos,12);return O?this.bb.readInt64(this.bb_pos+O):this.bb.createLong(0,0)}s(O){let b=this.bb.__offset(this.bb_pos,14);return b?this.bb.__string(this.bb_pos+b,O):null}t(O){let b=this.bb.__offset(this.bb_pos,16);return b?(O||new K.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+b),this.bb):null}g(O){let b=this.bb.__offset(this.bb_pos,18);return b?(O||new K.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+b),this.bb):null}floats(O){let b=this.bb.__offset(this.bb_pos,20);return b?this.bb.readFloat32(this.bb.__vector(this.bb_pos+b)+4*O):0}floatsLength(){let O=this.bb.__offset(this.bb_pos,20);return O?this.bb.__vector_len(this.bb_pos+O):0}floatsArray(){let O=this.bb.__offset(this.bb_pos,20);return O?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+O),this.bb.__vector_len(this.bb_pos+O)):null}ints(O){let b=this.bb.__offset(this.bb_pos,22);return b?this.bb.readInt64(this.bb.__vector(this.bb_pos+b)+8*O):this.bb.createLong(0,0)}intsLength(){let O=this.bb.__offset(this.bb_pos,22);return O?this.bb.__vector_len(this.bb_pos+O):0}strings(O,b){let F=this.bb.__offset(this.bb_pos,24);return F?this.bb.__string(this.bb.__vector(this.bb_pos+F)+4*O,b):null}stringsLength(){let O=this.bb.__offset(this.bb_pos,24);return O?this.bb.__vector_len(this.bb_pos+O):0}tensors(O,b){let F=this.bb.__offset(this.bb_pos,26);return F?(b||new K.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+F)+4*O),this.bb):null}tensorsLength(){let O=this.bb.__offset(this.bb_pos,26);return O?this.bb.__vector_len(this.bb_pos+O):0}graphs(O,b){let F=this.bb.__offset(this.bb_pos,28);return F?(b||new K.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+F)+4*O),this.bb):null}graphsLength(){let O=this.bb.__offset(this.bb_pos,28);return O?this.bb.__vector_len(this.bb_pos+O):0}static startAttribute(O){O.startObject(13)}static addName(O,b){O.addFieldOffset(0,b,0)}static addDocString(O,b){O.addFieldOffset(1,b,0)}static addType(O,b){O.addFieldInt32(2,b,K.experimental.fbs.AttributeType.UNDEFINED)}static addF(O,b){O.addFieldFloat32(3,b,0)}static addI(O,b){O.addFieldInt64(4,b,O.createLong(0,0))}static addS(O,b){O.addFieldOffset(5,b,0)}static addT(O,b){O.addFieldOffset(6,b,0)}static addG(O,b){O.addFieldOffset(7,b,0)}static addFloats(O,b){O.addFieldOffset(8,b,0)}static createFloatsVector(O,b){O.startVector(4,b.length,4);for(let F=b.length-1;F>=0;F--)O.addFloat32(b[F]);return O.endVector()}static startFloatsVector(O,b){O.startVector(4,b,4)}static addInts(O,b){O.addFieldOffset(9,b,0)}static createIntsVector(O,b){O.startVector(8,b.length,8);for(let F=b.length-1;F>=0;F--)O.addInt64(b[F]);return O.endVector()}static startIntsVector(O,b){O.startVector(8,b,8)}static addStrings(O,b){O.addFieldOffset(10,b,0)}static createStringsVector(O,b){O.startVector(4,b.length,4);for(let F=b.length-1;F>=0;F--)O.addOffset(b[F]);return O.endVector()}static startStringsVector(O,b){O.startVector(4,b,4)}static addTensors(O,b){O.addFieldOffset(11,b,0)}static createTensorsVector(O,b){O.startVector(4,b.length,4);for(let F=b.length-1;F>=0;F--)O.addOffset(b[F]);return O.endVector()}static startTensorsVector(O,b){O.startVector(4,b,4)}static addGraphs(O,b){O.addFieldOffset(12,b,0)}static createGraphsVector(O,b){O.startVector(4,b.length,4);for(let F=b.length-1;F>=0;F--)O.addOffset(b[F]);return O.endVector()}static startGraphsVector(O,b){O.startVector(4,b,4)}static endAttribute(O){return O.endObject()}static createAttribute(O,b,F,j,W,J,et,ot,it,at,st,lt,ct,pt){return q.startAttribute(O),q.addName(O,b),q.addDocString(O,F),q.addType(O,j),q.addF(O,W),q.addI(O,J),q.addS(O,et),q.addT(O,ot),q.addG(O,it),q.addFloats(O,at),q.addInts(O,st),q.addStrings(O,lt),q.addTensors(O,ct),q.addGraphs(O,pt),q.endAttribute(O)}}Q.Attribute=q})(X.fbs||(X.fbs={}))})(K.experimental||(K.experimental={}))}(U.onnxruntime||(U.onnxruntime={})),function(K){(function(X){(function(Q){class q{constructor(){this.bb=null,this.bb_pos=0}__init(O,b){return this.bb_pos=O,this.bb=b,this}static getRootAsGraph(O,b){return(b||new q).__init(O.readInt32(O.position())+O.position(),O)}static getSizePrefixedRootAsGraph(O,b){return O.setPosition(O.position()+tt.flatbuffers.SIZE_PREFIX_LENGTH),(b||new q).__init(O.readInt32(O.position())+O.position(),O)}initializers(O,b){let F=this.bb.__offset(this.bb_pos,4);return F?(b||new K.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+F)+4*O),this.bb):null}initializersLength(){let O=this.bb.__offset(this.bb_pos,4);return O?this.bb.__vector_len(this.bb_pos+O):0}nodeArgs(O,b){let F=this.bb.__offset(this.bb_pos,6);return F?(b||new K.experimental.fbs.ValueInfo).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+F)+4*O),this.bb):null}nodeArgsLength(){let O=this.bb.__offset(this.bb_pos,6);return O?this.bb.__vector_len(this.bb_pos+O):0}nodes(O,b){let F=this.bb.__offset(this.bb_pos,8);return F?(b||new K.experimental.fbs.Node).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+F)+4*O),this.bb):null}nodesLength(){let O=this.bb.__offset(this.bb_pos,8);return O?this.bb.__vector_len(this.bb_pos+O):0}maxNodeIndex(){let O=this.bb.__offset(this.bb_pos,10);return O?this.bb.readUint32(this.bb_pos+O):0}nodeEdges(O,b){let F=this.bb.__offset(this.bb_pos,12);return F?(b||new K.experimental.fbs.NodeEdge).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+F)+4*O),this.bb):null}nodeEdgesLength(){let O=this.bb.__offset(this.bb_pos,12);return O?this.bb.__vector_len(this.bb_pos+O):0}inputs(O,b){let F=this.bb.__offset(this.bb_pos,14);return F?this.bb.__string(this.bb.__vector(this.bb_pos+F)+4*O,b):null}inputsLength(){let O=this.bb.__offset(this.bb_pos,14);return O?this.bb.__vector_len(this.bb_pos+O):0}outputs(O,b){let F=this.bb.__offset(this.bb_pos,16);return F?this.bb.__string(this.bb.__vector(this.bb_pos+F)+4*O,b):null}outputsLength(){let O=this.bb.__offset(this.bb_pos,16);return O?this.bb.__vector_len(this.bb_pos+O):0}sparseInitializers(O,b){let F=this.bb.__offset(this.bb_pos,18);return F?(b||new K.experimental.fbs.SparseTensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+F)+4*O),this.bb):null}sparseInitializersLength(){let O=this.bb.__offset(this.bb_pos,18);return O?this.bb.__vector_len(this.bb_pos+O):0}static startGraph(O){O.startObject(8)}static addInitializers(O,b){O.addFieldOffset(0,b,0)}static createInitializersVector(O,b){O.startVector(4,b.length,4);for(let F=b.length-1;F>=0;F--)O.addOffset(b[F]);return O.endVector()}static startInitializersVector(O,b){O.startVector(4,b,4)}static addNodeArgs(O,b){O.addFieldOffset(1,b,0)}static createNodeArgsVector(O,b){O.startVector(4,b.length,4);for(let F=b.length-1;F>=0;F--)O.addOffset(b[F]);return O.endVector()}static startNodeArgsVector(O,b){O.startVector(4,b,4)}static addNodes(O,b){O.addFieldOffset(2,b,0)}static createNodesVector(O,b){O.startVector(4,b.length,4);for(let F=b.length-1;F>=0;F--)O.addOffset(b[F]);return O.endVector()}static startNodesVector(O,b){O.startVector(4,b,4)}static addMaxNodeIndex(O,b){O.addFieldInt32(3,b,0)}static addNodeEdges(O,b){O.addFieldOffset(4,b,0)}static createNodeEdgesVector(O,b){O.startVector(4,b.length,4);for(let F=b.length-1;F>=0;F--)O.addOffset(b[F]);return O.endVector()}static startNodeEdgesVector(O,b){O.startVector(4,b,4)}static addInputs(O,b){O.addFieldOffset(5,b,0)}static createInputsVector(O,b){O.startVector(4,b.length,4);for(let F=b.length-1;F>=0;F--)O.addOffset(b[F]);return O.endVector()}static startInputsVector(O,b){O.startVector(4,b,4)}static addOutputs(O,b){O.addFieldOffset(6,b,0)}static createOutputsVector(O,b){O.startVector(4,b.length,4);for(let F=b.length-1;F>=0;F--)O.addOffset(b[F]);return O.endVector()}static startOutputsVector(O,b){O.startVector(4,b,4)}static addSparseInitializers(O,b){O.addFieldOffset(7,b,0)}static createSparseInitializersVector(O,b){O.startVector(4,b.length,4);for(let F=b.length-1;F>=0;F--)O.addOffset(b[F]);return O.endVector()}static startSparseInitializersVector(O,b){O.startVector(4,b,4)}static endGraph(O){return O.endObject()}static createGraph(O,b,F,j,W,J,et,ot,it){return q.startGraph(O),q.addInitializers(O,b),q.addNodeArgs(O,F),q.addNodes(O,j),q.addMaxNodeIndex(O,W),q.addNodeEdges(O,J),q.addInputs(O,et),q.addOutputs(O,ot),q.addSparseInitializers(O,it),q.endGraph(O)}}Q.Graph=q})(X.fbs||(X.fbs={}))})(K.experimental||(K.experimental={}))}(U.onnxruntime||(U.onnxruntime={})),function(K){(function(X){(function(Q){class q{constructor(){this.bb=null,this.bb_pos=0}__init(O,b){return this.bb_pos=O,this.bb=b,this}static getRootAsModel(O,b){return(b||new q).__init(O.readInt32(O.position())+O.position(),O)}static getSizePrefixedRootAsModel(O,b){return O.setPosition(O.position()+tt.flatbuffers.SIZE_PREFIX_LENGTH),(b||new q).__init(O.readInt32(O.position())+O.position(),O)}irVersion(){let O=this.bb.__offset(this.bb_pos,4);return O?this.bb.readInt64(this.bb_pos+O):this.bb.createLong(0,0)}opsetImport(O,b){let F=this.bb.__offset(this.bb_pos,6);return F?(b||new K.experimental.fbs.OperatorSetId).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+F)+4*O),this.bb):null}opsetImportLength(){let O=this.bb.__offset(this.bb_pos,6);return O?this.bb.__vector_len(this.bb_pos+O):0}producerName(O){let b=this.bb.__offset(this.bb_pos,8);return b?this.bb.__string(this.bb_pos+b,O):null}producerVersion(O){let b=this.bb.__offset(this.bb_pos,10);return b?this.bb.__string(this.bb_pos+b,O):null}domain(O){let b=this.bb.__offset(this.bb_pos,12);return b?this.bb.__string(this.bb_pos+b,O):null}modelVersion(){let O=this.bb.__offset(this.bb_pos,14);return O?this.bb.readInt64(this.bb_pos+O):this.bb.createLong(0,0)}docString(O){let b=this.bb.__offset(this.bb_pos,16);return b?this.bb.__string(this.bb_pos+b,O):null}graph(O){let b=this.bb.__offset(this.bb_pos,18);return b?(O||new K.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+b),this.bb):null}graphDocString(O){let b=this.bb.__offset(this.bb_pos,20);return b?this.bb.__string(this.bb_pos+b,O):null}static startModel(O){O.startObject(9)}static addIrVersion(O,b){O.addFieldInt64(0,b,O.createLong(0,0))}static addOpsetImport(O,b){O.addFieldOffset(1,b,0)}static createOpsetImportVector(O,b){O.startVector(4,b.length,4);for(let F=b.length-1;F>=0;F--)O.addOffset(b[F]);return O.endVector()}static startOpsetImportVector(O,b){O.startVector(4,b,4)}static addProducerName(O,b){O.addFieldOffset(2,b,0)}static addProducerVersion(O,b){O.addFieldOffset(3,b,0)}static addDomain(O,b){O.addFieldOffset(4,b,0)}static addModelVersion(O,b){O.addFieldInt64(5,b,O.createLong(0,0))}static addDocString(O,b){O.addFieldOffset(6,b,0)}static addGraph(O,b){O.addFieldOffset(7,b,0)}static addGraphDocString(O,b){O.addFieldOffset(8,b,0)}static endModel(O){return O.endObject()}static createModel(O,b,F,j,W,J,et,ot,it,at){return q.startModel(O),q.addIrVersion(O,b),q.addOpsetImport(O,F),q.addProducerName(O,j),q.addProducerVersion(O,W),q.addDomain(O,J),q.addModelVersion(O,et),q.addDocString(O,ot),q.addGraph(O,it),q.addGraphDocString(O,at),q.endModel(O)}}Q.Model=q})(X.fbs||(X.fbs={}))})(K.experimental||(K.experimental={}))}(U.onnxruntime||(U.onnxruntime={})),function(K){(function(X){(function(Q){class q{constructor(){this.bb=null,this.bb_pos=0}__init(O,b){return this.bb_pos=O,this.bb=b,this}static getRootAsKernelCreateInfos(O,b){return(b||new q).__init(O.readInt32(O.position())+O.position(),O)}static getSizePrefixedRootAsKernelCreateInfos(O,b){return O.setPosition(O.position()+tt.flatbuffers.SIZE_PREFIX_LENGTH),(b||new q).__init(O.readInt32(O.position())+O.position(),O)}nodeIndices(O){let b=this.bb.__offset(this.bb_pos,4);return b?this.bb.readUint32(this.bb.__vector(this.bb_pos+b)+4*O):0}nodeIndicesLength(){let O=this.bb.__offset(this.bb_pos,4);return O?this.bb.__vector_len(this.bb_pos+O):0}nodeIndicesArray(){let O=this.bb.__offset(this.bb_pos,4);return O?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+O),this.bb.__vector_len(this.bb_pos+O)):null}kernelDefHashes(O){let b=this.bb.__offset(this.bb_pos,6);return b?this.bb.readUint64(this.bb.__vector(this.bb_pos+b)+8*O):this.bb.createLong(0,0)}kernelDefHashesLength(){let O=this.bb.__offset(this.bb_pos,6);return O?this.bb.__vector_len(this.bb_pos+O):0}static startKernelCreateInfos(O){O.startObject(2)}static addNodeIndices(O,b){O.addFieldOffset(0,b,0)}static createNodeIndicesVector(O,b){O.startVector(4,b.length,4);for(let F=b.length-1;F>=0;F--)O.addInt32(b[F]);return O.endVector()}static startNodeIndicesVector(O,b){O.startVector(4,b,4)}static addKernelDefHashes(O,b){O.addFieldOffset(1,b,0)}static createKernelDefHashesVector(O,b){O.startVector(8,b.length,8);for(let F=b.length-1;F>=0;F--)O.addInt64(b[F]);return O.endVector()}static startKernelDefHashesVector(O,b){O.startVector(8,b,8)}static endKernelCreateInfos(O){return O.endObject()}static createKernelCreateInfos(O,b,F){return q.startKernelCreateInfos(O),q.addNodeIndices(O,b),q.addKernelDefHashes(O,F),q.endKernelCreateInfos(O)}}Q.KernelCreateInfos=q})(X.fbs||(X.fbs={}))})(K.experimental||(K.experimental={}))}(U.onnxruntime||(U.onnxruntime={})),function(K){(function(X){(function(Q){class q{constructor(){this.bb=null,this.bb_pos=0}__init(O,b){return this.bb_pos=O,this.bb=b,this}static getRootAsSubGraphSessionState(O,b){return(b||new q).__init(O.readInt32(O.position())+O.position(),O)}static getSizePrefixedRootAsSubGraphSessionState(O,b){return O.setPosition(O.position()+tt.flatbuffers.SIZE_PREFIX_LENGTH),(b||new q).__init(O.readInt32(O.position())+O.position(),O)}graphId(O){let b=this.bb.__offset(this.bb_pos,4);return b?this.bb.__string(this.bb_pos+b,O):null}sessionState(O){let b=this.bb.__offset(this.bb_pos,6);return b?(O||new K.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+b),this.bb):null}static startSubGraphSessionState(O){O.startObject(2)}static addGraphId(O,b){O.addFieldOffset(0,b,0)}static addSessionState(O,b){O.addFieldOffset(1,b,0)}static endSubGraphSessionState(O){let b=O.endObject();return O.requiredField(b,4),b}static createSubGraphSessionState(O,b,F){return q.startSubGraphSessionState(O),q.addGraphId(O,b),q.addSessionState(O,F),q.endSubGraphSessionState(O)}}Q.SubGraphSessionState=q})(X.fbs||(X.fbs={}))})(K.experimental||(K.experimental={}))}(U.onnxruntime||(U.onnxruntime={})),function(K){(function(X){(function(Q){class q{constructor(){this.bb=null,this.bb_pos=0}__init(O,b){return this.bb_pos=O,this.bb=b,this}static getRootAsSessionState(O,b){return(b||new q).__init(O.readInt32(O.position())+O.position(),O)}static getSizePrefixedRootAsSessionState(O,b){return O.setPosition(O.position()+tt.flatbuffers.SIZE_PREFIX_LENGTH),(b||new q).__init(O.readInt32(O.position())+O.position(),O)}kernels(O){let b=this.bb.__offset(this.bb_pos,4);return b?(O||new K.experimental.fbs.KernelCreateInfos).__init(this.bb.__indirect(this.bb_pos+b),this.bb):null}subGraphSessionStates(O,b){let F=this.bb.__offset(this.bb_pos,6);return F?(b||new K.experimental.fbs.SubGraphSessionState).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+F)+4*O),this.bb):null}subGraphSessionStatesLength(){let O=this.bb.__offset(this.bb_pos,6);return O?this.bb.__vector_len(this.bb_pos+O):0}static startSessionState(O){O.startObject(2)}static addKernels(O,b){O.addFieldOffset(0,b,0)}static addSubGraphSessionStates(O,b){O.addFieldOffset(1,b,0)}static createSubGraphSessionStatesVector(O,b){O.startVector(4,b.length,4);for(let F=b.length-1;F>=0;F--)O.addOffset(b[F]);return O.endVector()}static startSubGraphSessionStatesVector(O,b){O.startVector(4,b,4)}static endSessionState(O){return O.endObject()}static createSessionState(O,b,F){return q.startSessionState(O),q.addKernels(O,b),q.addSubGraphSessionStates(O,F),q.endSessionState(O)}}Q.SessionState=q})(X.fbs||(X.fbs={}))})(K.experimental||(K.experimental={}))}(U.onnxruntime||(U.onnxruntime={})),function(K){(function(X){(function(Q){class q{constructor(){this.bb=null,this.bb_pos=0}__init(O,b){return this.bb_pos=O,this.bb=b,this}static getRootAsInferenceSession(O,b){return(b||new q).__init(O.readInt32(O.position())+O.position(),O)}static getSizePrefixedRootAsInferenceSession(O,b){return O.setPosition(O.position()+tt.flatbuffers.SIZE_PREFIX_LENGTH),(b||new q).__init(O.readInt32(O.position())+O.position(),O)}static bufferHasIdentifier(O){return O.__has_identifier("ORTM")}ortVersion(O){let b=this.bb.__offset(this.bb_pos,4);return b?this.bb.__string(this.bb_pos+b,O):null}model(O){let b=this.bb.__offset(this.bb_pos,6);return b?(O||new K.experimental.fbs.Model).__init(this.bb.__indirect(this.bb_pos+b),this.bb):null}sessionState(O){let b=this.bb.__offset(this.bb_pos,8);return b?(O||new K.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+b),this.bb):null}static startInferenceSession(O){O.startObject(3)}static addOrtVersion(O,b){O.addFieldOffset(0,b,0)}static addModel(O,b){O.addFieldOffset(1,b,0)}static addSessionState(O,b){O.addFieldOffset(2,b,0)}static endInferenceSession(O){return O.endObject()}static finishInferenceSessionBuffer(O,b){O.finish(b,"ORTM")}static finishSizePrefixedInferenceSessionBuffer(O,b){O.finish(b,"ORTM",!0)}static createInferenceSession(O,b,F,j){return q.startInferenceSession(O),q.addOrtVersion(O,b),q.addModel(O,F),q.addSessionState(O,j),q.endInferenceSession(O)}}Q.InferenceSession=q})(X.fbs||(X.fbs={}))})(K.experimental||(K.experimental={}))}(U.onnxruntime||(U.onnxruntime={}))},1723:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.OnnxjsSessionHandler=void 0;const tt=rt(8453),Y=rt(9240);U.OnnxjsSessionHandler=class{constructor(nt){this.session=nt,this.inputNames=this.session.inputNames,this.outputNames=this.session.outputNames}async dispose(){}async run(nt,K,X){const Q=new Map;for(const O in nt)if(Object.hasOwnProperty.call(nt,O)){const b=nt[O];Q.set(O,new Y.Tensor(b.dims,b.type,void 0,void 0,b.data))}const q=await this.session.run(Q),G={};return q.forEach((O,b)=>{G[b]=new tt.Tensor(O.type,O.data,O.dims)}),G}startProfiling(){this.session.startProfiling()}endProfiling(){this.session.endProfiling()}}},6027:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.Session=void 0;const tt=rt(7067),Y=rt(1296),nt=rt(1975),K=rt(6496),X=rt(1315),Q=rt(1745);U.Session=class{constructor(q={}){this._initialized=!1,this.backendHint=q.backendHint,this.profiler=X.Profiler.create(q.profiler),this.context={profiler:this.profiler,graphInputTypes:[],graphInputDims:[]}}get inputNames(){return this._model.graph.getInputNames()}get outputNames(){return this._model.graph.getOutputNames()}startProfiling(){this.profiler.start()}endProfiling(){this.profiler.stop()}async loadModel(q,G,O){await this.profiler.event("session","Session.loadModel",async()=>{const b=await(0,nt.resolveBackend)(this.backendHint);if(this.sessionHandler=b.createSessionHandler(this.context),this._model=new Q.Model,typeof q=="string"){const F=q.endsWith(".ort");if(typeof fetch>"u"){const j=await(0,Y.promisify)(tt.readFile)(q);this.initialize(j,F)}else{const j=await fetch(q),W=await j.arrayBuffer();this.initialize(new Uint8Array(W),F)}}else if(ArrayBuffer.isView(q))this.initialize(q);else{const F=new Uint8Array(q,G||0,O||q.byteLength);this.initialize(F)}})}initialize(q,G){if(this._initialized)throw new Error("already initialized");this.profiler.event("session","Session.initialize",()=>{const O=this.sessionHandler.transformGraph?this.sessionHandler:void 0;this._model.load(q,O,G),this.sessionHandler.onGraphInitialized&&this.sessionHandler.onGraphInitialized(this._model.graph),this.initializeOps(this._model.graph),this._executionPlan=new K.ExecutionPlan(this._model.graph,this._ops,this.profiler)}),this._initialized=!0}async run(q){if(!this._initialized)throw new Error("session not initialized yet");return this.profiler.event("session","Session.run",async()=>{const G=this.normalizeAndValidateInputs(q),O=await this._executionPlan.execute(this.sessionHandler,G);return this.createOutput(O)})}normalizeAndValidateInputs(q){const G=this._model.graph.getInputNames();if(Array.isArray(q)){if(q.length!==G.length)throw new Error(`incorrect input array length: expected ${G.length} but got ${q.length}`)}else{if(q.size!==G.length)throw new Error(`incorrect input map size: expected ${G.length} but got ${q.size}`);const O=new Array(q.size);let b=0;for(let F=0;F<G.length;++F){const j=q.get(G[F]);if(!j)throw new Error(`missing input tensor for: '${name}'`);O[b++]=j}q=O}if(this.context.graphInputTypes&&this.context.graphInputTypes.length!==0&&this.context.graphInputDims&&this.context.graphInputDims.length!==0)this.validateInputTensorDims(this.context.graphInputDims,q,!1);else{const O=this._model.graph.getInputIndices(),b=this._model.graph.getValues(),F=new Array(O.length);for(let j=0;j<O.length;++j){const W=b[O[j]];F[j]=W.type.shape.dims,this.context.graphInputTypes.push(W.type.tensorType),this.context.graphInputDims.push(q[j].dims)}this.validateInputTensorDims(F,q,!0)}return this.validateInputTensorTypes(this.context.graphInputTypes,q),q}validateInputTensorTypes(q,G){for(let O=0;O<G.length;O++){const b=q[O],F=G[O].type;if(b!==F)throw new Error(`input tensor[${O}] check failed: expected type '${b}' but got ${F}`)}}validateInputTensorDims(q,G,O){for(let b=0;b<G.length;b++){const F=q[b],j=G[b].dims;if(!this.compareTensorDims(F,j,O))throw new Error(`input tensor[${b}] check failed: expected shape '[${F.join(",")}]' but got [${j.join(",")}]`)}}compareTensorDims(q,G,O){if(q.length!==G.length)return!1;for(let b=0;b<q.length;++b)if(q[b]!==G[b]&&(!O||q[b]!==0))return!1;return!0}createOutput(q){const G=this._model.graph.getOutputNames();if(q.length!==G.length)throw new Error("expected number of outputs do not match number of generated outputs");const O=new Map;for(let b=0;b<G.length;++b)O.set(G[b],q[b]);return O}initializeOps(q){const G=q.getNodes();this._ops=new Array(G.length);for(let O=0;O<G.length;O++)this._ops[O]=this.sessionHandler.resolve(G[O],this._model.opsets,q)}}},9240:function(dt,U,rt){var tt=this&&this.__importDefault||function(W){return W&&W.__esModule?W:{default:W}};Object.defineProperty(U,"__esModule",{value:!0}),U.Tensor=void 0;const Y=rt(3442),nt=tt(rt(3720)),K=rt(1446),X=rt(1287),Q=rt(7273);var q=X.onnxruntime.experimental.fbs;class G{get data(){if(this.cache===void 0){const J=this.dataProvider(this.dataId);if(J.length!==this.size)throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");this.cache=J}return this.cache}get stringData(){if(this.type!=="string")throw new TypeError("data type is not string");return this.data}get integerData(){switch(this.type){case"uint8":case"int8":case"uint16":case"int16":case"int32":case"uint32":case"bool":return this.data;default:throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)")}}get floatData(){switch(this.type){case"float32":case"float64":return this.data;default:throw new TypeError("data type is not float (float32, float64)")}}get numberData(){if(this.type!=="string")return this.data;throw new TypeError("type cannot be non-number (string)")}get(J){return this.data[Q.ShapeUtil.indicesToOffset(J,this.strides)]}set(J,et){this.data[Q.ShapeUtil.indicesToOffset(J,this.strides)]=et}async getData(){return this.cache===void 0&&(this.cache=await this.asyncDataProvider(this.dataId)),this.cache}get strides(){return this._strides||(this._strides=Q.ShapeUtil.computeStrides(this.dims)),this._strides}constructor(J,et,ot,it,at,st=Y.Guid.create()){this.dims=J,this.type=et,this.dataProvider=ot,this.asyncDataProvider=it,this.cache=at,this.dataId=st,this.size=Q.ShapeUtil.validateDimsAndCalcSize(J);const lt=this.size,ct=ot===void 0&&it===void 0&&at===void 0;if(at!==void 0&&at.length!==lt)throw new RangeError("Input dims doesn't match data length.");if(et==="string"){if(!(at===void 0||Array.isArray(at)&&at.every(pt=>typeof pt=="string")))throw new TypeError("cache should be a string array");ct&&(this.cache=new Array(lt))}else{if(at!==void 0){const pt=b(et);if(!(at instanceof pt))throw new TypeError(`cache should be type ${pt.name}`)}if(ct){const pt=new ArrayBuffer(lt*function(ut){switch(ut){case"bool":case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;case"float64":return 8;default:throw new Error(`cannot calculate sizeof() on type ${ut}`)}}(et));this.cache=function(ut,ft){return new(b(ft))(ut)}(pt,et)}}}static fromProto(J){if(!J)throw new Error("cannot construct Value from an empty tensor");const et=Q.ProtoUtil.tensorDataTypeFromProto(J.dataType),ot=Q.ProtoUtil.tensorDimsFromProto(J.dims),it=new G(ot,et);if(et==="string")J.stringData.forEach((at,st)=>{it.data[st]=(0,Q.decodeUtf8String)(at)});else if(J.rawData&&typeof J.rawData.byteLength=="number"&&J.rawData.byteLength>0){const at=it.data,st=new DataView(J.rawData.buffer,J.rawData.byteOffset,J.rawData.byteLength),lt=O(J.dataType),ct=J.rawData.byteLength/lt;if(J.rawData.byteLength%lt!=0)throw new Error("invalid buffer length");if(at.length!==ct)throw new Error("buffer length mismatch");for(let pt=0;pt<ct;pt++){const ut=j(st,J.dataType,pt*lt);at[pt]=ut}}else{let at;switch(J.dataType){case K.onnx.TensorProto.DataType.FLOAT:at=J.floatData;break;case K.onnx.TensorProto.DataType.INT32:case K.onnx.TensorProto.DataType.INT16:case K.onnx.TensorProto.DataType.UINT16:case K.onnx.TensorProto.DataType.INT8:case K.onnx.TensorProto.DataType.UINT8:case K.onnx.TensorProto.DataType.BOOL:at=J.int32Data;break;case K.onnx.TensorProto.DataType.INT64:at=J.int64Data;break;case K.onnx.TensorProto.DataType.DOUBLE:at=J.doubleData;break;case K.onnx.TensorProto.DataType.UINT32:case K.onnx.TensorProto.DataType.UINT64:at=J.uint64Data;break;default:throw new Error("unspecific error")}if(at==null)throw new Error("failed to populate data from a tensorproto value");const st=it.data;if(st.length!==at.length)throw new Error("array length mismatch");for(let lt=0;lt<at.length;lt++){const ct=at[lt];nt.default.isLong(ct)?st[lt]=F(ct,J.dataType):st[lt]=ct}}return it}static fromData(J,et,ot){return new G(et,ot,void 0,void 0,J)}static fromOrtTensor(J){if(!J)throw new Error("cannot construct Value from an empty tensor");const et=Q.ProtoUtil.tensorDimsFromORTFormat(J),ot=Q.ProtoUtil.tensorDataTypeFromProto(J.dataType()),it=new G(et,ot);if(ot==="string")for(let at=0;at<J.stringDataLength();at++)it.data[at]=J.stringData(at);else if(J.rawDataArray()&&typeof J.rawDataLength()=="number"&&J.rawDataLength()>0){const at=it.data,st=new DataView(J.rawDataArray().buffer,J.rawDataArray().byteOffset,J.rawDataLength()),lt=O(J.dataType()),ct=J.rawDataLength()/lt;if(J.rawDataLength()%lt!=0)throw new Error("invalid buffer length");if(at.length!==ct)throw new Error("buffer length mismatch");for(let pt=0;pt<ct;pt++){const ut=j(st,J.dataType(),pt*lt);at[pt]=ut}}return it}}function O(W){switch(W){case K.onnx.TensorProto.DataType.UINT8:case K.onnx.TensorProto.DataType.INT8:case K.onnx.TensorProto.DataType.BOOL:return 1;case K.onnx.TensorProto.DataType.UINT16:case K.onnx.TensorProto.DataType.INT16:return 2;case K.onnx.TensorProto.DataType.FLOAT:case K.onnx.TensorProto.DataType.INT32:case K.onnx.TensorProto.DataType.UINT32:return 4;case K.onnx.TensorProto.DataType.INT64:case K.onnx.TensorProto.DataType.DOUBLE:case K.onnx.TensorProto.DataType.UINT64:return 8;default:throw new Error(`cannot calculate sizeof() on type ${K.onnx.TensorProto.DataType[W]}`)}}function b(W){switch(W){case"bool":case"uint8":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"uint16":return Uint16Array;case"int32":return Int32Array;case"uint32":return Uint32Array;case"float32":return Float32Array;case"float64":return Float64Array;default:throw new Error("unspecified error")}}function F(W,J){if(J===K.onnx.TensorProto.DataType.INT64||J===q.TensorDataType.INT64){if(W.greaterThanOrEqual(2147483648)||W.lessThan(-2147483648))throw new TypeError("int64 is not supported")}else{if(J!==K.onnx.TensorProto.DataType.UINT32&&J!==q.TensorDataType.UINT32&&J!==K.onnx.TensorProto.DataType.UINT64&&J!==q.TensorDataType.UINT64)throw new TypeError(`not a LONG type: ${K.onnx.TensorProto.DataType[J]}`);if(W.greaterThanOrEqual(4294967296)||W.lessThan(0))throw new TypeError("uint64 is not supported")}return W.toNumber()}function j(W,J,et){switch(J){case K.onnx.TensorProto.DataType.BOOL:case K.onnx.TensorProto.DataType.UINT8:return W.getUint8(et);case K.onnx.TensorProto.DataType.INT8:return W.getInt8(et);case K.onnx.TensorProto.DataType.UINT16:return W.getUint16(et,!0);case K.onnx.TensorProto.DataType.INT16:return W.getInt16(et,!0);case K.onnx.TensorProto.DataType.FLOAT:return W.getFloat32(et,!0);case K.onnx.TensorProto.DataType.INT32:return W.getInt32(et,!0);case K.onnx.TensorProto.DataType.UINT32:return W.getUint32(et,!0);case K.onnx.TensorProto.DataType.INT64:return F(nt.default.fromBits(W.getUint32(et,!0),W.getUint32(et+4,!0),!1),J);case K.onnx.TensorProto.DataType.DOUBLE:return W.getFloat64(et,!0);case K.onnx.TensorProto.DataType.UINT64:return F(nt.default.fromBits(W.getUint32(et,!0),W.getUint32(et+4,!0),!0),J);default:throw new Error(`cannot read from DataView for type ${K.onnx.TensorProto.DataType[J]}`)}}U.Tensor=G},7273:function(dt,U,rt){var tt=this&&this.__importDefault||function(J){return J&&J.__esModule?J:{default:J}};Object.defineProperty(U,"__esModule",{value:!0}),U.decodeUtf8String=U.MAX_CLIP=U.MIN_CLIP=U.PoolConvUtil=U.ReduceUtil=U.SplitUtil=U.MathUtil=U.ShapeUtil=U.LongUtil=U.ProtoUtil=U.GemmUtil=U.arrayCopyHelper=U.BroadcastUtil=U.MatMulUtil=U.ArrayUtil=U.assert=U.checkInputsShape=void 0;const Y=rt(5686),nt=tt(rt(3720)),K=rt(1446),X=rt(9240);U.checkInputsShape=function(J,...et){if(!J||J.length!==et.length)return!1;for(let ot=0;ot<J.length;ot++)if(!J[ot].dims||J[ot].dims.length!==et[ot])return!1;return!0},U.assert=function(J,et){if(!J)throw new Error(typeof et=="string"?et:et())},U.ArrayUtil=class{static arraysEqual(J,et){if(J.length!==et.length)return!1;for(let ot=0;ot<J.length;ot++)if(J[ot]!==et[ot])return!1;return!0}};class Q{static preprocessInputShapes(et,ot){return[et.length===1?[1,et[0]]:et,ot.length===1?[ot[0],1]:ot]}static postprocessOutputShape(et,ot,it){ot===1&&et.splice(et.length-2,1),it===1&&et.pop()}static calcMatMulShape(et,ot){return et[1]!==ot[0]?void 0:[et[0],ot[1]]}}U.MatMulUtil=Q;class q{static calcShape(et,ot,it=!1){const at=et.length,st=ot.length;if(at===0)return ot;if(st===0)return et;const lt=Math.max(et.length,ot.length),ct=new Array(lt);if(it){if(at<2||st<2)return;const pt=Q.calcMatMulShape([et[at-2],et[at-1]],[ot[st-2],ot[st-1]]);if(pt===void 0)return;[ct[lt-2],ct[lt-1]]=pt}for(let pt=it?3:1;pt<=lt;pt++){const ut=at-pt<0?1:et[at-pt],ft=st-pt<0?1:ot[st-pt];if(ut!==ft&&ut>1&&ft>1)return;ct[lt-pt]=Math.max(ut,ft)}return ct}static index(et,ot){const it=new Array(ot.length);return q.fillIndex(et,ot,it),it}static fillIndex(et,ot,it){const at=et.length-ot.length;for(let st=0;st<ot.length;st++)it[st]=et[at+st]%ot[st]}static calc(et,ot,it,at,st){const lt=q.calcShape(et.dims,ot.dims);if(lt){if(at&&!b.areEqual(lt,et.dims))return;const ct=b.size(lt),pt=at?et:new X.Tensor(lt,st||et.type);if(lt.length===0)pt.set([],it(et.get([]),ot.get([])));else{const ut=new Array(lt.length),ft=new Array(et.dims.length),gt=new Array(ot.dims.length);let _t,vt=0,bt=0,St=!1,yt=!1;et.dims.length===0&&(vt=et.get([]),St=!0),ot.dims.length===0&&(bt=ot.get([]),yt=!0);for(let wt=0;wt<ct;wt++){_t=wt;for(let Dt=lt.length-1;Dt>=0;Dt--)ut[Dt]=_t%lt[Dt],_t=Math.floor(_t/lt[Dt]);St||(q.fillIndex(ut,et.dims,ft),vt=et.get(ft)),yt||(q.fillIndex(ut,ot.dims,gt),bt=ot.get(gt)),pt.set(ut,it(vt,bt))}}return pt}}static isValidBroadcast(et,ot){const it=et.length,at=ot.length;if(it>at)return!1;for(let st=1;st<=it;st++)if(et[it-st]!==1&&et[it-st]!==ot[at-st])return!1;return!0}static getBroadcastDims(et,ot){const it=et.length,at=[];for(let st=0;st<it;st++){const lt=it-1-st,ct=et[lt]||1;(ot[ot.length-1-st]||1)>1&&ct===1&&at.unshift(lt)}return at}}U.BroadcastUtil=q,U.arrayCopyHelper=function(J,et,ot,it,at){if(it<0||it>=et.length)throw new Error("sourceIndex out of bounds");if(ot<0||ot>=J.length)throw new Error("targetIndex out of bounds");if(it+at>et.length)throw new Error("source indices to be copied are outside bounds");if(ot+at>J.length)throw new Error("target array is too small to hold result");for(let st=0;st<at;st++)J[ot+st]=et[it+st]},U.GemmUtil=class{static getShapeOfGemmResult(J,et,ot,it,at){if(J.length!==2||ot.length!==2)throw new Error("shape need to be of size 2");let st,lt,ct;et?(st=J[1],lt=J[0]):(st=J[0],lt=J[1]);let pt=-1;if(it?(ct=ot[0],pt=1):(ct=ot[1],pt=0),ot[pt]!==lt)throw new Error("dimension mismatch");if(st<=0||ct<=0||lt<=0)throw new Error("invalid shape specified");if(at&&!q.isValidBroadcast(at,[st,ct]))throw new Error("gemm: invalid bias shape for broadcast");return[st,ct,lt]}};class G{static tensorDataTypeFromProto(et){switch(et){case K.onnx.TensorProto.DataType.INT8:return"int8";case K.onnx.TensorProto.DataType.UINT8:return"uint8";case K.onnx.TensorProto.DataType.BOOL:return"bool";case K.onnx.TensorProto.DataType.INT16:return"int16";case K.onnx.TensorProto.DataType.UINT16:return"uint16";case K.onnx.TensorProto.DataType.INT32:return"int32";case K.onnx.TensorProto.DataType.UINT32:return"uint32";case K.onnx.TensorProto.DataType.FLOAT:return"float32";case K.onnx.TensorProto.DataType.DOUBLE:return"float64";case K.onnx.TensorProto.DataType.STRING:return"string";case K.onnx.TensorProto.DataType.INT64:return"int32";case K.onnx.TensorProto.DataType.UINT64:return"uint32";default:throw new Error(`unsupported data type: ${K.onnx.TensorProto.DataType[et]}`)}}static tensorDataTypeStringToEnum(et){switch(et){case"int8":return K.onnx.TensorProto.DataType.INT8;case"uint8":return K.onnx.TensorProto.DataType.UINT8;case"bool":return K.onnx.TensorProto.DataType.BOOL;case"int16":return K.onnx.TensorProto.DataType.INT16;case"uint16":return K.onnx.TensorProto.DataType.UINT16;case"int32":return K.onnx.TensorProto.DataType.INT32;case"uint32":return K.onnx.TensorProto.DataType.UINT32;case"float32":return K.onnx.TensorProto.DataType.FLOAT;case"float64":return K.onnx.TensorProto.DataType.DOUBLE;case"string":return K.onnx.TensorProto.DataType.STRING;case"int64":return K.onnx.TensorProto.DataType.INT64;case"uint64":return K.onnx.TensorProto.DataType.UINT64;default:throw new Error(`unsupported data type: ${et}`)}}static tensorDimsFromProto(et){return et.map(ot=>nt.default.isLong(ot)?ot.toNumber():ot)}static tensorValueTypeFromProto(et){return{tensorType:G.tensorDataTypeFromProto(et.elemType),shape:{dims:G.tensorDimsFromProto(et.shape.dim.map(ot=>ot.dimValue))}}}static tensorDimsFromORTFormat(et){const ot=[];for(let it=0;it<et.dimsLength();it++)ot.push(O.longToNumber(et.dims(it)));return ot}static tensorAttributesFromORTFormat(et){const ot=[];for(let it=0;it<et.attributesLength();it++)ot.push(et.attributes(it));return ot}}U.ProtoUtil=G;class O{static longToNumber(et,ot){return nt.default.isLong(et)?et.toNumber():et instanceof Y.flatbuffers.Long?nt.default.fromValue({low:et.low,high:et.high,unsigned:ot!=null&&ot}).toNumber():et}static isLong(et){return nt.default.isLong(et)||et instanceof Y.flatbuffers.Long}}U.LongUtil=O;class b{static size(et){return b.getSizeFromDimensionRange(et,0,et.length)}static sizeFromDimension(et,ot){if(ot<0||ot>et.length)throw new Error(`invalid dimension of ${ot} for sizeFromDimension as Tensor has ${et.length} dimensions.`);return b.getSizeFromDimensionRange(et,ot,et.length)}static sizeToDimension(et,ot){if(ot<0||ot>et.length)throw new Error(`invalid dimension of ${ot} for sizeToDimension as Tensor has ${et.length} dimensions.`);return b.getSizeFromDimensionRange(et,0,ot)}static getSizeFromDimensionRange(et,ot,it){let at=1;for(let st=ot;st<it;st++){if(et[st]<=0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");at*=et[st]}return at}static computeStrides(et){const ot=et.length;if(ot===0)return[];if(ot===1)return[1];const it=new Array(ot);it[ot-1]=1,it[ot-2]=et[ot-1];for(let at=ot-3;at>=0;--at)it[at]=it[at+1]*et[at+1];return it}static transpose(et){return et.slice().reverse()}static indicesToOffset(et,ot,it){it===void 0&&(it=et.length);let at=0;for(let st=0;st<it;++st)at+=ot[st]*et[st];return at}static offsetToIndices(et,ot){const it=ot.length;if(it===0)return[];if(it===1)return[et*ot[0]];const at=new Array(ot.length);for(let st=0;st<at.length-1;++st)at[st]=Math.floor(et/ot[st]),et-=at[st]*ot[st];return at[at.length-1]=et,at}static normalizeAxis(et,ot){if(et<-ot&&et>=ot)throw new Error("unsupported axis for this operation.");return et<0?et+ot:et}static normalizeAxes(et,ot){return et.map(it=>this.normalizeAxis(it,ot))}static incrementIndex(et,ot,it){if(ot.length===0||et.length===0)throw new Error("Index incrementing unsupported for scalar Tensor");if(it===void 0)it=ot.length;else if(it<=0||it>ot.length)throw new Error("Incorrect axis to increment on");for(let at=it-1;at>=0&&(et[at]++,!(et[at]<ot[at]));--at)et[at]=0}static calculateReshapedDims(et,ot){if(ot.length===0){if(et.length===0||b.size(et)===1)return[];throw new Error("cannot reshape to a scalar Tensor")}const it=ot.length,at=new Array(it);let st=-1,lt=1;for(let pt=0;pt<it;pt++){if(ot[pt]<-1)throw new Error("a dimension in shape hints cannot be less than -1");if(ot[pt]===-1){if(st!==-1)throw new Error("at most one dimension in shape hints can be -1");st=pt}else{if(ot[pt]===0){if(pt>=et.length)throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");at[pt]=et[pt]}else at[pt]=ot[pt];lt*=at[pt]}}const ct=b.size(et);if(st!==-1){if(ct%lt!=0)throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${et}] Output shape: [${ot}]`);at[st]=ct/lt}else if(lt!==ct)throw new Error("reshapedDims and originalDims don't have matching sizes");return at}static sortBasedOnPerm(et,ot){return ot?ot.map(it=>et[it]):et.slice().reverse()}static padShape(et,ot){const it=et.length;return et.map((at,st)=>at+ot[st]+ot[st+it])}static areEqual(et,ot){return et.length===ot.length&&et.every((it,at)=>it===ot[at])}static validateDimsAndCalcSize(et){if(et.length>6)throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");let ot=1;for(const it of et){if(!Number.isInteger(it))throw new TypeError(`Invalid shape: ${it} is not an integer`);if(it<0||it>2147483647)throw new TypeError(`Invalid shape: length ${it} is not allowed`);ot*=it}return ot}static flattenShape(et,ot){ot<0&&(ot+=et.length);const it=et.reduce((st,lt)=>st*lt,1),at=et.slice(ot).reduce((st,lt)=>st*lt,1);return[it/at,at]}static squeezeShape(et,ot){const it=new Array;ot=b.normalizeAxes(ot,et.length);for(let at=0;at<et.length;at++){const st=ot.indexOf(at)>=0;if(st&&et[at]!==1)throw new Error("squeeze an axis of size different than 1");(ot.length===0&&et[at]>1||ot.length>0&&!st)&&it.push(et[at])}return it}static unsqueezeShape(et,ot){const it=new Array(et.length+ot.length);it.fill(0);for(let st=0;st<ot.length;st++){const lt=b.normalizeAxis(ot[st],it.length);if(lt>=it.length)throw new Error("'axes' has an out of range axis");if(it[lt]!==0)throw new Error("'axes' has a duplicate axis");it[lt]=1}let at=0;for(let st=0;st<it.length;st++)it[st]===0&&(it[st]=et[at++]);if(at!==et.length)throw new Error("the unsqueezed dimension could not be established");return it}}U.ShapeUtil=b,U.MathUtil=class{static sqr(J,et,ot,it,at){if(it<0||it>=et.length)throw new Error("sourceIndex out of bounds");if(ot<0||ot>=J.length)throw new Error("targetIndex out of bounds");if(it+at>et.length)throw new Error("source indices to be copied are outside bounds");if(ot+at>J.length)throw new Error("target array is too small to hold result");for(let st=0;st<at;st++)J[ot+st]+=Math.pow(et[it+st],2)}static axpy(J,et,ot,it,at,st){if(it<0||it>=et.length)throw new Error("sourceIndex out of bounds");if(ot<0||ot>=J.length)throw new Error("targetIndex out of bounds");if(it+at>et.length)throw new Error("source indices to be copied are outside bounds");if(ot+at>J.length)throw new Error("target array is too small to hold result");for(let lt=0;lt<at;lt++)J[ot+lt]+=st*et[it+lt]}static powx(J,et,ot,it,at,st){if(it<0||it>=et.length)throw new Error("sourceIndex out of bounds");if(ot<0||ot>=J.length)throw new Error("targetIndex out of bounds");if(it+at>et.length)throw new Error("source indices to be copied are outside bounds");if(ot+at>J.length)throw new Error("target array is too small to hold result");for(let lt=0;lt<at;lt++)J[ot+lt]=Math.pow(et[it+lt],st)}static mul(J,et,ot,it,at){if(it<0||it>=et.length)throw new Error("sourceIndex out of bounds");if(ot<0||ot>=J.length)throw new Error("targetIndex out of bounds");if(it+at>et.length)throw new Error("source indices to be copied are outside bounds");if(ot+at>J.length)throw new Error("target array is too small to hold result");for(let st=0;st<at;st++)J[ot+st]=et[it+st]*J[ot+st]}};class F{static splitShape(et,ot,it,at){if(it.length===0){if(!at)throw new Error("need to know number of outputs when the 'split' attribute is not specified");F.determineSplit(et[ot],at,it)}const st=[],lt=[0];for(let ct=0;ct<it.length;++ct){ct!==0&&lt.push(lt[ct-1]+it[ct-1]);const pt=et.slice();pt[ot]=it[ct],st.push(pt)}return[st,lt]}static determineSplit(et,ot,it){if(et%ot!=0)throw new Error("cannot split tensor to equal sized parts");for(let at=0;at<ot;++at)it.push(et/ot)}}U.SplitUtil=F;class j{static calcReduce(et,ot,it,at,st){const lt=et.dims.slice(0);ot.length===0&&lt.forEach((vt,bt)=>ot.push(bt));const ct=j.calcReduceShape(lt,ot,!0),pt=b.size(ct),ut=new X.Tensor(ct,et.type),ft=b.computeStrides(ct),gt=b.computeStrides(lt),_t=new Array(lt.length);for(let vt=0;vt<pt;vt++){const bt=b.offsetToIndices(vt,ft);q.fillIndex(bt,lt,_t),ut.set(bt,j.calcReduceByAxis(et.numberData,ot,lt,0,b.indicesToOffset(_t,gt),at,st))}return it?ut:new X.Tensor(j.calcReduceShape(lt,ot,it),ut.type,void 0,void 0,ut.data,ut.dataId)}static calcReduceByAxis(et,ot,it,at,st,lt,ct){let pt=0;if(at>=ot.length)return lt(et[st]);const ut=ot[at],ft=ut>=it.length?1:b.size(it.slice(ut+1));for(let gt=0;gt<it[ut];gt++)pt=gt===0?j.calcReduceByAxis(et,ot,it,at+1,st,lt,ct):ct(pt,j.calcReduceByAxis(et,ot,it,at+1,st,lt,ct)),st+=ft;return pt}static calcReduceShape(et,ot,it){const at=et.slice();for(let st=0;st<ot.length;st++)at[ot[st]]=it?1:0;return at.filter(st=>st!==0)}}U.ReduceUtil=j;class W{static adjustPoolAttributes(et,ot,it,at,st,lt){if(!et&&it.length!==ot.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(et)for(let ct=0;ct<ot.length-2;ct++)ct>=it.length?it.push(ot[ct+2]):it[ct]=ot[ct+2];for(let ct=0;ct<it.length;ct++)if(ct<at.length){if(at[ct]<0)throw new Error("strides should be greater than or equal to 1")}else at.push(1);for(let ct=0;ct<it.length;ct++)if(ct<st.length){if(st[ct]<0)throw new Error("dilations should be greater than or equal to 1")}else st.push(1);for(let ct=0;ct<2*it.length;ct++)if(ct<lt.length){if(lt[ct]<0)throw new Error("pad should be greater than or equal to 1")}else lt.push(0);for(let ct=0;ct<it.length;ct++){if(it[ct]<=0)throw new Error("kernel shapes need to be greater than 0");if(lt[ct]>=it[ct]||lt[ct+it.length]>=it[ct])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(et,ot,it,at,st,lt){if(lt){if(st.length!==2*(et.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(ot.length!==et.length-2)throw new Error("length of strides should be the length of data dimensions");if(at.length!==et.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let ct=0;ct<et.length-2;ct++)W.adjustPadAndReturnShape(et[ct+2],ot[ct],it[ct],at[ct],st,ct,ct+et.length-2,lt)}}static computePoolOutputShape(et,ot,it,at,st,lt,ct){if(ot.length<=0)throw new Error("input shape must be of size greater than 0");const pt=[ot[0],ot[1]];return W.computeShapeHelper(et,ot,pt,it,at,st,lt,ct),pt}static computeConvOutputShape(et,ot,it,at,st,lt,ct){if(et.length<=0||ot.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");const pt=[et[0],ot[0]];return W.computeShapeHelper(!1,et,pt,it,at,st,lt,ct),pt}static computeShapeHelper(et,ot,it,at,st,lt,ct,pt){if(et)for(let ut=0;ut<ot.length-2;ut++)it.push(1);else for(let ut=0;ut<ot.length-2;ut++)it.push(W.adjustPadAndReturnShape(ot[ut+2],at[ut],st[ut],lt[ut],ct,ut,ut+ot.length-2,pt))}static adjustPadAndReturnShape(et,ot,it,at,st,lt,ct,pt){const ut=it*(at-1)+1;if(!pt||pt==="NOTSET")return Math.floor((et+st[lt]+st[ct]-ut)/ot+1);switch(pt){case"VALID":return st[lt]=0,st[ct]=0,Math.floor((et-ut)/ot+1);case"SAME_LOWER":case"SAME_UPPER":if(it!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{const ft=((et+ot-1)/ot-1)*ot+at-et;return st[lt]=Math.floor(pt==="SAME_LOWER"?(ft+1)/2:ft/2),st[ct]=ft-st[lt],Math.floor((et+ft-at)/ot+1)}default:throw new Error("Unsupported AutoPad type")}}}U.PoolConvUtil=W,U.MIN_CLIP=-34028234663852886e22,U.MAX_CLIP=34028234663852886e22,U.decodeUtf8String=function(J){return new TextDecoder().decode(J)}},3838:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.WebGpuBackend=void 0;const tt=rt(8453),Y=rt(4955),nt=rt(7771),K=rt(8510),X=rt(8305);U.WebGpuBackend=class{constructor(){this.currentKernelId=null,this.commandEncoder=null,this.computePassEncoder=null,this.pendingDispatchNumber=0,this.profilingEnabled=!1}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let Q=this.kernelCustomData.get(this.currentKernelId);return Q||(Q={},this.kernelCustomData.set(this.currentKernelId,Q)),Q}async initialize(){if(!navigator.gpu)throw new Error("WebGpuBackend: WebGPU is not available.");const Q=await navigator.gpu.requestAdapter();if(!Q)throw new Error("WebGpuBackend: Failed to get GPU adapter.");const q={requiredLimits:{maxComputeWorkgroupStorageSize:Q.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:Q.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:Q.limits.maxStorageBufferBindingSize}};Q.features.has("timestamp-query-inside-passes")&&tt.env.webgpu.profilingMode==="default"&&(this.profilingEnabled=!0,q.requiredFeatures=["timestamp-query-inside-passes"]),this.device=await Q.requestDevice(q),this.gpuDataManager=(0,nt.createGpuDataManager)(this),this.programManager=new X.ProgramManager(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,this.device.onuncapturederror=G=>{G.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${G.error.message}`)},this.profilingEnabled&&(this.profilingQuerySet=this.device.createQuerySet({type:"timestamp",count:2}))}dispose(){}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){return this.computePassEncoder||(this.computePassEncoder=this.getCommandEncoder().beginComputePass()),this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){this.endComputePass(),this.device.queue.submit([this.getCommandEncoder().finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0}run(Q,q,G,O,b){if(q.length!==Q.inputTypes.length)throw new Error(`Input size must be equal to ${Q.inputTypes.length}.`);const F=[];for(let st=0;st<q.length;++st){const lt=this.gpuDataManager.get(q[st].data);if(!lt)throw new Error(`no GPU data for input: ${q[st].data}`);F[st]=lt}const j=((st,lt,ct)=>{const pt=lt.map(gt=>`${gt.join(",")}`).join("_"),ut=ct.join("_");let ft=st.name;return st.cacheHint&&(ft+="["+st.cacheHint+"]"),ft+=":"+pt+";"+ut,ft})(Q,q.map(st=>st.dims),F.map(st=>st.type));let W=this.programManager.getArtifact(j);const J=W?W.programInfo:typeof Q.get=="function"?Q.get():Q,et=G.length===0?J.outputs.map((st,lt)=>lt):G;if(et.length!==J.outputs.length)throw new Error(`Output size ${et.length} must be equal to ${J.outputs.length}.`);const ot=[],it=[];for(let st=0;st<J.outputs.length;++st){if(!Number.isInteger(et[st])||et[st]<-2||et[st]>=J.outputs.length)throw new Error(`Invalid output index: ${et[st]}`);const lt=et[st]===-1,ct=et[st]===-2,pt=lt||ct?b(J.outputs[st].dataType,J.outputs[st].dims):O(et[st],J.outputs[st].dataType,J.outputs[st].dims),ut=this.gpuDataManager.get(pt.data);if(!ut)throw new Error(`no GPU data for output: ${pt.data}`);if(lt&&this.temporaryData.push(ut),ct){let ft=this.kernelPersistentData.get(this.currentKernelId);ft||(ft=[],this.kernelPersistentData.set(this.currentKernelId,ft)),ft.push(ut)}ot.push(pt),it.push(ut)}const at=this.programManager.normalizeDispatchGroupSize(J.dispatchGroup(q));return W||(W=this.programManager.build(J,at),this.programManager.setArtifact(j,W)),(0,Y.LOG_DEBUG)("info",()=>`[ProgramManager] run "${J.name}" (key=${j}) with ${at[0]}x${at[1]}x${at[2]}`),this.programManager.run(W,F,it,at),ot}upload(Q,q){this.gpuDataManager.upload(Q,q)}memcpy(Q,q){this.gpuDataManager.memcpy(Q,q)}async download(Q,q){const G=await this.gpuDataManager.download(Q);q().set(new Uint8Array(G))}alloc(Q){return this.gpuDataManager.create(Q).id}free(Q){return this.gpuDataManager.release(Q)}createKernel(Q,q,G){const O=K.WEBGPU_OP_RESOLVE_RULES.get(Q);if(!O)throw new Error(`kernel not implemented: ${Q}`);this.kernels.set(q,[Q,O[0],[O[1],G]])}releaseKernel(Q){const q=this.kernelPersistentData.get(Q);if(q){for(const G of q)this.gpuDataManager.release(G.id);this.kernelPersistentData.delete(Q)}this.kernelCustomData.delete(Q),this.kernels.delete(Q)}computeKernel(Q,q){const G=this.kernels.get(Q);if(!G)throw new Error(`kernel not created: ${Q}`);const[O,b,F]=G;if(this.currentKernelId!==null)throw new Error(`kernel "${O}" is not allowed to be called recursively`);this.currentKernelId=Q,F[0]&&(F[1]=F[0](F[1]),F[0]=void 0),(0,Y.LOG_DEBUG)("info",()=>`[WebGPU] Start to run kernel "${O}"...`),this.temporaryData=[];try{return b(q,F[1]),0}catch(j){return(0,Y.LOG_DEBUG)("warning",`[WebGPU] Kernel "${O}" failed. Error: ${j}`),1}finally{for(const j of this.temporaryData)this.gpuDataManager.release(j.id);this.temporaryData=[],this.currentKernelId=null}}}},7675:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.init=void 0;const tt=rt(7917),Y=rt(3838),nt=rt(4955),K=rt(6952);class X{constructor(G,O,b,F){this.module=G,this.dataType=O,this.data=b,this.dims=F}getFloat32Array(){return new Float32Array(this.module.HEAP8.buffer,this.data,K.ShapeUtil.size(this.dims))}reshape(G){if(K.ShapeUtil.size(G)!==K.ShapeUtil.size(this.dims))throw new Error("Invalid new shape");return new X(this.module,this.dataType,this.data,G)}}class Q{get customData(){return this.backend.currentKernelCustomData}constructor(G,O,b){this.module=G,this.backend=O;const F=G.HEAPU32;let j=b>>2;this.opKernelContext=F[j++];const W=F[j++],J=[];for(let et=0;et<W;et++){const ot=F[j++],it=F[j++],at=F[j++],st=[];for(let lt=0;lt<at;lt++)st.push(F[j++]);J.push(new X(G,ot,it,st))}this.inputs=J}compute(G,O){var b,F,j;const W=(F=(b=O==null?void 0:O.inputs)===null||b===void 0?void 0:b.map(et=>typeof et=="number"?this.inputs[et]:et))!==null&&F!==void 0?F:this.inputs,J=(j=O==null?void 0:O.outputs)!==null&&j!==void 0?j:[];return this.backend.run(G,W,J,(et,ot,it)=>new X(this.module,ot,this.output(et,it),it),(et,ot)=>{const it=(0,tt.getTensorElementSize)(et);if(!it)throw new Error(`Unsupported data type: ${et}`);const at=it*K.ShapeUtil.size(ot);return new X(this.module,et,this.backend.gpuDataManager.create(at).id,ot)})}output(G,O){const b=this.module.stackSave();try{const F=this.module.stackAlloc(4*(1+O.length));let j=F>>2;this.module.HEAPU32[j++]=O.length;for(let W=0;W<O.length;W++)this.module.HEAPU32[j++]=O[W];return this.module._JsepOutput(this.opKernelContext,G,F)}finally{this.module.stackRestore(b)}}}U.init=async q=>{const G=q.jsepInit;if(G&&navigator.gpu){const O=new Y.WebGpuBackend;await O.initialize(),G({backend:O},b=>O.alloc(b),b=>O.free(b),(b,F,j,W=!1)=>{if(W)(0,nt.LOG_DEBUG)("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${b}, dst=${F}, size=${j}`),O.memcpy(b,F);else{(0,nt.LOG_DEBUG)("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${b}, gpuDataId=${F}, size=${j}`);const J=q.HEAPU8.subarray(b,b+j);O.upload(F,J)}},async(b,F,j)=>{(0,nt.LOG_DEBUG)("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${b}, dataOffset=${F}, size=${j}`),await O.download(b,()=>q.HEAPU8.subarray(F,F+j))},(b,F,j)=>O.createKernel(b,F,j),b=>O.releaseKernel(b),(b,F)=>{(0,nt.LOG_DEBUG)("verbose",()=>`[WebGPU] jsepRun: kernel=${b}, contextDataOffset=${F}`);const j=new Q(q,O,F);return O.computeKernel(b,j)})}}},4955:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.LOG_DEBUG=U.LOG=void 0;const tt=rt(8453),Y=rt(7917),nt=["V","I","W","E","F"];U.LOG=(K,X)=>{const Q=(0,Y.logLevelStringToEnum)(K);var q,G;Q>=(0,Y.logLevelStringToEnum)(tt.env.logLevel)&&(q=Q,G=typeof X=="function"?X():X,console.log(`[${nt[q]},${new Date().toISOString()}]${G}`))},U.LOG_DEBUG=(...K)=>{tt.env.debug&&(0,U.LOG)(...K)}},6952:(dt,U)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.MAX_CLIP=U.MIN_CLIP=U.GemmUtil=U.PoolConvUtil=U.ShapeUtil=U.BroadcastUtil=U.MatMulUtil=void 0;class rt{static calcMatMulShape(X,Q){return X[1]!==Q[0]?void 0:[X[0],Q[1]]}}U.MatMulUtil=rt;class tt{static calcShape(X,Q,q=!1){const G=X.length,O=Q.length;if(G===0)return Q;if(O===0)return X;const b=Math.max(X.length,Q.length),F=new Array(b);if(q){if(G<2||O<2)return;const j=rt.calcMatMulShape([X[G-2],X[G-1]],[Q[O-2],Q[O-1]]);if(j===void 0)return;[F[b-2],F[b-1]]=j}for(let j=q?3:1;j<=b;j++){const W=G-j<0?1:X[G-j],J=O-j<0?1:Q[O-j];if(W!==J&&W>1&&J>1)return;F[b-j]=Math.max(W,J)}return F}static isValidBroadcast(X,Q){const q=X.length,G=Q.length;if(q>G)return!1;for(let O=1;O<=q;O++)if(X[q-O]!==1&&X[q-O]!==Q[G-O])return!1;return!0}}U.BroadcastUtil=tt;class Y{static size(X){return Y.getSizeFromDimensionRange(X,0,X.length)}static sizeFromDimension(X,Q){if(Q<0||Q>X.length)throw new Error(`invalid dimension of ${Q} for sizeFromDimension as Tensor has ${X.length} dimensions.`);return Y.getSizeFromDimensionRange(X,Q,X.length)}static sizeToDimension(X,Q){if(Q<0||Q>X.length)throw new Error(`invalid dimension of ${Q} for sizeToDimension as Tensor has ${X.length} dimensions.`);return Y.getSizeFromDimensionRange(X,0,Q)}static getSizeFromDimensionRange(X,Q,q){let G=1;for(let O=Q;O<q;O++){if(X[O]<=0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");G*=X[O]}return G}static computeStrides(X){const Q=X.length;if(Q===0)return[];if(Q===1)return[1];const q=new Array(Q);q[Q-1]=1,q[Q-2]=X[Q-1];for(let G=Q-3;G>=0;--G)q[G]=q[G+1]*X[G+1];return q}static normalizeAxis(X,Q){if(X<-Q&&X>=Q)throw new Error("unsupported axis for this operation.");return X<0?X+Q:X}static normalizeAxes(X,Q){return X.map(q=>this.normalizeAxis(q,Q??X.length))}static sortBasedOnPerm(X,Q){return Q?Q.map(q=>X[q]):X.slice().reverse()}static padShape(X,Q){const q=X.length;return X.map((G,O)=>G+Q[O]+Q[O+q])}static areEqual(X,Q){return X.length===Q.length&&X.every((q,G)=>q===Q[G])}}U.ShapeUtil=Y;class nt{static adjustPoolAttributes(X,Q,q,G,O,b){if(!X&&q.length!==Q.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(X)for(let F=0;F<Q.length-2;F++)F>=q.length?q.push(Q[F+2]):q[F]=Q[F+2];for(let F=0;F<q.length;F++)if(F<G.length){if(G[F]<0)throw new Error("strides should be greater than or equal to 1")}else G.push(1);for(let F=0;F<q.length;F++)if(F<O.length){if(O[F]<0)throw new Error("dilations should be greater than or equal to 1")}else O.push(1);for(let F=0;F<2*q.length;F++)if(F<b.length){if(b[F]<0)throw new Error("pad should be greater than or equal to 1")}else b.push(0);for(let F=0;F<q.length;F++){if(q[F]<=0)throw new Error("kernel shapes need to be greater than 0");if(b[F]>=q[F]||b[F+q.length]>=q[F])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(X,Q,q,G,O,b,F){if(F){if(O.length!==2*(X.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(Q.length!==X.length-2)throw new Error("length of strides should be the length of data dimensions");if(G.length!==X.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let j=0;j<X.length-2;j++)nt.adjustPadAndReturnShape(X[j+(b?1:2)],Q[j],q[j],G[j],O,j,j+X.length-2,F)}}static computePoolOutputShape(X,Q,q,G,O,b,F){if(Q.length<=0)throw new Error("input shape must be of size greater than 0");const j=[Q[0],Q[1]];return nt.computeShapeHelper(X,Q,j,q,G,O,b,F),j}static computeConvOutputShape(X,Q,q,G,O,b,F){if(X.length<=0||Q.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");const j=[X[0],Q[0]];return nt.computeShapeHelper(!1,X,j,q,G,O,b,F),j}static computeShapeHelper(X,Q,q,G,O,b,F,j){if(X)for(let W=0;W<Q.length-2;W++)q.push(1);else for(let W=0;W<Q.length-2;W++)q.push(nt.adjustPadAndReturnShape(Q[W+2],G[W],O[W],b[W],F,W,W+Q.length-2,j))}static adjustPadAndReturnShape(X,Q,q,G,O,b,F,j){const W=q*(G-1)+1;if(!j||j==="NOTSET")return Math.floor((X+O[b]+O[F]-W)/Q+1);switch(j){case"VALID":return O[b]=0,O[F]=0,Math.floor((X-W)/Q+1);case"SAME_LOWER":case"SAME_UPPER":if(q!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{const J=((X+Q-1)/Q-1)*Q+G-X;return O[b]=Math.floor(j==="SAME_LOWER"?(J+1)/2:J/2),O[F]=J-O[b],Math.floor((X+J-G)/Q+1)}default:throw new Error("Unsupported AutoPad type")}}}U.PoolConvUtil=nt,U.GemmUtil=class{static getShapeOfGemmResult(K,X,Q,q,G){if(K.length!==2||Q.length!==2)throw new Error("shape need to be of size 2");let O,b,F;X?(O=K[1],b=K[0]):(O=K[0],b=K[1]);let j=-1;if(q?(F=Q[0],j=1):(F=Q[1],j=0),Q[j]!==b)throw new Error("dimension mismatch");if(O<=0||F<=0||b<=0)throw new Error("invalid shape specified");if(G&&!tt.isValidBroadcast(G,[O,F]))throw new Error("gemm: invalid bias shape for broadcast");return[O,F,b]}},U.MIN_CLIP=-34028234663852886e22,U.MAX_CLIP=34028234663852886e22},387:(dt,U)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.createAttributeWithCacheKey=void 0;class rt{constructor(Y){Object.assign(this,Y)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map(Y=>`${this[Y]}`).join(";")),this._cacheKey}}U.createAttributeWithCacheKey=tt=>new rt(tt)},7771:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.createGpuDataManager=void 0;const tt=rt(4955),Y=rt(1163),nt=Q=>16*Math.ceil(Q/16);let K=0;class X{constructor(q){this.backend=q,this.storageCache=new Map,this.downloadCache=new Map,this.buffersForUploadingPending=[],this.buffersPending=[]}upload(q,G){const O=G.buffer,b=G.byteOffset,F=G.byteLength,j=nt(F),W=this.storageCache.get(q);if(!W)throw new Error("gpu data for uploading does not exist");if(W.originalSize!==F)throw new Error(`inconsistent data size. gpu data size=${W.originalSize}, data size=${F}`);const J=this.backend.device.createBuffer({mappedAtCreation:!0,size:j,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),et=J.getMappedRange();new Uint8Array(et).set(new Uint8Array(O,b,F)),J.unmap();const ot=this.backend.getCommandEncoder();this.backend.endComputePass(),ot.copyBufferToBuffer(J,0,W.gpuData.buffer,0,j),(0,tt.LOG_DEBUG)("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${q})`),this.buffersForUploadingPending.push(J)}memcpy(q,G){const O=this.storageCache.get(q);if(!O)throw new Error("source gpu data for memcpy does not exist");const b=this.storageCache.get(G);if(!b)throw new Error("destination gpu data for memcpy does not exist");if(O.originalSize!==b.originalSize)throw new Error("inconsistent source and destination gpu data size");const F=nt(O.originalSize);this.backend.getCommandEncoder().copyBufferToBuffer(O.gpuData.buffer,0,b.gpuData.buffer,0,F)}create(q,G=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){const O=nt(q),b=this.backend.device.createBuffer({size:O,usage:G}),F={id:K++,type:Y.GpuDataType.default,buffer:b};return this.storageCache.set(F.id,{gpuData:F,originalSize:q}),(0,tt.LOG_DEBUG)("verbose",()=>`[WebGPU] GpuDataManager.create(size=${q}) => id=${F.id}`),F}get(q){var G;return(G=this.storageCache.get(q))===null||G===void 0?void 0:G.gpuData}release(q){const G=this.storageCache.get(q);if(!G)throw new Error("releasing data does not exist");return(0,tt.LOG_DEBUG)("verbose",()=>`[WebGPU] GpuDataManager.release(id=${q}), gpuDataId=${G.gpuData.id}`),this.storageCache.delete(q),this.buffersPending.push(G.gpuData.buffer),this.downloadCache.get(q)&&this.downloadCache.delete(q),G.originalSize}async download(q){const G=this.downloadCache.get(q);if(G)return G.data;const O=this.storageCache.get(q);if(!O)throw new Error("data does not exist");const b=this.backend.getCommandEncoder();this.backend.endComputePass();const F=this.backend.device.createBuffer({size:O.originalSize,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});b.copyBufferToBuffer(O.gpuData.buffer,0,F,0,O.originalSize),this.backend.flush();const j=new Promise(W=>{F.mapAsync(GPUMapMode.READ).then(()=>{const J=F.getMappedRange().slice(0);F.destroy(),W(J)})});return this.downloadCache.set(q,{data:j}),j}refreshPendingBuffers(){for(const q of this.buffersForUploadingPending)q.destroy();for(const q of this.buffersPending)q.destroy()}}U.createGpuDataManager=(...Q)=>new X(...Q)},8510:function(dt,U,rt){var tt=this&&this.__createBinding||(Object.create?function(F,j,W,J){J===void 0&&(J=W);var et=Object.getOwnPropertyDescriptor(j,W);et&&!("get"in et?!j.__esModule:et.writable||et.configurable)||(et={enumerable:!0,get:function(){return j[W]}}),Object.defineProperty(F,J,et)}:function(F,j,W,J){J===void 0&&(J=W),F[J]=j[W]}),Y=this&&this.__setModuleDefault||(Object.create?function(F,j){Object.defineProperty(F,"default",{enumerable:!0,value:j})}:function(F,j){F.default=j}),nt=this&&this.__importStar||function(F){if(F&&F.__esModule)return F;var j={};if(F!=null)for(var W in F)W!=="default"&&Object.prototype.hasOwnProperty.call(F,W)&&tt(j,F,W);return Y(j,F),j};Object.defineProperty(U,"__esModule",{value:!0}),U.WEBGPU_OP_RESOLVE_RULES=void 0;const K=nt(rt(504)),X=rt(9770),Q=rt(4271),q=rt(1522),G=nt(rt(5262)),O=rt(2625),b=nt(rt(9302));U.WEBGPU_OP_RESOLVE_RULES=new Map([["Abs",[b.abs]],["Acos",[b.acos]],["Acosh",[b.acosh]],["Add",[K.add]],["Asin",[b.asin]],["Asinh",[b.asinh]],["Atan",[b.atan]],["Atanh",[b.atanh]],["AveragePool",[G.averagePool,G.parseAveragePoolAttributes]],["Ceil",[b.ceil]],["ClipV10",[b.clipV10]],["Clip",[b.clip]],["Conv",[X.conv,X.parseConvAttributes]],["Cos",[b.cos]],["Cosh",[b.cosh]],["Div",[K.div]],["Elu",[b.elu,b.parseAlphaAttributes]],["Erf",[b.erf]],["Exp",[b.exp]],["Floor",[b.floor]],["Gemm",[Q.gemm,Q.parseGemmAttributes]],["GlobalAveragePool",[G.globalAveragePool,G.parseGlobalAveragePoolAttributes]],["GlobalMaxPool",[G.globalMaxPool,G.parseGlobalMaxPoolAttributes]],["LeakyRelu",[b.leakyRelu,b.parseAlphaAttributes]],["MatMul",[q.matMul]],["MaxPool",[G.maxPool,G.parseMaxPoolAttributes]],["Mul",[K.mul]],["Neg",[b.neg]],["Pow",[K.pow]],["Reciprocal",[b.reciprocal]],["Relu",[b.relu]],["Sigmoid",[b.sigmoid]],["Sin",[b.sin]],["Sinh",[b.sinh]],["Sqrt",[b.sqrt]],["Sub",[K.sub]],["Tan",[b.tan]],["Tanh",[b.tanh]],["ThresholdedRelu",[b.thresholdedRelu,b.parseAlphaAttributes]],["Transpose",[O.transpose,O.parseTransposeAttributes]]])},1427:(dt,U)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.biasActivationSnippet=U.activationFnSnippet=U.typeSnippet=void 0,U.typeSnippet=rt=>{switch(rt){case 1:return"f32";case 2:return"vec2<f32>";case 3:return"vec3<f32>";case 4:return"vec4<f32>";default:throw new Error(`${rt}-component is not supported.`)}},U.activationFnSnippet=(rt,tt=!1,Y=!1,nt=3)=>"",U.biasActivationSnippet=(rt,tt)=>`
      ${rt?"value = value + getBiasByOutputCoords(coords);":""}
      ${tt?"value = activation(value, coords);":""}
      `},9456:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.createConv2DMatMulProgramInfo=void 0;const tt=rt(4955),Y=rt(6952),nt=rt(1163),K=rt(1427),X=rt(4085),Q=rt(158);U.createConv2DMatMulProgramInfo=(q,G,O,b,F,j,W,J,et)=>{const ot=O.format==="NHWC",it=ot?q[0].dims[3]:q[0].dims[1],at=b[0],st=ot?b[2]:b[3],lt=ot?b[1]:b[2],ct=ot?b[3]:b[1],pt=((it%4==0||it%3==0)&&ot||st%4==0&&!ot)&&ct%4==0,ut=ot?ct:st*lt,ft=ot?st*lt:ct,gt=pt?[8,8,1]:[ut<=4?4:16,ut>4&&ft<=4?4:16,1],_t=pt?[4,4,1]:[ut<=4?1:2,ut>4&&ft<=4?1:2,1],vt=[Math.ceil(ut/gt[0]/_t[0]),Math.ceil(ft/gt[1]/_t[1]),Math.ceil(at/gt[2]/_t[1])];(0,tt.LOG_DEBUG)("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${vt}`);const bt=pt?ot&&it%4!=0?3:4:_t[0],St=gt[1]*_t[1],yt=gt[0]*_t[0],wt=Math.max(gt[0]*bt,gt[1]),Dt=F%St==0,Pt=j%yt==0,Ft=W%wt==0,Rt=pt?[bt,4,4]:[1,1,1],Bt=[`@group(0) @binding(0) var<storage, read> x: array<${pt&&bt===4?"vec4<f32>":"f32"}>;`,`@group(0) @binding(1) var<storage, read> w: array<${pt?"vec4<f32>":"f32"}>;`];let Vt=`
      fn setOutputAtIndex(flatIndex : i32, value : ${pt?"vec4<f32>":"f32"}) {
        result[flatIndex] = ${pt?"vec4<f32>":"f32"}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${pt?"vec4<f32>":"f32"}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${pt?"/ 4":""}, value);
      }`;return J&&(Bt.push(`@group(0) @binding(2) var<storage, read> bias: array<${pt?"vec4<f32>":"f32"}>;`),Vt+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${pt?"vec4<f32>":"f32"} {
          return bias[coords.${ot?"w":"y"}${pt?"/ 4":""}];
        }`),Object.assign(Object.assign({},G),{outputs:[{dims:b,dataType:q[0].dataType,gpuDataType:nt.GpuDataType.default}],dispatchGroup:()=>({x:vt[0],y:vt[1],z:vt[2]}),getShaderSource:()=>`
        ${X.utilFunctions}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${Bt.join("")}
        @group(0) @binding(${Bt.length}) var<storage, read_write> result: array<${pt?"vec4<f32>":"f32"}>;
        //@group(0) @binding(${Bt.length+1}) var<uniform> uniforms: Uniforms;

        const xShape : vec4<i32> = vec4<i32>(${q[0].dims.join(",")});
        const wShape : vec4<i32> = vec4<i32>(${q[1].dims.join(",")});
        const outShape : vec4<i32> = vec4<i32>(${b.join(",")});
        const outShapeStrides : vec3<i32> = vec3<i32>(${Y.ShapeUtil.computeStrides(b).slice(0,3).join(",")});
        const filterDims : vec2<i32> = vec2<i32>(${O.kernelShape[0]}, ${O.kernelShape[1]});
        const pad : vec2<i32> = vec2<i32>(${O.pads[0]}, ${O.pads[1]});
        const stride : vec2<i32> = vec2<i32>(${O.strides[0]}, ${O.strides[1]});
        const dilation : vec2<i32> = vec2<i32>(${O.dilations[0]}, ${O.dilations[1]});
        const dimAOuter : i32 = ${F};
        const dimBOuter : i32 = ${j};
        const dimInner : i32 = ${W};
        ${Vt}
        ${((jt,qt,Kt,Gt,Qt=!1,zt,ne=!1,Zt=4,re=4,Xt=4)=>{const se=jt?`
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    `:`
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `,fe=jt?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,ye=jt?"xShape[1]":"xShape[2]",ve=jt?"xShape[2]":"xShape[3]",we=jt?"row":"col",_e=jt?"col":"row",oe=`
    let inChannels = wShape[2];
    let outWidth = ${jt?"outShape[2]":"outShape[3]"};
    let outRow = ${we} / outWidth;
    let outCol = ${we} % outWidth;

    let WRow = ${_e} / (filterDims[1] * inChannels);
    let WCol = ${_e} / inChannels % filterDims[1];
    let xRow = outRow * stride[0] + dilation[0] * WRow - pad[0];
    let xCol = outCol * stride[1] + dilation[1] * WCol - pad[1];
    let xCh = ${_e} % inChannels;
    var resData = ${(0,K.typeSnippet)(Zt)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${ye} && xCol >= 0 && xCol < ${ve}) {
      ${se}
      let xIndex = getIndexFromCoords4D(coord, xShape);
      ${(Te=>{switch(Te){case 1:return"resData = x[xIndex];";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${Te} is not supported.`)}})(Zt)}
    }
    return resData;`,ge=jt?qt&&Gt?`
    let col = colIn * ${Zt};
    ${oe}`:`
    let col = colIn * ${Zt};
    if (row < dimAOuter && col < dimInner) {
      ${oe}
    }
    return ${(0,K.typeSnippet)(Zt)}(0.0);`:Gt&&Kt?`
    let col = colIn * ${Zt};
    ${oe}`:`
    let col = colIn * ${Zt};
    if (row < dimInner && col < dimBOuter) {
      ${oe}
    }
    return ${(0,K.typeSnippet)(Zt)}(0.0);`,ue=`${(Te=>{switch(Te){case 1:return"return w[row * wShape[3] + colIn];";case 4:return"return w[row * wShape[3] / 4 + colIn];";default:throw new Error(`innerElementSize ${Te} is not supported.`)}})(re)}`,le=(0,K.typeSnippet)(Xt),Ee=jt?(0,K.typeSnippet)(Zt):(0,K.typeSnippet)(re),Pe=jt?(0,K.typeSnippet)(re):(0,K.typeSnippet)(Zt);return`
    ${(0,K.activationFnSnippet)(zt,ne,Xt===4,4)}
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${Ee} {
      ${jt?ge:ue}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${Pe} {
      ${jt?ue:ge}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${le}) {
      let col = colIn * ${Xt};
      if (row < dimAOuter && col < dimBOuter)
      {
      var value = valueIn;
      let outWidth = ${jt?"outShape[2]":"outShape[3]"};
      ${fe}
      ${(0,K.biasActivationSnippet)(Qt,zt)}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`})(ot,Dt,Pt,Ft,J,void 0,!1,Rt[0],Rt[1],Rt[2])}
            ${pt?(0,Q.makeMatMulPackedVec4Source)(_t,gt,!ot,wt):(0,Q.makeMatMulPackedSource)(_t,gt,!ot,wt,!1,void 0,et)}`})}},4085:(dt,U)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.utilFunctions=void 0,U.utilFunctions=`
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    outShapeStrides.x, outShapeStrides.y, outShapeStrides.z, 1));
}
`},158:(dt,U)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.makeMatMulPackedSource=U.makeMatMulPackedVec4Source=void 0,U.makeMatMulPackedVec4Source=(tt,Y,nt=!1,K=32,X=!1,Q=32,q=!1)=>{const G=Y[1]*tt[1],O=Y[0]*tt[0],b=nt?G:K,F=nt?K:G,j=b/Y[0],W=K/Y[1];if((!nt||j!==4||tt[1]!==4)&&(nt||j!==3&&j!==4)||b%Y[0]!=0||K%Y[1]!=0||tt[0]!==4)throw new Error(`If transposeA ${nt} is true, innerElementSize ${j} and workPerThread[1] ${tt[1]} must be 4.
      Otherwise, innerElementSize ${j} must be 3 or 4.
  tileAWidth ${b} must be divisible by workgroupSize[0]${Y[0]}. tileInner ${K} must be divisible by workgroupSize[1] ${Y[1]}. colPerThread ${tt[0]} must be 4.`);return`
var<workgroup> mm_Asub : array<array<vec${j}<f32>, ${b/j}>, ${F}>;
var<workgroup> mm_Bsub : array<array<vec4<f32>, ${O/tt[0]}>, ${K}>;

const rowPerThread = ${tt[1]};
const colPerThread = ${tt[0]};
const innerElementSize = ${j};
const tileInner = ${K};

@compute @workgroup_size(${Y[0]}, ${Y[1]}, ${Y[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = ${q?"0":"localRow * rowPerThread"};
  let tileCol = i32(localId.x);

  let globalRow = ${q?"0":"i32(globalId.y) * rowPerThread"};
  let globalCol = i32(globalId.x);
  let batch = ${X?"0":"i32(globalId.z)"};
  let globalRowStart = i32(workgroupId.y) * ${G};

  let numTiles = ${X?`${Math.ceil(Q/K)}`:"(dimInner - 1) / tileInner + 1"};
  var kStart = ${X?`i32(globalId.z) * ${Q}`:"0"};

  var acc: array<vec4<f32>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${W};
  for (var t = 0; t < numTiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${J=nt,J?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol);
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol);
        `}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${W}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol);
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${j===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${((et,ot)=>et?`
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${ot===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${ot===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`:`
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${ot===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}
        }`)(nt,j)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`;var J};const rt=tt=>tt?`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol);
            `:`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol);
            `;U.makeMatMulPackedSource=(tt,Y,nt=!1,K=32,X=!1,Q=32,q=!1)=>{const G=tt[1]*Y[1],O=tt[0]*Y[0],b=nt?G:K,F=nt?K:G;if(F%Y[1]!=0||b%Y[0]!=0||K%Y[1]!=0)throw new Error(`tileAHight ${F} must be divisible by workgroupSize[1]${Y[1]}, tileAWidth ${b} must be divisible by workgroupSize[0]${Y[0]}, tileInner ${K} must be divisible by workgroupSize[1]${Y[1]}`);const j=F/Y[1],W=b/Y[0],J=K/Y[1],et=q?`
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${G};
    let globalColStart = i32(workgroupId.x) * ${O};

    // Loop over shared dimension.
    for (var t = 0; t < numTiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${F}; inputRow = inputRow + ${Y[1]}) {
        for (var inputCol = localCol; inputCol < ${b}; inputCol = inputCol + ${Y[0]}) {
          ${rt(nt)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${K}; inputRow = inputRow + ${Y[1]}) {
            for (var inputCol = localCol; inputCol < ${O}; inputCol = inputCol + ${Y[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol);
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<f32, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${Y[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${nt?`mm_Asub[k][localRow + innerRow * ${Y[1]}];`:`mm_Asub[localRow + innerRow * ${Y[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${Y[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${Y[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    `:`
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${G};

let tileRowA = i32(localId.y) * ${j};
let tileColA = i32(localId.x) * ${W};
let tileRowB = i32(localId.y) * ${J};
// Loop over shared dimension.
for (var t = 0; t < numTiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${j}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${W}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${rt(nt)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${J}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol);
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<f32, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${(ot=>ot?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];")(nt)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;return`
  var<workgroup> mm_Asub : array<array<f32, ${b}>, ${F}>;
  var<workgroup> mm_Bsub : array<array<f32, ${O}>, ${K}>;
  const rowPerThread = ${tt[1]};
  const colPerThread = ${tt[0]};
  const tileInner = ${K};

@compute @workgroup_size(${Y[0]}, ${Y[1]}, ${Y[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${X?"0":"i32(globalId.z)"};
    let numTiles = ${X?`${Math.ceil(Q/K)}`:"(dimInner - 1) / tileInner + 1"};
    var kStart = ${X?`i32(globalId.z) * ${Q}`:"0"};

    var acc : array<array<f32, colPerThread>, rowPerThread>;

    // Without this initialization strange values show up in acc.
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = 0.0;
      }
    }
    ${et}
  }
`}},504:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.sub=U.pow=U.mul=U.div=U.add=void 0;const tt=rt(6952),Y=rt(1163),nt=rt(2075),K=(X,Q,q,G,O)=>{const b={name:Q,inputTypes:[Y.GpuDataType.default,Y.GpuDataType.default],cacheHint:O};return Object.assign(Object.assign({},b),{get:()=>((F,j,W,J,et,ot=j.dataType)=>{var it,at;const st=!tt.ShapeUtil.areEqual(j.dims,W.dims);let lt=j.dims,ct=tt.ShapeUtil.size(j.dims),pt=!1;if(st){const ut=tt.BroadcastUtil.calcShape(j.dims,W.dims,!1);if(!ut)throw new Error("Can't perform binary op on the given tensors");lt=ut,ct=tt.ShapeUtil.size(lt);let ft=1;for(let gt=0;gt<lt.length;gt++){const _t=(it=j.dims[j.dims.length-gt])!==null&&it!==void 0?it:1;if(_t!==((at=W.dims[W.dims.length-gt])!==null&&at!==void 0?at:1))break;ft*=_t}ft%4==0&&(pt=!0)}else pt=!0;return Object.assign(Object.assign({},F),{getShaderSource:ut=>((ft,gt,_t,vt,bt,St,yt,wt,Dt="f32",Pt="f32",Ft="f32")=>{const Rt=tt.ShapeUtil.size(vt),Bt=Math.ceil(Rt/4);let Vt,jt;typeof yt=="string"?Vt=jt=(Qt,zt)=>`${yt}((${Qt}),(${zt}))`:typeof yt=="function"?Vt=jt=yt:(Vt=yt.scalar,jt=yt.vector);let qt="";const Kt=(0,nt.createIndicesHelper)("output",vt);if(St){const Qt=zt=>{const ne=tt.ShapeUtil.computeStrides(zt),Zt=[];for(let re=zt.length-1;re>=0;re--){const Xt=vt.length===0?"0u":vt.length===1?"(*outputIndices)":`(*outputIndices)[${re+vt.length-zt.length}]`;Zt.push(`${ne[re]}u * (${Xt} % ${zt[re]}u)`)}return Zt.length>0?Zt.join("+"):"0u"};qt=`
  ${Kt.o2iImpl}

  fn calcOffsetA(outputIndices: ptr<function, ${Kt.iType}>) -> u32 {
    return ${Qt(gt)};
  }

  fn calcOffsetB(outputIndices: ptr<function, ${Kt.iType}>) -> u32 {
    return ${Qt(_t)};
  }
  `}let Gt;if(bt)Gt=St?`
      ${Kt.indicesVariableDeclaration("outputIndices")}
      ${Kt.o2iCall("global_idx * 4u","outputIndices")}
      let offsetA = calcOffsetA(&outputIndices);
      let offsetB = calcOffsetB(&outputIndices);
      outputData[global_idx] = ${jt("aData[offsetA / 4u]","bData[offsetB / 4u]")};`:`outputData[global_idx] = ${jt("aData[global_idx]","bData[global_idx]")};`;else{if(!St)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");const Qt=zt=>{const ne=`aData[indexA${zt}][componentA${zt}]`,Zt=`bData[indexB${zt}][componentB${zt}]`;return`
      ${Kt.o2iCall(`global_idx * 4u + ${zt}u`,"outputIndices")}
      let offsetA${zt} = calcOffsetA(&outputIndices);
      let offsetB${zt} = calcOffsetB(&outputIndices);
      let indexA${zt} = offsetA${zt} / 4u;
      let indexB${zt} = offsetB${zt} / 4u;
      let componentA${zt} = offsetA${zt} % 4u;
      let componentB${zt} = offsetB${zt} % 4u;
      outputData[global_idx][${zt}] = ${Vt(ne,Zt)};`};Gt=`
      ${Kt.indicesVariableDeclaration("outputIndices")}
      ${Qt(0)}
      ${Qt(1)}
      ${Qt(2)}
      ${Qt(3)}`}return`
  @group(0) @binding(0) var<storage, read> aData : array<vec4<${Dt}>>;
  @group(0) @binding(1) var<storage, read> bData : array<vec4<${Pt}>>;
  @group(0) @binding(2) var<storage, read_write> outputData : array<vec4<${Ft}>>;

  ${wt??""}
  ${qt}

  ${ft.mainStart()}
    ${ft.guardAgainstOutOfBoundsWorkgroupSizes(Bt)}
    ${Gt}
  }`})(ut,j.dims,W.dims,lt,pt,st,J,et),outputs:[{dims:lt,dataType:ot,gpuDataType:Y.GpuDataType.default}],dispatchGroup:()=>({x:Math.ceil(ct/64/(pt?4:1))})})})(b,X[0],X[1],q,G)})};U.add=X=>{X.compute(K(X.inputs,"Add",(Q,q)=>`${Q}+${q}`))},U.div=X=>{X.compute(K(X.inputs,"Div",(Q,q)=>`${Q}/${q}`))},U.mul=X=>{X.compute(K(X.inputs,"Mul",(Q,q)=>`${Q}*${q}`))},U.pow=X=>{X.compute(K(X.inputs,"Pow",{scalar:(Q,q)=>`pow_f32(${Q},${q})`,vector:(Q,q)=>`pow_vf32(${Q},${q})`},`
    fn pow_f32(a : f32, b : f32) -> f32 {
      if (b == 0.0) {
        return 1.0;
      } else if (a < 0.0 && b != floor(b)) {
        return pow(a, b); // NaN
      }
      return select(sign(a), 1.0, round(abs(b) % 2.0) != 1.0) * pow(abs(a), b);
    }
    fn pow_vf32(a : vec4<f32>, b : vec4<f32>) -> vec4<f32> {
      // TODO: implement vectorized pow
      return vec4<f32>(pow_f32(a.x, b.x), pow_f32(a.y, b.y), pow_f32(a.z, b.z), pow_f32(a.w, b.w));
    }
      `))},U.sub=X=>{X.compute(K(X.inputs,"Sub",(Q,q)=>`${Q}-${q}`))}},2075:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.createShaderHelper=U.createIndicesHelper=U.WORKGROUP_SIZE=void 0;const tt=rt(6952);U.WORKGROUP_SIZE=64,U.createIndicesHelper=(nt,K)=>{const X=K.length<2?"u32":`array<u32, ${K.length}>`,Q=tt.ShapeUtil.computeStrides(K);let q="";for(let b=0;b<K.length-1;b++)q+=`
    let dim${b} = current / ${Q[b]}u;
    let rest${b} = current % ${Q[b]}u;
    (*indices)[${b}] = dim${b};
    current = rest${b};
    `;q+=`(*indices)[${K.length-1}] = current;`;const G=K.length<2?"":`
  fn ih_o2i_${nt}(offset: u32, indices: ptr<function, ${X}>) {
    var current = offset;
    ${q}
  }`,O=[];if(K.length===0)O.push("0u");else if(K.length<2)O.push("(*indices)");else for(let b=K.length-1;b>=0;b--)O.push(`${Q[b]}u * ((*indices)[${b}])`);return{o2iImpl:G,o2iCall:(b,F)=>K.length<2?`${F}=${b};`:`ih_o2i_${nt}(${b}, &${F});`,i2oImpl:K.length<2?"":`
  fn ih_i2o_${nt}(indices: ptr<function, ${X}>) -> u32 {
    return ${O.join("+")};
  }`,i2oExpression:(b,F)=>K.length<2?`(${F?"*":""}${b})`:`ih_i2o_${nt}(${F?"":"&"}${b})`,indicesVariableDeclaration:(b,F)=>`var ${b}:${X}${F?`=${X}(${F.join(",")})`:""};`,iType:X}};class Y{constructor(K){this.normalizedDispatchGroup=K}guardAgainstOutOfBoundsWorkgroupSizes(K){return`if (global_idx >= ${typeof K=="number"?`${K}u`:K}) { return; }`}mainStart(K=U.WORKGROUP_SIZE){const X=typeof K=="number"?K:K[0],Q=typeof K=="number"?1:K[1],q=typeof K=="number"?1:K[2],G=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1;return`@compute @workgroup_size(${X}, ${Q}, ${q})
  fn main(${G?"@builtin(global_invocation_id) global_id : vec3<u32>":`@builtin(local_invocation_index) local_index : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>`}) {
    ${G?"let global_idx = global_id.x;":`let global_idx = (workgroup_id.z * ${this.normalizedDispatchGroup[0]*this.normalizedDispatchGroup[1]}u +
          workgroup_id.y * ${this.normalizedDispatchGroup[0]}u + workgroup_id.x) * ${X*Q*q}u + local_index;`}
  `}}U.createShaderHelper=nt=>new Y(nt)},9192:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.createGroupedConvProgramInfoLoader=void 0;const tt=rt(6952),Y=rt(1163),nt=rt(2075),K=rt(9770),X=rt(3997);U.createGroupedConvProgramInfoLoader=(Q,q,G)=>{const O=(b=Q.length>2,F=q.cacheKey,{name:"GroupedConv",inputTypes:b?[Y.GpuDataType.default,Y.GpuDataType.default,Y.GpuDataType.default]:[Y.GpuDataType.default,Y.GpuDataType.default],cacheHint:F});var b,F;return Object.assign(Object.assign({},O),{get:()=>((j,W,J,et)=>{const ot=j.length>2,it=ot?"value += b[output_channel];":"",at=j[0].dims,st=j[1].dims,lt=st[0]/J.group,ct="f32",{activationFunction:pt,applyActivation:ut}=(0,X.getActicationSnippet)(J),ft=[`@group(0) @binding(0) var<storage, read> x : array<${ct}>;`,`@group(0) @binding(1) var<storage, read> w : array<${ct}>;`];ot&&ft.push(`@group(0) @binding(2) var<storage, read> b : array<${ct}>;`);const gt=J.format==="NHWC",_t=(0,K.calculateOutputShape)(at,st,J.dilations,J.pads,J.strides,gt),vt=tt.ShapeUtil.size(_t),bt=(0,nt.createIndicesHelper)("output",_t),St=(0,nt.createIndicesHelper)("x",at),yt=(0,nt.createIndicesHelper)("w",st);return Object.assign(Object.assign({},W),{outputs:[{dims:et?et(_t):_t,dataType:j[0].dataType,gpuDataType:Y.GpuDataType.default}],getShaderSource:wt=>`
  const strides: vec2<u32> = vec2(${J.strides[0]}u, ${J.strides[1]}u);
  const pads: vec2<u32> = vec2(${J.pads[0]}u, ${J.pads[1]}u);

  ${ft.join(`
`)}
  @group(0) @binding(${ft.length}) var<storage, read_write> output : array<${ct}>;

  ${pt}
  ${bt.o2iImpl}
  ${St.i2oImpl}
  ${yt.i2oImpl}

  ${wt.mainStart()}
    ${wt.guardAgainstOutOfBoundsWorkgroupSizes(vt)}

    ${bt.indicesVariableDeclaration("outputIndices")}
    ${bt.o2iCall("global_idx","outputIndices")}
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${gt?3:1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${gt?1:2}], outputIndices[${gt?2:3}]) * strides - pads;
    let group_id: u32 = output_channel / ${lt}u;

    var value: ${ct} = ${ct}(0);
    for (var wInChannel: u32 = 0u; wInChannel < ${st[1]}u; wInChannel++) {
      let input_channel = group_id * ${st[1]}u + wInChannel;
      for (var wHeight: u32 = 0u; wHeight < ${st[2]}u; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * ${J.dilations[0]}u;

        if (xHeight < 0u || xHeight >= ${at[gt?1:2]}u) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < ${st[3]}u; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * ${J.dilations[1]}u;
          if (xWidth < 0u || xWidth >= ${at[gt?2:3]}u) {
            continue;
          }

          ${St.indicesVariableDeclaration("xIndices",gt?["batch","xHeight","xWidth","input_channel"]:["batch","input_channel","xHeight","xWidth"])}
          let xVal = x[${St.i2oExpression("xIndices")}];
          ${yt.indicesVariableDeclaration("wIndices",["output_channel","wInChannel","wHeight","wWidth"])}
          let wVal = w[${yt.i2oExpression("wIndices")}];
          value += xVal*wVal;
        }
      }
    }
    ${it}
    ${ut}
    output[global_idx] = value;
  }`,dispatchGroup:()=>({x:Math.ceil(vt/64)})})})(Q,O,q,G)})}},9770:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.conv=U.parseConvAttributes=U.calculateOutputShape=void 0;const tt=rt(6952),Y=rt(387),nt=rt(9192),K=rt(3822),X=rt(3997),Q=rt(2625);U.calculateOutputShape=(O,b,F,j,W,J)=>{const et=O[0],ot=O.slice(J?1:2,J?3:4),it=ot.length,at=b[0],st=b.slice(2).map((ct,pt)=>ct+(ct-1)*(F[pt]-1)),lt=ot.map((ct,pt)=>ct+j[pt]+j[pt+it]).map((ct,pt)=>Math.floor((ct-st[pt]+W[pt])/W[pt]));return lt.splice(0,0,et),lt.splice(J?3:1,0,at),lt};const q=(0,Y.createAttributeWithCacheKey)({perm:[2,3,1,0]}),G=(O,b)=>{const F=O.kernelShape.slice();for(let J=2;J<b[1].dims.length;++J)F[J-2]===0&&(F[J-2]=b[1].dims[J]);const j=O.pads.slice();tt.PoolConvUtil.adjustPadsBasedOnAutoPad(b[0].dims,O.strides,O.dilations,F,j,O.format==="NHWC",O.autoPad);const W=Object.assign({},O);return Object.assign(W,{kernelShape:F,pads:j,cacheKey:O.cacheKey}),W};U.parseConvAttributes=O=>{const b=(0,X.parseInternalActivationAttributes)(O),F=O.format,j=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][O.auto_pad],W=O.dilations,J=O.group,et=O.kernel_shape,ot=O.pads,it=O.strides,at=O.w_is_const();return(0,Y.createAttributeWithCacheKey)(Object.assign({autoPad:j,format:F,dilations:W,group:J,kernelShape:et,pads:ot,strides:it,wIsConst:at},b))},U.conv=(O,b)=>{((F,j)=>{if(!F||F.length!==2&&F.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(F[0].dims.length!==4&&F[0].dims.length!==3)throw new Error("currently only support conv 1D and 2D");if(F[0].dims.length!==F[1].dims.length)throw new Error("filter does not have same dimension as input");if(F[0].dims[j.format==="NHWC"?F[0].dims.length-1:1]!==F[1].dims[1]*j.group)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(F.length===3&&(F[2].dims.length!==1||F[1].dims[0]!==F[2].dims[0]))throw new Error("invalid bias");const W=F[0].dims.length-2;if(j.dilations.length!==W)throw new Error(`dilations should be ${W}D`);if(j.strides.length!==W)throw new Error(`strides should be ${W}D`);if(j.pads.length!==2*W)throw new Error(`pads should be ${2*W}D`);if(j.kernelShape.length!==0&&j.kernelShape.length!==F[1].dims.length-2)throw new Error("invalid kernel shape");if(F[0].dataType!==1||F[1].dataType!==1)throw new Error("Conv input(X,W) should be float tensor");if(F.length===3&&F[2].dataType!==1)throw new Error("Conv input(bias) should be float tensor")})(O.inputs,b),O.inputs[0].dims.length===3?((F,j)=>{const W=j.format==="NHWC",J=[F.inputs[0].reshape(W?[F.inputs[0].dims[0],1,F.inputs[0].dims[1],F.inputs[0].dims[2]]:[F.inputs[0].dims[0],F.inputs[0].dims[1],1,F.inputs[0].dims[2]]),F.inputs[1].reshape([F.inputs[1].dims[0],F.inputs[1].dims[1],1,F.inputs[1].dims[2]])];F.inputs.length===3&&J.push(F.inputs[2]);const et=[0,j.pads[0],0,j.pads[1]],ot=[1].concat(j.strides),it=[1].concat(j.dilations),at=[1].concat(j.kernelShape),st=G(Object.assign(Object.assign({},j),{pads:et,strides:ot,dilations:it,kernelShape:at}),J);F.compute((0,nt.createGroupedConvProgramInfoLoader)(J,st,lt=>W?[lt[0],lt[2],lt[3]]:[]))})(O,b):((F,j,W)=>{var J;const et=G(W,j),ot=j.length===3,it=W.format==="NHWC",at=j[0].dims[it?1:2],st=j[0].dims[it?2:3],lt=j[0].dims[it?3:1],ct=j[1].dims[2],pt=j[1].dims[3],ut=(0,U.calculateOutputShape)(j[0].dims,j[1].dims,W.dilations,et.pads,W.strides,it),ft=ut[it?1:2],gt=ut[it?2:3],_t=ut[it?3:1];if(it&&ct===at&&pt===st&&W.autoPad==="VALID"||ct===1&&pt===1&&W.dilations[0]===1&&W.dilations[1]===1&&W.strides[0]===1&&W.strides[1]===1&&(W.autoPad==="SAME_UPPER"||W.autoPad==="SAME_LOWER"||W.autoPad==="VALID")||!it||W.group!==1)return void F.compute((0,nt.createGroupedConvProgramInfoLoader)(j,et));const vt=it?ft*gt:_t,bt=it?_t:ft*gt,St=ct*pt*lt,yt=(J=F.customData.wT)!==null&&J!==void 0?J:F.compute(Object.assign(Object.assign({},Q.transposeProgramMetadata),{cacheHint:q.cacheKey,get:()=>(0,Q.createTransposeProgramInfo)(j[1],q.perm)}),{inputs:[1],outputs:[W.wIsConst?-2:-1]})[0];W.wIsConst&&!F.customData.wT&&(F.customData.wT=yt);const wt=[j[0],yt];ot&&(it||j[2].dims.length!==1?wt.push(j[2]):wt.push(j[2].reshape([j[2].dims[0],1,1]))),F.compute((0,K.createConv2DMatMulProgramInfoLoader)(wt,et,ut,vt,bt,St,ot,!0),{inputs:wt})})(O,O.inputs,b)}},3822:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.createConv2DMatMulProgramInfoLoader=void 0;const tt=rt(1163),Y=rt(9456);U.createConv2DMatMulProgramInfoLoader=(nt,K,X,Q,q,G,O,b)=>{const F=((j,W)=>({name:"Conv2DMatMul",inputTypes:j?[tt.GpuDataType.default,tt.GpuDataType.default,tt.GpuDataType.default]:[tt.GpuDataType.default,tt.GpuDataType.default],cacheHint:W}))(O,K.cacheKey);return Object.assign(Object.assign({},F),{get:()=>(0,Y.createConv2DMatMulProgramInfo)(nt,F,K,X,Q,q,G,O,b)})}},3997:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.parseInternalActivationAttributes=U.getActicationSnippet=void 0;const tt=rt(6952);U.getActicationSnippet=Y=>{switch(Y.activation){case"Relu":return{activationFunction:"",applyActivation:"value = max(value, 0.0);"};case"Sigmoid":return{activationFunction:"",applyActivation:"value = (1.0 / (1.0 + exp(-value)));"};case"Clip":return{activationFunction:`const clip_min_=f32(${Y.clipMin});const clip_max_=f32(${Y.clipMax});`,applyActivation:"value = clamp(value, clip_min_, clip_max_);"};default:return{activationFunction:"",applyActivation:""}}},U.parseInternalActivationAttributes=Y=>{const nt=(Y==null?void 0:Y.activation)||"";if(nt==="Clip"){const[K,X]=(Y==null?void 0:Y.activation_params)||[tt.MIN_CLIP,tt.MAX_CLIP];return{activation:nt,clipMax:X,clipMin:K,activationCacheKey:`${nt}:${K},${X}`}}return{activation:nt,activationCacheKey:nt}}},4271:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.parseGemmAttributes=U.gemm=void 0;const tt=rt(6952),Y=rt(387),nt=rt(1163);U.gemm=(K,X)=>{(Q=>{if(!Q)throw new Error("Input is missing");if(Q.length<2||Q.length>3)throw new Error("Invaid input number.");if(Q.length===3&&Q[2].dims.length>2)throw new Error("Invalid input shape of C");if(Q[0].dataType!==1||Q[1].dataType!==1||Q.length===3&&Q[2].dataType!==1)throw new Error("Invalid input type.");if(Q[0].dataType!==Q[1].dataType||Q.length===3&&Q[0].dataType!==Q[2].dataType)throw new Error("Input types are mismatched")})(K.inputs),K.compute(((Q,q)=>{const G={name:"Gemm",inputTypes:Q.length===3?[nt.GpuDataType.default,nt.GpuDataType.default,nt.GpuDataType.default]:[nt.GpuDataType.default,nt.GpuDataType.default],cacheHint:q.cacheKey};return Object.assign(Object.assign({},G),{get:()=>((O,b,F)=>{const j=b[0].dims.slice(),W=b[1].dims.slice(),[J,et,ot]=tt.GemmUtil.getShapeOfGemmResult(j,F.transA,W,F.transB,b.length===3?b[2].dims:void 0),it=[J,et];if(!it)throw new Error("Can't use gemm on the given tensors");const at=tt.ShapeUtil.size(it);let st="";F.transA&&F.transB?st="value += a[k * M + m] * b[n * K + k];":F.transA&&!F.transB?st="value += a[k * M + m] * b[k * N + n];":!F.transA&&F.transB?st="value += a[m * K + k] * b[n * K + k];":F.transA||F.transB||(st="value += a[m * K + k] * b[k * N + n];");const lt="f32",ct=F.alpha===1?"":"value *= alpha;",pt=b.length===3?`value += beta * c[${((ft,gt,_t)=>{if(_t.length===0)return"0u";const vt=_t.length===1&&ft!==1||_t.length===2&&_t[0]!==ft,bt=_t[_t.length-1]!==gt;let St="0u";return vt||(St+=`+ m * ${_t[_t.length-1]}u`),bt||(St+="+n"),St})(J,et,b[2].dims)}];`:"",ut=[`@group(0) @binding(0) var<storage, read> a : array<${lt}>;`,`@group(0) @binding(1) var<storage, read> b : array<${lt}>;`];return b.length===3&&ut.push(`@group(0) @binding(2) var<storage, read> c : array<${lt}>;`),Object.assign(Object.assign({},O),{outputs:[{dims:it,dataType:b[0].dataType,gpuDataType:nt.GpuDataType.default}],getShaderSource:ft=>`
  const M: u32 = ${J}u;
  const N: u32 = ${et}u;
  const K: u32 = ${ot}u;
  const alpha = ${lt}(${F.alpha});
  const beta = ${lt}(${F.beta});

  ${ut.join(`
`)}
  @group(0) @binding(${b.length}) var<storage, read_write> output : array<${lt}>;

  ${ft.mainStart()}
    ${ft.guardAgainstOutOfBoundsWorkgroupSizes(at)}

    let m = global_id.x / N;
    let n = global_id.x % N;

    var value = ${lt}(0);
    for (var k: u32 = 0u; k<${ot}u; k++) {
      ${st}
    }

    ${ct}
    ${pt}
    output[global_id.x] = value;

  }`,dispatchGroup:()=>({x:Math.ceil(at/64)})})})(G,Q,q)})})(K.inputs,X))},U.parseGemmAttributes=K=>(0,Y.createAttributeWithCacheKey)(K)},1522:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.matMul=U.createMatmulProgramInfoLoader=void 0;const tt=rt(6952),Y=rt(1163),nt=rt(3997);U.createMatmulProgramInfoLoader=(K,X)=>{const Q=(q=K.length>2,G=X.activationCacheKey,{name:"MatMul",inputTypes:q?[Y.GpuDataType.default,Y.GpuDataType.default,Y.GpuDataType.default]:[Y.GpuDataType.default,Y.GpuDataType.default],cacheHint:G});var q,G;return Object.assign(Object.assign({},Q),{get:()=>((O,b,F)=>{const j=b[0].dims,W=b[1].dims,J=tt.BroadcastUtil.calcShape(j,W,!0);if(!J)throw new Error("Can't use matmul on the given tensors");const et=tt.ShapeUtil.size(J),ot="f32",{activationFunction:it,applyActivation:at}=(0,nt.getActicationSnippet)(F),st=J[J.length-2],lt=j[j.length-1],ct=J[J.length-1];return Object.assign(Object.assign({},O),{outputs:[{dims:J,dataType:b[0].dataType,gpuDataType:Y.GpuDataType.default}],getShaderSource:pt=>`
  const M: u32 = ${st}u;
  const N: u32 = ${ct}u;
  const K: u32 = ${lt}u;

  @group(0) @binding(0) var<storage, read> a : array<${ot}>;
  @group(0) @binding(1) var<storage, read> b : array<${ot}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${ot}>;

  ${it}

  ${pt.mainStart()}
    ${pt.guardAgainstOutOfBoundsWorkgroupSizes(et)}

    let stack = global_idx / (M * N);
    let mn = global_idx % (M * N);
    let n = global_idx % N;
    let m = mn / N;

    let offsetA = stack * (M * K);
    let offsetB = stack * (K * N);

    var value = ${ot}(0);
    for (var k: u32 = 0u; k<${lt}u; k++) {
      value += a[offsetA + m * K + k] * b[offsetB + k * N + n];
    }
    ${at}
    output[global_idx] = value;
  }`,dispatchGroup:()=>({x:Math.ceil(et/64)})})})(Q,K,X)})},U.matMul=K=>{(X=>{if(!X||X.length!==2)throw new Error("MatMul requires 2 inputs.");if(X[0].dims[X[0].dims.length-1]!==X[1].dims[X[1].dims.length-2])throw new Error("shared dimension does not match.");if(X[0].dataType!==1||X[1].dataType!==1)throw new Error("inputs should be float type")})(K.inputs),K.compute((0,U.createMatmulProgramInfoLoader)(K.inputs,{activation:"",activationCacheKey:""}))}},5262:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.globalMaxPool=U.parseGlobalMaxPoolAttributes=U.parseMaxPoolAttributes=U.maxPool=U.globalAveragePool=U.parseGlobalAveragePoolAttributes=U.averagePool=U.parseAveragePoolAttributes=void 0;const tt=rt(6952),Y=rt(387),nt=rt(1163),K=rt(2075),X=j=>{if(!j||j.length!==1)throw new Error("Pool ops requires 1 input.");if(j[0].dims.length!==4)throw new Error("Pool ops supports 2-D inputs only for now.");if(j[0].dataType!==1)throw new Error("Invalid input type.")},Q=(j,W,J)=>{const et=W.format==="NHWC",ot=et?[j[0].dims[0],j[0].dims[3],j[0].dims[1],j[0].dims[2]]:j[0].dims.slice(),it=Object.hasOwnProperty.call(W,"dilations"),at=W.kernelShape.slice(),st=W.strides.slice(),lt=it?W.dilations.slice():[],ct=W.pads.slice();tt.PoolConvUtil.adjustPoolAttributes(J,ot,at,st,lt,ct);const pt=tt.PoolConvUtil.computePoolOutputShape(J,ot,st,lt,at,ct,W.autoPad),ut=Object.assign({},W);return it?Object.assign(ut,{kernelShape:at,strides:st,pads:ct,dilations:lt,cacheKey:W.cacheKey}):Object.assign(ut,{kernelShape:at,strides:st,pads:ct,cacheKey:W.cacheKey}),[ut,et?[pt[0],pt[2],pt[3],pt[1]]:pt]},q=(j,W,J,et,ot,it,at,st)=>{const lt=et.format==="NHWC",ct=W.length,pt=tt.ShapeUtil.size(J),ut=(0,K.createIndicesHelper)("output",J),ft=(0,K.createIndicesHelper)("x",W);if(et.kernelShape.length<=2){const gt=et.kernelShape[et.kernelShape.length-1],_t=et.strides[et.strides.length-1],vt=et.pads[et.pads.length/2-1],bt=ct-(lt?2:1);let St="",yt="",wt="";if(St=vt+et.pads[et.pads.length-1]!==0?`
              for (var i: u32 = 0u; i < ${gt}u; i++) {
                xIndices[${bt}] = indices[${bt}] * ${_t} - ${vt} + i;
                if (xIndices[${bt}] < 0 || xIndices[${bt}] >= ${W[bt]}) {
                  pad++;
                  continue;
                }
                let x_val = x[${ft.i2oExpression("xIndices")}];
                ${ot}
              }`:`
              for (var i: u32 = 0u; i < ${gt}u; i++) {
                xIndices[${bt}] = indices[${bt}] * ${_t} - ${vt} + i;
                let x_val = x[${ft.i2oExpression("xIndices")}];
                ${ot}
              }`,et.kernelShape.length===2){const Dt=et.kernelShape[et.kernelShape.length-2],Pt=et.strides[et.strides.length-2],Ft=et.pads[et.pads.length/2-2],Rt=et.pads[et.pads.length-2],Bt=ct-(lt?3:2),Vt=W[Bt];yt=Ft+Rt!==0?`
                for (var j: u32 = 0u; j < ${Dt}u; j++) {
                  xIndices[${Bt}] = indices[${Bt}] * ${Pt} - ${Ft} + j;
                  if (xIndices[${Bt}] < 0 || xIndices[${Bt}] >= ${Vt}) {
                    pad+= ${gt};
                    continue;
                  }
              `:`
                for (var j: u32 = 0u; j < ${Dt}u; j++) {
                  xIndices[${Bt}] = indices[${Bt}] * ${Pt} - ${Ft} + j;
                `,wt=`
              }
            `}return`
            @group(0) @binding(0) var<storage, read> x : array<${at}>;
            @group(0) @binding(1) var<storage, read_write> output : array<${at}>;

            ${ut.o2iImpl}
            ${ft.i2oImpl}

            ${j.mainStart()}
              ${j.guardAgainstOutOfBoundsWorkgroupSizes(pt)}

              ${ut.indicesVariableDeclaration("indices")}
              ${ut.o2iCall("global_idx","indices")}
              ${ut.indicesVariableDeclaration("xIndices")}
              ${ut.o2iCall("global_idx","xIndices")}

              var value: ${at} = ${at}(${st});
              var pad = 0;
              ${yt}
              ${St}
              ${wt}
              ${it}

              output[global_idx] = value;
            }`}{if(lt)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");const gt=tt.ShapeUtil.size(et.kernelShape),_t=tt.ShapeUtil.computeStrides(et.kernelShape),vt=_t.length,bt=et.pads.length;let St="";return St=et.pads.reduce((yt,wt)=>yt+wt)?`
                if (xIndices[j] >= inputDims[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${ft.i2oExpression("xIndices")}];
                ${ot}
              }`:`
              }
              let x_val = x[${ft.i2oExpression("xIndices")}];
              ${ot}
            `,`
            @group(0) @binding(0) var<storage, read> x : array<${at}>;
            @group(0) @binding(1) var<storage, read_write> output : array<${at}>;

            ${ut.o2iImpl}
            ${ft.i2oImpl}

            const pads = array<u32, ${bt}>(${et.pads.map(yt=>`${yt}u`).join(",")});
            const inputDims = array<u32, ${ct}>(${W.map(yt=>`${yt}u`).join(",")});
            const kernelStrides = array<u32, ${vt}>(${_t.map(yt=>`${yt}u`).join(",")});
            const strides = array<u32, ${vt}>(${et.strides.map(yt=>`${yt}u`).join(",")});

            ${j.mainStart()}
              ${j.guardAgainstOutOfBoundsWorkgroupSizes(pt)}

              ${ut.indicesVariableDeclaration("indices")}
              ${ut.o2iCall("global_idx","indices")}
              ${ut.indicesVariableDeclaration("xIndices")}
              ${ut.o2iCall("global_idx","xIndices")}

              var offsets: array<u32, ${vt}>;

              var value = ${at}(${st});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < ${gt}u; i++) {
                var offset = i;
                for (var j = 0u; j < ${vt-1}u; j++) {
                  offsets[j] = offset / kernelStrides[j];
                  offset -= offsets[j] * kernelStrides[j];
                }
                offsets[${vt-1}] = offset;

                isPad = false;
                for (var j = ${ct-vt}u; j < ${ct}u; j++) {
                  xIndices[j] = indices[j] * strides[j - ${ct-vt}u]
                    + offsets[j - ${ct-vt}u] - pads[j - 2u];
                  ${St}
              }
              ${it}

              output[global_idx] = value;
            }`}},G=j=>({format:j.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][j.auto_pad],ceilMode:j.ceil_mode,kernelShape:j.kernel_shape,strides:j.strides,pads:j.pads}),O=(j,W,J,et)=>{const[ot,it]=Q(j,et,J),at=tt.ShapeUtil.size(ot.kernelShape),st="f32";let lt="";return ot.countIncludePad?lt+=`value /= ${st}(${at});`:lt+=`value /= ${st}(${at} - pad);`,Object.assign(Object.assign({},W),{outputs:[{dims:it,dataType:j[0].dataType,gpuDataType:nt.GpuDataType.default}],getShaderSource:ct=>q(ct,j[0].dims,it,ot,"value += x_val;",lt,st,"0.0"),dispatchGroup:()=>({x:Math.ceil(tt.ShapeUtil.size(it)/64)})})};U.parseAveragePoolAttributes=j=>{const W=j.count_include_pad!==0,J=G(j);if(J.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return(0,Y.createAttributeWithCacheKey)(Object.assign({countIncludePad:W},J))},U.averagePool=(j,W)=>{X(j.inputs);const J={name:"AveragePool",inputTypes:[nt.GpuDataType.default],cacheHint:W.cacheKey};j.compute(Object.assign(Object.assign({},J),{get:()=>O(j.inputs,J,!1,W)}))};const b={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""};U.parseGlobalAveragePoolAttributes=j=>{const W=j.format;return Object.assign(Object.assign({format:W},b),{cacheKey:W})},U.globalAveragePool=(j,W)=>{X(j.inputs);const J={name:"GlobalAveragePool",inputTypes:[nt.GpuDataType.default],cacheHint:W.cacheKey};j.compute(Object.assign(Object.assign({},J),{get:()=>O(j.inputs,J,!0,W)}))};const F=(j,W,J,et)=>{const[ot,it]=Q(j,et,J);return Object.assign(Object.assign({},W),{outputs:[{dims:it,dataType:j[0].dataType,gpuDataType:nt.GpuDataType.default}],getShaderSource:at=>q(at,j[0].dims,it,ot,`
      value = max(x_val, value);
    `,"","f32","-1e5"),dispatchGroup:()=>({x:Math.ceil(tt.ShapeUtil.size(it)/64)})})};U.maxPool=(j,W)=>{X(j.inputs);const J={name:"MaxPool",inputTypes:[nt.GpuDataType.default],cacheHint:W.cacheKey};j.compute(Object.assign(Object.assign({},J),{get:()=>F(j.inputs,J,!1,W)}))},U.parseMaxPoolAttributes=j=>{const W=j.storage_order,J=j.dilations,et=G(j);if(W!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(et.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return(0,Y.createAttributeWithCacheKey)(Object.assign({storageOrder:W,dilations:J},et))},U.parseGlobalMaxPoolAttributes=j=>{const W=j.format;return Object.assign(Object.assign({format:W},b),{cacheKey:W})},U.globalMaxPool=(j,W)=>{X(j.inputs);const J={name:"GlobalMaxPool",inputTypes:[nt.GpuDataType.default],cacheHint:W.cacheKey};j.compute(Object.assign(Object.assign({},J),{get:()=>F(j.inputs,J,!0,W)}))}},2625:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.parseTransposeAttributes=U.transpose=U.createTransposeProgramInfo=U.transposeProgramMetadata=void 0;const tt=rt(6952),Y=rt(387),nt=rt(1163),K=rt(2075);U.transposeProgramMetadata={name:"Transpose",inputTypes:[nt.GpuDataType.default]};const X=(Q,q)=>q&&q.length!==Q.length?[...Q.keys()].reverse():q;U.createTransposeProgramInfo=(Q,q)=>{const G=Q.dims,O=X(G,q),b=((et,ot)=>tt.ShapeUtil.sortBasedOnPerm(et,X(et,ot)))(G,O),F=G.length,j=tt.ShapeUtil.size(b),W=(0,K.createIndicesHelper)("output",b),J=(0,K.createIndicesHelper)("a",G);return Object.assign(Object.assign({},U.transposeProgramMetadata),{outputs:[{dims:b,dataType:Q.dataType,gpuDataType:nt.GpuDataType.default}],getShaderSource:et=>`
  @group(0) @binding(0) var<storage, read> a : array<f32>;
  @group(0) @binding(1) var<storage, read_write> output : array<f32>;

  ${((ot,it)=>{const at=[];at.push(`fn perm(a: ptr<function, array<u32, ${it}>>, i: ptr<function, array<u32, ${it}>>) {`);for(let st=0;st<it;++st)at.push(`	(*a)[${ot[st]}]=(*i)[${st}];`);return at.push("	}"),at.join(`
`)})(O,F)}
  ${W.o2iImpl}
  ${J.i2oImpl}

  ${et.mainStart()}
    ${et.guardAgainstOutOfBoundsWorkgroupSizes(j)}

    ${W.indicesVariableDeclaration("indices")}
    ${W.o2iCall("global_idx","indices")}
    ${J.indicesVariableDeclaration("aIndices")}
    perm(&aIndices, &indices);

    output[global_idx] = a[${J.i2oExpression("aIndices")}];
  }`,dispatchGroup:()=>({x:Math.ceil(j/64)})})},U.transpose=(Q,q)=>{(G=>{if(!G||G.length!==1)throw new Error("Transpose requires 1 input.");if(G[0].dataType!==1)throw new Error("input should be float tensor")})(Q.inputs),Q.compute(Object.assign(Object.assign({},U.transposeProgramMetadata),{cacheHint:q.cacheKey,get:()=>(0,U.createTransposeProgramInfo)(Q.inputs[0],q.perm)}))},U.parseTransposeAttributes=Q=>(0,Y.createAttributeWithCacheKey)({perm:Q.perm})},9302:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.thresholdedRelu=U.tanh=U.tan=U.sqrt=U.sinh=U.sin=U.sigmoid=U.relu=U.reciprocal=U.neg=U.leakyRelu=U.floor=U.exp=U.erf=U.elu=U.parseAlphaAttributes=U.cosh=U.cos=U.ceil=U.clip=U.clipV10=U.atanh=U.atan=U.asinh=U.asin=U.acosh=U.acos=U.abs=void 0;const tt=rt(6952),Y=rt(387),nt=rt(1163),K=(X,Q,q,G,O)=>{const b={name:Q,inputTypes:[nt.GpuDataType.default],cacheHint:O};return Object.assign(Object.assign({},b),{get:()=>((F,j,W,J)=>Object.assign(Object.assign({},F),{getShaderSource:et=>((ot,it,at,st)=>{const lt=Math.ceil(it/4);let ct="";return ct=typeof at=="string"?`${at}(a)`:at("a"),`
  @group(0) @binding(0) var<storage, read> inputData : array<vec4<f32>>;
  @group(0) @binding(1) var<storage, read_write> outputData : array<vec4<f32>>;

  ${st??""}

  ${ot.mainStart()}
    ${ot.guardAgainstOutOfBoundsWorkgroupSizes(lt)}

    let a = inputData[global_idx];
    outputData[global_idx] = ${ct};
  }`})(et,tt.ShapeUtil.size(j.dims),W,J),outputs:[{dims:j.dims,dataType:j.dataType,gpuDataType:nt.GpuDataType.default}],dispatchGroup:et=>({x:Math.ceil(tt.ShapeUtil.size(et[0].dims)/64/4)})}))(b,X,q,G)})};U.abs=X=>{X.compute(K(X.inputs[0],"Abs","abs"))},U.acos=X=>{X.compute(K(X.inputs[0],"Acos","acos"))},U.acosh=X=>{X.compute(K(X.inputs[0],"Acosh","acosh"))},U.asin=X=>{X.compute(K(X.inputs[0],"Asin","asin"))},U.asinh=X=>{X.compute(K(X.inputs[0],"Asinh","asinh"))},U.atan=X=>{X.compute(K(X.inputs[0],"Atan","atan"))},U.atanh=X=>{X.compute(K(X.inputs[0],"Atanh","atanh"))},U.clipV10=(X,Q)=>{X.compute(K(X.inputs[0],"Clip",q=>`clamp(${q}, clip_min_, clip_max_)`,`
    const clip_min_: vec4<f32> = vec4(f32(${Q.min}));
    const clip_max_: vec4<f32> = vec4(f32(${Q.max}));
`,Q.cacheKey),{inputs:[0]})},U.clip=X=>{const Q=(q=>{const G=q.length>=2?q[1].getFloat32Array()[0]:tt.MIN_CLIP,O=q.length>=3?q[2].getFloat32Array()[0]:tt.MAX_CLIP;return(0,Y.createAttributeWithCacheKey)({min:G,max:O})})(X.inputs);(0,U.clipV10)(X,Q)},U.ceil=X=>{X.compute(K(X.inputs[0],"Ceil","ceil"))},U.cos=X=>{X.compute(K(X.inputs[0],"Cos","cos"))},U.cosh=X=>{X.compute(K(X.inputs[0],"Cosh","cosh"))},U.parseAlphaAttributes=X=>(0,Y.createAttributeWithCacheKey)(X),U.elu=(X,Q)=>{X.compute(K(X.inputs[0],"Elu",q=>`elu_vf32(${q})`,`
  const elu_alpha_: f32 = f32(${Q.alpha});

  fn elu_f32(a: f32) -> f32 {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<f32>) -> vec4<f32> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,Q.cacheKey))},U.erf=X=>{X.compute(K(X.inputs[0],"Erf",Q=>`erf_vf32(${Q})`,`
  const r0: f32 = 0.3275911;
  const r1: f32 = 0.254829592;
  const r2: f32 = -0.284496736;
  const r3: f32 = 1.421413741;
  const r4: f32 = -1.453152027;
  const r5: f32 = 1.061405429;

  fn erf_vf32(v: vec4<f32>) -> vec4<f32> {
    let absv = abs(v);
    let x = 1.0 / (1.0 + r0 * absv);
    return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
  }`))},U.exp=X=>{X.compute(K(X.inputs[0],"Exp","exp"))},U.floor=X=>{X.compute(K(X.inputs[0],"Floor","floor"))},U.leakyRelu=(X,Q)=>{X.compute(K(X.inputs[0],"LeakyRelu",q=>`select(leaky_relu_alpha_ * ${q}, ${q}, ${q} >= vec4<f32>(0.0))`,`const leaky_relu_alpha_: f32 = f32(${Q.alpha});`,Q.cacheKey))},U.neg=X=>{X.compute(K(X.inputs[0],"Neg",Q=>`-${Q}`))},U.reciprocal=X=>{X.compute(K(X.inputs[0],"Reciprocal",Q=>`1.0/${Q}`))},U.relu=X=>{X.compute(K(X.inputs[0],"Relu",Q=>`select(vec4<f32>(0.0), ${Q}, ${Q} > vec4<f32>(0.0))`))},U.sigmoid=X=>{X.compute(K(X.inputs[0],"Sigmoid",Q=>`(1.0 / (1.0 + exp(-${Q})))`))},U.sin=X=>{X.compute(K(X.inputs[0],"Sin","sin"))},U.sinh=X=>{X.compute(K(X.inputs[0],"Sinh","sinh"))},U.sqrt=X=>{X.compute(K(X.inputs[0],"Sqrt","sqrt"))},U.tan=X=>{X.compute(K(X.inputs[0],"Tan","tan"))},U.tanh=X=>{X.compute(K(X.inputs[0],"Tanh","tanh"))},U.thresholdedRelu=(X,Q)=>(X.compute(K(X.inputs[0],"ThresholdedRelu",q=>`select(vec4<f32>(0.0), ${q}, ${q} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_: vec4<f32> = vec4<f32>(${Q.alpha});`,Q.cacheKey)),0)},8305:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.ProgramManager=void 0;const tt=rt(4955),Y=rt(2075);U.ProgramManager=class{constructor(nt){this.backend=nt,this.repo=new Map,this.attributesBound=!1}getArtifact(nt){return this.repo.get(nt)}setArtifact(nt,K){this.repo.set(nt,K)}run(nt,K,X,Q){const q=this.backend.device,G=this.backend.getComputePassEncoder();this.backend.profilingEnabled&&G.writeTimestamp(this.backend.profilingQuerySet,0),G.setPipeline(nt.computePipeline);const O=[];for(const F of K)O.push({binding:O.length,resource:{buffer:F.buffer}});for(const F of X)O.push({binding:O.length,resource:{buffer:F.buffer}});const b=q.createBindGroup({layout:nt.computePipeline.getBindGroupLayout(0),entries:O});if(G.setBindGroup(0,b),G.dispatchWorkgroups(...Q),this.backend.pendingDispatchNumber++,this.backend.profilingEnabled){G.writeTimestamp(this.backend.profilingQuerySet,1);const F=this.backend.gpuDataManager.create(16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),j=this.backend.gpuDataManager.create(16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.backend.endComputePass(),this.backend.getCommandEncoder().resolveQuerySet(this.backend.profilingQuerySet,0,2,F.buffer,0),this.backend.getCommandEncoder().copyBufferToBuffer(F.buffer,0,j.buffer,0,16),this.backend.flush();const W=this.backend.currentKernelId,J=this.backend.kernels.get(W)[0];j.buffer.mapAsync(GPUMapMode.READ).then(()=>{const et=new BigUint64Array(j.buffer.getMappedRange()),ot=et[0],it=et[1];j.buffer.unmap(),this.backend.profilingTimeBase===void 0&&(this.backend.profilingTimeBase=ot);const at=Number(ot-this.backend.profilingTimeBase),st=Number(it-this.backend.profilingTimeBase);if(!Number.isSafeInteger(at)||!Number.isSafeInteger(st))throw new RangeError("incorrect timestamp range");this.backend.gpuDataManager.release(F.id),this.backend.gpuDataManager.release(j.id),console.log(`[profiling] kernel "${W}|${J}" execution time: ${st-at} ns`)})}this.backend.pendingDispatchNumber>=16&&this.backend.flush()}dispose(){}build(nt,K){const X=this.backend.device,Q=nt.getShaderSource((0,Y.createShaderHelper)(K)),q=X.createShaderModule({code:Q});return(0,tt.LOG_DEBUG)("verbose",()=>`[WebGPU] shader code: ${Q}`),{programInfo:nt,computePipeline:X.createComputePipeline({compute:{module:q,entryPoint:"main"},layout:"auto"})}}normalizeDispatchGroupSize(nt){const K=typeof nt=="number"?nt:nt.x,X=typeof nt=="number"?1:nt.y||1,Q=typeof nt=="number"?1:nt.z||1,q=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(K<=q&&X<=q&&Q<=q)return[K,X,Q];const G=K*X*Q;let O=Math.ceil(Math.sqrt(G));if(O>q){if(O=Math.ceil(Math.cbrt(G)),O>q)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[O,O,O]}return[O,O,1]}}},1163:(dt,U)=>{var rt;Object.defineProperty(U,"__esModule",{value:!0}),U.GpuDataType=void 0,(rt=U.GpuDataType||(U.GpuDataType={}))[rt.default=0]="default",rt[rt.upload=1]="upload",rt[rt.profile=2]="profile"},3899:(dt,U)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.iterateExtraOptions=void 0,U.iterateExtraOptions=(rt,tt,Y,nt)=>{if(typeof rt=="object"&&rt!==null){if(Y.has(rt))throw new Error("Circular reference in options");Y.add(rt)}Object.entries(rt).forEach(([K,X])=>{const Q=tt?tt+K:K;if(typeof X=="object")(0,U.iterateExtraOptions)(X,Q+".",Y,nt);else if(typeof X=="string"||typeof X=="number")nt(Q,X.toString());else{if(typeof X!="boolean")throw new Error("Can't handle extra config type: "+typeof X);nt(Q,X?"1":"0")}})}},9544:function(dt,U,rt){var tt,Y=this&&this.__createBinding||(Object.create?function(gt,_t,vt,bt){bt===void 0&&(bt=vt);var St=Object.getOwnPropertyDescriptor(_t,vt);St&&!("get"in St?!_t.__esModule:St.writable||St.configurable)||(St={enumerable:!0,get:function(){return _t[vt]}}),Object.defineProperty(gt,bt,St)}:function(gt,_t,vt,bt){bt===void 0&&(bt=vt),gt[bt]=_t[vt]}),nt=this&&this.__setModuleDefault||(Object.create?function(gt,_t){Object.defineProperty(gt,"default",{enumerable:!0,value:_t})}:function(gt,_t){gt.default=_t}),K=this&&this.__importStar||function(gt){if(gt&&gt.__esModule)return gt;var _t={};if(gt!=null)for(var vt in gt)vt!=="default"&&Object.prototype.hasOwnProperty.call(gt,vt)&&Y(_t,gt,vt);return nt(_t,gt),_t};Object.defineProperty(U,"__esModule",{value:!0}),U.endProfiling=U.run=U.releaseSession=U.createSession=U.createSessionFinalize=U.createSessionAllocate=U.initOrt=U.initWasm=void 0;const X=rt(8453),Q=rt(7675),q=K(rt(1259)),G=rt(263),O=()=>!!X.env.wasm.proxy&&typeof document<"u";let b,F,j,W=!1,J=!1,et=!1;const ot=[],it=[],at=[],st=[],lt=[],ct=[],pt=()=>{if(W||!J||et||!b)throw new Error("worker not ready")},ut=gt=>{switch(gt.data.type){case"init-wasm":W=!1,gt.data.err?(et=!0,F[1](gt.data.err)):(J=!0,F[0]());break;case"init-ort":gt.data.err?j[1](gt.data.err):j[0]();break;case"create_allocate":gt.data.err?ot.shift()[1](gt.data.err):ot.shift()[0](gt.data.out);break;case"create_finalize":gt.data.err?it.shift()[1](gt.data.err):it.shift()[0](gt.data.out);break;case"create":gt.data.err?at.shift()[1](gt.data.err):at.shift()[0](gt.data.out);break;case"release":gt.data.err?st.shift()[1](gt.data.err):st.shift()[0]();break;case"run":gt.data.err?lt.shift()[1](gt.data.err):lt.shift()[0](gt.data.out);break;case"end-profiling":gt.data.err?ct.shift()[1](gt.data.err):ct.shift()[0]()}},ft=typeof document<"u"?(tt=document==null?void 0:document.currentScript)===null||tt===void 0?void 0:tt.src:void 0;U.initWasm=async()=>{if(O()){if(J)return;if(W)throw new Error("multiple calls to 'initWasm()' detected.");if(et)throw new Error("previous call to 'initWasm()' failed.");return W=!0,X.env.wasm.wasmPaths===void 0&&ft&&ft.indexOf("blob:")!==0&&(X.env.wasm.wasmPaths=ft.substr(0,+ft.lastIndexOf("/")+1)),new Promise((gt,_t)=>{b==null||b.terminate(),b=rt(8050).Z(),b.onmessage=ut,F=[gt,_t];const vt={type:"init-wasm",in:X.env.wasm};b.postMessage(vt)})}return(0,G.initializeWebAssembly)(X.env.wasm)},U.initOrt=async(gt,_t)=>{if(O())return pt(),new Promise((vt,bt)=>{j=[vt,bt];const St={type:"init-ort",in:{numThreads:gt,loggingLevel:_t}};b.postMessage(St)});q.initOrt(gt,_t),await(0,Q.init)((0,G.getInstance)())},U.createSessionAllocate=async gt=>O()?(pt(),new Promise((_t,vt)=>{ot.push([_t,vt]);const bt={type:"create_allocate",in:{model:gt}};b.postMessage(bt,[gt.buffer])})):q.createSessionAllocate(gt),U.createSessionFinalize=async(gt,_t)=>O()?(pt(),new Promise((vt,bt)=>{it.push([vt,bt]);const St={type:"create_finalize",in:{modeldata:gt,options:_t}};b.postMessage(St)})):q.createSessionFinalize(gt,_t),U.createSession=async(gt,_t)=>O()?(pt(),new Promise((vt,bt)=>{at.push([vt,bt]);const St={type:"create",in:{model:gt,options:_t}};b.postMessage(St,[gt.buffer])})):q.createSession(gt,_t),U.releaseSession=async gt=>{if(O())return pt(),new Promise((_t,vt)=>{st.push([_t,vt]);const bt={type:"release",in:gt};b.postMessage(bt)});q.releaseSession(gt)},U.run=async(gt,_t,vt,bt,St)=>O()?(pt(),new Promise((yt,wt)=>{lt.push([yt,wt]);const Dt={type:"run",in:{sessionId:gt,inputIndices:_t,inputs:vt,outputIndices:bt,options:St}};b.postMessage(Dt,q.extractTransferableBuffers(vt))})):q.run(gt,_t,vt,bt,St),U.endProfiling=async gt=>{if(O())return pt(),new Promise((_t,vt)=>{ct.push([_t,vt]);const bt={type:"end-profiling",in:gt};b.postMessage(bt)});q.endProfiling(gt)}},7918:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.setRunOptions=void 0;const tt=rt(3899),Y=rt(9444),nt=rt(263);U.setRunOptions=K=>{const X=(0,nt.getInstance)();let Q=0;const q=[],G=K||{};try{if((K==null?void 0:K.logSeverityLevel)===void 0)G.logSeverityLevel=2;else if(typeof K.logSeverityLevel!="number"||!Number.isInteger(K.logSeverityLevel)||K.logSeverityLevel<0||K.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${K.logSeverityLevel}`);if((K==null?void 0:K.logVerbosityLevel)===void 0)G.logVerbosityLevel=0;else if(typeof K.logVerbosityLevel!="number"||!Number.isInteger(K.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${K.logVerbosityLevel}`);(K==null?void 0:K.terminate)===void 0&&(G.terminate=!1);let O=0;if((K==null?void 0:K.tag)!==void 0&&(O=(0,Y.allocWasmString)(K.tag,q)),Q=X._OrtCreateRunOptions(G.logSeverityLevel,G.logVerbosityLevel,!!G.terminate,O),Q===0)throw new Error("Can't create run options");return(K==null?void 0:K.extra)!==void 0&&(0,tt.iterateExtraOptions)(K.extra,"",new WeakSet,(b,F)=>{const j=(0,Y.allocWasmString)(b,q),W=(0,Y.allocWasmString)(F,q);if(X._OrtAddRunConfigEntry(Q,j,W)!==0)throw new Error(`Can't set a run config entry: ${b} - ${F}`)}),[Q,q]}catch(O){throw Q!==0&&X._OrtReleaseRunOptions(Q),q.forEach(X._free),O}}},6640:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.OnnxruntimeWebAssemblySessionHandler=void 0;const tt=rt(2806),Y=rt(8453),nt=rt(2850),K=rt(9544),X=rt(7917);let Q;U.OnnxruntimeWebAssemblySessionHandler=class{async createSessionAllocate(q){const G=await fetch(q),O=await G.arrayBuffer();return(0,K.createSessionAllocate)(new Uint8Array(O))}async loadModel(q,G){if(Q||(await(0,K.initOrt)(Y.env.wasm.numThreads,(0,X.logLevelStringToEnum)(Y.env.logLevel)),Q=!0),typeof q=="string")if(typeof fetch>"u"){const O=await(0,nt.promisify)(tt.readFile)(q);[this.sessionId,this.inputNames,this.outputNames]=await(0,K.createSession)(O,G)}else{const O=await this.createSessionAllocate(q);[this.sessionId,this.inputNames,this.outputNames]=await(0,K.createSessionFinalize)(O,G)}else[this.sessionId,this.inputNames,this.outputNames]=await(0,K.createSession)(q,G)}async dispose(){return(0,K.releaseSession)(this.sessionId)}async run(q,G,O){const b=[],F=[];Object.entries(q).forEach(et=>{const ot=et[0],it=et[1],at=this.inputNames.indexOf(ot);if(at===-1)throw new Error(`invalid input '${ot}'`);b.push(it),F.push(at)});const j=[];Object.entries(G).forEach(et=>{const ot=et[0],it=this.outputNames.indexOf(ot);if(it===-1)throw new Error(`invalid output '${ot}'`);j.push(it)});const W=await(0,K.run)(this.sessionId,F,b.map(et=>[et.type,et.dims,et.data]),j,O),J={};for(let et=0;et<W.length;et++)J[this.outputNames[j[et]]]=new Y.Tensor(W[et][0],W[et][2],W[et][1]);return J}startProfiling(){}endProfiling(){(0,K.endProfiling)(this.sessionId)}}},7622:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.setSessionOptions=void 0;const tt=rt(3899),Y=rt(9444),nt=rt(263);U.setSessionOptions=K=>{var X,Q,q,G;const O=(0,nt.getInstance)();let b=0;const F=[],j=K||{};(W=>{W.extra||(W.extra={}),W.extra.session||(W.extra.session={});const J=W.extra.session;J.use_ort_model_bytes_directly||(J.use_ort_model_bytes_directly="1"),W.executionProviders&&W.executionProviders.some(et=>(typeof et=="string"?et:et.name)==="webgpu")&&(W.enableMemPattern=!1)})(j);try{const W=(st=>{switch(st){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${st}`)}})((X=j.graphOptimizationLevel)!==null&&X!==void 0?X:"all"),J=(st=>{switch(st){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${st}`)}})((Q=j.executionMode)!==null&&Q!==void 0?Q:"sequential"),et=typeof j.logId=="string"?(0,Y.allocWasmString)(j.logId,F):0,ot=(q=j.logSeverityLevel)!==null&&q!==void 0?q:2;if(!Number.isInteger(ot)||ot<0||ot>4)throw new Error(`log serverity level is not valid: ${ot}`);const it=(G=j.logVerbosityLevel)!==null&&G!==void 0?G:0;if(!Number.isInteger(it)||it<0||it>4)throw new Error(`log verbosity level is not valid: ${it}`);const at=typeof j.optimizedModelFilePath=="string"?(0,Y.allocWasmString)(j.optimizedModelFilePath,F):0;if(b=O._OrtCreateSessionOptions(W,!!j.enableCpuMemArena,!!j.enableMemPattern,J,!!j.enableProfiling,0,et,ot,it,at),b===0)throw new Error("Can't create session options");return j.executionProviders&&((st,lt,ct)=>{for(const pt of lt){let ut=typeof pt=="string"?pt:pt.name;switch(ut){case"xnnpack":ut="XNNPACK";break;case"webgpu":ut="JS";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported EP: ${ut}`)}const ft=(0,Y.allocWasmString)(ut,ct);if((0,nt.getInstance)()._OrtAppendExecutionProvider(st,ft)!==0)throw new Error(`Can't append execution provider: ${ut}`)}})(b,j.executionProviders,F),j.extra!==void 0&&(0,tt.iterateExtraOptions)(j.extra,"",new WeakSet,(st,lt)=>{const ct=(0,Y.allocWasmString)(st,F),pt=(0,Y.allocWasmString)(lt,F);if(O._OrtAddSessionConfigEntry(b,ct,pt)!==0)throw new Error(`Can't set a session config entry: ${st} - ${lt}`)}),[b,F]}catch(W){throw b!==0&&O._OrtReleaseSessionOptions(b),F.forEach(O._free),W}}},9444:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.allocWasmString=void 0;const tt=rt(263);U.allocWasmString=(Y,nt)=>{const K=(0,tt.getInstance)(),X=K.lengthBytesUTF8(Y)+1,Q=K._malloc(X);return K.stringToUTF8(Y,Q,X),nt.push(Q),Q}},7917:(dt,U)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.logLevelStringToEnum=U.tensorTypeToTypedArrayConstructor=U.getTensorElementSize=U.tensorDataTypeEnumToString=U.tensorDataTypeStringToEnum=void 0,U.tensorDataTypeStringToEnum=rt=>{switch(rt){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${rt}`)}},U.tensorDataTypeEnumToString=rt=>{switch(rt){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${rt}`)}},U.getTensorElementSize=rt=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][rt],U.tensorTypeToTypedArrayConstructor=rt=>{switch(rt){case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${rt}`)}},U.logLevelStringToEnum=rt=>{switch(rt){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${rt}`)}}},1259:(dt,U,rt)=>{Object.defineProperty(U,"__esModule",{value:!0}),U.extractTransferableBuffers=U.endProfiling=U.run=U.releaseSession=U.createSession=U.createSessionFinalize=U.createSessionAllocate=U.initOrt=void 0;const tt=rt(7918),Y=rt(7622),nt=rt(9444),K=rt(7917),X=rt(263);U.initOrt=(q,G)=>{const O=(0,X.getInstance)()._OrtInit(q,G);if(O!==0)throw new Error(`Can't initialize onnxruntime. error code = ${O}`)};const Q=new Map;U.createSessionAllocate=q=>{const G=(0,X.getInstance)(),O=G._malloc(q.byteLength);return G.HEAPU8.set(q,O),[O,q.byteLength]},U.createSessionFinalize=(q,G)=>{const O=(0,X.getInstance)();let b=0,F=0,j=[];try{if([F,j]=(0,Y.setSessionOptions)(G),b=O._OrtCreateSession(q[0],q[1],F),b===0)throw new Error("Can't create a session")}finally{O._free(q[0]),F!==0&&O._OrtReleaseSessionOptions(F),j.forEach(O._free)}const W=O._OrtGetInputCount(b),J=O._OrtGetOutputCount(b),et=[],ot=[],it=[],at=[];for(let st=0;st<W;st++){const lt=O._OrtGetInputName(b,st);if(lt===0)throw new Error("Can't get an input name");ot.push(lt),et.push(O.UTF8ToString(lt))}for(let st=0;st<J;st++){const lt=O._OrtGetOutputName(b,st);if(lt===0)throw new Error("Can't get an output name");at.push(lt),it.push(O.UTF8ToString(lt))}return Q.set(b,[b,ot,at]),[b,et,it]},U.createSession=(q,G)=>{const O=(0,U.createSessionAllocate)(q);return(0,U.createSessionFinalize)(O,G)},U.releaseSession=q=>{const G=(0,X.getInstance)(),O=Q.get(q);if(!O)throw new Error("invalid session id");const b=O[0],F=O[1],j=O[2];F.forEach(G._OrtFree),j.forEach(G._OrtFree),G._OrtReleaseSession(b),Q.delete(q)},U.run=async(q,G,O,b,F)=>{const j=(0,X.getInstance)(),W=Q.get(q);if(!W)throw new Error("invalid session id");const J=W[0],et=W[1],ot=W[2],it=G.length,at=b.length;let st=0,lt=[];const ct=[],pt=[];try{[st,lt]=(0,tt.setRunOptions)(F);for(let bt=0;bt<it;bt++){const St=O[bt][0],yt=O[bt][1],wt=O[bt][2];let Dt,Pt;if(Array.isArray(wt)){Pt=4*wt.length,Dt=j._malloc(Pt),pt.push(Dt);let Bt=Dt/4;for(let Vt=0;Vt<wt.length;Vt++){if(typeof wt[Vt]!="string")throw new TypeError(`tensor data at index ${Vt} is not a string`);j.HEAPU32[Bt++]=(0,nt.allocWasmString)(wt[Vt],pt)}}else Pt=wt.byteLength,Dt=j._malloc(Pt),pt.push(Dt),j.HEAPU8.set(new Uint8Array(wt.buffer,wt.byteOffset,Pt),Dt);const Ft=j.stackSave(),Rt=j.stackAlloc(4*yt.length);try{let Bt=Rt/4;yt.forEach(jt=>j.HEAP32[Bt++]=jt);const Vt=j._OrtCreateTensor((0,K.tensorDataTypeStringToEnum)(St),Dt,Pt,Rt,yt.length);if(Vt===0)throw new Error("Can't create a tensor");ct.push(Vt)}finally{j.stackRestore(Ft)}}const ut=j.stackSave(),ft=j.stackAlloc(4*it),gt=j.stackAlloc(4*it),_t=j.stackAlloc(4*at),vt=j.stackAlloc(4*at);try{let bt=ft/4,St=gt/4,yt=_t/4,wt=vt/4;for(let Rt=0;Rt<it;Rt++)j.HEAPU32[bt++]=ct[Rt],j.HEAPU32[St++]=et[G[Rt]];for(let Rt=0;Rt<at;Rt++)j.HEAPU32[yt++]=0,j.HEAPU32[wt++]=ot[b[Rt]];let Dt=j._OrtRun(J,gt,ft,it,vt,at,_t,st);const Pt=j.jsepRunPromise;Pt&&Pt.then!==void 0&&(Dt=await Pt);const Ft=[];if(Dt===0)for(let Rt=0;Rt<at;Rt++){const Bt=j.HEAPU32[_t/4+Rt],Vt=j.stackSave(),jt=j.stackAlloc(16);let qt,Kt=0;try{if(Dt=j._OrtGetTensorData(Bt,jt,jt+4,jt+8,jt+12),Dt!==0)throw new Error(`Can't access output tensor data. error code = ${Dt}`);let Gt=jt/4;const Qt=j.HEAPU32[Gt++];Kt=j.HEAPU32[Gt++];const zt=j.HEAPU32[Gt++],ne=j.HEAPU32[Gt++],Zt=[];for(let Xt=0;Xt<ne;Xt++)Zt.push(j.HEAPU32[zt/4+Xt]);j._OrtFree(zt);const re=Zt.length===0?1:Zt.reduce((Xt,se)=>Xt*se);if(qt=(0,K.tensorDataTypeEnumToString)(Qt),qt==="string"){const Xt=[];let se=Kt/4;for(let fe=0;fe<re;fe++){const ye=j.HEAPU32[se++],ve=fe===re-1?void 0:j.HEAPU32[se]-ye;Xt.push(j.UTF8ToString(ye,ve))}Ft.push([qt,Zt,Xt])}else{const Xt=new((0,K.tensorTypeToTypedArrayConstructor)(qt))(re);new Uint8Array(Xt.buffer,Xt.byteOffset,Xt.byteLength).set(j.HEAPU8.subarray(Kt,Kt+Xt.byteLength)),Ft.push([qt,Zt,Xt])}}finally{j.stackRestore(Vt),qt==="string"&&Kt&&j._free(Kt),j._OrtReleaseTensor(Bt)}}if(Dt===0)return Ft;throw new Error(`failed to call OrtRun(). error code = ${Dt}.`)}finally{j.stackRestore(ut)}}finally{ct.forEach(j._OrtReleaseTensor),pt.forEach(j._free),j._OrtReleaseRunOptions(st),lt.forEach(j._free)}},U.endProfiling=q=>{const G=(0,X.getInstance)(),O=Q.get(q);if(!O)throw new Error("invalid session id");const b=O[0],F=G._OrtEndProfiling(b);if(F===0)throw new Error("Can't get an profile file name");G._OrtFree(F)},U.extractTransferableBuffers=q=>{const G=[];for(const O of q){const b=O[2];!Array.isArray(b)&&b.buffer&&G.push(b.buffer)}return G}},263:function(dt,U,rt){var tt=this&&this.__createBinding||(Object.create?function(F,j,W,J){J===void 0&&(J=W);var et=Object.getOwnPropertyDescriptor(j,W);et&&!("get"in et?!j.__esModule:et.writable||et.configurable)||(et={enumerable:!0,get:function(){return j[W]}}),Object.defineProperty(F,J,et)}:function(F,j,W,J){J===void 0&&(J=W),F[J]=j[W]}),Y=this&&this.__setModuleDefault||(Object.create?function(F,j){Object.defineProperty(F,"default",{enumerable:!0,value:j})}:function(F,j){F.default=j}),nt=this&&this.__importStar||function(F){if(F&&F.__esModule)return F;var j={};if(F!=null)for(var W in F)W!=="default"&&Object.prototype.hasOwnProperty.call(F,W)&&tt(j,F,W);return Y(j,F),j};Object.defineProperty(U,"__esModule",{value:!0}),U.dispose=U.getInstance=U.initializeWebAssembly=void 0;const K=nt(rt(6449)),X=rt(932),Q=rt(3474);let q,G=!1,O=!1,b=!1;U.initializeWebAssembly=async F=>{if(G)return Promise.resolve();if(O)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(b)throw new Error("previous call to 'initializeWebAssembly()' failed.");O=!0;const j=F.initTimeout,W=F.numThreads,J=F.simd,et=W>1&&(()=>{try{return typeof SharedArrayBuffer<"u"&&(typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch{return!1}})(),ot=J&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}})(),it=F.wasmPaths,at=typeof it=="string"?it:void 0,st=((ut,ft)=>ft?ut?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":ut?"ort-wasm-simd.wasm":"ort-wasm.wasm")(ot,et),lt=typeof it=="object"?it[st]:void 0;let ct=!1;const pt=[];if(j>0&&pt.push(new Promise(ut=>{setTimeout(()=>{ct=!0,ut()},j)})),pt.push(new Promise((ut,ft)=>{const gt=et?Q:X,_t={locateFile:(vt,bt)=>et&&vt.endsWith(".worker.js")&&typeof Blob<"u"?URL.createObjectURL(new Blob([rt(4154)],{type:"text/javascript"})):vt.endsWith(".wasm")?lt||(at??bt)+st:bt+vt};if(et)if(typeof Blob>"u")_t.mainScriptUrlOrBlob=K.join("/","ort-wasm-threaded.js");else{const vt=`var ortWasmThreaded=(function(){var _scriptDir;return ${gt.toString()}})();`;_t.mainScriptUrlOrBlob=new Blob([vt],{type:"text/javascript"})}gt(_t).then(vt=>{O=!1,G=!0,q=vt,ut()},vt=>{O=!1,b=!0,ft(vt)})})),await Promise.race(pt),ct)throw new Error(`WebAssembly backend initializing failed due to timeout: ${j}ms`)},U.getInstance=()=>{if(G&&q)return q;throw new Error("WebAssembly is not initialized yet.")},U.dispose=()=>{var F;!G||O||b||(O=!0,(F=q.PThread)===null||F===void 0||F.terminateAllThreads(),q=void 0,O=!1,G=!1,b=!0)}},8050:(dt,U,rt)=>{rt.d(U,{Z:()=>nt});var tt=rt(6614),Y=rt.n(tt);function nt(){return Y()('/*!\n* ONNX Runtime Web v1.15.1\n* Copyright (c) Microsoft Corporation. All rights reserved.\n* Licensed under the MIT License.\n*/\n(()=>{var e={899:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.iterateExtraOptions=void 0,t.iterateExtraOptions=(e,n,r,a)=>{if("object"==typeof e&&null!==e){if(r.has(e))throw new Error("Circular reference in options");r.add(e)}Object.entries(e).forEach((([e,o])=>{const i=n?n+e:e;if("object"==typeof o)(0,t.iterateExtraOptions)(o,i+".",r,a);else if("string"==typeof o||"number"==typeof o)a(i,o.toString());else{if("boolean"!=typeof o)throw new Error("Can\'t handle extra config type: "+typeof o);a(i,o?"1":"0")}}))}},918:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.setRunOptions=void 0;const r=n(899),a=n(444),o=n(263);t.setRunOptions=e=>{const t=(0,o.getInstance)();let n=0;const i=[],s=e||{};try{if(void 0===(null==e?void 0:e.logSeverityLevel))s.logSeverityLevel=2;else if("number"!=typeof e.logSeverityLevel||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(void 0===(null==e?void 0:e.logVerbosityLevel))s.logVerbosityLevel=0;else if("number"!=typeof e.logVerbosityLevel||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);void 0===(null==e?void 0:e.terminate)&&(s.terminate=!1);let o=0;if(void 0!==(null==e?void 0:e.tag)&&(o=(0,a.allocWasmString)(e.tag,i)),n=t._OrtCreateRunOptions(s.logSeverityLevel,s.logVerbosityLevel,!!s.terminate,o),0===n)throw new Error("Can\'t create run options");return void 0!==(null==e?void 0:e.extra)&&(0,r.iterateExtraOptions)(e.extra,"",new WeakSet,((e,r)=>{const o=(0,a.allocWasmString)(e,i),s=(0,a.allocWasmString)(r,i);if(0!==t._OrtAddRunConfigEntry(n,o,s))throw new Error(`Can\'t set a run config entry: ${e} - ${r}`)})),[n,i]}catch(e){throw 0!==n&&t._OrtReleaseRunOptions(n),i.forEach(t._free),e}}},622:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.setSessionOptions=void 0;const r=n(899),a=n(444),o=n(263);t.setSessionOptions=e=>{var t,n,i,s;const u=(0,o.getInstance)();let c=0;const l=[],f=e||{};(e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});const t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some((e=>"webgpu"===("string"==typeof e?e:e.name)))&&(e.enableMemPattern=!1)})(f);try{const e=(e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}})(null!==(t=f.graphOptimizationLevel)&&void 0!==t?t:"all"),p=(e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}})(null!==(n=f.executionMode)&&void 0!==n?n:"sequential"),d="string"==typeof f.logId?(0,a.allocWasmString)(f.logId,l):0,m=null!==(i=f.logSeverityLevel)&&void 0!==i?i:2;if(!Number.isInteger(m)||m<0||m>4)throw new Error(`log serverity level is not valid: ${m}`);const g=null!==(s=f.logVerbosityLevel)&&void 0!==s?s:0;if(!Number.isInteger(g)||g<0||g>4)throw new Error(`log verbosity level is not valid: ${g}`);const h="string"==typeof f.optimizedModelFilePath?(0,a.allocWasmString)(f.optimizedModelFilePath,l):0;if(c=u._OrtCreateSessionOptions(e,!!f.enableCpuMemArena,!!f.enableMemPattern,p,!!f.enableProfiling,0,d,m,g,h),0===c)throw new Error("Can\'t create session options");return f.executionProviders&&((e,t,n)=>{for(const r of t){let t="string"==typeof r?r:r.name;switch(t){case"xnnpack":t="XNNPACK";break;case"webgpu":t="JS";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported EP: ${t}`)}const i=(0,a.allocWasmString)(t,n);if(0!==(0,o.getInstance)()._OrtAppendExecutionProvider(e,i))throw new Error(`Can\'t append execution provider: ${t}`)}})(c,f.executionProviders,l),void 0!==f.extra&&(0,r.iterateExtraOptions)(f.extra,"",new WeakSet,((e,t)=>{const n=(0,a.allocWasmString)(e,l),r=(0,a.allocWasmString)(t,l);if(0!==u._OrtAddSessionConfigEntry(c,n,r))throw new Error(`Can\'t set a session config entry: ${e} - ${t}`)})),[c,l]}catch(e){throw 0!==c&&u._OrtReleaseSessionOptions(c),l.forEach(u._free),e}}},444:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.allocWasmString=void 0;const r=n(263);t.allocWasmString=(e,t)=>{const n=(0,r.getInstance)(),a=n.lengthBytesUTF8(e)+1,o=n._malloc(a);return n.stringToUTF8(e,o,a),t.push(o),o}},917:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.logLevelStringToEnum=t.tensorTypeToTypedArrayConstructor=t.getTensorElementSize=t.tensorDataTypeEnumToString=t.tensorDataTypeStringToEnum=void 0,t.tensorDataTypeStringToEnum=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},t.tensorDataTypeEnumToString=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},t.getTensorElementSize=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],t.tensorTypeToTypedArrayConstructor=e=>{switch(e){case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},t.logLevelStringToEnum=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}}},259:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.extractTransferableBuffers=t.endProfiling=t.run=t.releaseSession=t.createSession=t.createSessionFinalize=t.createSessionAllocate=t.initOrt=void 0;const r=n(918),a=n(622),o=n(444),i=n(917),s=n(263);t.initOrt=(e,t)=>{const n=(0,s.getInstance)()._OrtInit(e,t);if(0!==n)throw new Error(`Can\'t initialize onnxruntime. error code = ${n}`)};const u=new Map;t.createSessionAllocate=e=>{const t=(0,s.getInstance)(),n=t._malloc(e.byteLength);return t.HEAPU8.set(e,n),[n,e.byteLength]},t.createSessionFinalize=(e,t)=>{const n=(0,s.getInstance)();let r=0,o=0,i=[];try{if([o,i]=(0,a.setSessionOptions)(t),r=n._OrtCreateSession(e[0],e[1],o),0===r)throw new Error("Can\'t create a session")}finally{n._free(e[0]),0!==o&&n._OrtReleaseSessionOptions(o),i.forEach(n._free)}const c=n._OrtGetInputCount(r),l=n._OrtGetOutputCount(r),f=[],p=[],d=[],m=[];for(let e=0;e<c;e++){const t=n._OrtGetInputName(r,e);if(0===t)throw new Error("Can\'t get an input name");p.push(t),f.push(n.UTF8ToString(t))}for(let e=0;e<l;e++){const t=n._OrtGetOutputName(r,e);if(0===t)throw new Error("Can\'t get an output name");m.push(t),d.push(n.UTF8ToString(t))}return u.set(r,[r,p,m]),[r,f,d]},t.createSession=(e,n)=>{const r=(0,t.createSessionAllocate)(e);return(0,t.createSessionFinalize)(r,n)},t.releaseSession=e=>{const t=(0,s.getInstance)(),n=u.get(e);if(!n)throw new Error("invalid session id");const r=n[0],a=n[1],o=n[2];a.forEach(t._OrtFree),o.forEach(t._OrtFree),t._OrtReleaseSession(r),u.delete(e)},t.run=async(e,t,n,a,c)=>{const l=(0,s.getInstance)(),f=u.get(e);if(!f)throw new Error("invalid session id");const p=f[0],d=f[1],m=f[2],g=t.length,h=a.length;let y=0,v=[];const b=[],w=[];try{[y,v]=(0,r.setRunOptions)(c);for(let e=0;e<g;e++){const t=n[e][0],r=n[e][1],a=n[e][2];let s,u;if(Array.isArray(a)){u=4*a.length,s=l._malloc(u),w.push(s);let e=s/4;for(let t=0;t<a.length;t++){if("string"!=typeof a[t])throw new TypeError(`tensor data at index ${t} is not a string`);l.HEAPU32[e++]=(0,o.allocWasmString)(a[t],w)}}else u=a.byteLength,s=l._malloc(u),w.push(s),l.HEAPU8.set(new Uint8Array(a.buffer,a.byteOffset,u),s);const c=l.stackSave(),f=l.stackAlloc(4*r.length);try{let e=f/4;r.forEach((t=>l.HEAP32[e++]=t));const n=l._OrtCreateTensor((0,i.tensorDataTypeStringToEnum)(t),s,u,f,r.length);if(0===n)throw new Error("Can\'t create a tensor");b.push(n)}finally{l.stackRestore(c)}}const e=l.stackSave(),s=l.stackAlloc(4*g),u=l.stackAlloc(4*g),f=l.stackAlloc(4*h),_=l.stackAlloc(4*h);try{let e=s/4,n=u/4,r=f/4,o=_/4;for(let r=0;r<g;r++)l.HEAPU32[e++]=b[r],l.HEAPU32[n++]=d[t[r]];for(let e=0;e<h;e++)l.HEAPU32[r++]=0,l.HEAPU32[o++]=m[a[e]];let c=l._OrtRun(p,u,s,g,_,h,f,y);const v=l.jsepRunPromise;v&&void 0!==v.then&&(c=await v);const w=[];if(0===c)for(let e=0;e<h;e++){const t=l.HEAPU32[f/4+e],n=l.stackSave(),r=l.stackAlloc(16);let a,o=0;try{if(c=l._OrtGetTensorData(t,r,r+4,r+8,r+12),0!==c)throw new Error(`Can\'t access output tensor data. error code = ${c}`);let e=r/4;const n=l.HEAPU32[e++];o=l.HEAPU32[e++];const s=l.HEAPU32[e++],u=l.HEAPU32[e++],f=[];for(let e=0;e<u;e++)f.push(l.HEAPU32[s/4+e]);l._OrtFree(s);const p=0===f.length?1:f.reduce(((e,t)=>e*t));if(a=(0,i.tensorDataTypeEnumToString)(n),"string"===a){const e=[];let t=o/4;for(let n=0;n<p;n++){const r=l.HEAPU32[t++],a=n===p-1?void 0:l.HEAPU32[t]-r;e.push(l.UTF8ToString(r,a))}w.push([a,f,e])}else{const e=new((0,i.tensorTypeToTypedArrayConstructor)(a))(p);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(l.HEAPU8.subarray(o,o+e.byteLength)),w.push([a,f,e])}}finally{l.stackRestore(n),"string"===a&&o&&l._free(o),l._OrtReleaseTensor(t)}}if(0===c)return w;throw new Error(`failed to call OrtRun(). error code = ${c}.`)}finally{l.stackRestore(e)}}finally{b.forEach(l._OrtReleaseTensor),w.forEach(l._free),l._OrtReleaseRunOptions(y),v.forEach(l._free)}},t.endProfiling=e=>{const t=(0,s.getInstance)(),n=u.get(e);if(!n)throw new Error("invalid session id");const r=n[0],a=t._OrtEndProfiling(r);if(0===a)throw new Error("Can\'t get an profile file name");t._OrtFree(a)},t.extractTransferableBuffers=e=>{const t=[];for(const n of e){const e=n[2];!Array.isArray(e)&&e.buffer&&t.push(e.buffer)}return t}},263:function(e,t,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,t,n,r){void 0===r&&(r=n);var a=Object.getOwnPropertyDescriptor(t,n);a&&!("get"in a?!t.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,r,a)}:function(e,t,n,r){void 0===r&&(r=n),e[r]=t[n]}),a=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)"default"!==n&&Object.prototype.hasOwnProperty.call(e,n)&&r(t,e,n);return a(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.dispose=t.getInstance=t.initializeWebAssembly=void 0;const i=o(n(449)),s=n(932),u=n(474);let c,l=!1,f=!1,p=!1;t.initializeWebAssembly=async e=>{if(l)return Promise.resolve();if(f)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(p)throw new Error("previous call to \'initializeWebAssembly()\' failed.");f=!0;const t=e.initTimeout,r=e.numThreads,a=e.simd,o=r>1&&(()=>{try{return"undefined"!=typeof SharedArrayBuffer&&("undefined"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(e){return!1}})(),d=a&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(e){return!1}})(),m=e.wasmPaths,g="string"==typeof m?m:void 0,h=((e,t)=>t?e?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":e?"ort-wasm-simd.wasm":"ort-wasm.wasm")(d,o),y="object"==typeof m?m[h]:void 0;let v=!1;const b=[];if(t>0&&b.push(new Promise((e=>{setTimeout((()=>{v=!0,e()}),t)}))),b.push(new Promise(((e,t)=>{const r=o?u:s,a={locateFile:(e,t)=>o&&e.endsWith(".worker.js")&&"undefined"!=typeof Blob?URL.createObjectURL(new Blob([n(154)],{type:"text/javascript"})):e.endsWith(".wasm")?y||(null!=g?g:t)+h:t+e};if(o)if("undefined"==typeof Blob)a.mainScriptUrlOrBlob=i.join("/","ort-wasm-threaded.js");else{const e=`var ortWasmThreaded=(function(){var _scriptDir;return ${r.toString()}})();`;a.mainScriptUrlOrBlob=new Blob([e],{type:"text/javascript"})}r(a).then((t=>{f=!1,l=!0,c=t,e()}),(e=>{f=!1,p=!0,t(e)}))}))),await Promise.race(b),v)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},t.getInstance=()=>{if(l&&c)return c;throw new Error("WebAssembly is not initialized yet.")},t.dispose=()=>{var e;!l||f||p||(f=!0,null===(e=c.PThread)||void 0===e||e.terminateAllThreads(),c=void 0,f=!1,l=!1,p=!0)}},474:(e,t,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(e){function t(){return P.buffer!=D&&G(P.buffer),F}function r(){return P.buffer!=D&&G(P.buffer),U}function a(){return P.buffer!=D&&G(P.buffer),I}function o(){return P.buffer!=D&&G(P.buffer),W}function i(){return P.buffer!=D&&G(P.buffer),j}var s,u,c;e=e||{},s||(s=void 0!==e?e:{}),s.ready=new Promise((function(e,t){u=e,c=t}));var l,f,p,d,m,g,h=Object.assign({},s),y="./this.program",v=(e,t)=>{throw t},b="object"==typeof window,w="function"==typeof importScripts,_="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,O=s.ENVIRONMENT_IS_PTHREAD||!1,S="";function T(e){return s.locateFile?s.locateFile(e,S):S+e}if(_){let t;S=w?n(908).dirname(S)+"/":"//",g=()=>{m||(d=n(384),m=n(908))},l=function(e,t){return g(),e=m.normalize(e),d.readFileSync(e,t?void 0:"utf8")},p=e=>((e=l(e,!0)).buffer||(e=new Uint8Array(e)),e),f=(e,t,n)=>{g(),e=m.normalize(e),d.readFile(e,(function(e,r){e?n(e):t(r.buffer)}))},1<process.argv.length&&(y=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof ie))throw e})),process.on("unhandledRejection",(function(e){throw e})),v=(e,t)=>{if(C)throw process.exitCode=e,t;t instanceof ie||x("exiting due to exception: "+t),process.exit(e)},s.inspect=function(){return"[Emscripten Module object]"};try{t=n(925)}catch(e){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),e}n.g.Worker=t.Worker}else(b||w)&&(w?S=self.location.href:"undefined"!=typeof document&&document.currentScript&&(S=document.currentScript.src),_scriptDir&&(S=_scriptDir),S=0!==S.indexOf("blob:")?S.substr(0,S.replace(/[?#].*/,"").lastIndexOf("/")+1):"",_||(l=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},w&&(p=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),f=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)}));_&&"undefined"==typeof performance&&(n.g.performance=n(953).performance);var A=console.log.bind(console),E=console.warn.bind(console);_&&(g(),A=e=>d.writeSync(1,e+"\\n"),E=e=>d.writeSync(2,e+"\\n"));var M,R=s.print||A,x=s.printErr||E;Object.assign(s,h),h=null,s.thisProgram&&(y=s.thisProgram),s.quit&&(v=s.quit),s.wasmBinary&&(M=s.wasmBinary);var C=s.noExitRuntime||!0;"object"!=typeof WebAssembly&&ne("no native wasm support detected");var P,k,D,F,U,I,W,j,H=!1,L="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function Y(e,t,n){var r=(t>>>=0)+n;for(n=t;e[n]&&!(n>=r);)++n;if(16<n-t&&e.buffer&&L)return L.decode(e.buffer instanceof SharedArrayBuffer?e.slice(t,n):e.subarray(t,n));for(r="";t<n;){var a=e[t++];if(128&a){var o=63&e[t++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|o);else{var i=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|o<<6|i:(7&a)<<18|o<<12|i<<6|63&e[t++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function z(e,t){return(e>>>=0)?Y(r(),e,t):""}function B(e,t,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var o=0;o<e.length;++o){var i=e.charCodeAt(o);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++o)),127>=i){if(n>=r)break;t[n++>>>0]=i}else{if(2047>=i){if(n+1>=r)break;t[n++>>>0]=192|i>>6}else{if(65535>=i){if(n+2>=r)break;t[n++>>>0]=224|i>>12}else{if(n+3>=r)break;t[n++>>>0]=240|i>>18,t[n++>>>0]=128|i>>12&63}t[n++>>>0]=128|i>>6&63}t[n++>>>0]=128|63&i}}return t[n>>>0]=0,n-a}function N(e){for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);127>=r?t++:2047>=r?t+=2:55296<=r&&57343>=r?(t+=4,++n):t+=3}return t}function G(e){D=e,s.HEAP8=F=new Int8Array(e),s.HEAP16=new Int16Array(e),s.HEAP32=I=new Int32Array(e),s.HEAPU8=U=new Uint8Array(e),s.HEAPU16=new Uint16Array(e),s.HEAPU32=W=new Uint32Array(e),s.HEAPF32=new Float32Array(e),s.HEAPF64=j=new Float64Array(e)}O&&(D=s.buffer);var q=s.INITIAL_MEMORY||16777216;if(O)P=s.wasmMemory,D=s.buffer;else if(s.wasmMemory)P=s.wasmMemory;else if(!((P=new WebAssembly.Memory({initial:q/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw x("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),_&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");P&&(D=P.buffer),q=D.byteLength,G(D);var $,V=[],J=[],Q=[];function X(){var e=s.preRun.shift();V.unshift(e)}var K,Z=0,ee=null,te=null;function ne(e){throw O?postMessage({cmd:"onAbort",arg:e}):s.onAbort&&s.onAbort(e),x(e="Aborted("+e+")"),H=!0,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),c(e),e}function re(){return K.startsWith("data:application/octet-stream;base64,")}function ae(){var e=K;try{if(e==K&&M)return new Uint8Array(M);if(p)return p(e);throw"both async and sync fetching of the wasm failed"}catch(e){ne(e)}}K="ort-wasm-threaded.wasm",re()||(K=T(K));var oe={};function ie(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function se(e){(e=fe.La[e])||ne(),fe.Xa(e)}function ue(e){var t=fe.lb();if(!t)return 6;fe.Ra.push(t),fe.La[e.Ka]=t,t.Ka=e.Ka;var n={cmd:"run",start_routine:e.pb,arg:e.ib,pthread_ptr:e.Ka};return t.Qa=()=>{n.time=performance.now(),t.postMessage(n,e.vb)},t.loaded&&(t.Qa(),delete t.Qa),0}function ce(e){if(O)return He(1,1,e);C||(fe.qb(),s.onExit&&s.onExit(e),H=!0),v(e,new ie(e))}function le(e,t){if(!t&&O)throw de(e),"unwind";ce(e)}var fe={Oa:[],Ra:[],$a:[],La:{},Ua:function(){O&&fe.mb()},xb:function(){},mb:function(){fe.receiveObjectTransfer=fe.ob,fe.threadInitTLS=fe.Za,fe.setExitStatus=fe.Ya,C=!1},Ya:function(){},qb:function(){for(var e of Object.values(fe.La))fe.Xa(e);for(e of fe.Oa)e.terminate();fe.Oa=[]},Xa:function(e){var t=e.Ka;delete fe.La[t],fe.Oa.push(e),fe.Ra.splice(fe.Ra.indexOf(e),1),e.Ka=0,ct(t)},ob:function(){},Za:function(){fe.$a.forEach((e=>e()))},nb:function(e,t){e.onmessage=n=>{var r=(n=n.data).cmd;if(e.Ka&&(fe.kb=e.Ka),n.targetThread&&n.targetThread!=rt()){var a=fe.La[n.yb];a?a.postMessage(n,n.transferList):x(\'Internal error! Worker sent a message "\'+r+\'" to target pthread \'+n.targetThread+", but that thread no longer exists!")}else"processProxyingQueue"===r?De(n.queue):"spawnThread"===r?ue(n):"cleanupThread"===r?se(n.thread):"killThread"===r?(n=n.thread,r=fe.La[n],delete fe.La[n],r.terminate(),ct(n),fe.Ra.splice(fe.Ra.indexOf(r),1),r.Ka=0):"cancelThread"===r?fe.La[n.thread].postMessage({cmd:"cancel"}):"loaded"===r?(e.loaded=!0,t&&t(e),e.Qa&&(e.Qa(),delete e.Qa)):"print"===r?R("Thread "+n.threadId+": "+n.text):"printErr"===r?x("Thread "+n.threadId+": "+n.text):"alert"===r?alert("Thread "+n.threadId+": "+n.text):"setimmediate"===n.target?e.postMessage(n):"onAbort"===r?s.onAbort&&s.onAbort(n.arg):r&&x("worker sent an unknown command "+r);fe.kb=void 0},e.onerror=e=>{throw x("worker sent an error! "+e.filename+":"+e.lineno+": "+e.message),e},_&&(e.on("message",(function(t){e.onmessage({data:t})})),e.on("error",(function(t){e.onerror(t)})),e.on("detachedExit",(function(){}))),e.postMessage({cmd:"load",urlOrBlob:s.mainScriptUrlOrBlob||_scriptDir,wasmMemory:P,wasmModule:k})},hb:function(){var e=T("ort-wasm-threaded.worker.js");fe.Oa.push(new Worker(e))},lb:function(){return 0==fe.Oa.length&&(fe.hb(),fe.nb(fe.Oa[0])),fe.Oa.pop()}};function pe(e){for(;0<e.length;)e.shift()(s)}function de(e){if(O)return He(2,0,e);try{le(e)}catch(e){e instanceof ie||"unwind"==e||v(1,e)}}s.PThread=fe,s.establishStackSpace=function(){var e=rt(),t=a()[e+44>>2>>>0];e=a()[e+48>>2>>>0],ft(t,t-e),dt(t)};var me,ge,he=[];function ye(e){this.Pa=e-24,this.gb=function(e){o()[this.Pa+4>>2>>>0]=e},this.cb=function(e){o()[this.Pa+8>>2>>>0]=e},this.eb=function(){a()[this.Pa>>2>>>0]=0},this.bb=function(){t()[this.Pa+12>>0>>>0]=0},this.fb=function(){t()[this.Pa+13>>0>>>0]=0},this.Ua=function(e,t){this.ab(),this.gb(e),this.cb(t),this.eb(),this.bb(),this.fb()},this.ab=function(){o()[this.Pa+16>>2>>>0]=0}}function ve(e,t,n,r){return O?He(3,1,e,t,n,r):be(e,t,n,r)}function be(e,t,n,r){if("undefined"==typeof SharedArrayBuffer)return x("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[];return O&&0===a.length?ve(e,t,n,r):(e={pb:n,Ka:e,ib:r,vb:a},O?(e.wb="spawnThread",postMessage(e,a),0):ue(e))}function we(e,t,n){return O?He(4,1,e,t,n):0}function _e(e,t){if(O)return He(5,1,e,t)}function Oe(e,t){if(O)return He(6,1,e,t)}function Se(e,t,n){if(O)return He(7,1,e,t,n)}function Te(e,t,n){return O?He(8,1,e,t,n):0}function Ae(e,t){if(O)return He(9,1,e,t)}function Ee(e,t,n){if(O)return He(10,1,e,t,n)}function Me(e,t,n,r){if(O)return He(11,1,e,t,n,r)}function Re(e,t,n,r){if(O)return He(12,1,e,t,n,r)}function xe(e,t,n,r){if(O)return He(13,1,e,t,n,r)}function Ce(e){if(O)return He(14,1,e)}function Pe(e,t){if(O)return He(15,1,e,t)}function ke(e,t,n){if(O)return He(16,1,e,t,n)}function De(e){Atomics.store(a(),e>>2,1),rt()&&ut(e),Atomics.compareExchange(a(),e>>2,1,0)}function Fe(e){return o()[e>>>2]+4294967296*a()[e+4>>>2]}function Ue(e,t,n,r,a,o){return O?He(17,1,e,t,n,r,a,o):-52}function Ie(e,t,n,r,a,o){if(O)return He(18,1,e,t,n,r,a,o)}function We(e){var n=N(e)+1,r=at(n);return r&&B(e,t(),r,n),r}function je(e,t,n){function r(e){return(e=e.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?e[1]:"GMT"}if(O)return He(19,1,e,t,n);var i=(new Date).getFullYear(),s=new Date(i,0,1),u=new Date(i,6,1);i=s.getTimezoneOffset();var c=u.getTimezoneOffset(),l=Math.max(i,c);a()[e>>2>>>0]=60*l,a()[t>>2>>>0]=Number(i!=c),e=r(s),t=r(u),e=We(e),t=We(t),c<i?(o()[n>>2>>>0]=e,o()[n+4>>2>>>0]=t):(o()[n>>2>>>0]=t,o()[n+4>>2>>>0]=e)}function He(e,t){var n=arguments.length-2,r=arguments;return function(e){var t=pt();return e=e(),dt(t),e}((()=>{for(var a=mt(8*n),o=a>>3,s=0;s<n;s++){var u=r[2+s];i()[o+s>>>0]=u}return st(e,n,a,t)}))}s.invokeEntryPoint=function(e,t){var n=he[e];n||(e>=he.length&&(he.length=e+1),he[e]=n=$.get(e)),e=n(t),C?fe.Ya(e):lt(e)},s.executeNotifiedProxyingQueue=De,ge=_?()=>{var e=process.hrtime();return 1e3*e[0]+e[1]/1e6}:O?()=>performance.now()-s.__performance_now_clock_drift:()=>performance.now();var Le,Ye=[],ze={};function Be(){if(!Le){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:y||"./this.program"};for(e in ze)void 0===ze[e]?delete t[e]:t[e]=ze[e];var n=[];for(e in t)n.push(e+"="+t[e]);Le=n}return Le}function Ne(e,n){if(O)return He(20,1,e,n);var r=0;return Be().forEach((function(a,i){var s=n+r;for(i=o()[e+4*i>>2>>>0]=s,s=0;s<a.length;++s)t()[i++>>0>>>0]=a.charCodeAt(s);t()[i>>0>>>0]=0,r+=a.length+1})),0}function Ge(e,t){if(O)return He(21,1,e,t);var n=Be();o()[e>>2>>>0]=n.length;var r=0;return n.forEach((function(e){r+=e.length+1})),o()[t>>2>>>0]=r,0}function qe(e){return O?He(22,1,e):52}function $e(e,t,n,r){return O?He(23,1,e,t,n,r):52}function Ve(e,t,n,r,a){return O?He(24,1,e,t,n,r,a):70}var Je=[null,[],[]];function Qe(e,t,n,a){if(O)return He(25,1,e,t,n,a);for(var i=0,s=0;s<n;s++){var u=o()[t>>2>>>0],c=o()[t+4>>2>>>0];t+=8;for(var l=0;l<c;l++){var f=r()[u+l>>>0],p=Je[e];0===f||10===f?((1===e?R:x)(Y(p,0)),p.length=0):p.push(f)}i+=c}return o()[a>>2>>>0]=i,0}function Xe(e){return 0==e%4&&(0!=e%100||0==e%400)}var Ke=[31,29,31,30,31,30,31,31,30,31,30,31],Ze=[31,28,31,30,31,30,31,31,30,31,30,31];function et(e,n,r,o){function i(e,t,n){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=n[0]+e;return e}function s(e,t){return i(e,t,"0")}function u(e,t){function n(e){return 0>e?-1:0<e?1:0}var r;return 0===(r=n(e.getFullYear()-t.getFullYear()))&&0===(r=n(e.getMonth()-t.getMonth()))&&(r=n(e.getDate()-t.getDate())),r}function c(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function l(e){var t=e.Ma;for(e=new Date(new Date(e.Na+1900,0,1).getTime());0<t;){var n=e.getMonth(),r=(Xe(e.getFullYear())?Ke:Ze)[n];if(!(t>r-e.getDate())){e.setDate(e.getDate()+t);break}t-=r-e.getDate()+1,e.setDate(1),11>n?e.setMonth(n+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return n=new Date(e.getFullYear()+1,0,4),t=c(new Date(e.getFullYear(),0,4)),n=c(n),0>=u(t,e)?0>=u(n,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}var f=a()[o+40>>2>>>0];for(var p in o={tb:a()[o>>2>>>0],sb:a()[o+4>>2>>>0],Sa:a()[o+8>>2>>>0],Va:a()[o+12>>2>>>0],Ta:a()[o+16>>2>>>0],Na:a()[o+20>>2>>>0],Ja:a()[o+24>>2>>>0],Ma:a()[o+28>>2>>>0],zb:a()[o+32>>2>>>0],rb:a()[o+36>>2>>>0],ub:f?z(f):""},r=z(r),f={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})r=r.replace(new RegExp(p,"g"),f[p]);var d="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),m="January February March April May June July August September October November December".split(" ");for(p in f={"%a":function(e){return d[e.Ja].substring(0,3)},"%A":function(e){return d[e.Ja]},"%b":function(e){return m[e.Ta].substring(0,3)},"%B":function(e){return m[e.Ta]},"%C":function(e){return s((e.Na+1900)/100|0,2)},"%d":function(e){return s(e.Va,2)},"%e":function(e){return i(e.Va,2," ")},"%g":function(e){return l(e).toString().substring(2)},"%G":function(e){return l(e)},"%H":function(e){return s(e.Sa,2)},"%I":function(e){return 0==(e=e.Sa)?e=12:12<e&&(e-=12),s(e,2)},"%j":function(e){for(var t=0,n=0;n<=e.Ta-1;t+=(Xe(e.Na+1900)?Ke:Ze)[n++]);return s(e.Va+t,3)},"%m":function(e){return s(e.Ta+1,2)},"%M":function(e){return s(e.sb,2)},"%n":function(){return"\\n"},"%p":function(e){return 0<=e.Sa&&12>e.Sa?"AM":"PM"},"%S":function(e){return s(e.tb,2)},"%t":function(){return"\\t"},"%u":function(e){return e.Ja||7},"%U":function(e){return s(Math.floor((e.Ma+7-e.Ja)/7),2)},"%V":function(e){var t=Math.floor((e.Ma+7-(e.Ja+6)%7)/7);if(2>=(e.Ja+371-e.Ma-2)%7&&t++,t)53==t&&(4==(n=(e.Ja+371-e.Ma)%7)||3==n&&Xe(e.Na)||(t=1));else{t=52;var n=(e.Ja+7-e.Ma-1)%7;(4==n||5==n&&Xe(e.Na%400-1))&&t++}return s(t,2)},"%w":function(e){return e.Ja},"%W":function(e){return s(Math.floor((e.Ma+7-(e.Ja+6)%7)/7),2)},"%y":function(e){return(e.Na+1900).toString().substring(2)},"%Y":function(e){return e.Na+1900},"%z":function(e){var t=0<=(e=e.rb);return e=Math.abs(e)/60,(t?"+":"-")+String("0000"+(e/60*100+e%60)).slice(-4)},"%Z":function(e){return e.ub},"%%":function(){return"%"}},r=r.replace(/%%/g,"\\0\\0"),f)r.includes(p)&&(r=r.replace(new RegExp(p,"g"),f[p](o)));return p=function(e){var t=Array(N(e)+1);return B(e,t,0,t.length),t}(r=r.replace(/\\0\\0/g,"%")),p.length>n?0:(function(e,n){t().set(e,n>>>0)}(p,e),p.length-1)}fe.Ua();var tt=[null,ce,de,ve,we,_e,Oe,Se,Te,Ae,Ee,Me,Re,xe,Ce,Pe,ke,Ue,Ie,je,Ne,Ge,qe,$e,Ve,Qe],nt={b:function(e){return at(e+24)+24},c:function(e,t,n){throw new ye(e).Ua(t,n),e},L:function(e){ot(e,!w,1,!b),fe.Za()},l:function(e){O?postMessage({cmd:"cleanupThread",thread:e}):se(e)},D:be,i:we,R:_e,z:Oe,B:Se,T:Te,P:Ae,I:Ee,O:Me,p:Re,A:xe,x:Ce,Q:Pe,y:ke,r:function(){},j:function(){ne("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},s:function(){ne("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},q:function(){return Date.now()},E:function(){return 2097152},V:function(){return!0},F:function(e,t,n,r){if(e==t)setTimeout((()=>De(r)));else if(O)postMessage({targetThread:e,cmd:"processProxyingQueue",queue:r});else{if(!(e=fe.La[e]))return;e.postMessage({cmd:"processProxyingQueue",queue:r})}return 1},K:function(){return-1},W:function(e,t){e=new Date(1e3*Fe(e)),a()[t>>2>>>0]=e.getUTCSeconds(),a()[t+4>>2>>>0]=e.getUTCMinutes(),a()[t+8>>2>>>0]=e.getUTCHours(),a()[t+12>>2>>>0]=e.getUTCDate(),a()[t+16>>2>>>0]=e.getUTCMonth(),a()[t+20>>2>>>0]=e.getUTCFullYear()-1900,a()[t+24>>2>>>0]=e.getUTCDay(),e=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[t+28>>2>>>0]=e},X:function(e,t){e=new Date(1e3*Fe(e)),a()[t>>2>>>0]=e.getSeconds(),a()[t+4>>2>>>0]=e.getMinutes(),a()[t+8>>2>>>0]=e.getHours(),a()[t+12>>2>>>0]=e.getDate(),a()[t+16>>2>>>0]=e.getMonth(),a()[t+20>>2>>>0]=e.getFullYear()-1900,a()[t+24>>2>>>0]=e.getDay();var n=new Date(e.getFullYear(),0,1),r=(e.getTime()-n.getTime())/864e5|0;a()[t+28>>2>>>0]=r,a()[t+36>>2>>>0]=-60*e.getTimezoneOffset(),r=new Date(e.getFullYear(),6,1).getTimezoneOffset(),e=0|(r!=(n=n.getTimezoneOffset())&&e.getTimezoneOffset()==Math.min(n,r)),a()[t+32>>2>>>0]=e},Y:function(e){var t=new Date(a()[e+20>>2>>>0]+1900,a()[e+16>>2>>>0],a()[e+12>>2>>>0],a()[e+8>>2>>>0],a()[e+4>>2>>>0],a()[e>>2>>>0],0),n=a()[e+32>>2>>>0],r=t.getTimezoneOffset(),o=new Date(t.getFullYear(),0,1),i=new Date(t.getFullYear(),6,1).getTimezoneOffset(),s=o.getTimezoneOffset(),u=Math.min(s,i);return 0>n?a()[e+32>>2>>>0]=Number(i!=s&&u==r):0<n!=(u==r)&&(i=Math.max(s,i),t.setTime(t.getTime()+6e4*((0<n?u:i)-r))),a()[e+24>>2>>>0]=t.getDay(),n=(t.getTime()-o.getTime())/864e5|0,a()[e+28>>2>>>0]=n,a()[e>>2>>>0]=t.getSeconds(),a()[e+4>>2>>>0]=t.getMinutes(),a()[e+8>>2>>>0]=t.getHours(),a()[e+12>>2>>>0]=t.getDate(),a()[e+16>>2>>>0]=t.getMonth(),t.getTime()/1e3|0},G:Ue,H:Ie,Z:function e(t,n,r){e.jb||(e.jb=!0,je(t,n,r))},d:function(){ne("")},m:function(){if(!_&&!w){var e="Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";me||(me={}),me[e]||(me[e]=1,_&&(e="warning: "+e),x(e))}},w:function(){return 4294901760},f:ge,S:function(e,t,n){r().copyWithin(e>>>0,t>>>0,t+n>>>0)},g:function(){return _?n(993).cpus().length:navigator.hardwareConcurrency},J:function(e,t,n){Ye.length=t,n>>=3;for(var r=0;r<t;r++)Ye[r]=i()[n+r>>>0];return(0>e?oe[-e-1]:tt[e]).apply(null,Ye)},v:function(e){var t=r().length;if((e>>>=0)<=t||4294901760<e)return!1;for(var n=1;4>=n;n*=2){var a=t*(1+.2/n);a=Math.min(a,e+100663296);var o=Math;a=Math.max(e,a),o=o.min.call(o,4294901760,a+(65536-a%65536)%65536);e:{try{P.grow(o-D.byteLength+65535>>>16),G(P.buffer);var i=1;break e}catch(e){}i=void 0}if(i)return!0}return!1},U:function(){throw"unwind"},M:Ne,N:Ge,k:le,h:qe,o:$e,t:Ve,n:Qe,u:function e(r,a){e.Wa||(e.Wa=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var e=new Uint8Array(1);return()=>(crypto.getRandomValues(e),e[0])}if(_)try{var t=n(760);return()=>t.randomBytes(1)[0]}catch(e){}return()=>ne("randomDevice")}());for(var o=0;o<a;o++)t()[r+o>>0>>>0]=e.Wa();return 0},a:P||s.wasmMemory,C:et,e:function(e,t,n,r){return et(e,t,n,r)}};!function(){function e(e,t){s.asm=e.exports,fe.$a.push(s.asm.wa),$=s.asm.za,J.unshift(s.asm._),k=t,O||(Z--,s.monitorRunDependencies&&s.monitorRunDependencies(Z),0==Z&&(null!==ee&&(clearInterval(ee),ee=null),te&&(e=te,te=null,e())))}function t(t){e(t.instance,t.module)}function n(e){return function(){if(!M&&(b||w)){if("function"==typeof fetch&&!K.startsWith("file://"))return fetch(K,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at \'"+K+"\'";return e.arrayBuffer()})).catch((function(){return ae()}));if(f)return new Promise((function(e,t){f(K,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return ae()}))}().then((function(e){return WebAssembly.instantiate(e,r)})).then((function(e){return e})).then(e,(function(e){x("failed to asynchronously prepare wasm: "+e),ne(e)}))}var r={a:nt};if(O||(Z++,s.monitorRunDependencies&&s.monitorRunDependencies(Z)),s.instantiateWasm)try{return s.instantiateWasm(r,e)}catch(e){return x("Module.instantiateWasm callback failed with error: "+e),!1}(M||"function"!=typeof WebAssembly.instantiateStreaming||re()||K.startsWith("file://")||_||"function"!=typeof fetch?n(t):fetch(K,{credentials:"same-origin"}).then((function(e){return WebAssembly.instantiateStreaming(e,r).then(t,(function(e){return x("wasm streaming compile failed: "+e),x("falling back to ArrayBuffer instantiation"),n(t)}))}))).catch(c)}(),s.___wasm_call_ctors=function(){return(s.___wasm_call_ctors=s.asm._).apply(null,arguments)},s._OrtInit=function(){return(s._OrtInit=s.asm.$).apply(null,arguments)},s._OrtCreateSessionOptions=function(){return(s._OrtCreateSessionOptions=s.asm.aa).apply(null,arguments)},s._OrtAppendExecutionProvider=function(){return(s._OrtAppendExecutionProvider=s.asm.ba).apply(null,arguments)},s._OrtAddSessionConfigEntry=function(){return(s._OrtAddSessionConfigEntry=s.asm.ca).apply(null,arguments)},s._OrtReleaseSessionOptions=function(){return(s._OrtReleaseSessionOptions=s.asm.da).apply(null,arguments)},s._OrtCreateSession=function(){return(s._OrtCreateSession=s.asm.ea).apply(null,arguments)},s._OrtReleaseSession=function(){return(s._OrtReleaseSession=s.asm.fa).apply(null,arguments)},s._OrtGetInputCount=function(){return(s._OrtGetInputCount=s.asm.ga).apply(null,arguments)},s._OrtGetOutputCount=function(){return(s._OrtGetOutputCount=s.asm.ha).apply(null,arguments)},s._OrtGetInputName=function(){return(s._OrtGetInputName=s.asm.ia).apply(null,arguments)},s._OrtGetOutputName=function(){return(s._OrtGetOutputName=s.asm.ja).apply(null,arguments)},s._OrtFree=function(){return(s._OrtFree=s.asm.ka).apply(null,arguments)},s._OrtCreateTensor=function(){return(s._OrtCreateTensor=s.asm.la).apply(null,arguments)},s._OrtGetTensorData=function(){return(s._OrtGetTensorData=s.asm.ma).apply(null,arguments)},s._OrtReleaseTensor=function(){return(s._OrtReleaseTensor=s.asm.na).apply(null,arguments)},s._OrtCreateRunOptions=function(){return(s._OrtCreateRunOptions=s.asm.oa).apply(null,arguments)},s._OrtAddRunConfigEntry=function(){return(s._OrtAddRunConfigEntry=s.asm.pa).apply(null,arguments)},s._OrtReleaseRunOptions=function(){return(s._OrtReleaseRunOptions=s.asm.qa).apply(null,arguments)},s._OrtRun=function(){return(s._OrtRun=s.asm.ra).apply(null,arguments)},s._OrtEndProfiling=function(){return(s._OrtEndProfiling=s.asm.sa).apply(null,arguments)};var rt=s._pthread_self=function(){return(rt=s._pthread_self=s.asm.ta).apply(null,arguments)},at=s._malloc=function(){return(at=s._malloc=s.asm.ua).apply(null,arguments)};s._free=function(){return(s._free=s.asm.va).apply(null,arguments)},s.__emscripten_tls_init=function(){return(s.__emscripten_tls_init=s.asm.wa).apply(null,arguments)};var ot=s.__emscripten_thread_init=function(){return(ot=s.__emscripten_thread_init=s.asm.xa).apply(null,arguments)};s.__emscripten_thread_crashed=function(){return(s.__emscripten_thread_crashed=s.asm.ya).apply(null,arguments)};var it,st=s._emscripten_run_in_main_runtime_thread_js=function(){return(st=s._emscripten_run_in_main_runtime_thread_js=s.asm.Aa).apply(null,arguments)},ut=s.__emscripten_proxy_execute_task_queue=function(){return(ut=s.__emscripten_proxy_execute_task_queue=s.asm.Ba).apply(null,arguments)},ct=s.__emscripten_thread_free_data=function(){return(ct=s.__emscripten_thread_free_data=s.asm.Ca).apply(null,arguments)},lt=s.__emscripten_thread_exit=function(){return(lt=s.__emscripten_thread_exit=s.asm.Da).apply(null,arguments)},ft=s._emscripten_stack_set_limits=function(){return(ft=s._emscripten_stack_set_limits=s.asm.Ea).apply(null,arguments)},pt=s.stackSave=function(){return(pt=s.stackSave=s.asm.Fa).apply(null,arguments)},dt=s.stackRestore=function(){return(dt=s.stackRestore=s.asm.Ga).apply(null,arguments)},mt=s.stackAlloc=function(){return(mt=s.stackAlloc=s.asm.Ha).apply(null,arguments)};function gt(){function e(){if(!it&&(it=!0,s.calledRun=!0,!H)&&(O||pe(J),u(s),s.onRuntimeInitialized&&s.onRuntimeInitialized(),!O)){if(s.postRun)for("function"==typeof s.postRun&&(s.postRun=[s.postRun]);s.postRun.length;){var e=s.postRun.shift();Q.unshift(e)}pe(Q)}}if(!(0<Z))if(O)u(s),O||pe(J),postMessage({cmd:"loaded"});else{if(s.preRun)for("function"==typeof s.preRun&&(s.preRun=[s.preRun]);s.preRun.length;)X();pe(V),0<Z||(s.setStatus?(s.setStatus("Running..."),setTimeout((function(){setTimeout((function(){s.setStatus("")}),1),e()}),1)):e())}}if(s.___cxa_is_pointer_type=function(){return(s.___cxa_is_pointer_type=s.asm.Ia).apply(null,arguments)},s.UTF8ToString=z,s.stringToUTF8=function(e,t,n){return B(e,r(),t,n)},s.lengthBytesUTF8=N,s.keepRuntimeAlive=function(){return C},s.wasmMemory=P,s.stackSave=pt,s.stackRestore=dt,s.stackAlloc=mt,s.ExitStatus=ie,s.PThread=fe,te=function e(){it||gt(),it||(te=e)},s.preInit)for("function"==typeof s.preInit&&(s.preInit=[s.preInit]);0<s.preInit.length;)s.preInit.pop()();return gt(),e.ready});e.exports=r},932:(e,t,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(e){var t,r,a;e=e||{},t||(t=void 0!==e?e:{}),t.ready=new Promise((function(e,t){r=e,a=t}));var o,i,s,u,c,l,f=Object.assign({},t),p="./this.program",d=(e,t)=>{throw t},m="object"==typeof window,g="function"==typeof importScripts,h="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,y="";h?(y=g?n(908).dirname(y)+"/":"//",l=()=>{c||(u=n(384),c=n(908))},o=function(e,t){return l(),e=c.normalize(e),u.readFileSync(e,t?void 0:"utf8")},s=e=>((e=o(e,!0)).buffer||(e=new Uint8Array(e)),e),i=(e,t,n)=>{l(),e=c.normalize(e),u.readFile(e,(function(e,r){e?n(e):t(r.buffer)}))},1<process.argv.length&&(p=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof $))throw e})),process.on("unhandledRejection",(function(e){throw e})),d=(e,t)=>{if(_)throw process.exitCode=e,t;t instanceof $||w("exiting due to exception: "+t),process.exit(e)},t.inspect=function(){return"[Emscripten Module object]"}):(m||g)&&(g?y=self.location.href:"undefined"!=typeof document&&document.currentScript&&(y=document.currentScript.src),_scriptDir&&(y=_scriptDir),y=0!==y.indexOf("blob:")?y.substr(0,y.replace(/[?#].*/,"").lastIndexOf("/")+1):"",o=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},g&&(s=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),i=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)});var v,b=t.print||console.log.bind(console),w=t.printErr||console.warn.bind(console);Object.assign(t,f),f=null,t.thisProgram&&(p=t.thisProgram),t.quit&&(d=t.quit),t.wasmBinary&&(v=t.wasmBinary);var _=t.noExitRuntime||!0;"object"!=typeof WebAssembly&&B("no native wasm support detected");var O,S,T,A,E,M,R=!1,x="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function C(e,t,n){var r=(t>>>=0)+n;for(n=t;e[n]&&!(n>=r);)++n;if(16<n-t&&e.buffer&&x)return x.decode(e.subarray(t,n));for(r="";t<n;){var a=e[t++];if(128&a){var o=63&e[t++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|o);else{var i=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|o<<6|i:(7&a)<<18|o<<12|i<<6|63&e[t++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function P(e,t){return(e>>>=0)?C(A,e,t):""}function k(e,t,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var o=0;o<e.length;++o){var i=e.charCodeAt(o);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++o)),127>=i){if(n>=r)break;t[n++>>>0]=i}else{if(2047>=i){if(n+1>=r)break;t[n++>>>0]=192|i>>6}else{if(65535>=i){if(n+2>=r)break;t[n++>>>0]=224|i>>12}else{if(n+3>=r)break;t[n++>>>0]=240|i>>18,t[n++>>>0]=128|i>>12&63}t[n++>>>0]=128|i>>6&63}t[n++>>>0]=128|63&i}}return t[n>>>0]=0,n-a}function D(e){for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);127>=r?t++:2047>=r?t+=2:55296<=r&&57343>=r?(t+=4,++n):t+=3}return t}function F(){var e=O.buffer;S=e,t.HEAP8=T=new Int8Array(e),t.HEAP16=new Int16Array(e),t.HEAP32=E=new Int32Array(e),t.HEAPU8=A=new Uint8Array(e),t.HEAPU16=new Uint16Array(e),t.HEAPU32=M=new Uint32Array(e),t.HEAPF32=new Float32Array(e),t.HEAPF64=new Float64Array(e)}var U=[],I=[],W=[];function j(){var e=t.preRun.shift();U.unshift(e)}var H,L=0,Y=null,z=null;function B(e){throw t.onAbort&&t.onAbort(e),w(e="Aborted("+e+")"),R=!0,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),a(e),e}function N(){return H.startsWith("data:application/octet-stream;base64,")}if(H="ort-wasm.wasm",!N()){var G=H;H=t.locateFile?t.locateFile(G,y):y+G}function q(){var e=H;try{if(e==H&&v)return new Uint8Array(v);if(s)return s(e);throw"both async and sync fetching of the wasm failed"}catch(e){B(e)}}function $(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function V(e){for(;0<e.length;)e.shift()(t)}function J(e){this.sa=e-24,this.Ia=function(e){M[this.sa+4>>2>>>0]=e},this.Ba=function(e){M[this.sa+8>>2>>>0]=e},this.Ga=function(){E[this.sa>>2>>>0]=0},this.Aa=function(){T[this.sa+12>>0>>>0]=0},this.Ha=function(){T[this.sa+13>>0>>>0]=0},this.ya=function(e,t){this.za(),this.Ia(e),this.Ba(t),this.Ga(),this.Aa(),this.Ha()},this.za=function(){M[this.sa+16>>2>>>0]=0}}function Q(e){var t=D(e)+1,n=ie(t);return n&&k(e,T,n,t),n}var X={};function K(){if(!Z){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:p||"./this.program"};for(e in X)void 0===X[e]?delete t[e]:t[e]=X[e];var n=[];for(e in t)n.push(e+"="+t[e]);Z=n}return Z}var Z,ee=[null,[],[]];function te(e){return 0==e%4&&(0!=e%100||0==e%400)}var ne=[31,29,31,30,31,30,31,31,30,31,30,31],re=[31,28,31,30,31,30,31,31,30,31,30,31];function ae(e,t,n,r){function a(e,t,n){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=n[0]+e;return e}function o(e,t){return a(e,t,"0")}function i(e,t){function n(e){return 0>e?-1:0<e?1:0}var r;return 0===(r=n(e.getFullYear()-t.getFullYear()))&&0===(r=n(e.getMonth()-t.getMonth()))&&(r=n(e.getDate()-t.getDate())),r}function s(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function u(e){var t=e.qa;for(e=new Date(new Date(e.ra+1900,0,1).getTime());0<t;){var n=e.getMonth(),r=(te(e.getFullYear())?ne:re)[n];if(!(t>r-e.getDate())){e.setDate(e.getDate()+t);break}t-=r-e.getDate()+1,e.setDate(1),11>n?e.setMonth(n+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return n=new Date(e.getFullYear()+1,0,4),t=s(new Date(e.getFullYear(),0,4)),n=s(n),0>=i(t,e)?0>=i(n,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}var c=E[r+40>>2>>>0];for(var l in r={Ea:E[r>>2>>>0],Da:E[r+4>>2>>>0],ta:E[r+8>>2>>>0],va:E[r+12>>2>>>0],ua:E[r+16>>2>>>0],ra:E[r+20>>2>>>0],la:E[r+24>>2>>>0],qa:E[r+28>>2>>>0],Ja:E[r+32>>2>>>0],Ca:E[r+36>>2>>>0],Fa:c?P(c):""},n=P(n),c={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})n=n.replace(new RegExp(l,"g"),c[l]);var f="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),p="January February March April May June July August September October November December".split(" ");for(l in c={"%a":function(e){return f[e.la].substring(0,3)},"%A":function(e){return f[e.la]},"%b":function(e){return p[e.ua].substring(0,3)},"%B":function(e){return p[e.ua]},"%C":function(e){return o((e.ra+1900)/100|0,2)},"%d":function(e){return o(e.va,2)},"%e":function(e){return a(e.va,2," ")},"%g":function(e){return u(e).toString().substring(2)},"%G":function(e){return u(e)},"%H":function(e){return o(e.ta,2)},"%I":function(e){return 0==(e=e.ta)?e=12:12<e&&(e-=12),o(e,2)},"%j":function(e){for(var t=0,n=0;n<=e.ua-1;t+=(te(e.ra+1900)?ne:re)[n++]);return o(e.va+t,3)},"%m":function(e){return o(e.ua+1,2)},"%M":function(e){return o(e.Da,2)},"%n":function(){return"\\n"},"%p":function(e){return 0<=e.ta&&12>e.ta?"AM":"PM"},"%S":function(e){return o(e.Ea,2)},"%t":function(){return"\\t"},"%u":function(e){return e.la||7},"%U":function(e){return o(Math.floor((e.qa+7-e.la)/7),2)},"%V":function(e){var t=Math.floor((e.qa+7-(e.la+6)%7)/7);if(2>=(e.la+371-e.qa-2)%7&&t++,t)53==t&&(4==(n=(e.la+371-e.qa)%7)||3==n&&te(e.ra)||(t=1));else{t=52;var n=(e.la+7-e.qa-1)%7;(4==n||5==n&&te(e.ra%400-1))&&t++}return o(t,2)},"%w":function(e){return e.la},"%W":function(e){return o(Math.floor((e.qa+7-(e.la+6)%7)/7),2)},"%y":function(e){return(e.ra+1900).toString().substring(2)},"%Y":function(e){return e.ra+1900},"%z":function(e){var t=0<=(e=e.Ca);return e=Math.abs(e)/60,(t?"+":"-")+String("0000"+(e/60*100+e%60)).slice(-4)},"%Z":function(e){return e.Fa},"%%":function(){return"%"}},n=n.replace(/%%/g,"\\0\\0"),c)n.includes(l)&&(n=n.replace(new RegExp(l,"g"),c[l](r)));return l=function(e){var t=Array(D(e)+1);return k(e,t,0,t.length),t}(n=n.replace(/\\0\\0/g,"%")),l.length>t?0:(T.set(l,e>>>0),l.length-1)}var oe={a:function(e){return ie(e+24)+24},b:function(e,t,n){throw new J(e).ya(t,n),e},g:function(){return 0},I:function(){},w:function(){},y:function(){},K:function(){return 0},G:function(){},C:function(){},F:function(){},k:function(){},x:function(){},u:function(){},H:function(){},v:function(){},n:function(){},p:function(){B("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},o:function(){B("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},l:function(){return Date.now()},L:function(){return!0},M:function(e,t){e=new Date(1e3*(M[e>>>2]+4294967296*E[e+4>>>2])),E[t>>2>>>0]=e.getUTCSeconds(),E[t+4>>2>>>0]=e.getUTCMinutes(),E[t+8>>2>>>0]=e.getUTCHours(),E[t+12>>2>>>0]=e.getUTCDate(),E[t+16>>2>>>0]=e.getUTCMonth(),E[t+20>>2>>>0]=e.getUTCFullYear()-1900,E[t+24>>2>>>0]=e.getUTCDay(),E[t+28>>2>>>0]=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},N:function(e,t){e=new Date(1e3*(M[e>>>2]+4294967296*E[e+4>>>2])),E[t>>2>>>0]=e.getSeconds(),E[t+4>>2>>>0]=e.getMinutes(),E[t+8>>2>>>0]=e.getHours(),E[t+12>>2>>>0]=e.getDate(),E[t+16>>2>>>0]=e.getMonth(),E[t+20>>2>>>0]=e.getFullYear()-1900,E[t+24>>2>>>0]=e.getDay();var n=new Date(e.getFullYear(),0,1);E[t+28>>2>>>0]=(e.getTime()-n.getTime())/864e5|0,E[t+36>>2>>>0]=-60*e.getTimezoneOffset();var r=new Date(e.getFullYear(),6,1).getTimezoneOffset();n=n.getTimezoneOffset(),E[t+32>>2>>>0]=0|(r!=n&&e.getTimezoneOffset()==Math.min(n,r))},O:function(e){var t=new Date(E[e+20>>2>>>0]+1900,E[e+16>>2>>>0],E[e+12>>2>>>0],E[e+8>>2>>>0],E[e+4>>2>>>0],E[e>>2>>>0],0),n=E[e+32>>2>>>0],r=t.getTimezoneOffset(),a=new Date(t.getFullYear(),0,1),o=new Date(t.getFullYear(),6,1).getTimezoneOffset(),i=a.getTimezoneOffset(),s=Math.min(i,o);return 0>n?E[e+32>>2>>>0]=Number(o!=i&&s==r):0<n!=(s==r)&&(o=Math.max(i,o),t.setTime(t.getTime()+6e4*((0<n?s:o)-r))),E[e+24>>2>>>0]=t.getDay(),E[e+28>>2>>>0]=(t.getTime()-a.getTime())/864e5|0,E[e>>2>>>0]=t.getSeconds(),E[e+4>>2>>>0]=t.getMinutes(),E[e+8>>2>>>0]=t.getHours(),E[e+12>>2>>>0]=t.getDate(),E[e+16>>2>>>0]=t.getMonth(),t.getTime()/1e3|0},z:function(){return-52},B:function(){},m:function e(t,n,r){e.xa||(e.xa=!0,function(e,t,n){function r(e){return(e=e.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?e[1]:"GMT"}var a=(new Date).getFullYear(),o=new Date(a,0,1),i=new Date(a,6,1);a=o.getTimezoneOffset();var s=i.getTimezoneOffset();E[e>>2>>>0]=60*Math.max(a,s),E[t>>2>>>0]=Number(a!=s),e=r(o),t=r(i),e=Q(e),t=Q(t),s<a?(M[n>>2>>>0]=e,M[n+4>>2>>>0]=t):(M[n>>2>>>0]=t,M[n+4>>2>>>0]=e)}(t,n,r))},d:function(){B("")},t:function(){return 4294901760},h:h?()=>{var e=process.hrtime();return 1e3*e[0]+e[1]/1e6}:()=>performance.now(),J:function(e,t,n){A.copyWithin(e>>>0,t>>>0,t+n>>>0)},f:function(e){var t=A.length;if(4294901760<(e>>>=0))return!1;for(var n=1;4>=n;n*=2){var r=t*(1+.2/n);r=Math.min(r,e+100663296);var a=Math;r=Math.max(e,r),a=a.min.call(a,4294901760,r+(65536-r%65536)%65536);e:{try{O.grow(a-S.byteLength+65535>>>16),F();var o=1;break e}catch(e){}o=void 0}if(o)return!0}return!1},D:function(e,t){var n=0;return K().forEach((function(r,a){var o=t+n;for(a=M[e+4*a>>2>>>0]=o,o=0;o<r.length;++o)T[a++>>0>>>0]=r.charCodeAt(o);T[a>>0>>>0]=0,n+=r.length+1})),0},E:function(e,t){var n=K();M[e>>2>>>0]=n.length;var r=0;return n.forEach((function(e){r+=e.length+1})),M[t>>2>>>0]=r,0},r:function(e){_||(t.onExit&&t.onExit(e),R=!0),d(e,new $(e))},e:function(){return 52},j:function(){return 52},q:function(){return 70},i:function(e,t,n,r){for(var a=0,o=0;o<n;o++){var i=M[t>>2>>>0],s=M[t+4>>2>>>0];t+=8;for(var u=0;u<s;u++){var c=A[i+u>>>0],l=ee[e];0===c||10===c?((1===e?b:w)(C(l,0)),l.length=0):l.push(c)}a+=s}return M[r>>2>>>0]=a,0},s:function e(t,r){e.wa||(e.wa=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var e=new Uint8Array(1);return()=>(crypto.getRandomValues(e),e[0])}if(h)try{var t=n(760);return()=>t.randomBytes(1)[0]}catch(e){}return()=>B("randomDevice")}());for(var a=0;a<r;a++)T[t+a>>0>>>0]=e.wa();return 0},A:ae,c:function(e,t,n,r){return ae(e,t,n,r)}};!function(){function e(e){t.asm=e.exports,O=t.asm.P,F(),I.unshift(t.asm.Q),L--,t.monitorRunDependencies&&t.monitorRunDependencies(L),0==L&&(null!==Y&&(clearInterval(Y),Y=null),z&&(e=z,z=null,e()))}function n(t){e(t.instance)}function r(e){return function(){if(!v&&(m||g)){if("function"==typeof fetch&&!H.startsWith("file://"))return fetch(H,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at \'"+H+"\'";return e.arrayBuffer()})).catch((function(){return q()}));if(i)return new Promise((function(e,t){i(H,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return q()}))}().then((function(e){return WebAssembly.instantiate(e,o)})).then((function(e){return e})).then(e,(function(e){w("failed to asynchronously prepare wasm: "+e),B(e)}))}var o={a:oe};if(L++,t.monitorRunDependencies&&t.monitorRunDependencies(L),t.instantiateWasm)try{return t.instantiateWasm(o,e)}catch(e){return w("Module.instantiateWasm callback failed with error: "+e),!1}(v||"function"!=typeof WebAssembly.instantiateStreaming||N()||H.startsWith("file://")||h||"function"!=typeof fetch?r(n):fetch(H,{credentials:"same-origin"}).then((function(e){return WebAssembly.instantiateStreaming(e,o).then(n,(function(e){return w("wasm streaming compile failed: "+e),w("falling back to ArrayBuffer instantiation"),r(n)}))}))).catch(a)}(),t.___wasm_call_ctors=function(){return(t.___wasm_call_ctors=t.asm.Q).apply(null,arguments)},t._OrtInit=function(){return(t._OrtInit=t.asm.R).apply(null,arguments)},t._OrtCreateSessionOptions=function(){return(t._OrtCreateSessionOptions=t.asm.S).apply(null,arguments)},t._OrtAppendExecutionProvider=function(){return(t._OrtAppendExecutionProvider=t.asm.T).apply(null,arguments)},t._OrtAddSessionConfigEntry=function(){return(t._OrtAddSessionConfigEntry=t.asm.U).apply(null,arguments)},t._OrtReleaseSessionOptions=function(){return(t._OrtReleaseSessionOptions=t.asm.V).apply(null,arguments)},t._OrtCreateSession=function(){return(t._OrtCreateSession=t.asm.W).apply(null,arguments)},t._OrtReleaseSession=function(){return(t._OrtReleaseSession=t.asm.X).apply(null,arguments)},t._OrtGetInputCount=function(){return(t._OrtGetInputCount=t.asm.Y).apply(null,arguments)},t._OrtGetOutputCount=function(){return(t._OrtGetOutputCount=t.asm.Z).apply(null,arguments)},t._OrtGetInputName=function(){return(t._OrtGetInputName=t.asm._).apply(null,arguments)},t._OrtGetOutputName=function(){return(t._OrtGetOutputName=t.asm.$).apply(null,arguments)},t._OrtFree=function(){return(t._OrtFree=t.asm.aa).apply(null,arguments)},t._OrtCreateTensor=function(){return(t._OrtCreateTensor=t.asm.ba).apply(null,arguments)},t._OrtGetTensorData=function(){return(t._OrtGetTensorData=t.asm.ca).apply(null,arguments)},t._OrtReleaseTensor=function(){return(t._OrtReleaseTensor=t.asm.da).apply(null,arguments)},t._OrtCreateRunOptions=function(){return(t._OrtCreateRunOptions=t.asm.ea).apply(null,arguments)},t._OrtAddRunConfigEntry=function(){return(t._OrtAddRunConfigEntry=t.asm.fa).apply(null,arguments)},t._OrtReleaseRunOptions=function(){return(t._OrtReleaseRunOptions=t.asm.ga).apply(null,arguments)},t._OrtRun=function(){return(t._OrtRun=t.asm.ha).apply(null,arguments)},t._OrtEndProfiling=function(){return(t._OrtEndProfiling=t.asm.ia).apply(null,arguments)};var ie=t._malloc=function(){return(ie=t._malloc=t.asm.ja).apply(null,arguments)};t._free=function(){return(t._free=t.asm.ka).apply(null,arguments)};var se,ue=t.stackSave=function(){return(ue=t.stackSave=t.asm.ma).apply(null,arguments)},ce=t.stackRestore=function(){return(ce=t.stackRestore=t.asm.na).apply(null,arguments)},le=t.stackAlloc=function(){return(le=t.stackAlloc=t.asm.oa).apply(null,arguments)};function fe(){function e(){if(!se&&(se=!0,t.calledRun=!0,!R)){if(V(I),r(t),t.onRuntimeInitialized&&t.onRuntimeInitialized(),t.postRun)for("function"==typeof t.postRun&&(t.postRun=[t.postRun]);t.postRun.length;){var e=t.postRun.shift();W.unshift(e)}V(W)}}if(!(0<L)){if(t.preRun)for("function"==typeof t.preRun&&(t.preRun=[t.preRun]);t.preRun.length;)j();V(U),0<L||(t.setStatus?(t.setStatus("Running..."),setTimeout((function(){setTimeout((function(){t.setStatus("")}),1),e()}),1)):e())}}if(t.___cxa_is_pointer_type=function(){return(t.___cxa_is_pointer_type=t.asm.pa).apply(null,arguments)},t.UTF8ToString=P,t.stringToUTF8=function(e,t,n){return k(e,A,t,n)},t.lengthBytesUTF8=D,t.stackSave=ue,t.stackRestore=ce,t.stackAlloc=le,z=function e(){se||fe(),se||(z=e)},t.preInit)for("function"==typeof t.preInit&&(t.preInit=[t.preInit]);0<t.preInit.length;)t.preInit.pop()();return fe(),e.ready});e.exports=r},154:e=>{"use strict";e.exports=\'"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\\n\'},760:()=>{},384:()=>{},993:()=>{},908:()=>{},953:()=>{},925:()=>{},449:()=>{}},t={};function n(r){var a=t[r];if(void 0!==a)return a.exports;var o=t[r]={exports:{}};return e[r].call(o.exports,o,o.exports,n),o.exports}n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),(()=>{"use strict";const e=n(259),t=n(263);self.onmessage=n=>{switch(n.data.type){case"init-wasm":(0,t.initializeWebAssembly)(n.data.in).then((()=>postMessage({type:"init-wasm"})),(e=>postMessage({type:"init-wasm",err:e})));break;case"init-ort":try{const{numThreads:t,loggingLevel:r}=n.data.in;(0,e.initOrt)(t,r),postMessage({type:"init-ort"})}catch(e){postMessage({type:"init-ort",err:e})}break;case"create_allocate":try{const{model:t}=n.data.in,r=(0,e.createSessionAllocate)(t);postMessage({type:"create_allocate",out:r})}catch(e){postMessage({type:"create_allocate",err:e})}break;case"create_finalize":try{const{modeldata:t,options:r}=n.data.in,a=(0,e.createSessionFinalize)(t,r);postMessage({type:"create_finalize",out:a})}catch(e){postMessage({type:"create_finalize",err:e})}break;case"create":try{const{model:t,options:r}=n.data.in,a=(0,e.createSession)(t,r);postMessage({type:"create",out:a})}catch(e){postMessage({type:"create",err:e})}break;case"release":try{const t=n.data.in;(0,e.releaseSession)(t),postMessage({type:"release"})}catch(e){postMessage({type:"release",err:e})}break;case"run":try{const{sessionId:t,inputIndices:r,inputs:a,outputIndices:o,options:i}=n.data.in;(0,e.run)(t,r,a,o,i).then((t=>{postMessage({type:"run",out:t},(0,e.extractTransferableBuffers)(t))}),(e=>{postMessage({type:"run",err:e})}))}catch(e){postMessage({type:"run",err:e})}break;case"end-profiling":try{const t=n.data.in;(0,e.endProfiling)(t),postMessage({type:"end-profiling"})}catch(e){postMessage({type:"end-profiling",err:e})}}}})()})();\n',"Worker",void 0,void 0)}},6614:dt=>{dt.exports=function(U,rt,tt,Y){var nt=self||window;try{try{var K;try{K=new nt.Blob([U])}catch{(K=new(nt.BlobBuilder||nt.WebKitBlobBuilder||nt.MozBlobBuilder||nt.MSBlobBuilder)).append(U),K=K.getBlob()}var X=nt.URL||nt.webkitURL,Q=X.createObjectURL(K),q=new nt[rt](Q,tt);return X.revokeObjectURL(Q),q}catch{return new nt[rt]("data:application/javascript,".concat(encodeURIComponent(U)),tt)}}catch{if(!Y)throw Error("Inline worker is not supported");return new nt[rt](Y,tt)}}},3474:(dt,U,rt)=>{var tt,Y=(tt=(tt=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(nt){function K(){return Pt.buffer!=Rt&&Xt(Pt.buffer),Bt}function X(){return Pt.buffer!=Rt&&Xt(Pt.buffer),Vt}function Q(){return Pt.buffer!=Rt&&Xt(Pt.buffer),jt}function q(){return Pt.buffer!=Rt&&Xt(Pt.buffer),qt}function G(){return Pt.buffer!=Rt&&Xt(Pt.buffer),Kt}var O,b,F;nt=nt||{},O||(O=nt!==void 0?nt:{}),O.ready=new Promise(function(ht,mt){b=ht,F=mt});var j,W,J,et,ot,it,at=Object.assign({},O),st="./this.program",lt=(ht,mt)=>{throw mt},ct=typeof window=="object",pt=typeof importScripts=="function",ut=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",ft=O.ENVIRONMENT_IS_PTHREAD||!1,gt="";function _t(ht){return O.locateFile?O.locateFile(ht,gt):gt+ht}if(ut){let ht;gt=pt?rt(908).dirname(gt)+"/":"//",it=()=>{ot||(et=rt(1384),ot=rt(908))},j=function(mt,Tt){return it(),mt=ot.normalize(mt),et.readFileSync(mt,Tt?void 0:"utf8")},J=mt=>((mt=j(mt,!0)).buffer||(mt=new Uint8Array(mt)),mt),W=(mt,Tt,Ot)=>{it(),mt=ot.normalize(mt),et.readFile(mt,function(kt,Mt){kt?Ot(kt):Tt(Mt.buffer)})},1<process.argv.length&&(st=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",function(mt){if(!(mt instanceof Se))throw mt}),process.on("unhandledRejection",function(mt){throw mt}),lt=(mt,Tt)=>{if(Dt)throw process.exitCode=mt,Tt;Tt instanceof Se||wt("exiting due to exception: "+Tt),process.exit(mt)},O.inspect=function(){return"[Emscripten Module object]"};try{ht=rt(9925)}catch(mt){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),mt}rt.g.Worker=ht.Worker}else(ct||pt)&&(pt?gt=self.location.href:typeof document<"u"&&document.currentScript&&(gt=document.currentScript.src),tt&&(gt=tt),gt=gt.indexOf("blob:")!==0?gt.substr(0,gt.replace(/[?#].*/,"").lastIndexOf("/")+1):"",ut||(j=ht=>{var mt=new XMLHttpRequest;return mt.open("GET",ht,!1),mt.send(null),mt.responseText},pt&&(J=ht=>{var mt=new XMLHttpRequest;return mt.open("GET",ht,!1),mt.responseType="arraybuffer",mt.send(null),new Uint8Array(mt.response)}),W=(ht,mt,Tt)=>{var Ot=new XMLHttpRequest;Ot.open("GET",ht,!0),Ot.responseType="arraybuffer",Ot.onload=()=>{Ot.status==200||Ot.status==0&&Ot.response?mt(Ot.response):Tt()},Ot.onerror=Tt,Ot.send(null)}));ut&&typeof performance>"u"&&(rt.g.performance=rt(6953).performance);var vt=console.log.bind(console),bt=console.warn.bind(console);ut&&(it(),vt=ht=>et.writeSync(1,ht+`
`),bt=ht=>et.writeSync(2,ht+`
`));var St,yt=O.print||vt,wt=O.printErr||bt;Object.assign(O,at),at=null,O.thisProgram&&(st=O.thisProgram),O.quit&&(lt=O.quit),O.wasmBinary&&(St=O.wasmBinary);var Dt=O.noExitRuntime||!0;typeof WebAssembly!="object"&&le("no native wasm support detected");var Pt,Ft,Rt,Bt,Vt,jt,qt,Kt,Gt=!1,Qt=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function zt(ht,mt,Tt){var Ot=(mt>>>=0)+Tt;for(Tt=mt;ht[Tt]&&!(Tt>=Ot);)++Tt;if(16<Tt-mt&&ht.buffer&&Qt)return Qt.decode(ht.buffer instanceof SharedArrayBuffer?ht.slice(mt,Tt):ht.subarray(mt,Tt));for(Ot="";mt<Tt;){var kt=ht[mt++];if(128&kt){var Mt=63&ht[mt++];if((224&kt)==192)Ot+=String.fromCharCode((31&kt)<<6|Mt);else{var Wt=63&ht[mt++];65536>(kt=(240&kt)==224?(15&kt)<<12|Mt<<6|Wt:(7&kt)<<18|Mt<<12|Wt<<6|63&ht[mt++])?Ot+=String.fromCharCode(kt):(kt-=65536,Ot+=String.fromCharCode(55296|kt>>10,56320|1023&kt))}}else Ot+=String.fromCharCode(kt)}return Ot}function ne(ht,mt){return(ht>>>=0)?zt(X(),ht,mt):""}function Zt(ht,mt,Tt,Ot){if(!(0<Ot))return 0;var kt=Tt>>>=0;Ot=Tt+Ot-1;for(var Mt=0;Mt<ht.length;++Mt){var Wt=ht.charCodeAt(Mt);if(55296<=Wt&&57343>=Wt&&(Wt=65536+((1023&Wt)<<10)|1023&ht.charCodeAt(++Mt)),127>=Wt){if(Tt>=Ot)break;mt[Tt++>>>0]=Wt}else{if(2047>=Wt){if(Tt+1>=Ot)break;mt[Tt++>>>0]=192|Wt>>6}else{if(65535>=Wt){if(Tt+2>=Ot)break;mt[Tt++>>>0]=224|Wt>>12}else{if(Tt+3>=Ot)break;mt[Tt++>>>0]=240|Wt>>18,mt[Tt++>>>0]=128|Wt>>12&63}mt[Tt++>>>0]=128|Wt>>6&63}mt[Tt++>>>0]=128|63&Wt}}return mt[Tt>>>0]=0,Tt-kt}function re(ht){for(var mt=0,Tt=0;Tt<ht.length;++Tt){var Ot=ht.charCodeAt(Tt);127>=Ot?mt++:2047>=Ot?mt+=2:55296<=Ot&&57343>=Ot?(mt+=4,++Tt):mt+=3}return mt}function Xt(ht){Rt=ht,O.HEAP8=Bt=new Int8Array(ht),O.HEAP16=new Int16Array(ht),O.HEAP32=jt=new Int32Array(ht),O.HEAPU8=Vt=new Uint8Array(ht),O.HEAPU16=new Uint16Array(ht),O.HEAPU32=qt=new Uint32Array(ht),O.HEAPF32=new Float32Array(ht),O.HEAPF64=Kt=new Float64Array(ht)}ft&&(Rt=O.buffer);var se=O.INITIAL_MEMORY||16777216;if(ft)Pt=O.wasmMemory,Rt=O.buffer;else if(O.wasmMemory)Pt=O.wasmMemory;else if(!((Pt=new WebAssembly.Memory({initial:se/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw wt("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),ut&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");Pt&&(Rt=Pt.buffer),se=Rt.byteLength,Xt(Rt);var fe,ye=[],ve=[],we=[];function _e(){var ht=O.preRun.shift();ye.unshift(ht)}var oe,ge=0,ue=null;function le(ht){throw ft?postMessage({cmd:"onAbort",arg:ht}):O.onAbort&&O.onAbort(ht),wt(ht="Aborted("+ht+")"),Gt=!0,ht=new WebAssembly.RuntimeError(ht+". Build with -sASSERTIONS for more info."),F(ht),ht}function Ee(){return oe.startsWith("data:application/octet-stream;base64,")}function Pe(){var ht=oe;try{if(ht==oe&&St)return new Uint8Array(St);if(J)return J(ht);throw"both async and sync fetching of the wasm failed"}catch(mt){le(mt)}}oe="ort-wasm-threaded.wasm",Ee()||(oe=_t(oe));var Te={};function Se(ht){this.name="ExitStatus",this.message="Program terminated with exit("+ht+")",this.status=ht}function Ie(ht){(ht=Ut.La[ht])||le(),Ut.Xa(ht)}function Ce(ht){var mt=Ut.lb();if(!mt)return 6;Ut.Ra.push(mt),Ut.La[ht.Ka]=mt,mt.Ka=ht.Ka;var Tt={cmd:"run",start_routine:ht.pb,arg:ht.ib,pthread_ptr:ht.Ka};return mt.Qa=()=>{Tt.time=performance.now(),mt.postMessage(Tt,ht.vb)},mt.loaded&&(mt.Qa(),delete mt.Qa),0}function ke(ht){if(ft)return te(1,1,ht);Dt||(Ut.qb(),O.onExit&&O.onExit(ht),Gt=!0),lt(ht,new Se(ht))}function Re(ht,mt){if(!mt&&ft)throw $t(ht),"unwind";ke(ht)}var Ut={Oa:[],Ra:[],$a:[],La:{},Ua:function(){ft&&Ut.mb()},xb:function(){},mb:function(){Ut.receiveObjectTransfer=Ut.ob,Ut.threadInitTLS=Ut.Za,Ut.setExitStatus=Ut.Ya,Dt=!1},Ya:function(){},qb:function(){for(var ht of Object.values(Ut.La))Ut.Xa(ht);for(ht of Ut.Oa)ht.terminate();Ut.Oa=[]},Xa:function(ht){var mt=ht.Ka;delete Ut.La[mt],Ut.Oa.push(ht),Ut.Ra.splice(Ut.Ra.indexOf(ht),1),ht.Ka=0,He(mt)},ob:function(){},Za:function(){Ut.$a.forEach(ht=>ht())},nb:function(ht,mt){ht.onmessage=Tt=>{var Ot=(Tt=Tt.data).cmd;if(ht.Ka&&(Ut.kb=ht.Ka),Tt.targetThread&&Tt.targetThread!=Le()){var kt=Ut.La[Tt.yb];kt?kt.postMessage(Tt,Tt.transferList):wt('Internal error! Worker sent a message "'+Ot+'" to target pthread '+Tt.targetThread+", but that thread no longer exists!")}else Ot==="processProxyingQueue"?Ue(Tt.queue):Ot==="spawnThread"?Ce(Tt):Ot==="cleanupThread"?Ie(Tt.thread):Ot==="killThread"?(Tt=Tt.thread,Ot=Ut.La[Tt],delete Ut.La[Tt],Ot.terminate(),He(Tt),Ut.Ra.splice(Ut.Ra.indexOf(Ot),1),Ot.Ka=0):Ot==="cancelThread"?Ut.La[Tt.thread].postMessage({cmd:"cancel"}):Ot==="loaded"?(ht.loaded=!0,mt&&mt(ht),ht.Qa&&(ht.Qa(),delete ht.Qa)):Ot==="print"?yt("Thread "+Tt.threadId+": "+Tt.text):Ot==="printErr"?wt("Thread "+Tt.threadId+": "+Tt.text):Ot==="alert"?alert("Thread "+Tt.threadId+": "+Tt.text):Tt.target==="setimmediate"?ht.postMessage(Tt):Ot==="onAbort"?O.onAbort&&O.onAbort(Tt.arg):Ot&&wt("worker sent an unknown command "+Ot);Ut.kb=void 0},ht.onerror=Tt=>{throw wt("worker sent an error! "+Tt.filename+":"+Tt.lineno+": "+Tt.message),Tt},ut&&(ht.on("message",function(Tt){ht.onmessage({data:Tt})}),ht.on("error",function(Tt){ht.onerror(Tt)}),ht.on("detachedExit",function(){})),ht.postMessage({cmd:"load",urlOrBlob:O.mainScriptUrlOrBlob||tt,wasmMemory:Pt,wasmModule:Ft})},hb:function(){var ht=_t("ort-wasm-threaded.worker.js");Ut.Oa.push(new Worker(ht))},lb:function(){return Ut.Oa.length==0&&(Ut.hb(),Ut.nb(Ut.Oa[0])),Ut.Oa.pop()}};function xt(ht){for(;0<ht.length;)ht.shift()(O)}function $t(ht){if(ft)return te(2,0,ht);try{Re(ht)}catch(mt){mt instanceof Se||mt=="unwind"||lt(1,mt)}}O.PThread=Ut,O.establishStackSpace=function(){var ht=Le(),mt=Q()[ht+44>>2>>>0];ht=Q()[ht+48>>2>>>0],bn(mt,mt-ht),je(mt)};var It,Ct,Nt=[];function Lt(ht){this.Pa=ht-24,this.gb=function(mt){q()[this.Pa+4>>2>>>0]=mt},this.cb=function(mt){q()[this.Pa+8>>2>>>0]=mt},this.eb=function(){Q()[this.Pa>>2>>>0]=0},this.bb=function(){K()[this.Pa+12>>0>>>0]=0},this.fb=function(){K()[this.Pa+13>>0>>>0]=0},this.Ua=function(mt,Tt){this.ab(),this.gb(mt),this.cb(Tt),this.eb(),this.bb(),this.fb()},this.ab=function(){q()[this.Pa+16>>2>>>0]=0}}function Ht(ht,mt,Tt,Ot){return ft?te(3,1,ht,mt,Tt,Ot):ce(ht,mt,Tt,Ot)}function ce(ht,mt,Tt,Ot){if(typeof SharedArrayBuffer>"u")return wt("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var kt=[];return ft&&kt.length===0?Ht(ht,mt,Tt,Ot):(ht={pb:Tt,Ka:ht,ib:Ot,vb:kt},ft?(ht.wb="spawnThread",postMessage(ht,kt),0):Ce(ht))}function he(ht,mt,Tt){return ft?te(4,1,ht,mt,Tt):0}function pe(ht,mt){if(ft)return te(5,1,ht,mt)}function ae(ht,mt){if(ft)return te(6,1,ht,mt)}function Oe(ht,mt,Tt){if(ft)return te(7,1,ht,mt,Tt)}function $e(ht,mt,Tt){return ft?te(8,1,ht,mt,Tt):0}function At(ht,mt){if(ft)return te(9,1,ht,mt)}function Yt(ht,mt,Tt){if(ft)return te(10,1,ht,mt,Tt)}function ee(ht,mt,Tt,Ot){if(ft)return te(11,1,ht,mt,Tt,Ot)}function xe(ht,mt,Tt,Ot){if(ft)return te(12,1,ht,mt,Tt,Ot)}function Me(ht,mt,Tt,Ot){if(ft)return te(13,1,ht,mt,Tt,Ot)}function Ke(ht){if(ft)return te(14,1,ht)}function Xe(ht,mt){if(ft)return te(15,1,ht,mt)}function Ye(ht,mt,Tt){if(ft)return te(16,1,ht,mt,Tt)}function Ue(ht){Atomics.store(Q(),ht>>2,1),Le()&&gn(ht),Atomics.compareExchange(Q(),ht>>2,1,0)}function Ze(ht){return q()[ht>>>2]+4294967296*Q()[ht+4>>>2]}function Je(ht,mt,Tt,Ot,kt,Mt){return ft?te(17,1,ht,mt,Tt,Ot,kt,Mt):-52}function Qe(ht,mt,Tt,Ot,kt,Mt){if(ft)return te(18,1,ht,mt,Tt,Ot,kt,Mt)}function tn(ht){var mt=re(ht)+1,Tt=Ve(mt);return Tt&&Zt(ht,K(),Tt,mt),Tt}function en(ht,mt,Tt){function Ot(me){return(me=me.toTimeString().match(/\(([A-Za-z ]+)\)$/))?me[1]:"GMT"}if(ft)return te(19,1,ht,mt,Tt);var kt=new Date().getFullYear(),Mt=new Date(kt,0,1),Wt=new Date(kt,6,1);kt=Mt.getTimezoneOffset();var de=Wt.getTimezoneOffset(),Ae=Math.max(kt,de);Q()[ht>>2>>>0]=60*Ae,Q()[mt>>2>>>0]=+(kt!=de),ht=Ot(Mt),mt=Ot(Wt),ht=tn(ht),mt=tn(mt),de<kt?(q()[Tt>>2>>>0]=ht,q()[Tt+4>>2>>>0]=mt):(q()[Tt>>2>>>0]=mt,q()[Tt+4>>2>>>0]=ht)}function te(ht,mt){var Tt=arguments.length-2,Ot=arguments;return function(kt){var Mt=We();return kt=kt(),je(Mt),kt}(()=>{for(var kt=qe(8*Tt),Mt=kt>>3,Wt=0;Wt<Tt;Wt++){var de=Ot[2+Wt];G()[Mt+Wt>>>0]=de}return fn(ht,Tt,kt,mt)})}O.invokeEntryPoint=function(ht,mt){var Tt=Nt[ht];Tt||(ht>=Nt.length&&(Nt.length=ht+1),Nt[ht]=Tt=fe.get(ht)),ht=Tt(mt),Dt?Ut.Ya(ht):mn(ht)},O.executeNotifiedProxyingQueue=Ue,Ct=ut?()=>{var ht=process.hrtime();return 1e3*ht[0]+ht[1]/1e6}:ft?()=>performance.now()-O.__performance_now_clock_drift:()=>performance.now();var Be,Ge=[],ze={};function nn(){if(!Be){var ht,mt={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:st||"./this.program"};for(ht in ze)ze[ht]===void 0?delete mt[ht]:mt[ht]=ze[ht];var Tt=[];for(ht in mt)Tt.push(ht+"="+mt[ht]);Be=Tt}return Be}function rn(ht,mt){if(ft)return te(20,1,ht,mt);var Tt=0;return nn().forEach(function(Ot,kt){var Mt=mt+Tt;for(kt=q()[ht+4*kt>>2>>>0]=Mt,Mt=0;Mt<Ot.length;++Mt)K()[kt++>>0>>>0]=Ot.charCodeAt(Mt);K()[kt>>0>>>0]=0,Tt+=Ot.length+1}),0}function on(ht,mt){if(ft)return te(21,1,ht,mt);var Tt=nn();q()[ht>>2>>>0]=Tt.length;var Ot=0;return Tt.forEach(function(kt){Ot+=kt.length+1}),q()[mt>>2>>>0]=Ot,0}function sn(ht){return ft?te(22,1,ht):52}function an(ht,mt,Tt,Ot){return ft?te(23,1,ht,mt,Tt,Ot):52}function un(ht,mt,Tt,Ot,kt){return ft?te(24,1,ht,mt,Tt,Ot,kt):70}var xn=[null,[],[]];function ln(ht,mt,Tt,Ot){if(ft)return te(25,1,ht,mt,Tt,Ot);for(var kt=0,Mt=0;Mt<Tt;Mt++){var Wt=q()[mt>>2>>>0],de=q()[mt+4>>2>>>0];mt+=8;for(var Ae=0;Ae<de;Ae++){var me=X()[Wt+Ae>>>0],be=xn[ht];me===0||me===10?((ht===1?yt:wt)(zt(be,0)),be.length=0):be.push(me)}kt+=de}return q()[Ot>>2>>>0]=kt,0}function Ne(ht){return ht%4==0&&(ht%100!=0||ht%400==0)}var cn=[31,29,31,30,31,30,31,31,30,31,30,31],pn=[31,28,31,30,31,30,31,31,30,31,30,31];function dn(ht,mt,Tt,Ot){function kt(Et,Jt,ie){for(Et=typeof Et=="number"?Et.toString():Et||"";Et.length<Jt;)Et=ie[0]+Et;return Et}function Mt(Et,Jt){return kt(Et,Jt,"0")}function Wt(Et,Jt){function ie(_n){return 0>_n?-1:0<_n?1:0}var De;return(De=ie(Et.getFullYear()-Jt.getFullYear()))===0&&(De=ie(Et.getMonth()-Jt.getMonth()))===0&&(De=ie(Et.getDate()-Jt.getDate())),De}function de(Et){switch(Et.getDay()){case 0:return new Date(Et.getFullYear()-1,11,29);case 1:return Et;case 2:return new Date(Et.getFullYear(),0,3);case 3:return new Date(Et.getFullYear(),0,2);case 4:return new Date(Et.getFullYear(),0,1);case 5:return new Date(Et.getFullYear()-1,11,31);case 6:return new Date(Et.getFullYear()-1,11,30)}}function Ae(Et){var Jt=Et.Ma;for(Et=new Date(new Date(Et.Na+1900,0,1).getTime());0<Jt;){var ie=Et.getMonth(),De=(Ne(Et.getFullYear())?cn:pn)[ie];if(!(Jt>De-Et.getDate())){Et.setDate(Et.getDate()+Jt);break}Jt-=De-Et.getDate()+1,Et.setDate(1),11>ie?Et.setMonth(ie+1):(Et.setMonth(0),Et.setFullYear(Et.getFullYear()+1))}return ie=new Date(Et.getFullYear()+1,0,4),Jt=de(new Date(Et.getFullYear(),0,4)),ie=de(ie),0>=Wt(Jt,Et)?0>=Wt(ie,Et)?Et.getFullYear()+1:Et.getFullYear():Et.getFullYear()-1}var me=Q()[Ot+40>>2>>>0];for(var be in Ot={tb:Q()[Ot>>2>>>0],sb:Q()[Ot+4>>2>>>0],Sa:Q()[Ot+8>>2>>>0],Va:Q()[Ot+12>>2>>>0],Ta:Q()[Ot+16>>2>>>0],Na:Q()[Ot+20>>2>>>0],Ja:Q()[Ot+24>>2>>>0],Ma:Q()[Ot+28>>2>>>0],zb:Q()[Ot+32>>2>>>0],rb:Q()[Ot+36>>2>>>0],ub:me?ne(me):""},Tt=ne(Tt),me={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})Tt=Tt.replace(new RegExp(be,"g"),me[be]);var vn="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),wn="January February March April May June July August September October November December".split(" ");for(be in me={"%a":function(Et){return vn[Et.Ja].substring(0,3)},"%A":function(Et){return vn[Et.Ja]},"%b":function(Et){return wn[Et.Ta].substring(0,3)},"%B":function(Et){return wn[Et.Ta]},"%C":function(Et){return Mt((Et.Na+1900)/100|0,2)},"%d":function(Et){return Mt(Et.Va,2)},"%e":function(Et){return kt(Et.Va,2," ")},"%g":function(Et){return Ae(Et).toString().substring(2)},"%G":function(Et){return Ae(Et)},"%H":function(Et){return Mt(Et.Sa,2)},"%I":function(Et){return(Et=Et.Sa)==0?Et=12:12<Et&&(Et-=12),Mt(Et,2)},"%j":function(Et){for(var Jt=0,ie=0;ie<=Et.Ta-1;Jt+=(Ne(Et.Na+1900)?cn:pn)[ie++]);return Mt(Et.Va+Jt,3)},"%m":function(Et){return Mt(Et.Ta+1,2)},"%M":function(Et){return Mt(Et.sb,2)},"%n":function(){return`
`},"%p":function(Et){return 0<=Et.Sa&&12>Et.Sa?"AM":"PM"},"%S":function(Et){return Mt(Et.tb,2)},"%t":function(){return"	"},"%u":function(Et){return Et.Ja||7},"%U":function(Et){return Mt(Math.floor((Et.Ma+7-Et.Ja)/7),2)},"%V":function(Et){var Jt=Math.floor((Et.Ma+7-(Et.Ja+6)%7)/7);if(2>=(Et.Ja+371-Et.Ma-2)%7&&Jt++,Jt)Jt==53&&((ie=(Et.Ja+371-Et.Ma)%7)==4||ie==3&&Ne(Et.Na)||(Jt=1));else{Jt=52;var ie=(Et.Ja+7-Et.Ma-1)%7;(ie==4||ie==5&&Ne(Et.Na%400-1))&&Jt++}return Mt(Jt,2)},"%w":function(Et){return Et.Ja},"%W":function(Et){return Mt(Math.floor((Et.Ma+7-(Et.Ja+6)%7)/7),2)},"%y":function(Et){return(Et.Na+1900).toString().substring(2)},"%Y":function(Et){return Et.Na+1900},"%z":function(Et){var Jt=0<=(Et=Et.rb);return Et=Math.abs(Et)/60,(Jt?"+":"-")+("0000"+(Et/60*100+Et%60)).slice(-4)},"%Z":function(Et){return Et.ub},"%%":function(){return"%"}},Tt=Tt.replace(/%%/g,"\0\0"),me)Tt.includes(be)&&(Tt=Tt.replace(new RegExp(be,"g"),me[be](Ot)));return be=function(Et){var Jt=Array(re(Et)+1);return Zt(Et,Jt,0,Jt.length),Jt}(Tt=Tt.replace(/\0\0/g,"%")),be.length>mt?0:(function(Et,Jt){K().set(Et,Jt>>>0)}(be,ht),be.length-1)}Ut.Ua();var Tn=[null,ke,$t,Ht,he,pe,ae,Oe,$e,At,Yt,ee,xe,Me,Ke,Xe,Ye,Je,Qe,en,rn,on,sn,an,un,ln],Sn={b:function(ht){return Ve(ht+24)+24},c:function(ht,mt,Tt){throw new Lt(ht).Ua(mt,Tt),ht},L:function(ht){hn(ht,!pt,1,!ct),Ut.Za()},l:function(ht){ft?postMessage({cmd:"cleanupThread",thread:ht}):Ie(ht)},D:ce,i:he,R:pe,z:ae,B:Oe,T:$e,P:At,I:Yt,O:ee,p:xe,A:Me,x:Ke,Q:Xe,y:Ye,r:function(){},j:function(){le("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},s:function(){le("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},q:function(){return Date.now()},E:function(){return 2097152},V:function(){return!0},F:function(ht,mt,Tt,Ot){if(ht==mt)setTimeout(()=>Ue(Ot));else if(ft)postMessage({targetThread:ht,cmd:"processProxyingQueue",queue:Ot});else{if(!(ht=Ut.La[ht]))return;ht.postMessage({cmd:"processProxyingQueue",queue:Ot})}return 1},K:function(){return-1},W:function(ht,mt){ht=new Date(1e3*Ze(ht)),Q()[mt>>2>>>0]=ht.getUTCSeconds(),Q()[mt+4>>2>>>0]=ht.getUTCMinutes(),Q()[mt+8>>2>>>0]=ht.getUTCHours(),Q()[mt+12>>2>>>0]=ht.getUTCDate(),Q()[mt+16>>2>>>0]=ht.getUTCMonth(),Q()[mt+20>>2>>>0]=ht.getUTCFullYear()-1900,Q()[mt+24>>2>>>0]=ht.getUTCDay(),ht=(ht.getTime()-Date.UTC(ht.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,Q()[mt+28>>2>>>0]=ht},X:function(ht,mt){ht=new Date(1e3*Ze(ht)),Q()[mt>>2>>>0]=ht.getSeconds(),Q()[mt+4>>2>>>0]=ht.getMinutes(),Q()[mt+8>>2>>>0]=ht.getHours(),Q()[mt+12>>2>>>0]=ht.getDate(),Q()[mt+16>>2>>>0]=ht.getMonth(),Q()[mt+20>>2>>>0]=ht.getFullYear()-1900,Q()[mt+24>>2>>>0]=ht.getDay();var Tt=new Date(ht.getFullYear(),0,1),Ot=(ht.getTime()-Tt.getTime())/864e5|0;Q()[mt+28>>2>>>0]=Ot,Q()[mt+36>>2>>>0]=-60*ht.getTimezoneOffset(),Ot=new Date(ht.getFullYear(),6,1).getTimezoneOffset(),ht=0|(Ot!=(Tt=Tt.getTimezoneOffset())&&ht.getTimezoneOffset()==Math.min(Tt,Ot)),Q()[mt+32>>2>>>0]=ht},Y:function(ht){var mt=new Date(Q()[ht+20>>2>>>0]+1900,Q()[ht+16>>2>>>0],Q()[ht+12>>2>>>0],Q()[ht+8>>2>>>0],Q()[ht+4>>2>>>0],Q()[ht>>2>>>0],0),Tt=Q()[ht+32>>2>>>0],Ot=mt.getTimezoneOffset(),kt=new Date(mt.getFullYear(),0,1),Mt=new Date(mt.getFullYear(),6,1).getTimezoneOffset(),Wt=kt.getTimezoneOffset(),de=Math.min(Wt,Mt);return 0>Tt?Q()[ht+32>>2>>>0]=+(Mt!=Wt&&de==Ot):0<Tt!=(de==Ot)&&(Mt=Math.max(Wt,Mt),mt.setTime(mt.getTime()+6e4*((0<Tt?de:Mt)-Ot))),Q()[ht+24>>2>>>0]=mt.getDay(),Tt=(mt.getTime()-kt.getTime())/864e5|0,Q()[ht+28>>2>>>0]=Tt,Q()[ht>>2>>>0]=mt.getSeconds(),Q()[ht+4>>2>>>0]=mt.getMinutes(),Q()[ht+8>>2>>>0]=mt.getHours(),Q()[ht+12>>2>>>0]=mt.getDate(),Q()[ht+16>>2>>>0]=mt.getMonth(),mt.getTime()/1e3|0},G:Je,H:Qe,Z:function ht(mt,Tt,Ot){ht.jb||(ht.jb=!0,en(mt,Tt,Ot))},d:function(){le("")},m:function(){if(!ut&&!pt){var ht="Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";It||(It={}),It[ht]||(It[ht]=1,ut&&(ht="warning: "+ht),wt(ht))}},w:function(){return 4294901760},f:Ct,S:function(ht,mt,Tt){X().copyWithin(ht>>>0,mt>>>0,mt+Tt>>>0)},g:function(){return ut?rt(3993).cpus().length:navigator.hardwareConcurrency},J:function(ht,mt,Tt){Ge.length=mt,Tt>>=3;for(var Ot=0;Ot<mt;Ot++)Ge[Ot]=G()[Tt+Ot>>>0];return(0>ht?Te[-ht-1]:Tn[ht]).apply(null,Ge)},v:function(ht){var mt=X().length;if((ht>>>=0)<=mt||4294901760<ht)return!1;for(var Tt=1;4>=Tt;Tt*=2){var Ot=mt*(1+.2/Tt);Ot=Math.min(Ot,ht+100663296);var kt=Math;Ot=Math.max(ht,Ot),kt=kt.min.call(kt,4294901760,Ot+(65536-Ot%65536)%65536);t:{try{Pt.grow(kt-Rt.byteLength+65535>>>16),Xt(Pt.buffer);var Mt=1;break t}catch{}Mt=void 0}if(Mt)return!0}return!1},U:function(){throw"unwind"},M:rn,N:on,k:Re,h:sn,o:an,t:un,n:ln,u:function ht(mt,Tt){ht.Wa||(ht.Wa=function(){if(typeof crypto=="object"&&typeof crypto.getRandomValues=="function"){var kt=new Uint8Array(1);return()=>(crypto.getRandomValues(kt),kt[0])}if(ut)try{var Mt=rt(760);return()=>Mt.randomBytes(1)[0]}catch{}return()=>le("randomDevice")}());for(var Ot=0;Ot<Tt;Ot++)K()[mt+Ot>>0>>>0]=ht.Wa();return 0},a:Pt||O.wasmMemory,C:dn,e:function(ht,mt,Tt,Ot){return dn(ht,mt,Tt,Ot)}};(function(){function ht(kt,Mt){O.asm=kt.exports,Ut.$a.push(O.asm.wa),fe=O.asm.za,ve.unshift(O.asm._),Ft=Mt,ft||(ge--,O.monitorRunDependencies&&O.monitorRunDependencies(ge),ge==0&&ue&&(kt=ue,ue=null,kt()))}function mt(kt){ht(kt.instance,kt.module)}function Tt(kt){return function(){if(!St&&(ct||pt)){if(typeof fetch=="function"&&!oe.startsWith("file://"))return fetch(oe,{credentials:"same-origin"}).then(function(Mt){if(!Mt.ok)throw"failed to load wasm binary file at '"+oe+"'";return Mt.arrayBuffer()}).catch(function(){return Pe()});if(W)return new Promise(function(Mt,Wt){W(oe,function(de){Mt(new Uint8Array(de))},Wt)})}return Promise.resolve().then(function(){return Pe()})}().then(function(Mt){return WebAssembly.instantiate(Mt,Ot)}).then(function(Mt){return Mt}).then(kt,function(Mt){wt("failed to asynchronously prepare wasm: "+Mt),le(Mt)})}var Ot={a:Sn};if(ft||(ge++,O.monitorRunDependencies&&O.monitorRunDependencies(ge)),O.instantiateWasm)try{return O.instantiateWasm(Ot,ht)}catch(kt){return wt("Module.instantiateWasm callback failed with error: "+kt),!1}(St||typeof WebAssembly.instantiateStreaming!="function"||Ee()||oe.startsWith("file://")||ut||typeof fetch!="function"?Tt(mt):fetch(oe,{credentials:"same-origin"}).then(function(kt){return WebAssembly.instantiateStreaming(kt,Ot).then(mt,function(Mt){return wt("wasm streaming compile failed: "+Mt),wt("falling back to ArrayBuffer instantiation"),Tt(mt)})})).catch(F)})(),O.___wasm_call_ctors=function(){return(O.___wasm_call_ctors=O.asm._).apply(null,arguments)},O._OrtInit=function(){return(O._OrtInit=O.asm.$).apply(null,arguments)},O._OrtCreateSessionOptions=function(){return(O._OrtCreateSessionOptions=O.asm.aa).apply(null,arguments)},O._OrtAppendExecutionProvider=function(){return(O._OrtAppendExecutionProvider=O.asm.ba).apply(null,arguments)},O._OrtAddSessionConfigEntry=function(){return(O._OrtAddSessionConfigEntry=O.asm.ca).apply(null,arguments)},O._OrtReleaseSessionOptions=function(){return(O._OrtReleaseSessionOptions=O.asm.da).apply(null,arguments)},O._OrtCreateSession=function(){return(O._OrtCreateSession=O.asm.ea).apply(null,arguments)},O._OrtReleaseSession=function(){return(O._OrtReleaseSession=O.asm.fa).apply(null,arguments)},O._OrtGetInputCount=function(){return(O._OrtGetInputCount=O.asm.ga).apply(null,arguments)},O._OrtGetOutputCount=function(){return(O._OrtGetOutputCount=O.asm.ha).apply(null,arguments)},O._OrtGetInputName=function(){return(O._OrtGetInputName=O.asm.ia).apply(null,arguments)},O._OrtGetOutputName=function(){return(O._OrtGetOutputName=O.asm.ja).apply(null,arguments)},O._OrtFree=function(){return(O._OrtFree=O.asm.ka).apply(null,arguments)},O._OrtCreateTensor=function(){return(O._OrtCreateTensor=O.asm.la).apply(null,arguments)},O._OrtGetTensorData=function(){return(O._OrtGetTensorData=O.asm.ma).apply(null,arguments)},O._OrtReleaseTensor=function(){return(O._OrtReleaseTensor=O.asm.na).apply(null,arguments)},O._OrtCreateRunOptions=function(){return(O._OrtCreateRunOptions=O.asm.oa).apply(null,arguments)},O._OrtAddRunConfigEntry=function(){return(O._OrtAddRunConfigEntry=O.asm.pa).apply(null,arguments)},O._OrtReleaseRunOptions=function(){return(O._OrtReleaseRunOptions=O.asm.qa).apply(null,arguments)},O._OrtRun=function(){return(O._OrtRun=O.asm.ra).apply(null,arguments)},O._OrtEndProfiling=function(){return(O._OrtEndProfiling=O.asm.sa).apply(null,arguments)};var Le=O._pthread_self=function(){return(Le=O._pthread_self=O.asm.ta).apply(null,arguments)},Ve=O._malloc=function(){return(Ve=O._malloc=O.asm.ua).apply(null,arguments)};O._free=function(){return(O._free=O.asm.va).apply(null,arguments)},O.__emscripten_tls_init=function(){return(O.__emscripten_tls_init=O.asm.wa).apply(null,arguments)};var hn=O.__emscripten_thread_init=function(){return(hn=O.__emscripten_thread_init=O.asm.xa).apply(null,arguments)};O.__emscripten_thread_crashed=function(){return(O.__emscripten_thread_crashed=O.asm.ya).apply(null,arguments)};var Fe,fn=O._emscripten_run_in_main_runtime_thread_js=function(){return(fn=O._emscripten_run_in_main_runtime_thread_js=O.asm.Aa).apply(null,arguments)},gn=O.__emscripten_proxy_execute_task_queue=function(){return(gn=O.__emscripten_proxy_execute_task_queue=O.asm.Ba).apply(null,arguments)},He=O.__emscripten_thread_free_data=function(){return(He=O.__emscripten_thread_free_data=O.asm.Ca).apply(null,arguments)},mn=O.__emscripten_thread_exit=function(){return(mn=O.__emscripten_thread_exit=O.asm.Da).apply(null,arguments)},bn=O._emscripten_stack_set_limits=function(){return(bn=O._emscripten_stack_set_limits=O.asm.Ea).apply(null,arguments)},We=O.stackSave=function(){return(We=O.stackSave=O.asm.Fa).apply(null,arguments)},je=O.stackRestore=function(){return(je=O.stackRestore=O.asm.Ga).apply(null,arguments)},qe=O.stackAlloc=function(){return(qe=O.stackAlloc=O.asm.Ha).apply(null,arguments)};function yn(){function ht(){if(!Fe&&(Fe=!0,O.calledRun=!0,!Gt)&&(ft||xt(ve),b(O),O.onRuntimeInitialized&&O.onRuntimeInitialized(),!ft)){if(O.postRun)for(typeof O.postRun=="function"&&(O.postRun=[O.postRun]);O.postRun.length;){var mt=O.postRun.shift();we.unshift(mt)}xt(we)}}if(!(0<ge))if(ft)b(O),ft||xt(ve),postMessage({cmd:"loaded"});else{if(O.preRun)for(typeof O.preRun=="function"&&(O.preRun=[O.preRun]);O.preRun.length;)_e();xt(ye),0<ge||(O.setStatus?(O.setStatus("Running..."),setTimeout(function(){setTimeout(function(){O.setStatus("")},1),ht()},1)):ht())}}if(O.___cxa_is_pointer_type=function(){return(O.___cxa_is_pointer_type=O.asm.Ia).apply(null,arguments)},O.UTF8ToString=ne,O.stringToUTF8=function(ht,mt,Tt){return Zt(ht,X(),mt,Tt)},O.lengthBytesUTF8=re,O.keepRuntimeAlive=function(){return Dt},O.wasmMemory=Pt,O.stackSave=We,O.stackRestore=je,O.stackAlloc=qe,O.ExitStatus=Se,O.PThread=Ut,ue=function ht(){Fe||yn(),Fe||(ue=ht)},O.preInit)for(typeof O.preInit=="function"&&(O.preInit=[O.preInit]);0<O.preInit.length;)O.preInit.pop()();return yn(),nt.ready});dt.exports=Y},932:(dt,U,rt)=>{var tt,Y=(tt=(tt=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(nt){var K,X,Q;nt=nt||{},K||(K=nt!==void 0?nt:{}),K.ready=new Promise(function(xt,$t){X=xt,Q=$t});var q,G,O,b,F,j,W=Object.assign({},K),J="./this.program",et=(xt,$t)=>{throw $t},ot=typeof window=="object",it=typeof importScripts=="function",at=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",st="";at?(st=it?rt(908).dirname(st)+"/":"//",j=()=>{F||(b=rt(1384),F=rt(908))},q=function(xt,$t){return j(),xt=F.normalize(xt),b.readFileSync(xt,$t?void 0:"utf8")},O=xt=>((xt=q(xt,!0)).buffer||(xt=new Uint8Array(xt)),xt),G=(xt,$t,It)=>{j(),xt=F.normalize(xt),b.readFile(xt,function(Ct,Nt){Ct?It(Ct):$t(Nt.buffer)})},1<process.argv.length&&(J=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",function(xt){if(!(xt instanceof se))throw xt}),process.on("unhandledRejection",function(xt){throw xt}),et=(xt,$t)=>{if(ut)throw process.exitCode=xt,$t;$t instanceof se||pt("exiting due to exception: "+$t),process.exit(xt)},K.inspect=function(){return"[Emscripten Module object]"}):(ot||it)&&(it?st=self.location.href:typeof document<"u"&&document.currentScript&&(st=document.currentScript.src),tt&&(st=tt),st=st.indexOf("blob:")!==0?st.substr(0,st.replace(/[?#].*/,"").lastIndexOf("/")+1):"",q=xt=>{var $t=new XMLHttpRequest;return $t.open("GET",xt,!1),$t.send(null),$t.responseText},it&&(O=xt=>{var $t=new XMLHttpRequest;return $t.open("GET",xt,!1),$t.responseType="arraybuffer",$t.send(null),new Uint8Array($t.response)}),G=(xt,$t,It)=>{var Ct=new XMLHttpRequest;Ct.open("GET",xt,!0),Ct.responseType="arraybuffer",Ct.onload=()=>{Ct.status==200||Ct.status==0&&Ct.response?$t(Ct.response):It()},Ct.onerror=It,Ct.send(null)});var lt,ct=K.print||console.log.bind(console),pt=K.printErr||console.warn.bind(console);Object.assign(K,W),W=null,K.thisProgram&&(J=K.thisProgram),K.quit&&(et=K.quit),K.wasmBinary&&(lt=K.wasmBinary);var ut=K.noExitRuntime||!0;typeof WebAssembly!="object"&&ne("no native wasm support detected");var ft,gt,_t,vt,bt,St,yt=!1,wt=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function Dt(xt,$t,It){var Ct=($t>>>=0)+It;for(It=$t;xt[It]&&!(It>=Ct);)++It;if(16<It-$t&&xt.buffer&&wt)return wt.decode(xt.subarray($t,It));for(Ct="";$t<It;){var Nt=xt[$t++];if(128&Nt){var Lt=63&xt[$t++];if((224&Nt)==192)Ct+=String.fromCharCode((31&Nt)<<6|Lt);else{var Ht=63&xt[$t++];65536>(Nt=(240&Nt)==224?(15&Nt)<<12|Lt<<6|Ht:(7&Nt)<<18|Lt<<12|Ht<<6|63&xt[$t++])?Ct+=String.fromCharCode(Nt):(Nt-=65536,Ct+=String.fromCharCode(55296|Nt>>10,56320|1023&Nt))}}else Ct+=String.fromCharCode(Nt)}return Ct}function Pt(xt,$t){return(xt>>>=0)?Dt(vt,xt,$t):""}function Ft(xt,$t,It,Ct){if(!(0<Ct))return 0;var Nt=It>>>=0;Ct=It+Ct-1;for(var Lt=0;Lt<xt.length;++Lt){var Ht=xt.charCodeAt(Lt);if(55296<=Ht&&57343>=Ht&&(Ht=65536+((1023&Ht)<<10)|1023&xt.charCodeAt(++Lt)),127>=Ht){if(It>=Ct)break;$t[It++>>>0]=Ht}else{if(2047>=Ht){if(It+1>=Ct)break;$t[It++>>>0]=192|Ht>>6}else{if(65535>=Ht){if(It+2>=Ct)break;$t[It++>>>0]=224|Ht>>12}else{if(It+3>=Ct)break;$t[It++>>>0]=240|Ht>>18,$t[It++>>>0]=128|Ht>>12&63}$t[It++>>>0]=128|Ht>>6&63}$t[It++>>>0]=128|63&Ht}}return $t[It>>>0]=0,It-Nt}function Rt(xt){for(var $t=0,It=0;It<xt.length;++It){var Ct=xt.charCodeAt(It);127>=Ct?$t++:2047>=Ct?$t+=2:55296<=Ct&&57343>=Ct?($t+=4,++It):$t+=3}return $t}function Bt(){var xt=ft.buffer;gt=xt,K.HEAP8=_t=new Int8Array(xt),K.HEAP16=new Int16Array(xt),K.HEAP32=bt=new Int32Array(xt),K.HEAPU8=vt=new Uint8Array(xt),K.HEAPU16=new Uint16Array(xt),K.HEAPU32=St=new Uint32Array(xt),K.HEAPF32=new Float32Array(xt),K.HEAPF64=new Float64Array(xt)}var Vt=[],jt=[],qt=[];function Kt(){var xt=K.preRun.shift();Vt.unshift(xt)}var Gt,Qt=0,zt=null;function ne(xt){throw K.onAbort&&K.onAbort(xt),pt(xt="Aborted("+xt+")"),yt=!0,xt=new WebAssembly.RuntimeError(xt+". Build with -sASSERTIONS for more info."),Q(xt),xt}function Zt(){return Gt.startsWith("data:application/octet-stream;base64,")}if(Gt="ort-wasm.wasm",!Zt()){var re=Gt;Gt=K.locateFile?K.locateFile(re,st):st+re}function Xt(){var xt=Gt;try{if(xt==Gt&&lt)return new Uint8Array(lt);if(O)return O(xt);throw"both async and sync fetching of the wasm failed"}catch($t){ne($t)}}function se(xt){this.name="ExitStatus",this.message="Program terminated with exit("+xt+")",this.status=xt}function fe(xt){for(;0<xt.length;)xt.shift()(K)}function ye(xt){this.sa=xt-24,this.Ia=function($t){St[this.sa+4>>2>>>0]=$t},this.Ba=function($t){St[this.sa+8>>2>>>0]=$t},this.Ga=function(){bt[this.sa>>2>>>0]=0},this.Aa=function(){_t[this.sa+12>>0>>>0]=0},this.Ha=function(){_t[this.sa+13>>0>>>0]=0},this.ya=function($t,It){this.za(),this.Ia($t),this.Ba(It),this.Ga(),this.Aa(),this.Ha()},this.za=function(){St[this.sa+16>>2>>>0]=0}}function ve(xt){var $t=Rt(xt)+1,It=Se($t);return It&&Ft(xt,_t,It,$t),It}var we={};function _e(){if(!oe){var xt,$t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:J||"./this.program"};for(xt in we)we[xt]===void 0?delete $t[xt]:$t[xt]=we[xt];var It=[];for(xt in $t)It.push(xt+"="+$t[xt]);oe=It}return oe}var oe,ge=[null,[],[]];function ue(xt){return xt%4==0&&(xt%100!=0||xt%400==0)}var le=[31,29,31,30,31,30,31,31,30,31,30,31],Ee=[31,28,31,30,31,30,31,31,30,31,30,31];function Pe(xt,$t,It,Ct){function Nt(At,Yt,ee){for(At=typeof At=="number"?At.toString():At||"";At.length<Yt;)At=ee[0]+At;return At}function Lt(At,Yt){return Nt(At,Yt,"0")}function Ht(At,Yt){function ee(Me){return 0>Me?-1:0<Me?1:0}var xe;return(xe=ee(At.getFullYear()-Yt.getFullYear()))===0&&(xe=ee(At.getMonth()-Yt.getMonth()))===0&&(xe=ee(At.getDate()-Yt.getDate())),xe}function ce(At){switch(At.getDay()){case 0:return new Date(At.getFullYear()-1,11,29);case 1:return At;case 2:return new Date(At.getFullYear(),0,3);case 3:return new Date(At.getFullYear(),0,2);case 4:return new Date(At.getFullYear(),0,1);case 5:return new Date(At.getFullYear()-1,11,31);case 6:return new Date(At.getFullYear()-1,11,30)}}function he(At){var Yt=At.qa;for(At=new Date(new Date(At.ra+1900,0,1).getTime());0<Yt;){var ee=At.getMonth(),xe=(ue(At.getFullYear())?le:Ee)[ee];if(!(Yt>xe-At.getDate())){At.setDate(At.getDate()+Yt);break}Yt-=xe-At.getDate()+1,At.setDate(1),11>ee?At.setMonth(ee+1):(At.setMonth(0),At.setFullYear(At.getFullYear()+1))}return ee=new Date(At.getFullYear()+1,0,4),Yt=ce(new Date(At.getFullYear(),0,4)),ee=ce(ee),0>=Ht(Yt,At)?0>=Ht(ee,At)?At.getFullYear()+1:At.getFullYear():At.getFullYear()-1}var pe=bt[Ct+40>>2>>>0];for(var ae in Ct={Ea:bt[Ct>>2>>>0],Da:bt[Ct+4>>2>>>0],ta:bt[Ct+8>>2>>>0],va:bt[Ct+12>>2>>>0],ua:bt[Ct+16>>2>>>0],ra:bt[Ct+20>>2>>>0],la:bt[Ct+24>>2>>>0],qa:bt[Ct+28>>2>>>0],Ja:bt[Ct+32>>2>>>0],Ca:bt[Ct+36>>2>>>0],Fa:pe?Pt(pe):""},It=Pt(It),pe={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})It=It.replace(new RegExp(ae,"g"),pe[ae]);var Oe="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),$e="January February March April May June July August September October November December".split(" ");for(ae in pe={"%a":function(At){return Oe[At.la].substring(0,3)},"%A":function(At){return Oe[At.la]},"%b":function(At){return $e[At.ua].substring(0,3)},"%B":function(At){return $e[At.ua]},"%C":function(At){return Lt((At.ra+1900)/100|0,2)},"%d":function(At){return Lt(At.va,2)},"%e":function(At){return Nt(At.va,2," ")},"%g":function(At){return he(At).toString().substring(2)},"%G":function(At){return he(At)},"%H":function(At){return Lt(At.ta,2)},"%I":function(At){return(At=At.ta)==0?At=12:12<At&&(At-=12),Lt(At,2)},"%j":function(At){for(var Yt=0,ee=0;ee<=At.ua-1;Yt+=(ue(At.ra+1900)?le:Ee)[ee++]);return Lt(At.va+Yt,3)},"%m":function(At){return Lt(At.ua+1,2)},"%M":function(At){return Lt(At.Da,2)},"%n":function(){return`
`},"%p":function(At){return 0<=At.ta&&12>At.ta?"AM":"PM"},"%S":function(At){return Lt(At.Ea,2)},"%t":function(){return"	"},"%u":function(At){return At.la||7},"%U":function(At){return Lt(Math.floor((At.qa+7-At.la)/7),2)},"%V":function(At){var Yt=Math.floor((At.qa+7-(At.la+6)%7)/7);if(2>=(At.la+371-At.qa-2)%7&&Yt++,Yt)Yt==53&&((ee=(At.la+371-At.qa)%7)==4||ee==3&&ue(At.ra)||(Yt=1));else{Yt=52;var ee=(At.la+7-At.qa-1)%7;(ee==4||ee==5&&ue(At.ra%400-1))&&Yt++}return Lt(Yt,2)},"%w":function(At){return At.la},"%W":function(At){return Lt(Math.floor((At.qa+7-(At.la+6)%7)/7),2)},"%y":function(At){return(At.ra+1900).toString().substring(2)},"%Y":function(At){return At.ra+1900},"%z":function(At){var Yt=0<=(At=At.Ca);return At=Math.abs(At)/60,(Yt?"+":"-")+("0000"+(At/60*100+At%60)).slice(-4)},"%Z":function(At){return At.Fa},"%%":function(){return"%"}},It=It.replace(/%%/g,"\0\0"),pe)It.includes(ae)&&(It=It.replace(new RegExp(ae,"g"),pe[ae](Ct)));return ae=function(At){var Yt=Array(Rt(At)+1);return Ft(At,Yt,0,Yt.length),Yt}(It=It.replace(/\0\0/g,"%")),ae.length>$t?0:(_t.set(ae,xt>>>0),ae.length-1)}var Te={a:function(xt){return Se(xt+24)+24},b:function(xt,$t,It){throw new ye(xt).ya($t,It),xt},g:function(){return 0},I:function(){},w:function(){},y:function(){},K:function(){return 0},G:function(){},C:function(){},F:function(){},k:function(){},x:function(){},u:function(){},H:function(){},v:function(){},n:function(){},p:function(){ne("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},o:function(){ne("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},l:function(){return Date.now()},L:function(){return!0},M:function(xt,$t){xt=new Date(1e3*(St[xt>>>2]+4294967296*bt[xt+4>>>2])),bt[$t>>2>>>0]=xt.getUTCSeconds(),bt[$t+4>>2>>>0]=xt.getUTCMinutes(),bt[$t+8>>2>>>0]=xt.getUTCHours(),bt[$t+12>>2>>>0]=xt.getUTCDate(),bt[$t+16>>2>>>0]=xt.getUTCMonth(),bt[$t+20>>2>>>0]=xt.getUTCFullYear()-1900,bt[$t+24>>2>>>0]=xt.getUTCDay(),bt[$t+28>>2>>>0]=(xt.getTime()-Date.UTC(xt.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},N:function(xt,$t){xt=new Date(1e3*(St[xt>>>2]+4294967296*bt[xt+4>>>2])),bt[$t>>2>>>0]=xt.getSeconds(),bt[$t+4>>2>>>0]=xt.getMinutes(),bt[$t+8>>2>>>0]=xt.getHours(),bt[$t+12>>2>>>0]=xt.getDate(),bt[$t+16>>2>>>0]=xt.getMonth(),bt[$t+20>>2>>>0]=xt.getFullYear()-1900,bt[$t+24>>2>>>0]=xt.getDay();var It=new Date(xt.getFullYear(),0,1);bt[$t+28>>2>>>0]=(xt.getTime()-It.getTime())/864e5|0,bt[$t+36>>2>>>0]=-60*xt.getTimezoneOffset();var Ct=new Date(xt.getFullYear(),6,1).getTimezoneOffset();It=It.getTimezoneOffset(),bt[$t+32>>2>>>0]=0|(Ct!=It&&xt.getTimezoneOffset()==Math.min(It,Ct))},O:function(xt){var $t=new Date(bt[xt+20>>2>>>0]+1900,bt[xt+16>>2>>>0],bt[xt+12>>2>>>0],bt[xt+8>>2>>>0],bt[xt+4>>2>>>0],bt[xt>>2>>>0],0),It=bt[xt+32>>2>>>0],Ct=$t.getTimezoneOffset(),Nt=new Date($t.getFullYear(),0,1),Lt=new Date($t.getFullYear(),6,1).getTimezoneOffset(),Ht=Nt.getTimezoneOffset(),ce=Math.min(Ht,Lt);return 0>It?bt[xt+32>>2>>>0]=+(Lt!=Ht&&ce==Ct):0<It!=(ce==Ct)&&(Lt=Math.max(Ht,Lt),$t.setTime($t.getTime()+6e4*((0<It?ce:Lt)-Ct))),bt[xt+24>>2>>>0]=$t.getDay(),bt[xt+28>>2>>>0]=($t.getTime()-Nt.getTime())/864e5|0,bt[xt>>2>>>0]=$t.getSeconds(),bt[xt+4>>2>>>0]=$t.getMinutes(),bt[xt+8>>2>>>0]=$t.getHours(),bt[xt+12>>2>>>0]=$t.getDate(),bt[xt+16>>2>>>0]=$t.getMonth(),$t.getTime()/1e3|0},z:function(){return-52},B:function(){},m:function xt($t,It,Ct){xt.xa||(xt.xa=!0,function(Nt,Lt,Ht){function ce($e){return($e=$e.toTimeString().match(/\(([A-Za-z ]+)\)$/))?$e[1]:"GMT"}var he=new Date().getFullYear(),pe=new Date(he,0,1),ae=new Date(he,6,1);he=pe.getTimezoneOffset();var Oe=ae.getTimezoneOffset();bt[Nt>>2>>>0]=60*Math.max(he,Oe),bt[Lt>>2>>>0]=+(he!=Oe),Nt=ce(pe),Lt=ce(ae),Nt=ve(Nt),Lt=ve(Lt),Oe<he?(St[Ht>>2>>>0]=Nt,St[Ht+4>>2>>>0]=Lt):(St[Ht>>2>>>0]=Lt,St[Ht+4>>2>>>0]=Nt)}($t,It,Ct))},d:function(){ne("")},t:function(){return 4294901760},h:at?()=>{var xt=process.hrtime();return 1e3*xt[0]+xt[1]/1e6}:()=>performance.now(),J:function(xt,$t,It){vt.copyWithin(xt>>>0,$t>>>0,$t+It>>>0)},f:function(xt){var $t=vt.length;if(4294901760<(xt>>>=0))return!1;for(var It=1;4>=It;It*=2){var Ct=$t*(1+.2/It);Ct=Math.min(Ct,xt+100663296);var Nt=Math;Ct=Math.max(xt,Ct),Nt=Nt.min.call(Nt,4294901760,Ct+(65536-Ct%65536)%65536);t:{try{ft.grow(Nt-gt.byteLength+65535>>>16),Bt();var Lt=1;break t}catch{}Lt=void 0}if(Lt)return!0}return!1},D:function(xt,$t){var It=0;return _e().forEach(function(Ct,Nt){var Lt=$t+It;for(Nt=St[xt+4*Nt>>2>>>0]=Lt,Lt=0;Lt<Ct.length;++Lt)_t[Nt++>>0>>>0]=Ct.charCodeAt(Lt);_t[Nt>>0>>>0]=0,It+=Ct.length+1}),0},E:function(xt,$t){var It=_e();St[xt>>2>>>0]=It.length;var Ct=0;return It.forEach(function(Nt){Ct+=Nt.length+1}),St[$t>>2>>>0]=Ct,0},r:function(xt){ut||(K.onExit&&K.onExit(xt),yt=!0),et(xt,new se(xt))},e:function(){return 52},j:function(){return 52},q:function(){return 70},i:function(xt,$t,It,Ct){for(var Nt=0,Lt=0;Lt<It;Lt++){var Ht=St[$t>>2>>>0],ce=St[$t+4>>2>>>0];$t+=8;for(var he=0;he<ce;he++){var pe=vt[Ht+he>>>0],ae=ge[xt];pe===0||pe===10?((xt===1?ct:pt)(Dt(ae,0)),ae.length=0):ae.push(pe)}Nt+=ce}return St[Ct>>2>>>0]=Nt,0},s:function xt($t,It){xt.wa||(xt.wa=function(){if(typeof crypto=="object"&&typeof crypto.getRandomValues=="function"){var Nt=new Uint8Array(1);return()=>(crypto.getRandomValues(Nt),Nt[0])}if(at)try{var Lt=rt(760);return()=>Lt.randomBytes(1)[0]}catch{}return()=>ne("randomDevice")}());for(var Ct=0;Ct<It;Ct++)_t[$t+Ct>>0>>>0]=xt.wa();return 0},A:Pe,c:function(xt,$t,It,Ct){return Pe(xt,$t,It,Ct)}};(function(){function xt(Nt){K.asm=Nt.exports,ft=K.asm.P,Bt(),jt.unshift(K.asm.Q),Qt--,K.monitorRunDependencies&&K.monitorRunDependencies(Qt),Qt==0&&zt&&(Nt=zt,zt=null,Nt())}function $t(Nt){xt(Nt.instance)}function It(Nt){return function(){if(!lt&&(ot||it)){if(typeof fetch=="function"&&!Gt.startsWith("file://"))return fetch(Gt,{credentials:"same-origin"}).then(function(Lt){if(!Lt.ok)throw"failed to load wasm binary file at '"+Gt+"'";return Lt.arrayBuffer()}).catch(function(){return Xt()});if(G)return new Promise(function(Lt,Ht){G(Gt,function(ce){Lt(new Uint8Array(ce))},Ht)})}return Promise.resolve().then(function(){return Xt()})}().then(function(Lt){return WebAssembly.instantiate(Lt,Ct)}).then(function(Lt){return Lt}).then(Nt,function(Lt){pt("failed to asynchronously prepare wasm: "+Lt),ne(Lt)})}var Ct={a:Te};if(Qt++,K.monitorRunDependencies&&K.monitorRunDependencies(Qt),K.instantiateWasm)try{return K.instantiateWasm(Ct,xt)}catch(Nt){return pt("Module.instantiateWasm callback failed with error: "+Nt),!1}(lt||typeof WebAssembly.instantiateStreaming!="function"||Zt()||Gt.startsWith("file://")||at||typeof fetch!="function"?It($t):fetch(Gt,{credentials:"same-origin"}).then(function(Nt){return WebAssembly.instantiateStreaming(Nt,Ct).then($t,function(Lt){return pt("wasm streaming compile failed: "+Lt),pt("falling back to ArrayBuffer instantiation"),It($t)})})).catch(Q)})(),K.___wasm_call_ctors=function(){return(K.___wasm_call_ctors=K.asm.Q).apply(null,arguments)},K._OrtInit=function(){return(K._OrtInit=K.asm.R).apply(null,arguments)},K._OrtCreateSessionOptions=function(){return(K._OrtCreateSessionOptions=K.asm.S).apply(null,arguments)},K._OrtAppendExecutionProvider=function(){return(K._OrtAppendExecutionProvider=K.asm.T).apply(null,arguments)},K._OrtAddSessionConfigEntry=function(){return(K._OrtAddSessionConfigEntry=K.asm.U).apply(null,arguments)},K._OrtReleaseSessionOptions=function(){return(K._OrtReleaseSessionOptions=K.asm.V).apply(null,arguments)},K._OrtCreateSession=function(){return(K._OrtCreateSession=K.asm.W).apply(null,arguments)},K._OrtReleaseSession=function(){return(K._OrtReleaseSession=K.asm.X).apply(null,arguments)},K._OrtGetInputCount=function(){return(K._OrtGetInputCount=K.asm.Y).apply(null,arguments)},K._OrtGetOutputCount=function(){return(K._OrtGetOutputCount=K.asm.Z).apply(null,arguments)},K._OrtGetInputName=function(){return(K._OrtGetInputName=K.asm._).apply(null,arguments)},K._OrtGetOutputName=function(){return(K._OrtGetOutputName=K.asm.$).apply(null,arguments)},K._OrtFree=function(){return(K._OrtFree=K.asm.aa).apply(null,arguments)},K._OrtCreateTensor=function(){return(K._OrtCreateTensor=K.asm.ba).apply(null,arguments)},K._OrtGetTensorData=function(){return(K._OrtGetTensorData=K.asm.ca).apply(null,arguments)},K._OrtReleaseTensor=function(){return(K._OrtReleaseTensor=K.asm.da).apply(null,arguments)},K._OrtCreateRunOptions=function(){return(K._OrtCreateRunOptions=K.asm.ea).apply(null,arguments)},K._OrtAddRunConfigEntry=function(){return(K._OrtAddRunConfigEntry=K.asm.fa).apply(null,arguments)},K._OrtReleaseRunOptions=function(){return(K._OrtReleaseRunOptions=K.asm.ga).apply(null,arguments)},K._OrtRun=function(){return(K._OrtRun=K.asm.ha).apply(null,arguments)},K._OrtEndProfiling=function(){return(K._OrtEndProfiling=K.asm.ia).apply(null,arguments)};var Se=K._malloc=function(){return(Se=K._malloc=K.asm.ja).apply(null,arguments)};K._free=function(){return(K._free=K.asm.ka).apply(null,arguments)};var Ie,Ce=K.stackSave=function(){return(Ce=K.stackSave=K.asm.ma).apply(null,arguments)},ke=K.stackRestore=function(){return(ke=K.stackRestore=K.asm.na).apply(null,arguments)},Re=K.stackAlloc=function(){return(Re=K.stackAlloc=K.asm.oa).apply(null,arguments)};function Ut(){function xt(){if(!Ie&&(Ie=!0,K.calledRun=!0,!yt)){if(fe(jt),X(K),K.onRuntimeInitialized&&K.onRuntimeInitialized(),K.postRun)for(typeof K.postRun=="function"&&(K.postRun=[K.postRun]);K.postRun.length;){var $t=K.postRun.shift();qt.unshift($t)}fe(qt)}}if(!(0<Qt)){if(K.preRun)for(typeof K.preRun=="function"&&(K.preRun=[K.preRun]);K.preRun.length;)Kt();fe(Vt),0<Qt||(K.setStatus?(K.setStatus("Running..."),setTimeout(function(){setTimeout(function(){K.setStatus("")},1),xt()},1)):xt())}}if(K.___cxa_is_pointer_type=function(){return(K.___cxa_is_pointer_type=K.asm.pa).apply(null,arguments)},K.UTF8ToString=Pt,K.stringToUTF8=function(xt,$t,It){return Ft(xt,vt,$t,It)},K.lengthBytesUTF8=Rt,K.stackSave=Ce,K.stackRestore=ke,K.stackAlloc=Re,zt=function xt(){Ie||Ut(),Ie||(zt=xt)},K.preInit)for(typeof K.preInit=="function"&&(K.preInit=[K.preInit]);0<K.preInit.length;)K.preInit.pop()();return Ut(),nt.ready});dt.exports=Y},4537:dt=>{dt.exports=function(U,rt){for(var tt=new Array(arguments.length-1),Y=0,nt=2,K=!0;nt<arguments.length;)tt[Y++]=arguments[nt++];return new Promise(function(X,Q){tt[Y]=function(q){if(K)if(K=!1,q)Q(q);else{for(var G=new Array(arguments.length-1),O=0;O<G.length;)G[O++]=arguments[O];X.apply(null,G)}};try{U.apply(rt||null,tt)}catch(q){K&&(K=!1,Q(q))}})}},7419:(dt,U)=>{var rt=U;rt.length=function(X){var Q=X.length;if(!Q)return 0;for(var q=0;--Q%4>1&&X.charAt(Q)==="=";)++q;return Math.ceil(3*X.length)/4-q};for(var tt=new Array(64),Y=new Array(123),nt=0;nt<64;)Y[tt[nt]=nt<26?nt+65:nt<52?nt+71:nt<62?nt-4:nt-59|43]=nt++;rt.encode=function(X,Q,q){for(var G,O=null,b=[],F=0,j=0;Q<q;){var W=X[Q++];switch(j){case 0:b[F++]=tt[W>>2],G=(3&W)<<4,j=1;break;case 1:b[F++]=tt[G|W>>4],G=(15&W)<<2,j=2;break;case 2:b[F++]=tt[G|W>>6],b[F++]=tt[63&W],j=0}F>8191&&((O||(O=[])).push(String.fromCharCode.apply(String,b)),F=0)}return j&&(b[F++]=tt[G],b[F++]=61,j===1&&(b[F++]=61)),O?(F&&O.push(String.fromCharCode.apply(String,b.slice(0,F))),O.join("")):String.fromCharCode.apply(String,b.slice(0,F))};var K="invalid encoding";rt.decode=function(X,Q,q){for(var G,O=q,b=0,F=0;F<X.length;){var j=X.charCodeAt(F++);if(j===61&&b>1)break;if((j=Y[j])===void 0)throw Error(K);switch(b){case 0:G=j,b=1;break;case 1:Q[q++]=G<<2|(48&j)>>4,G=j,b=2;break;case 2:Q[q++]=(15&G)<<4|(60&j)>>2,G=j,b=3;break;case 3:Q[q++]=(3&G)<<6|j,b=0}}if(b===1)throw Error(K);return q-O},rt.test=function(X){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(X)}},9211:dt=>{function U(){this._listeners={}}dt.exports=U,U.prototype.on=function(rt,tt,Y){return(this._listeners[rt]||(this._listeners[rt]=[])).push({fn:tt,ctx:Y||this}),this},U.prototype.off=function(rt,tt){if(rt===void 0)this._listeners={};else if(tt===void 0)this._listeners[rt]=[];else for(var Y=this._listeners[rt],nt=0;nt<Y.length;)Y[nt].fn===tt?Y.splice(nt,1):++nt;return this},U.prototype.emit=function(rt){var tt=this._listeners[rt];if(tt){for(var Y=[],nt=1;nt<arguments.length;)Y.push(arguments[nt++]);for(nt=0;nt<tt.length;)tt[nt].fn.apply(tt[nt++].ctx,Y)}return this}},945:dt=>{function U(K){return typeof Float32Array<"u"?function(){var X=new Float32Array([-0]),Q=new Uint8Array(X.buffer),q=Q[3]===128;function G(j,W,J){X[0]=j,W[J]=Q[0],W[J+1]=Q[1],W[J+2]=Q[2],W[J+3]=Q[3]}function O(j,W,J){X[0]=j,W[J]=Q[3],W[J+1]=Q[2],W[J+2]=Q[1],W[J+3]=Q[0]}function b(j,W){return Q[0]=j[W],Q[1]=j[W+1],Q[2]=j[W+2],Q[3]=j[W+3],X[0]}function F(j,W){return Q[3]=j[W],Q[2]=j[W+1],Q[1]=j[W+2],Q[0]=j[W+3],X[0]}K.writeFloatLE=q?G:O,K.writeFloatBE=q?O:G,K.readFloatLE=q?b:F,K.readFloatBE=q?F:b}():function(){function X(q,G,O,b){var F=G<0?1:0;if(F&&(G=-G),G===0)q(1/G>0?0:2147483648,O,b);else if(isNaN(G))q(2143289344,O,b);else if(G>34028234663852886e22)q((F<<31|2139095040)>>>0,O,b);else if(G<11754943508222875e-54)q((F<<31|Math.round(G/1401298464324817e-60))>>>0,O,b);else{var j=Math.floor(Math.log(G)/Math.LN2);q((F<<31|j+127<<23|8388607&Math.round(G*Math.pow(2,-j)*8388608))>>>0,O,b)}}function Q(q,G,O){var b=q(G,O),F=2*(b>>31)+1,j=b>>>23&255,W=8388607&b;return j===255?W?NaN:F*(1/0):j===0?1401298464324817e-60*F*W:F*Math.pow(2,j-150)*(W+8388608)}K.writeFloatLE=X.bind(null,rt),K.writeFloatBE=X.bind(null,tt),K.readFloatLE=Q.bind(null,Y),K.readFloatBE=Q.bind(null,nt)}(),typeof Float64Array<"u"?function(){var X=new Float64Array([-0]),Q=new Uint8Array(X.buffer),q=Q[7]===128;function G(j,W,J){X[0]=j,W[J]=Q[0],W[J+1]=Q[1],W[J+2]=Q[2],W[J+3]=Q[3],W[J+4]=Q[4],W[J+5]=Q[5],W[J+6]=Q[6],W[J+7]=Q[7]}function O(j,W,J){X[0]=j,W[J]=Q[7],W[J+1]=Q[6],W[J+2]=Q[5],W[J+3]=Q[4],W[J+4]=Q[3],W[J+5]=Q[2],W[J+6]=Q[1],W[J+7]=Q[0]}function b(j,W){return Q[0]=j[W],Q[1]=j[W+1],Q[2]=j[W+2],Q[3]=j[W+3],Q[4]=j[W+4],Q[5]=j[W+5],Q[6]=j[W+6],Q[7]=j[W+7],X[0]}function F(j,W){return Q[7]=j[W],Q[6]=j[W+1],Q[5]=j[W+2],Q[4]=j[W+3],Q[3]=j[W+4],Q[2]=j[W+5],Q[1]=j[W+6],Q[0]=j[W+7],X[0]}K.writeDoubleLE=q?G:O,K.writeDoubleBE=q?O:G,K.readDoubleLE=q?b:F,K.readDoubleBE=q?F:b}():function(){function X(q,G,O,b,F,j){var W=b<0?1:0;if(W&&(b=-b),b===0)q(0,F,j+G),q(1/b>0?0:2147483648,F,j+O);else if(isNaN(b))q(0,F,j+G),q(2146959360,F,j+O);else if(b>17976931348623157e292)q(0,F,j+G),q((W<<31|2146435072)>>>0,F,j+O);else{var J;if(b<22250738585072014e-324)q((J=b/5e-324)>>>0,F,j+G),q((W<<31|J/4294967296)>>>0,F,j+O);else{var et=Math.floor(Math.log(b)/Math.LN2);et===1024&&(et=1023),q(4503599627370496*(J=b*Math.pow(2,-et))>>>0,F,j+G),q((W<<31|et+1023<<20|1048576*J&1048575)>>>0,F,j+O)}}}function Q(q,G,O,b,F){var j=q(b,F+G),W=q(b,F+O),J=2*(W>>31)+1,et=W>>>20&2047,ot=4294967296*(1048575&W)+j;return et===2047?ot?NaN:J*(1/0):et===0?5e-324*J*ot:J*Math.pow(2,et-1075)*(ot+4503599627370496)}K.writeDoubleLE=X.bind(null,rt,0,4),K.writeDoubleBE=X.bind(null,tt,4,0),K.readDoubleLE=Q.bind(null,Y,0,4),K.readDoubleBE=Q.bind(null,nt,4,0)}(),K}function rt(K,X,Q){X[Q]=255&K,X[Q+1]=K>>>8&255,X[Q+2]=K>>>16&255,X[Q+3]=K>>>24}function tt(K,X,Q){X[Q]=K>>>24,X[Q+1]=K>>>16&255,X[Q+2]=K>>>8&255,X[Q+3]=255&K}function Y(K,X){return(K[X]|K[X+1]<<8|K[X+2]<<16|K[X+3]<<24)>>>0}function nt(K,X){return(K[X]<<24|K[X+1]<<16|K[X+2]<<8|K[X+3])>>>0}dt.exports=U(U)},7199:module=>{function inquire(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(dt){}return null}module.exports=inquire},6662:dt=>{dt.exports=function(U,rt,tt){var Y=tt||8192,nt=Y>>>1,K=null,X=Y;return function(Q){if(Q<1||Q>nt)return U(Q);X+Q>Y&&(K=U(Y),X=0);var q=rt.call(K,X,X+=Q);return 7&X&&(X=1+(7|X)),q}}},4997:(dt,U)=>{var rt=U;rt.length=function(tt){for(var Y=0,nt=0,K=0;K<tt.length;++K)(nt=tt.charCodeAt(K))<128?Y+=1:nt<2048?Y+=2:(64512&nt)==55296&&(64512&tt.charCodeAt(K+1))==56320?(++K,Y+=4):Y+=3;return Y},rt.read=function(tt,Y,nt){if(nt-Y<1)return"";for(var K,X=null,Q=[],q=0;Y<nt;)(K=tt[Y++])<128?Q[q++]=K:K>191&&K<224?Q[q++]=(31&K)<<6|63&tt[Y++]:K>239&&K<365?(K=((7&K)<<18|(63&tt[Y++])<<12|(63&tt[Y++])<<6|63&tt[Y++])-65536,Q[q++]=55296+(K>>10),Q[q++]=56320+(1023&K)):Q[q++]=(15&K)<<12|(63&tt[Y++])<<6|63&tt[Y++],q>8191&&((X||(X=[])).push(String.fromCharCode.apply(String,Q)),q=0);return X?(q&&X.push(String.fromCharCode.apply(String,Q.slice(0,q))),X.join("")):String.fromCharCode.apply(String,Q.slice(0,q))},rt.write=function(tt,Y,nt){for(var K,X,Q=nt,q=0;q<tt.length;++q)(K=tt.charCodeAt(q))<128?Y[nt++]=K:K<2048?(Y[nt++]=K>>6|192,Y[nt++]=63&K|128):(64512&K)==55296&&(64512&(X=tt.charCodeAt(q+1)))==56320?(K=65536+((1023&K)<<10)+(1023&X),++q,Y[nt++]=K>>18|240,Y[nt++]=K>>12&63|128,Y[nt++]=K>>6&63|128,Y[nt++]=63&K|128):(Y[nt++]=K>>12|224,Y[nt++]=K>>6&63|128,Y[nt++]=63&K|128);return nt-Q}},3442:(dt,U)=>{U.__esModule=!0;var rt=function(){function tt(Y){if(!Y)throw new TypeError("Invalid argument; `value` has no value.");this.value=tt.EMPTY,Y&&tt.isGuid(Y)&&(this.value=Y)}return tt.isGuid=function(Y){var nt=Y.toString();return Y&&(Y instanceof tt||tt.validator.test(nt))},tt.create=function(){return new tt([tt.gen(2),tt.gen(1),tt.gen(1),tt.gen(1),tt.gen(3)].join("-"))},tt.createEmpty=function(){return new tt("emptyguid")},tt.parse=function(Y){return new tt(Y)},tt.raw=function(){return[tt.gen(2),tt.gen(1),tt.gen(1),tt.gen(1),tt.gen(3)].join("-")},tt.gen=function(Y){for(var nt="",K=0;K<Y;K++)nt+=(65536*(1+Math.random())|0).toString(16).substring(1);return nt},tt.prototype.equals=function(Y){return tt.isGuid(Y)&&this.value===Y.toString()},tt.prototype.isEmpty=function(){return this.value===tt.EMPTY},tt.prototype.toString=function(){return this.value},tt.prototype.toJSON=function(){return{value:this.value}},tt.validator=new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$","i"),tt.EMPTY="00000000-0000-0000-0000-000000000000",tt}();U.Guid=rt},3720:dt=>{dt.exports=rt;var U=null;try{U=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function rt(ut,ft,gt){this.low=0|ut,this.high=0|ft,this.unsigned=!!gt}function tt(ut){return(ut&&ut.__isLong__)===!0}rt.prototype.__isLong__,Object.defineProperty(rt.prototype,"__isLong__",{value:!0}),rt.isLong=tt;var Y={},nt={};function K(ut,ft){var gt,_t,vt;return ft?(vt=0<=(ut>>>=0)&&ut<256)&&(_t=nt[ut])?_t:(gt=Q(ut,(0|ut)<0?-1:0,!0),vt&&(nt[ut]=gt),gt):(vt=-128<=(ut|=0)&&ut<128)&&(_t=Y[ut])?_t:(gt=Q(ut,ut<0?-1:0,!1),vt&&(Y[ut]=gt),gt)}function X(ut,ft){if(isNaN(ut))return ft?et:J;if(ft){if(ut<0)return et;if(ut>=F)return lt}else{if(ut<=-j)return ct;if(ut+1>=j)return st}return ut<0?X(-ut,ft).neg():Q(ut%b|0,ut/b|0,ft)}function Q(ut,ft,gt){return new rt(ut,ft,gt)}rt.fromInt=K,rt.fromNumber=X,rt.fromBits=Q;var q=Math.pow;function G(ut,ft,gt){if(ut.length===0)throw Error("empty string");if(ut==="NaN"||ut==="Infinity"||ut==="+Infinity"||ut==="-Infinity")return J;if(typeof ft=="number"?(gt=ft,ft=!1):ft=!!ft,(gt=gt||10)<2||36<gt)throw RangeError("radix");var _t;if((_t=ut.indexOf("-"))>0)throw Error("interior hyphen");if(_t===0)return G(ut.substring(1),ft,gt).neg();for(var vt=X(q(gt,8)),bt=J,St=0;St<ut.length;St+=8){var yt=Math.min(8,ut.length-St),wt=parseInt(ut.substring(St,St+yt),gt);if(yt<8){var Dt=X(q(gt,yt));bt=bt.mul(Dt).add(X(wt))}else bt=(bt=bt.mul(vt)).add(X(wt))}return bt.unsigned=ft,bt}function O(ut,ft){return typeof ut=="number"?X(ut,ft):typeof ut=="string"?G(ut,ft):Q(ut.low,ut.high,typeof ft=="boolean"?ft:ut.unsigned)}rt.fromString=G,rt.fromValue=O;var b=4294967296,F=b*b,j=F/2,W=K(1<<24),J=K(0);rt.ZERO=J;var et=K(0,!0);rt.UZERO=et;var ot=K(1);rt.ONE=ot;var it=K(1,!0);rt.UONE=it;var at=K(-1);rt.NEG_ONE=at;var st=Q(-1,2147483647,!1);rt.MAX_VALUE=st;var lt=Q(-1,-1,!0);rt.MAX_UNSIGNED_VALUE=lt;var ct=Q(0,-2147483648,!1);rt.MIN_VALUE=ct;var pt=rt.prototype;pt.toInt=function(){return this.unsigned?this.low>>>0:this.low},pt.toNumber=function(){return this.unsigned?(this.high>>>0)*b+(this.low>>>0):this.high*b+(this.low>>>0)},pt.toString=function(ut){if((ut=ut||10)<2||36<ut)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(ct)){var ft=X(ut),gt=this.div(ft),_t=gt.mul(ft).sub(this);return gt.toString(ut)+_t.toInt().toString(ut)}return"-"+this.neg().toString(ut)}for(var vt=X(q(ut,6),this.unsigned),bt=this,St="";;){var yt=bt.div(vt),wt=(bt.sub(yt.mul(vt)).toInt()>>>0).toString(ut);if((bt=yt).isZero())return wt+St;for(;wt.length<6;)wt="0"+wt;St=""+wt+St}},pt.getHighBits=function(){return this.high},pt.getHighBitsUnsigned=function(){return this.high>>>0},pt.getLowBits=function(){return this.low},pt.getLowBitsUnsigned=function(){return this.low>>>0},pt.getNumBitsAbs=function(){if(this.isNegative())return this.eq(ct)?64:this.neg().getNumBitsAbs();for(var ut=this.high!=0?this.high:this.low,ft=31;ft>0&&!(ut&1<<ft);ft--);return this.high!=0?ft+33:ft+1},pt.isZero=function(){return this.high===0&&this.low===0},pt.eqz=pt.isZero,pt.isNegative=function(){return!this.unsigned&&this.high<0},pt.isPositive=function(){return this.unsigned||this.high>=0},pt.isOdd=function(){return(1&this.low)==1},pt.isEven=function(){return(1&this.low)==0},pt.equals=function(ut){return tt(ut)||(ut=O(ut)),(this.unsigned===ut.unsigned||this.high>>>31!=1||ut.high>>>31!=1)&&this.high===ut.high&&this.low===ut.low},pt.eq=pt.equals,pt.notEquals=function(ut){return!this.eq(ut)},pt.neq=pt.notEquals,pt.ne=pt.notEquals,pt.lessThan=function(ut){return this.comp(ut)<0},pt.lt=pt.lessThan,pt.lessThanOrEqual=function(ut){return this.comp(ut)<=0},pt.lte=pt.lessThanOrEqual,pt.le=pt.lessThanOrEqual,pt.greaterThan=function(ut){return this.comp(ut)>0},pt.gt=pt.greaterThan,pt.greaterThanOrEqual=function(ut){return this.comp(ut)>=0},pt.gte=pt.greaterThanOrEqual,pt.ge=pt.greaterThanOrEqual,pt.compare=function(ut){if(tt(ut)||(ut=O(ut)),this.eq(ut))return 0;var ft=this.isNegative(),gt=ut.isNegative();return ft&&!gt?-1:!ft&&gt?1:this.unsigned?ut.high>>>0>this.high>>>0||ut.high===this.high&&ut.low>>>0>this.low>>>0?-1:1:this.sub(ut).isNegative()?-1:1},pt.comp=pt.compare,pt.negate=function(){return!this.unsigned&&this.eq(ct)?ct:this.not().add(ot)},pt.neg=pt.negate,pt.add=function(ut){tt(ut)||(ut=O(ut));var ft=this.high>>>16,gt=65535&this.high,_t=this.low>>>16,vt=65535&this.low,bt=ut.high>>>16,St=65535&ut.high,yt=ut.low>>>16,wt=0,Dt=0,Pt=0,Ft=0;return Pt+=(Ft+=vt+(65535&ut.low))>>>16,Dt+=(Pt+=_t+yt)>>>16,wt+=(Dt+=gt+St)>>>16,wt+=ft+bt,Q((Pt&=65535)<<16|(Ft&=65535),(wt&=65535)<<16|(Dt&=65535),this.unsigned)},pt.subtract=function(ut){return tt(ut)||(ut=O(ut)),this.add(ut.neg())},pt.sub=pt.subtract,pt.multiply=function(ut){if(this.isZero())return J;if(tt(ut)||(ut=O(ut)),U)return Q(U.mul(this.low,this.high,ut.low,ut.high),U.get_high(),this.unsigned);if(ut.isZero())return J;if(this.eq(ct))return ut.isOdd()?ct:J;if(ut.eq(ct))return this.isOdd()?ct:J;if(this.isNegative())return ut.isNegative()?this.neg().mul(ut.neg()):this.neg().mul(ut).neg();if(ut.isNegative())return this.mul(ut.neg()).neg();if(this.lt(W)&&ut.lt(W))return X(this.toNumber()*ut.toNumber(),this.unsigned);var ft=this.high>>>16,gt=65535&this.high,_t=this.low>>>16,vt=65535&this.low,bt=ut.high>>>16,St=65535&ut.high,yt=ut.low>>>16,wt=65535&ut.low,Dt=0,Pt=0,Ft=0,Rt=0;return Ft+=(Rt+=vt*wt)>>>16,Pt+=(Ft+=_t*wt)>>>16,Ft&=65535,Pt+=(Ft+=vt*yt)>>>16,Dt+=(Pt+=gt*wt)>>>16,Pt&=65535,Dt+=(Pt+=_t*yt)>>>16,Pt&=65535,Dt+=(Pt+=vt*St)>>>16,Dt+=ft*wt+gt*yt+_t*St+vt*bt,Q((Ft&=65535)<<16|(Rt&=65535),(Dt&=65535)<<16|(Pt&=65535),this.unsigned)},pt.mul=pt.multiply,pt.divide=function(ut){if(tt(ut)||(ut=O(ut)),ut.isZero())throw Error("division by zero");var ft,gt,_t;if(U)return this.unsigned||this.high!==-2147483648||ut.low!==-1||ut.high!==-1?Q((this.unsigned?U.div_u:U.div_s)(this.low,this.high,ut.low,ut.high),U.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?et:J;if(this.unsigned){if(ut.unsigned||(ut=ut.toUnsigned()),ut.gt(this))return et;if(ut.gt(this.shru(1)))return it;_t=et}else{if(this.eq(ct))return ut.eq(ot)||ut.eq(at)?ct:ut.eq(ct)?ot:(ft=this.shr(1).div(ut).shl(1)).eq(J)?ut.isNegative()?ot:at:(gt=this.sub(ut.mul(ft)),_t=ft.add(gt.div(ut)));if(ut.eq(ct))return this.unsigned?et:J;if(this.isNegative())return ut.isNegative()?this.neg().div(ut.neg()):this.neg().div(ut).neg();if(ut.isNegative())return this.div(ut.neg()).neg();_t=J}for(gt=this;gt.gte(ut);){ft=Math.max(1,Math.floor(gt.toNumber()/ut.toNumber()));for(var vt=Math.ceil(Math.log(ft)/Math.LN2),bt=vt<=48?1:q(2,vt-48),St=X(ft),yt=St.mul(ut);yt.isNegative()||yt.gt(gt);)yt=(St=X(ft-=bt,this.unsigned)).mul(ut);St.isZero()&&(St=ot),_t=_t.add(St),gt=gt.sub(yt)}return _t},pt.div=pt.divide,pt.modulo=function(ut){return tt(ut)||(ut=O(ut)),U?Q((this.unsigned?U.rem_u:U.rem_s)(this.low,this.high,ut.low,ut.high),U.get_high(),this.unsigned):this.sub(this.div(ut).mul(ut))},pt.mod=pt.modulo,pt.rem=pt.modulo,pt.not=function(){return Q(~this.low,~this.high,this.unsigned)},pt.and=function(ut){return tt(ut)||(ut=O(ut)),Q(this.low&ut.low,this.high&ut.high,this.unsigned)},pt.or=function(ut){return tt(ut)||(ut=O(ut)),Q(this.low|ut.low,this.high|ut.high,this.unsigned)},pt.xor=function(ut){return tt(ut)||(ut=O(ut)),Q(this.low^ut.low,this.high^ut.high,this.unsigned)},pt.shiftLeft=function(ut){return tt(ut)&&(ut=ut.toInt()),(ut&=63)==0?this:ut<32?Q(this.low<<ut,this.high<<ut|this.low>>>32-ut,this.unsigned):Q(0,this.low<<ut-32,this.unsigned)},pt.shl=pt.shiftLeft,pt.shiftRight=function(ut){return tt(ut)&&(ut=ut.toInt()),(ut&=63)==0?this:ut<32?Q(this.low>>>ut|this.high<<32-ut,this.high>>ut,this.unsigned):Q(this.high>>ut-32,this.high>=0?0:-1,this.unsigned)},pt.shr=pt.shiftRight,pt.shiftRightUnsigned=function(ut){if(tt(ut)&&(ut=ut.toInt()),(ut&=63)==0)return this;var ft=this.high;return ut<32?Q(this.low>>>ut|ft<<32-ut,ft>>>ut,this.unsigned):Q(ut===32?ft:ft>>>ut-32,0,this.unsigned)},pt.shru=pt.shiftRightUnsigned,pt.shr_u=pt.shiftRightUnsigned,pt.toSigned=function(){return this.unsigned?Q(this.low,this.high,!1):this},pt.toUnsigned=function(){return this.unsigned?this:Q(this.low,this.high,!0)},pt.toBytes=function(ut){return ut?this.toBytesLE():this.toBytesBE()},pt.toBytesLE=function(){var ut=this.high,ft=this.low;return[255&ft,ft>>>8&255,ft>>>16&255,ft>>>24,255&ut,ut>>>8&255,ut>>>16&255,ut>>>24]},pt.toBytesBE=function(){var ut=this.high,ft=this.low;return[ut>>>24,ut>>>16&255,ut>>>8&255,255&ut,ft>>>24,ft>>>16&255,ft>>>8&255,255&ft]},rt.fromBytes=function(ut,ft,gt){return gt?rt.fromBytesLE(ut,ft):rt.fromBytesBE(ut,ft)},rt.fromBytesLE=function(ut,ft){return new rt(ut[0]|ut[1]<<8|ut[2]<<16|ut[3]<<24,ut[4]|ut[5]<<8|ut[6]<<16|ut[7]<<24,ft)},rt.fromBytesBE=function(ut,ft){return new rt(ut[4]<<24|ut[5]<<16|ut[6]<<8|ut[7],ut[0]<<24|ut[1]<<16|ut[2]<<8|ut[3],ft)}},1446:(dt,U,rt)=>{var tt,Y,nt,K=rt(2100),X=K.Reader,Q=K.Writer,q=K.util,G=K.roots.default||(K.roots.default={});G.onnx=((nt={}).Version=(tt={},(Y=Object.create(tt))[tt[0]="_START_VERSION"]=0,Y[tt[1]="IR_VERSION_2017_10_10"]=1,Y[tt[2]="IR_VERSION_2017_10_30"]=2,Y[tt[3]="IR_VERSION_2017_11_3"]=3,Y[tt[4]="IR_VERSION_2019_1_22"]=4,Y[tt[5]="IR_VERSION"]=5,Y),nt.AttributeProto=function(){function O(b){if(this.floats=[],this.ints=[],this.strings=[],this.tensors=[],this.graphs=[],b)for(var F=Object.keys(b),j=0;j<F.length;++j)b[F[j]]!=null&&(this[F[j]]=b[F[j]])}return O.prototype.name="",O.prototype.refAttrName="",O.prototype.docString="",O.prototype.type=0,O.prototype.f=0,O.prototype.i=q.Long?q.Long.fromBits(0,0,!1):0,O.prototype.s=q.newBuffer([]),O.prototype.t=null,O.prototype.g=null,O.prototype.floats=q.emptyArray,O.prototype.ints=q.emptyArray,O.prototype.strings=q.emptyArray,O.prototype.tensors=q.emptyArray,O.prototype.graphs=q.emptyArray,O.create=function(b){return new O(b)},O.encode=function(b,F){if(F||(F=Q.create()),b.name!=null&&b.hasOwnProperty("name")&&F.uint32(10).string(b.name),b.f!=null&&b.hasOwnProperty("f")&&F.uint32(21).float(b.f),b.i!=null&&b.hasOwnProperty("i")&&F.uint32(24).int64(b.i),b.s!=null&&b.hasOwnProperty("s")&&F.uint32(34).bytes(b.s),b.t!=null&&b.hasOwnProperty("t")&&G.onnx.TensorProto.encode(b.t,F.uint32(42).fork()).ldelim(),b.g!=null&&b.hasOwnProperty("g")&&G.onnx.GraphProto.encode(b.g,F.uint32(50).fork()).ldelim(),b.floats!=null&&b.floats.length){F.uint32(58).fork();for(var j=0;j<b.floats.length;++j)F.float(b.floats[j]);F.ldelim()}if(b.ints!=null&&b.ints.length){for(F.uint32(66).fork(),j=0;j<b.ints.length;++j)F.int64(b.ints[j]);F.ldelim()}if(b.strings!=null&&b.strings.length)for(j=0;j<b.strings.length;++j)F.uint32(74).bytes(b.strings[j]);if(b.tensors!=null&&b.tensors.length)for(j=0;j<b.tensors.length;++j)G.onnx.TensorProto.encode(b.tensors[j],F.uint32(82).fork()).ldelim();if(b.graphs!=null&&b.graphs.length)for(j=0;j<b.graphs.length;++j)G.onnx.GraphProto.encode(b.graphs[j],F.uint32(90).fork()).ldelim();return b.docString!=null&&b.hasOwnProperty("docString")&&F.uint32(106).string(b.docString),b.type!=null&&b.hasOwnProperty("type")&&F.uint32(160).int32(b.type),b.refAttrName!=null&&b.hasOwnProperty("refAttrName")&&F.uint32(170).string(b.refAttrName),F},O.encodeDelimited=function(b,F){return this.encode(b,F).ldelim()},O.decode=function(b,F){b instanceof X||(b=X.create(b));for(var j=F===void 0?b.len:b.pos+F,W=new G.onnx.AttributeProto;b.pos<j;){var J=b.uint32();switch(J>>>3){case 1:W.name=b.string();break;case 21:W.refAttrName=b.string();break;case 13:W.docString=b.string();break;case 20:W.type=b.int32();break;case 2:W.f=b.float();break;case 3:W.i=b.int64();break;case 4:W.s=b.bytes();break;case 5:W.t=G.onnx.TensorProto.decode(b,b.uint32());break;case 6:W.g=G.onnx.GraphProto.decode(b,b.uint32());break;case 7:if(W.floats&&W.floats.length||(W.floats=[]),(7&J)==2)for(var et=b.uint32()+b.pos;b.pos<et;)W.floats.push(b.float());else W.floats.push(b.float());break;case 8:if(W.ints&&W.ints.length||(W.ints=[]),(7&J)==2)for(et=b.uint32()+b.pos;b.pos<et;)W.ints.push(b.int64());else W.ints.push(b.int64());break;case 9:W.strings&&W.strings.length||(W.strings=[]),W.strings.push(b.bytes());break;case 10:W.tensors&&W.tensors.length||(W.tensors=[]),W.tensors.push(G.onnx.TensorProto.decode(b,b.uint32()));break;case 11:W.graphs&&W.graphs.length||(W.graphs=[]),W.graphs.push(G.onnx.GraphProto.decode(b,b.uint32()));break;default:b.skipType(7&J)}}return W},O.decodeDelimited=function(b){return b instanceof X||(b=new X(b)),this.decode(b,b.uint32())},O.verify=function(b){if(typeof b!="object"||b===null)return"object expected";if(b.name!=null&&b.hasOwnProperty("name")&&!q.isString(b.name))return"name: string expected";if(b.refAttrName!=null&&b.hasOwnProperty("refAttrName")&&!q.isString(b.refAttrName))return"refAttrName: string expected";if(b.docString!=null&&b.hasOwnProperty("docString")&&!q.isString(b.docString))return"docString: string expected";if(b.type!=null&&b.hasOwnProperty("type"))switch(b.type){default:return"type: enum value expected";case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:}if(b.f!=null&&b.hasOwnProperty("f")&&typeof b.f!="number")return"f: number expected";if(b.i!=null&&b.hasOwnProperty("i")&&!(q.isInteger(b.i)||b.i&&q.isInteger(b.i.low)&&q.isInteger(b.i.high)))return"i: integer|Long expected";if(b.s!=null&&b.hasOwnProperty("s")&&!(b.s&&typeof b.s.length=="number"||q.isString(b.s)))return"s: buffer expected";if(b.t!=null&&b.hasOwnProperty("t")&&(j=G.onnx.TensorProto.verify(b.t)))return"t."+j;if(b.g!=null&&b.hasOwnProperty("g")&&(j=G.onnx.GraphProto.verify(b.g)))return"g."+j;if(b.floats!=null&&b.hasOwnProperty("floats")){if(!Array.isArray(b.floats))return"floats: array expected";for(var F=0;F<b.floats.length;++F)if(typeof b.floats[F]!="number")return"floats: number[] expected"}if(b.ints!=null&&b.hasOwnProperty("ints")){if(!Array.isArray(b.ints))return"ints: array expected";for(F=0;F<b.ints.length;++F)if(!(q.isInteger(b.ints[F])||b.ints[F]&&q.isInteger(b.ints[F].low)&&q.isInteger(b.ints[F].high)))return"ints: integer|Long[] expected"}if(b.strings!=null&&b.hasOwnProperty("strings")){if(!Array.isArray(b.strings))return"strings: array expected";for(F=0;F<b.strings.length;++F)if(!(b.strings[F]&&typeof b.strings[F].length=="number"||q.isString(b.strings[F])))return"strings: buffer[] expected"}if(b.tensors!=null&&b.hasOwnProperty("tensors")){if(!Array.isArray(b.tensors))return"tensors: array expected";for(F=0;F<b.tensors.length;++F)if(j=G.onnx.TensorProto.verify(b.tensors[F]))return"tensors."+j}if(b.graphs!=null&&b.hasOwnProperty("graphs")){if(!Array.isArray(b.graphs))return"graphs: array expected";for(F=0;F<b.graphs.length;++F){var j;if(j=G.onnx.GraphProto.verify(b.graphs[F]))return"graphs."+j}}return null},O.fromObject=function(b){if(b instanceof G.onnx.AttributeProto)return b;var F=new G.onnx.AttributeProto;switch(b.name!=null&&(F.name=String(b.name)),b.refAttrName!=null&&(F.refAttrName=String(b.refAttrName)),b.docString!=null&&(F.docString=String(b.docString)),b.type){case"UNDEFINED":case 0:F.type=0;break;case"FLOAT":case 1:F.type=1;break;case"INT":case 2:F.type=2;break;case"STRING":case 3:F.type=3;break;case"TENSOR":case 4:F.type=4;break;case"GRAPH":case 5:F.type=5;break;case"FLOATS":case 6:F.type=6;break;case"INTS":case 7:F.type=7;break;case"STRINGS":case 8:F.type=8;break;case"TENSORS":case 9:F.type=9;break;case"GRAPHS":case 10:F.type=10}if(b.f!=null&&(F.f=Number(b.f)),b.i!=null&&(q.Long?(F.i=q.Long.fromValue(b.i)).unsigned=!1:typeof b.i=="string"?F.i=parseInt(b.i,10):typeof b.i=="number"?F.i=b.i:typeof b.i=="object"&&(F.i=new q.LongBits(b.i.low>>>0,b.i.high>>>0).toNumber())),b.s!=null&&(typeof b.s=="string"?q.base64.decode(b.s,F.s=q.newBuffer(q.base64.length(b.s)),0):b.s.length&&(F.s=b.s)),b.t!=null){if(typeof b.t!="object")throw TypeError(".onnx.AttributeProto.t: object expected");F.t=G.onnx.TensorProto.fromObject(b.t)}if(b.g!=null){if(typeof b.g!="object")throw TypeError(".onnx.AttributeProto.g: object expected");F.g=G.onnx.GraphProto.fromObject(b.g)}if(b.floats){if(!Array.isArray(b.floats))throw TypeError(".onnx.AttributeProto.floats: array expected");F.floats=[];for(var j=0;j<b.floats.length;++j)F.floats[j]=Number(b.floats[j])}if(b.ints){if(!Array.isArray(b.ints))throw TypeError(".onnx.AttributeProto.ints: array expected");for(F.ints=[],j=0;j<b.ints.length;++j)q.Long?(F.ints[j]=q.Long.fromValue(b.ints[j])).unsigned=!1:typeof b.ints[j]=="string"?F.ints[j]=parseInt(b.ints[j],10):typeof b.ints[j]=="number"?F.ints[j]=b.ints[j]:typeof b.ints[j]=="object"&&(F.ints[j]=new q.LongBits(b.ints[j].low>>>0,b.ints[j].high>>>0).toNumber())}if(b.strings){if(!Array.isArray(b.strings))throw TypeError(".onnx.AttributeProto.strings: array expected");for(F.strings=[],j=0;j<b.strings.length;++j)typeof b.strings[j]=="string"?q.base64.decode(b.strings[j],F.strings[j]=q.newBuffer(q.base64.length(b.strings[j])),0):b.strings[j].length&&(F.strings[j]=b.strings[j])}if(b.tensors){if(!Array.isArray(b.tensors))throw TypeError(".onnx.AttributeProto.tensors: array expected");for(F.tensors=[],j=0;j<b.tensors.length;++j){if(typeof b.tensors[j]!="object")throw TypeError(".onnx.AttributeProto.tensors: object expected");F.tensors[j]=G.onnx.TensorProto.fromObject(b.tensors[j])}}if(b.graphs){if(!Array.isArray(b.graphs))throw TypeError(".onnx.AttributeProto.graphs: array expected");for(F.graphs=[],j=0;j<b.graphs.length;++j){if(typeof b.graphs[j]!="object")throw TypeError(".onnx.AttributeProto.graphs: object expected");F.graphs[j]=G.onnx.GraphProto.fromObject(b.graphs[j])}}return F},O.toObject=function(b,F){F||(F={});var j={};if((F.arrays||F.defaults)&&(j.floats=[],j.ints=[],j.strings=[],j.tensors=[],j.graphs=[]),F.defaults){if(j.name="",j.f=0,q.Long){var W=new q.Long(0,0,!1);j.i=F.longs===String?W.toString():F.longs===Number?W.toNumber():W}else j.i=F.longs===String?"0":0;F.bytes===String?j.s="":(j.s=[],F.bytes!==Array&&(j.s=q.newBuffer(j.s))),j.t=null,j.g=null,j.docString="",j.type=F.enums===String?"UNDEFINED":0,j.refAttrName=""}if(b.name!=null&&b.hasOwnProperty("name")&&(j.name=b.name),b.f!=null&&b.hasOwnProperty("f")&&(j.f=F.json&&!isFinite(b.f)?String(b.f):b.f),b.i!=null&&b.hasOwnProperty("i")&&(typeof b.i=="number"?j.i=F.longs===String?String(b.i):b.i:j.i=F.longs===String?q.Long.prototype.toString.call(b.i):F.longs===Number?new q.LongBits(b.i.low>>>0,b.i.high>>>0).toNumber():b.i),b.s!=null&&b.hasOwnProperty("s")&&(j.s=F.bytes===String?q.base64.encode(b.s,0,b.s.length):F.bytes===Array?Array.prototype.slice.call(b.s):b.s),b.t!=null&&b.hasOwnProperty("t")&&(j.t=G.onnx.TensorProto.toObject(b.t,F)),b.g!=null&&b.hasOwnProperty("g")&&(j.g=G.onnx.GraphProto.toObject(b.g,F)),b.floats&&b.floats.length){j.floats=[];for(var J=0;J<b.floats.length;++J)j.floats[J]=F.json&&!isFinite(b.floats[J])?String(b.floats[J]):b.floats[J]}if(b.ints&&b.ints.length)for(j.ints=[],J=0;J<b.ints.length;++J)typeof b.ints[J]=="number"?j.ints[J]=F.longs===String?String(b.ints[J]):b.ints[J]:j.ints[J]=F.longs===String?q.Long.prototype.toString.call(b.ints[J]):F.longs===Number?new q.LongBits(b.ints[J].low>>>0,b.ints[J].high>>>0).toNumber():b.ints[J];if(b.strings&&b.strings.length)for(j.strings=[],J=0;J<b.strings.length;++J)j.strings[J]=F.bytes===String?q.base64.encode(b.strings[J],0,b.strings[J].length):F.bytes===Array?Array.prototype.slice.call(b.strings[J]):b.strings[J];if(b.tensors&&b.tensors.length)for(j.tensors=[],J=0;J<b.tensors.length;++J)j.tensors[J]=G.onnx.TensorProto.toObject(b.tensors[J],F);if(b.graphs&&b.graphs.length)for(j.graphs=[],J=0;J<b.graphs.length;++J)j.graphs[J]=G.onnx.GraphProto.toObject(b.graphs[J],F);return b.docString!=null&&b.hasOwnProperty("docString")&&(j.docString=b.docString),b.type!=null&&b.hasOwnProperty("type")&&(j.type=F.enums===String?G.onnx.AttributeProto.AttributeType[b.type]:b.type),b.refAttrName!=null&&b.hasOwnProperty("refAttrName")&&(j.refAttrName=b.refAttrName),j},O.prototype.toJSON=function(){return this.constructor.toObject(this,K.util.toJSONOptions)},O.AttributeType=function(){var b={},F=Object.create(b);return F[b[0]="UNDEFINED"]=0,F[b[1]="FLOAT"]=1,F[b[2]="INT"]=2,F[b[3]="STRING"]=3,F[b[4]="TENSOR"]=4,F[b[5]="GRAPH"]=5,F[b[6]="FLOATS"]=6,F[b[7]="INTS"]=7,F[b[8]="STRINGS"]=8,F[b[9]="TENSORS"]=9,F[b[10]="GRAPHS"]=10,F}(),O}(),nt.ValueInfoProto=function(){function O(b){if(b)for(var F=Object.keys(b),j=0;j<F.length;++j)b[F[j]]!=null&&(this[F[j]]=b[F[j]])}return O.prototype.name="",O.prototype.type=null,O.prototype.docString="",O.create=function(b){return new O(b)},O.encode=function(b,F){return F||(F=Q.create()),b.name!=null&&b.hasOwnProperty("name")&&F.uint32(10).string(b.name),b.type!=null&&b.hasOwnProperty("type")&&G.onnx.TypeProto.encode(b.type,F.uint32(18).fork()).ldelim(),b.docString!=null&&b.hasOwnProperty("docString")&&F.uint32(26).string(b.docString),F},O.encodeDelimited=function(b,F){return this.encode(b,F).ldelim()},O.decode=function(b,F){b instanceof X||(b=X.create(b));for(var j=F===void 0?b.len:b.pos+F,W=new G.onnx.ValueInfoProto;b.pos<j;){var J=b.uint32();switch(J>>>3){case 1:W.name=b.string();break;case 2:W.type=G.onnx.TypeProto.decode(b,b.uint32());break;case 3:W.docString=b.string();break;default:b.skipType(7&J)}}return W},O.decodeDelimited=function(b){return b instanceof X||(b=new X(b)),this.decode(b,b.uint32())},O.verify=function(b){if(typeof b!="object"||b===null)return"object expected";if(b.name!=null&&b.hasOwnProperty("name")&&!q.isString(b.name))return"name: string expected";if(b.type!=null&&b.hasOwnProperty("type")){var F=G.onnx.TypeProto.verify(b.type);if(F)return"type."+F}return b.docString!=null&&b.hasOwnProperty("docString")&&!q.isString(b.docString)?"docString: string expected":null},O.fromObject=function(b){if(b instanceof G.onnx.ValueInfoProto)return b;var F=new G.onnx.ValueInfoProto;if(b.name!=null&&(F.name=String(b.name)),b.type!=null){if(typeof b.type!="object")throw TypeError(".onnx.ValueInfoProto.type: object expected");F.type=G.onnx.TypeProto.fromObject(b.type)}return b.docString!=null&&(F.docString=String(b.docString)),F},O.toObject=function(b,F){F||(F={});var j={};return F.defaults&&(j.name="",j.type=null,j.docString=""),b.name!=null&&b.hasOwnProperty("name")&&(j.name=b.name),b.type!=null&&b.hasOwnProperty("type")&&(j.type=G.onnx.TypeProto.toObject(b.type,F)),b.docString!=null&&b.hasOwnProperty("docString")&&(j.docString=b.docString),j},O.prototype.toJSON=function(){return this.constructor.toObject(this,K.util.toJSONOptions)},O}(),nt.NodeProto=function(){function O(b){if(this.input=[],this.output=[],this.attribute=[],b)for(var F=Object.keys(b),j=0;j<F.length;++j)b[F[j]]!=null&&(this[F[j]]=b[F[j]])}return O.prototype.input=q.emptyArray,O.prototype.output=q.emptyArray,O.prototype.name="",O.prototype.opType="",O.prototype.domain="",O.prototype.attribute=q.emptyArray,O.prototype.docString="",O.create=function(b){return new O(b)},O.encode=function(b,F){if(F||(F=Q.create()),b.input!=null&&b.input.length)for(var j=0;j<b.input.length;++j)F.uint32(10).string(b.input[j]);if(b.output!=null&&b.output.length)for(j=0;j<b.output.length;++j)F.uint32(18).string(b.output[j]);if(b.name!=null&&b.hasOwnProperty("name")&&F.uint32(26).string(b.name),b.opType!=null&&b.hasOwnProperty("opType")&&F.uint32(34).string(b.opType),b.attribute!=null&&b.attribute.length)for(j=0;j<b.attribute.length;++j)G.onnx.AttributeProto.encode(b.attribute[j],F.uint32(42).fork()).ldelim();return b.docString!=null&&b.hasOwnProperty("docString")&&F.uint32(50).string(b.docString),b.domain!=null&&b.hasOwnProperty("domain")&&F.uint32(58).string(b.domain),F},O.encodeDelimited=function(b,F){return this.encode(b,F).ldelim()},O.decode=function(b,F){b instanceof X||(b=X.create(b));for(var j=F===void 0?b.len:b.pos+F,W=new G.onnx.NodeProto;b.pos<j;){var J=b.uint32();switch(J>>>3){case 1:W.input&&W.input.length||(W.input=[]),W.input.push(b.string());break;case 2:W.output&&W.output.length||(W.output=[]),W.output.push(b.string());break;case 3:W.name=b.string();break;case 4:W.opType=b.string();break;case 7:W.domain=b.string();break;case 5:W.attribute&&W.attribute.length||(W.attribute=[]),W.attribute.push(G.onnx.AttributeProto.decode(b,b.uint32()));break;case 6:W.docString=b.string();break;default:b.skipType(7&J)}}return W},O.decodeDelimited=function(b){return b instanceof X||(b=new X(b)),this.decode(b,b.uint32())},O.verify=function(b){if(typeof b!="object"||b===null)return"object expected";if(b.input!=null&&b.hasOwnProperty("input")){if(!Array.isArray(b.input))return"input: array expected";for(var F=0;F<b.input.length;++F)if(!q.isString(b.input[F]))return"input: string[] expected"}if(b.output!=null&&b.hasOwnProperty("output")){if(!Array.isArray(b.output))return"output: array expected";for(F=0;F<b.output.length;++F)if(!q.isString(b.output[F]))return"output: string[] expected"}if(b.name!=null&&b.hasOwnProperty("name")&&!q.isString(b.name))return"name: string expected";if(b.opType!=null&&b.hasOwnProperty("opType")&&!q.isString(b.opType))return"opType: string expected";if(b.domain!=null&&b.hasOwnProperty("domain")&&!q.isString(b.domain))return"domain: string expected";if(b.attribute!=null&&b.hasOwnProperty("attribute")){if(!Array.isArray(b.attribute))return"attribute: array expected";for(F=0;F<b.attribute.length;++F){var j=G.onnx.AttributeProto.verify(b.attribute[F]);if(j)return"attribute."+j}}return b.docString!=null&&b.hasOwnProperty("docString")&&!q.isString(b.docString)?"docString: string expected":null},O.fromObject=function(b){if(b instanceof G.onnx.NodeProto)return b;var F=new G.onnx.NodeProto;if(b.input){if(!Array.isArray(b.input))throw TypeError(".onnx.NodeProto.input: array expected");F.input=[];for(var j=0;j<b.input.length;++j)F.input[j]=String(b.input[j])}if(b.output){if(!Array.isArray(b.output))throw TypeError(".onnx.NodeProto.output: array expected");for(F.output=[],j=0;j<b.output.length;++j)F.output[j]=String(b.output[j])}if(b.name!=null&&(F.name=String(b.name)),b.opType!=null&&(F.opType=String(b.opType)),b.domain!=null&&(F.domain=String(b.domain)),b.attribute){if(!Array.isArray(b.attribute))throw TypeError(".onnx.NodeProto.attribute: array expected");for(F.attribute=[],j=0;j<b.attribute.length;++j){if(typeof b.attribute[j]!="object")throw TypeError(".onnx.NodeProto.attribute: object expected");F.attribute[j]=G.onnx.AttributeProto.fromObject(b.attribute[j])}}return b.docString!=null&&(F.docString=String(b.docString)),F},O.toObject=function(b,F){F||(F={});var j={};if((F.arrays||F.defaults)&&(j.input=[],j.output=[],j.attribute=[]),F.defaults&&(j.name="",j.opType="",j.docString="",j.domain=""),b.input&&b.input.length){j.input=[];for(var W=0;W<b.input.length;++W)j.input[W]=b.input[W]}if(b.output&&b.output.length)for(j.output=[],W=0;W<b.output.length;++W)j.output[W]=b.output[W];if(b.name!=null&&b.hasOwnProperty("name")&&(j.name=b.name),b.opType!=null&&b.hasOwnProperty("opType")&&(j.opType=b.opType),b.attribute&&b.attribute.length)for(j.attribute=[],W=0;W<b.attribute.length;++W)j.attribute[W]=G.onnx.AttributeProto.toObject(b.attribute[W],F);return b.docString!=null&&b.hasOwnProperty("docString")&&(j.docString=b.docString),b.domain!=null&&b.hasOwnProperty("domain")&&(j.domain=b.domain),j},O.prototype.toJSON=function(){return this.constructor.toObject(this,K.util.toJSONOptions)},O}(),nt.ModelProto=function(){function O(b){if(this.opsetImport=[],this.metadataProps=[],b)for(var F=Object.keys(b),j=0;j<F.length;++j)b[F[j]]!=null&&(this[F[j]]=b[F[j]])}return O.prototype.irVersion=q.Long?q.Long.fromBits(0,0,!1):0,O.prototype.opsetImport=q.emptyArray,O.prototype.producerName="",O.prototype.producerVersion="",O.prototype.domain="",O.prototype.modelVersion=q.Long?q.Long.fromBits(0,0,!1):0,O.prototype.docString="",O.prototype.graph=null,O.prototype.metadataProps=q.emptyArray,O.create=function(b){return new O(b)},O.encode=function(b,F){if(F||(F=Q.create()),b.irVersion!=null&&b.hasOwnProperty("irVersion")&&F.uint32(8).int64(b.irVersion),b.producerName!=null&&b.hasOwnProperty("producerName")&&F.uint32(18).string(b.producerName),b.producerVersion!=null&&b.hasOwnProperty("producerVersion")&&F.uint32(26).string(b.producerVersion),b.domain!=null&&b.hasOwnProperty("domain")&&F.uint32(34).string(b.domain),b.modelVersion!=null&&b.hasOwnProperty("modelVersion")&&F.uint32(40).int64(b.modelVersion),b.docString!=null&&b.hasOwnProperty("docString")&&F.uint32(50).string(b.docString),b.graph!=null&&b.hasOwnProperty("graph")&&G.onnx.GraphProto.encode(b.graph,F.uint32(58).fork()).ldelim(),b.opsetImport!=null&&b.opsetImport.length)for(var j=0;j<b.opsetImport.length;++j)G.onnx.OperatorSetIdProto.encode(b.opsetImport[j],F.uint32(66).fork()).ldelim();if(b.metadataProps!=null&&b.metadataProps.length)for(j=0;j<b.metadataProps.length;++j)G.onnx.StringStringEntryProto.encode(b.metadataProps[j],F.uint32(114).fork()).ldelim();return F},O.encodeDelimited=function(b,F){return this.encode(b,F).ldelim()},O.decode=function(b,F){b instanceof X||(b=X.create(b));for(var j=F===void 0?b.len:b.pos+F,W=new G.onnx.ModelProto;b.pos<j;){var J=b.uint32();switch(J>>>3){case 1:W.irVersion=b.int64();break;case 8:W.opsetImport&&W.opsetImport.length||(W.opsetImport=[]),W.opsetImport.push(G.onnx.OperatorSetIdProto.decode(b,b.uint32()));break;case 2:W.producerName=b.string();break;case 3:W.producerVersion=b.string();break;case 4:W.domain=b.string();break;case 5:W.modelVersion=b.int64();break;case 6:W.docString=b.string();break;case 7:W.graph=G.onnx.GraphProto.decode(b,b.uint32());break;case 14:W.metadataProps&&W.metadataProps.length||(W.metadataProps=[]),W.metadataProps.push(G.onnx.StringStringEntryProto.decode(b,b.uint32()));break;default:b.skipType(7&J)}}return W},O.decodeDelimited=function(b){return b instanceof X||(b=new X(b)),this.decode(b,b.uint32())},O.verify=function(b){if(typeof b!="object"||b===null)return"object expected";if(b.irVersion!=null&&b.hasOwnProperty("irVersion")&&!(q.isInteger(b.irVersion)||b.irVersion&&q.isInteger(b.irVersion.low)&&q.isInteger(b.irVersion.high)))return"irVersion: integer|Long expected";if(b.opsetImport!=null&&b.hasOwnProperty("opsetImport")){if(!Array.isArray(b.opsetImport))return"opsetImport: array expected";for(var F=0;F<b.opsetImport.length;++F)if(j=G.onnx.OperatorSetIdProto.verify(b.opsetImport[F]))return"opsetImport."+j}if(b.producerName!=null&&b.hasOwnProperty("producerName")&&!q.isString(b.producerName))return"producerName: string expected";if(b.producerVersion!=null&&b.hasOwnProperty("producerVersion")&&!q.isString(b.producerVersion))return"producerVersion: string expected";if(b.domain!=null&&b.hasOwnProperty("domain")&&!q.isString(b.domain))return"domain: string expected";if(b.modelVersion!=null&&b.hasOwnProperty("modelVersion")&&!(q.isInteger(b.modelVersion)||b.modelVersion&&q.isInteger(b.modelVersion.low)&&q.isInteger(b.modelVersion.high)))return"modelVersion: integer|Long expected";if(b.docString!=null&&b.hasOwnProperty("docString")&&!q.isString(b.docString))return"docString: string expected";if(b.graph!=null&&b.hasOwnProperty("graph")&&(j=G.onnx.GraphProto.verify(b.graph)))return"graph."+j;if(b.metadataProps!=null&&b.hasOwnProperty("metadataProps")){if(!Array.isArray(b.metadataProps))return"metadataProps: array expected";for(F=0;F<b.metadataProps.length;++F){var j;if(j=G.onnx.StringStringEntryProto.verify(b.metadataProps[F]))return"metadataProps."+j}}return null},O.fromObject=function(b){if(b instanceof G.onnx.ModelProto)return b;var F=new G.onnx.ModelProto;if(b.irVersion!=null&&(q.Long?(F.irVersion=q.Long.fromValue(b.irVersion)).unsigned=!1:typeof b.irVersion=="string"?F.irVersion=parseInt(b.irVersion,10):typeof b.irVersion=="number"?F.irVersion=b.irVersion:typeof b.irVersion=="object"&&(F.irVersion=new q.LongBits(b.irVersion.low>>>0,b.irVersion.high>>>0).toNumber())),b.opsetImport){if(!Array.isArray(b.opsetImport))throw TypeError(".onnx.ModelProto.opsetImport: array expected");F.opsetImport=[];for(var j=0;j<b.opsetImport.length;++j){if(typeof b.opsetImport[j]!="object")throw TypeError(".onnx.ModelProto.opsetImport: object expected");F.opsetImport[j]=G.onnx.OperatorSetIdProto.fromObject(b.opsetImport[j])}}if(b.producerName!=null&&(F.producerName=String(b.producerName)),b.producerVersion!=null&&(F.producerVersion=String(b.producerVersion)),b.domain!=null&&(F.domain=String(b.domain)),b.modelVersion!=null&&(q.Long?(F.modelVersion=q.Long.fromValue(b.modelVersion)).unsigned=!1:typeof b.modelVersion=="string"?F.modelVersion=parseInt(b.modelVersion,10):typeof b.modelVersion=="number"?F.modelVersion=b.modelVersion:typeof b.modelVersion=="object"&&(F.modelVersion=new q.LongBits(b.modelVersion.low>>>0,b.modelVersion.high>>>0).toNumber())),b.docString!=null&&(F.docString=String(b.docString)),b.graph!=null){if(typeof b.graph!="object")throw TypeError(".onnx.ModelProto.graph: object expected");F.graph=G.onnx.GraphProto.fromObject(b.graph)}if(b.metadataProps){if(!Array.isArray(b.metadataProps))throw TypeError(".onnx.ModelProto.metadataProps: array expected");for(F.metadataProps=[],j=0;j<b.metadataProps.length;++j){if(typeof b.metadataProps[j]!="object")throw TypeError(".onnx.ModelProto.metadataProps: object expected");F.metadataProps[j]=G.onnx.StringStringEntryProto.fromObject(b.metadataProps[j])}}return F},O.toObject=function(b,F){F||(F={});var j={};if((F.arrays||F.defaults)&&(j.opsetImport=[],j.metadataProps=[]),F.defaults){if(q.Long){var W=new q.Long(0,0,!1);j.irVersion=F.longs===String?W.toString():F.longs===Number?W.toNumber():W}else j.irVersion=F.longs===String?"0":0;j.producerName="",j.producerVersion="",j.domain="",q.Long?(W=new q.Long(0,0,!1),j.modelVersion=F.longs===String?W.toString():F.longs===Number?W.toNumber():W):j.modelVersion=F.longs===String?"0":0,j.docString="",j.graph=null}if(b.irVersion!=null&&b.hasOwnProperty("irVersion")&&(typeof b.irVersion=="number"?j.irVersion=F.longs===String?String(b.irVersion):b.irVersion:j.irVersion=F.longs===String?q.Long.prototype.toString.call(b.irVersion):F.longs===Number?new q.LongBits(b.irVersion.low>>>0,b.irVersion.high>>>0).toNumber():b.irVersion),b.producerName!=null&&b.hasOwnProperty("producerName")&&(j.producerName=b.producerName),b.producerVersion!=null&&b.hasOwnProperty("producerVersion")&&(j.producerVersion=b.producerVersion),b.domain!=null&&b.hasOwnProperty("domain")&&(j.domain=b.domain),b.modelVersion!=null&&b.hasOwnProperty("modelVersion")&&(typeof b.modelVersion=="number"?j.modelVersion=F.longs===String?String(b.modelVersion):b.modelVersion:j.modelVersion=F.longs===String?q.Long.prototype.toString.call(b.modelVersion):F.longs===Number?new q.LongBits(b.modelVersion.low>>>0,b.modelVersion.high>>>0).toNumber():b.modelVersion),b.docString!=null&&b.hasOwnProperty("docString")&&(j.docString=b.docString),b.graph!=null&&b.hasOwnProperty("graph")&&(j.graph=G.onnx.GraphProto.toObject(b.graph,F)),b.opsetImport&&b.opsetImport.length){j.opsetImport=[];for(var J=0;J<b.opsetImport.length;++J)j.opsetImport[J]=G.onnx.OperatorSetIdProto.toObject(b.opsetImport[J],F)}if(b.metadataProps&&b.metadataProps.length)for(j.metadataProps=[],J=0;J<b.metadataProps.length;++J)j.metadataProps[J]=G.onnx.StringStringEntryProto.toObject(b.metadataProps[J],F);return j},O.prototype.toJSON=function(){return this.constructor.toObject(this,K.util.toJSONOptions)},O}(),nt.StringStringEntryProto=function(){function O(b){if(b)for(var F=Object.keys(b),j=0;j<F.length;++j)b[F[j]]!=null&&(this[F[j]]=b[F[j]])}return O.prototype.key="",O.prototype.value="",O.create=function(b){return new O(b)},O.encode=function(b,F){return F||(F=Q.create()),b.key!=null&&b.hasOwnProperty("key")&&F.uint32(10).string(b.key),b.value!=null&&b.hasOwnProperty("value")&&F.uint32(18).string(b.value),F},O.encodeDelimited=function(b,F){return this.encode(b,F).ldelim()},O.decode=function(b,F){b instanceof X||(b=X.create(b));for(var j=F===void 0?b.len:b.pos+F,W=new G.onnx.StringStringEntryProto;b.pos<j;){var J=b.uint32();switch(J>>>3){case 1:W.key=b.string();break;case 2:W.value=b.string();break;default:b.skipType(7&J)}}return W},O.decodeDelimited=function(b){return b instanceof X||(b=new X(b)),this.decode(b,b.uint32())},O.verify=function(b){return typeof b!="object"||b===null?"object expected":b.key!=null&&b.hasOwnProperty("key")&&!q.isString(b.key)?"key: string expected":b.value!=null&&b.hasOwnProperty("value")&&!q.isString(b.value)?"value: string expected":null},O.fromObject=function(b){if(b instanceof G.onnx.StringStringEntryProto)return b;var F=new G.onnx.StringStringEntryProto;return b.key!=null&&(F.key=String(b.key)),b.value!=null&&(F.value=String(b.value)),F},O.toObject=function(b,F){F||(F={});var j={};return F.defaults&&(j.key="",j.value=""),b.key!=null&&b.hasOwnProperty("key")&&(j.key=b.key),b.value!=null&&b.hasOwnProperty("value")&&(j.value=b.value),j},O.prototype.toJSON=function(){return this.constructor.toObject(this,K.util.toJSONOptions)},O}(),nt.TensorAnnotation=function(){function O(b){if(this.quantParameterTensorNames=[],b)for(var F=Object.keys(b),j=0;j<F.length;++j)b[F[j]]!=null&&(this[F[j]]=b[F[j]])}return O.prototype.tensorName="",O.prototype.quantParameterTensorNames=q.emptyArray,O.create=function(b){return new O(b)},O.encode=function(b,F){if(F||(F=Q.create()),b.tensorName!=null&&b.hasOwnProperty("tensorName")&&F.uint32(10).string(b.tensorName),b.quantParameterTensorNames!=null&&b.quantParameterTensorNames.length)for(var j=0;j<b.quantParameterTensorNames.length;++j)G.onnx.StringStringEntryProto.encode(b.quantParameterTensorNames[j],F.uint32(18).fork()).ldelim();return F},O.encodeDelimited=function(b,F){return this.encode(b,F).ldelim()},O.decode=function(b,F){b instanceof X||(b=X.create(b));for(var j=F===void 0?b.len:b.pos+F,W=new G.onnx.TensorAnnotation;b.pos<j;){var J=b.uint32();switch(J>>>3){case 1:W.tensorName=b.string();break;case 2:W.quantParameterTensorNames&&W.quantParameterTensorNames.length||(W.quantParameterTensorNames=[]),W.quantParameterTensorNames.push(G.onnx.StringStringEntryProto.decode(b,b.uint32()));break;default:b.skipType(7&J)}}return W},O.decodeDelimited=function(b){return b instanceof X||(b=new X(b)),this.decode(b,b.uint32())},O.verify=function(b){if(typeof b!="object"||b===null)return"object expected";if(b.tensorName!=null&&b.hasOwnProperty("tensorName")&&!q.isString(b.tensorName))return"tensorName: string expected";if(b.quantParameterTensorNames!=null&&b.hasOwnProperty("quantParameterTensorNames")){if(!Array.isArray(b.quantParameterTensorNames))return"quantParameterTensorNames: array expected";for(var F=0;F<b.quantParameterTensorNames.length;++F){var j=G.onnx.StringStringEntryProto.verify(b.quantParameterTensorNames[F]);if(j)return"quantParameterTensorNames."+j}}return null},O.fromObject=function(b){if(b instanceof G.onnx.TensorAnnotation)return b;var F=new G.onnx.TensorAnnotation;if(b.tensorName!=null&&(F.tensorName=String(b.tensorName)),b.quantParameterTensorNames){if(!Array.isArray(b.quantParameterTensorNames))throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");F.quantParameterTensorNames=[];for(var j=0;j<b.quantParameterTensorNames.length;++j){if(typeof b.quantParameterTensorNames[j]!="object")throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");F.quantParameterTensorNames[j]=G.onnx.StringStringEntryProto.fromObject(b.quantParameterTensorNames[j])}}return F},O.toObject=function(b,F){F||(F={});var j={};if((F.arrays||F.defaults)&&(j.quantParameterTensorNames=[]),F.defaults&&(j.tensorName=""),b.tensorName!=null&&b.hasOwnProperty("tensorName")&&(j.tensorName=b.tensorName),b.quantParameterTensorNames&&b.quantParameterTensorNames.length){j.quantParameterTensorNames=[];for(var W=0;W<b.quantParameterTensorNames.length;++W)j.quantParameterTensorNames[W]=G.onnx.StringStringEntryProto.toObject(b.quantParameterTensorNames[W],F)}return j},O.prototype.toJSON=function(){return this.constructor.toObject(this,K.util.toJSONOptions)},O}(),nt.GraphProto=function(){function O(b){if(this.node=[],this.initializer=[],this.input=[],this.output=[],this.valueInfo=[],this.quantizationAnnotation=[],b)for(var F=Object.keys(b),j=0;j<F.length;++j)b[F[j]]!=null&&(this[F[j]]=b[F[j]])}return O.prototype.node=q.emptyArray,O.prototype.name="",O.prototype.initializer=q.emptyArray,O.prototype.docString="",O.prototype.input=q.emptyArray,O.prototype.output=q.emptyArray,O.prototype.valueInfo=q.emptyArray,O.prototype.quantizationAnnotation=q.emptyArray,O.create=function(b){return new O(b)},O.encode=function(b,F){if(F||(F=Q.create()),b.node!=null&&b.node.length)for(var j=0;j<b.node.length;++j)G.onnx.NodeProto.encode(b.node[j],F.uint32(10).fork()).ldelim();if(b.name!=null&&b.hasOwnProperty("name")&&F.uint32(18).string(b.name),b.initializer!=null&&b.initializer.length)for(j=0;j<b.initializer.length;++j)G.onnx.TensorProto.encode(b.initializer[j],F.uint32(42).fork()).ldelim();if(b.docString!=null&&b.hasOwnProperty("docString")&&F.uint32(82).string(b.docString),b.input!=null&&b.input.length)for(j=0;j<b.input.length;++j)G.onnx.ValueInfoProto.encode(b.input[j],F.uint32(90).fork()).ldelim();if(b.output!=null&&b.output.length)for(j=0;j<b.output.length;++j)G.onnx.ValueInfoProto.encode(b.output[j],F.uint32(98).fork()).ldelim();if(b.valueInfo!=null&&b.valueInfo.length)for(j=0;j<b.valueInfo.length;++j)G.onnx.ValueInfoProto.encode(b.valueInfo[j],F.uint32(106).fork()).ldelim();if(b.quantizationAnnotation!=null&&b.quantizationAnnotation.length)for(j=0;j<b.quantizationAnnotation.length;++j)G.onnx.TensorAnnotation.encode(b.quantizationAnnotation[j],F.uint32(114).fork()).ldelim();return F},O.encodeDelimited=function(b,F){return this.encode(b,F).ldelim()},O.decode=function(b,F){b instanceof X||(b=X.create(b));for(var j=F===void 0?b.len:b.pos+F,W=new G.onnx.GraphProto;b.pos<j;){var J=b.uint32();switch(J>>>3){case 1:W.node&&W.node.length||(W.node=[]),W.node.push(G.onnx.NodeProto.decode(b,b.uint32()));break;case 2:W.name=b.string();break;case 5:W.initializer&&W.initializer.length||(W.initializer=[]),W.initializer.push(G.onnx.TensorProto.decode(b,b.uint32()));break;case 10:W.docString=b.string();break;case 11:W.input&&W.input.length||(W.input=[]),W.input.push(G.onnx.ValueInfoProto.decode(b,b.uint32()));break;case 12:W.output&&W.output.length||(W.output=[]),W.output.push(G.onnx.ValueInfoProto.decode(b,b.uint32()));break;case 13:W.valueInfo&&W.valueInfo.length||(W.valueInfo=[]),W.valueInfo.push(G.onnx.ValueInfoProto.decode(b,b.uint32()));break;case 14:W.quantizationAnnotation&&W.quantizationAnnotation.length||(W.quantizationAnnotation=[]),W.quantizationAnnotation.push(G.onnx.TensorAnnotation.decode(b,b.uint32()));break;default:b.skipType(7&J)}}return W},O.decodeDelimited=function(b){return b instanceof X||(b=new X(b)),this.decode(b,b.uint32())},O.verify=function(b){if(typeof b!="object"||b===null)return"object expected";if(b.node!=null&&b.hasOwnProperty("node")){if(!Array.isArray(b.node))return"node: array expected";for(var F=0;F<b.node.length;++F)if(j=G.onnx.NodeProto.verify(b.node[F]))return"node."+j}if(b.name!=null&&b.hasOwnProperty("name")&&!q.isString(b.name))return"name: string expected";if(b.initializer!=null&&b.hasOwnProperty("initializer")){if(!Array.isArray(b.initializer))return"initializer: array expected";for(F=0;F<b.initializer.length;++F)if(j=G.onnx.TensorProto.verify(b.initializer[F]))return"initializer."+j}if(b.docString!=null&&b.hasOwnProperty("docString")&&!q.isString(b.docString))return"docString: string expected";if(b.input!=null&&b.hasOwnProperty("input")){if(!Array.isArray(b.input))return"input: array expected";for(F=0;F<b.input.length;++F)if(j=G.onnx.ValueInfoProto.verify(b.input[F]))return"input."+j}if(b.output!=null&&b.hasOwnProperty("output")){if(!Array.isArray(b.output))return"output: array expected";for(F=0;F<b.output.length;++F)if(j=G.onnx.ValueInfoProto.verify(b.output[F]))return"output."+j}if(b.valueInfo!=null&&b.hasOwnProperty("valueInfo")){if(!Array.isArray(b.valueInfo))return"valueInfo: array expected";for(F=0;F<b.valueInfo.length;++F)if(j=G.onnx.ValueInfoProto.verify(b.valueInfo[F]))return"valueInfo."+j}if(b.quantizationAnnotation!=null&&b.hasOwnProperty("quantizationAnnotation")){if(!Array.isArray(b.quantizationAnnotation))return"quantizationAnnotation: array expected";for(F=0;F<b.quantizationAnnotation.length;++F){var j;if(j=G.onnx.TensorAnnotation.verify(b.quantizationAnnotation[F]))return"quantizationAnnotation."+j}}return null},O.fromObject=function(b){if(b instanceof G.onnx.GraphProto)return b;var F=new G.onnx.GraphProto;if(b.node){if(!Array.isArray(b.node))throw TypeError(".onnx.GraphProto.node: array expected");F.node=[];for(var j=0;j<b.node.length;++j){if(typeof b.node[j]!="object")throw TypeError(".onnx.GraphProto.node: object expected");F.node[j]=G.onnx.NodeProto.fromObject(b.node[j])}}if(b.name!=null&&(F.name=String(b.name)),b.initializer){if(!Array.isArray(b.initializer))throw TypeError(".onnx.GraphProto.initializer: array expected");for(F.initializer=[],j=0;j<b.initializer.length;++j){if(typeof b.initializer[j]!="object")throw TypeError(".onnx.GraphProto.initializer: object expected");F.initializer[j]=G.onnx.TensorProto.fromObject(b.initializer[j])}}if(b.docString!=null&&(F.docString=String(b.docString)),b.input){if(!Array.isArray(b.input))throw TypeError(".onnx.GraphProto.input: array expected");for(F.input=[],j=0;j<b.input.length;++j){if(typeof b.input[j]!="object")throw TypeError(".onnx.GraphProto.input: object expected");F.input[j]=G.onnx.ValueInfoProto.fromObject(b.input[j])}}if(b.output){if(!Array.isArray(b.output))throw TypeError(".onnx.GraphProto.output: array expected");for(F.output=[],j=0;j<b.output.length;++j){if(typeof b.output[j]!="object")throw TypeError(".onnx.GraphProto.output: object expected");F.output[j]=G.onnx.ValueInfoProto.fromObject(b.output[j])}}if(b.valueInfo){if(!Array.isArray(b.valueInfo))throw TypeError(".onnx.GraphProto.valueInfo: array expected");for(F.valueInfo=[],j=0;j<b.valueInfo.length;++j){if(typeof b.valueInfo[j]!="object")throw TypeError(".onnx.GraphProto.valueInfo: object expected");F.valueInfo[j]=G.onnx.ValueInfoProto.fromObject(b.valueInfo[j])}}if(b.quantizationAnnotation){if(!Array.isArray(b.quantizationAnnotation))throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");for(F.quantizationAnnotation=[],j=0;j<b.quantizationAnnotation.length;++j){if(typeof b.quantizationAnnotation[j]!="object")throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");F.quantizationAnnotation[j]=G.onnx.TensorAnnotation.fromObject(b.quantizationAnnotation[j])}}return F},O.toObject=function(b,F){F||(F={});var j={};if((F.arrays||F.defaults)&&(j.node=[],j.initializer=[],j.input=[],j.output=[],j.valueInfo=[],j.quantizationAnnotation=[]),F.defaults&&(j.name="",j.docString=""),b.node&&b.node.length){j.node=[];for(var W=0;W<b.node.length;++W)j.node[W]=G.onnx.NodeProto.toObject(b.node[W],F)}if(b.name!=null&&b.hasOwnProperty("name")&&(j.name=b.name),b.initializer&&b.initializer.length)for(j.initializer=[],W=0;W<b.initializer.length;++W)j.initializer[W]=G.onnx.TensorProto.toObject(b.initializer[W],F);if(b.docString!=null&&b.hasOwnProperty("docString")&&(j.docString=b.docString),b.input&&b.input.length)for(j.input=[],W=0;W<b.input.length;++W)j.input[W]=G.onnx.ValueInfoProto.toObject(b.input[W],F);if(b.output&&b.output.length)for(j.output=[],W=0;W<b.output.length;++W)j.output[W]=G.onnx.ValueInfoProto.toObject(b.output[W],F);if(b.valueInfo&&b.valueInfo.length)for(j.valueInfo=[],W=0;W<b.valueInfo.length;++W)j.valueInfo[W]=G.onnx.ValueInfoProto.toObject(b.valueInfo[W],F);if(b.quantizationAnnotation&&b.quantizationAnnotation.length)for(j.quantizationAnnotation=[],W=0;W<b.quantizationAnnotation.length;++W)j.quantizationAnnotation[W]=G.onnx.TensorAnnotation.toObject(b.quantizationAnnotation[W],F);return j},O.prototype.toJSON=function(){return this.constructor.toObject(this,K.util.toJSONOptions)},O}(),nt.TensorProto=function(){function O(b){if(this.dims=[],this.floatData=[],this.int32Data=[],this.stringData=[],this.int64Data=[],this.externalData=[],this.doubleData=[],this.uint64Data=[],b)for(var F=Object.keys(b),j=0;j<F.length;++j)b[F[j]]!=null&&(this[F[j]]=b[F[j]])}return O.prototype.dims=q.emptyArray,O.prototype.dataType=0,O.prototype.segment=null,O.prototype.floatData=q.emptyArray,O.prototype.int32Data=q.emptyArray,O.prototype.stringData=q.emptyArray,O.prototype.int64Data=q.emptyArray,O.prototype.name="",O.prototype.docString="",O.prototype.rawData=q.newBuffer([]),O.prototype.externalData=q.emptyArray,O.prototype.dataLocation=0,O.prototype.doubleData=q.emptyArray,O.prototype.uint64Data=q.emptyArray,O.create=function(b){return new O(b)},O.encode=function(b,F){if(F||(F=Q.create()),b.dims!=null&&b.dims.length){F.uint32(10).fork();for(var j=0;j<b.dims.length;++j)F.int64(b.dims[j]);F.ldelim()}if(b.dataType!=null&&b.hasOwnProperty("dataType")&&F.uint32(16).int32(b.dataType),b.segment!=null&&b.hasOwnProperty("segment")&&G.onnx.TensorProto.Segment.encode(b.segment,F.uint32(26).fork()).ldelim(),b.floatData!=null&&b.floatData.length){for(F.uint32(34).fork(),j=0;j<b.floatData.length;++j)F.float(b.floatData[j]);F.ldelim()}if(b.int32Data!=null&&b.int32Data.length){for(F.uint32(42).fork(),j=0;j<b.int32Data.length;++j)F.int32(b.int32Data[j]);F.ldelim()}if(b.stringData!=null&&b.stringData.length)for(j=0;j<b.stringData.length;++j)F.uint32(50).bytes(b.stringData[j]);if(b.int64Data!=null&&b.int64Data.length){for(F.uint32(58).fork(),j=0;j<b.int64Data.length;++j)F.int64(b.int64Data[j]);F.ldelim()}if(b.name!=null&&b.hasOwnProperty("name")&&F.uint32(66).string(b.name),b.rawData!=null&&b.hasOwnProperty("rawData")&&F.uint32(74).bytes(b.rawData),b.doubleData!=null&&b.doubleData.length){for(F.uint32(82).fork(),j=0;j<b.doubleData.length;++j)F.double(b.doubleData[j]);F.ldelim()}if(b.uint64Data!=null&&b.uint64Data.length){for(F.uint32(90).fork(),j=0;j<b.uint64Data.length;++j)F.uint64(b.uint64Data[j]);F.ldelim()}if(b.docString!=null&&b.hasOwnProperty("docString")&&F.uint32(98).string(b.docString),b.externalData!=null&&b.externalData.length)for(j=0;j<b.externalData.length;++j)G.onnx.StringStringEntryProto.encode(b.externalData[j],F.uint32(106).fork()).ldelim();return b.dataLocation!=null&&b.hasOwnProperty("dataLocation")&&F.uint32(112).int32(b.dataLocation),F},O.encodeDelimited=function(b,F){return this.encode(b,F).ldelim()},O.decode=function(b,F){b instanceof X||(b=X.create(b));for(var j=F===void 0?b.len:b.pos+F,W=new G.onnx.TensorProto;b.pos<j;){var J=b.uint32();switch(J>>>3){case 1:if(W.dims&&W.dims.length||(W.dims=[]),(7&J)==2)for(var et=b.uint32()+b.pos;b.pos<et;)W.dims.push(b.int64());else W.dims.push(b.int64());break;case 2:W.dataType=b.int32();break;case 3:W.segment=G.onnx.TensorProto.Segment.decode(b,b.uint32());break;case 4:if(W.floatData&&W.floatData.length||(W.floatData=[]),(7&J)==2)for(et=b.uint32()+b.pos;b.pos<et;)W.floatData.push(b.float());else W.floatData.push(b.float());break;case 5:if(W.int32Data&&W.int32Data.length||(W.int32Data=[]),(7&J)==2)for(et=b.uint32()+b.pos;b.pos<et;)W.int32Data.push(b.int32());else W.int32Data.push(b.int32());break;case 6:W.stringData&&W.stringData.length||(W.stringData=[]),W.stringData.push(b.bytes());break;case 7:if(W.int64Data&&W.int64Data.length||(W.int64Data=[]),(7&J)==2)for(et=b.uint32()+b.pos;b.pos<et;)W.int64Data.push(b.int64());else W.int64Data.push(b.int64());break;case 8:W.name=b.string();break;case 12:W.docString=b.string();break;case 9:W.rawData=b.bytes();break;case 13:W.externalData&&W.externalData.length||(W.externalData=[]),W.externalData.push(G.onnx.StringStringEntryProto.decode(b,b.uint32()));break;case 14:W.dataLocation=b.int32();break;case 10:if(W.doubleData&&W.doubleData.length||(W.doubleData=[]),(7&J)==2)for(et=b.uint32()+b.pos;b.pos<et;)W.doubleData.push(b.double());else W.doubleData.push(b.double());break;case 11:if(W.uint64Data&&W.uint64Data.length||(W.uint64Data=[]),(7&J)==2)for(et=b.uint32()+b.pos;b.pos<et;)W.uint64Data.push(b.uint64());else W.uint64Data.push(b.uint64());break;default:b.skipType(7&J)}}return W},O.decodeDelimited=function(b){return b instanceof X||(b=new X(b)),this.decode(b,b.uint32())},O.verify=function(b){if(typeof b!="object"||b===null)return"object expected";if(b.dims!=null&&b.hasOwnProperty("dims")){if(!Array.isArray(b.dims))return"dims: array expected";for(var F=0;F<b.dims.length;++F)if(!(q.isInteger(b.dims[F])||b.dims[F]&&q.isInteger(b.dims[F].low)&&q.isInteger(b.dims[F].high)))return"dims: integer|Long[] expected"}if(b.dataType!=null&&b.hasOwnProperty("dataType")&&!q.isInteger(b.dataType))return"dataType: integer expected";if(b.segment!=null&&b.hasOwnProperty("segment")&&(j=G.onnx.TensorProto.Segment.verify(b.segment)))return"segment."+j;if(b.floatData!=null&&b.hasOwnProperty("floatData")){if(!Array.isArray(b.floatData))return"floatData: array expected";for(F=0;F<b.floatData.length;++F)if(typeof b.floatData[F]!="number")return"floatData: number[] expected"}if(b.int32Data!=null&&b.hasOwnProperty("int32Data")){if(!Array.isArray(b.int32Data))return"int32Data: array expected";for(F=0;F<b.int32Data.length;++F)if(!q.isInteger(b.int32Data[F]))return"int32Data: integer[] expected"}if(b.stringData!=null&&b.hasOwnProperty("stringData")){if(!Array.isArray(b.stringData))return"stringData: array expected";for(F=0;F<b.stringData.length;++F)if(!(b.stringData[F]&&typeof b.stringData[F].length=="number"||q.isString(b.stringData[F])))return"stringData: buffer[] expected"}if(b.int64Data!=null&&b.hasOwnProperty("int64Data")){if(!Array.isArray(b.int64Data))return"int64Data: array expected";for(F=0;F<b.int64Data.length;++F)if(!(q.isInteger(b.int64Data[F])||b.int64Data[F]&&q.isInteger(b.int64Data[F].low)&&q.isInteger(b.int64Data[F].high)))return"int64Data: integer|Long[] expected"}if(b.name!=null&&b.hasOwnProperty("name")&&!q.isString(b.name))return"name: string expected";if(b.docString!=null&&b.hasOwnProperty("docString")&&!q.isString(b.docString))return"docString: string expected";if(b.rawData!=null&&b.hasOwnProperty("rawData")&&!(b.rawData&&typeof b.rawData.length=="number"||q.isString(b.rawData)))return"rawData: buffer expected";if(b.externalData!=null&&b.hasOwnProperty("externalData")){if(!Array.isArray(b.externalData))return"externalData: array expected";for(F=0;F<b.externalData.length;++F){var j;if(j=G.onnx.StringStringEntryProto.verify(b.externalData[F]))return"externalData."+j}}if(b.dataLocation!=null&&b.hasOwnProperty("dataLocation"))switch(b.dataLocation){default:return"dataLocation: enum value expected";case 0:case 1:}if(b.doubleData!=null&&b.hasOwnProperty("doubleData")){if(!Array.isArray(b.doubleData))return"doubleData: array expected";for(F=0;F<b.doubleData.length;++F)if(typeof b.doubleData[F]!="number")return"doubleData: number[] expected"}if(b.uint64Data!=null&&b.hasOwnProperty("uint64Data")){if(!Array.isArray(b.uint64Data))return"uint64Data: array expected";for(F=0;F<b.uint64Data.length;++F)if(!(q.isInteger(b.uint64Data[F])||b.uint64Data[F]&&q.isInteger(b.uint64Data[F].low)&&q.isInteger(b.uint64Data[F].high)))return"uint64Data: integer|Long[] expected"}return null},O.fromObject=function(b){if(b instanceof G.onnx.TensorProto)return b;var F=new G.onnx.TensorProto;if(b.dims){if(!Array.isArray(b.dims))throw TypeError(".onnx.TensorProto.dims: array expected");F.dims=[];for(var j=0;j<b.dims.length;++j)q.Long?(F.dims[j]=q.Long.fromValue(b.dims[j])).unsigned=!1:typeof b.dims[j]=="string"?F.dims[j]=parseInt(b.dims[j],10):typeof b.dims[j]=="number"?F.dims[j]=b.dims[j]:typeof b.dims[j]=="object"&&(F.dims[j]=new q.LongBits(b.dims[j].low>>>0,b.dims[j].high>>>0).toNumber())}if(b.dataType!=null&&(F.dataType=0|b.dataType),b.segment!=null){if(typeof b.segment!="object")throw TypeError(".onnx.TensorProto.segment: object expected");F.segment=G.onnx.TensorProto.Segment.fromObject(b.segment)}if(b.floatData){if(!Array.isArray(b.floatData))throw TypeError(".onnx.TensorProto.floatData: array expected");for(F.floatData=[],j=0;j<b.floatData.length;++j)F.floatData[j]=Number(b.floatData[j])}if(b.int32Data){if(!Array.isArray(b.int32Data))throw TypeError(".onnx.TensorProto.int32Data: array expected");for(F.int32Data=[],j=0;j<b.int32Data.length;++j)F.int32Data[j]=0|b.int32Data[j]}if(b.stringData){if(!Array.isArray(b.stringData))throw TypeError(".onnx.TensorProto.stringData: array expected");for(F.stringData=[],j=0;j<b.stringData.length;++j)typeof b.stringData[j]=="string"?q.base64.decode(b.stringData[j],F.stringData[j]=q.newBuffer(q.base64.length(b.stringData[j])),0):b.stringData[j].length&&(F.stringData[j]=b.stringData[j])}if(b.int64Data){if(!Array.isArray(b.int64Data))throw TypeError(".onnx.TensorProto.int64Data: array expected");for(F.int64Data=[],j=0;j<b.int64Data.length;++j)q.Long?(F.int64Data[j]=q.Long.fromValue(b.int64Data[j])).unsigned=!1:typeof b.int64Data[j]=="string"?F.int64Data[j]=parseInt(b.int64Data[j],10):typeof b.int64Data[j]=="number"?F.int64Data[j]=b.int64Data[j]:typeof b.int64Data[j]=="object"&&(F.int64Data[j]=new q.LongBits(b.int64Data[j].low>>>0,b.int64Data[j].high>>>0).toNumber())}if(b.name!=null&&(F.name=String(b.name)),b.docString!=null&&(F.docString=String(b.docString)),b.rawData!=null&&(typeof b.rawData=="string"?q.base64.decode(b.rawData,F.rawData=q.newBuffer(q.base64.length(b.rawData)),0):b.rawData.length&&(F.rawData=b.rawData)),b.externalData){if(!Array.isArray(b.externalData))throw TypeError(".onnx.TensorProto.externalData: array expected");for(F.externalData=[],j=0;j<b.externalData.length;++j){if(typeof b.externalData[j]!="object")throw TypeError(".onnx.TensorProto.externalData: object expected");F.externalData[j]=G.onnx.StringStringEntryProto.fromObject(b.externalData[j])}}switch(b.dataLocation){case"DEFAULT":case 0:F.dataLocation=0;break;case"EXTERNAL":case 1:F.dataLocation=1}if(b.doubleData){if(!Array.isArray(b.doubleData))throw TypeError(".onnx.TensorProto.doubleData: array expected");for(F.doubleData=[],j=0;j<b.doubleData.length;++j)F.doubleData[j]=Number(b.doubleData[j])}if(b.uint64Data){if(!Array.isArray(b.uint64Data))throw TypeError(".onnx.TensorProto.uint64Data: array expected");for(F.uint64Data=[],j=0;j<b.uint64Data.length;++j)q.Long?(F.uint64Data[j]=q.Long.fromValue(b.uint64Data[j])).unsigned=!0:typeof b.uint64Data[j]=="string"?F.uint64Data[j]=parseInt(b.uint64Data[j],10):typeof b.uint64Data[j]=="number"?F.uint64Data[j]=b.uint64Data[j]:typeof b.uint64Data[j]=="object"&&(F.uint64Data[j]=new q.LongBits(b.uint64Data[j].low>>>0,b.uint64Data[j].high>>>0).toNumber(!0))}return F},O.toObject=function(b,F){F||(F={});var j={};if((F.arrays||F.defaults)&&(j.dims=[],j.floatData=[],j.int32Data=[],j.stringData=[],j.int64Data=[],j.doubleData=[],j.uint64Data=[],j.externalData=[]),F.defaults&&(j.dataType=0,j.segment=null,j.name="",F.bytes===String?j.rawData="":(j.rawData=[],F.bytes!==Array&&(j.rawData=q.newBuffer(j.rawData))),j.docString="",j.dataLocation=F.enums===String?"DEFAULT":0),b.dims&&b.dims.length){j.dims=[];for(var W=0;W<b.dims.length;++W)typeof b.dims[W]=="number"?j.dims[W]=F.longs===String?String(b.dims[W]):b.dims[W]:j.dims[W]=F.longs===String?q.Long.prototype.toString.call(b.dims[W]):F.longs===Number?new q.LongBits(b.dims[W].low>>>0,b.dims[W].high>>>0).toNumber():b.dims[W]}if(b.dataType!=null&&b.hasOwnProperty("dataType")&&(j.dataType=b.dataType),b.segment!=null&&b.hasOwnProperty("segment")&&(j.segment=G.onnx.TensorProto.Segment.toObject(b.segment,F)),b.floatData&&b.floatData.length)for(j.floatData=[],W=0;W<b.floatData.length;++W)j.floatData[W]=F.json&&!isFinite(b.floatData[W])?String(b.floatData[W]):b.floatData[W];if(b.int32Data&&b.int32Data.length)for(j.int32Data=[],W=0;W<b.int32Data.length;++W)j.int32Data[W]=b.int32Data[W];if(b.stringData&&b.stringData.length)for(j.stringData=[],W=0;W<b.stringData.length;++W)j.stringData[W]=F.bytes===String?q.base64.encode(b.stringData[W],0,b.stringData[W].length):F.bytes===Array?Array.prototype.slice.call(b.stringData[W]):b.stringData[W];if(b.int64Data&&b.int64Data.length)for(j.int64Data=[],W=0;W<b.int64Data.length;++W)typeof b.int64Data[W]=="number"?j.int64Data[W]=F.longs===String?String(b.int64Data[W]):b.int64Data[W]:j.int64Data[W]=F.longs===String?q.Long.prototype.toString.call(b.int64Data[W]):F.longs===Number?new q.LongBits(b.int64Data[W].low>>>0,b.int64Data[W].high>>>0).toNumber():b.int64Data[W];if(b.name!=null&&b.hasOwnProperty("name")&&(j.name=b.name),b.rawData!=null&&b.hasOwnProperty("rawData")&&(j.rawData=F.bytes===String?q.base64.encode(b.rawData,0,b.rawData.length):F.bytes===Array?Array.prototype.slice.call(b.rawData):b.rawData),b.doubleData&&b.doubleData.length)for(j.doubleData=[],W=0;W<b.doubleData.length;++W)j.doubleData[W]=F.json&&!isFinite(b.doubleData[W])?String(b.doubleData[W]):b.doubleData[W];if(b.uint64Data&&b.uint64Data.length)for(j.uint64Data=[],W=0;W<b.uint64Data.length;++W)typeof b.uint64Data[W]=="number"?j.uint64Data[W]=F.longs===String?String(b.uint64Data[W]):b.uint64Data[W]:j.uint64Data[W]=F.longs===String?q.Long.prototype.toString.call(b.uint64Data[W]):F.longs===Number?new q.LongBits(b.uint64Data[W].low>>>0,b.uint64Data[W].high>>>0).toNumber(!0):b.uint64Data[W];if(b.docString!=null&&b.hasOwnProperty("docString")&&(j.docString=b.docString),b.externalData&&b.externalData.length)for(j.externalData=[],W=0;W<b.externalData.length;++W)j.externalData[W]=G.onnx.StringStringEntryProto.toObject(b.externalData[W],F);return b.dataLocation!=null&&b.hasOwnProperty("dataLocation")&&(j.dataLocation=F.enums===String?G.onnx.TensorProto.DataLocation[b.dataLocation]:b.dataLocation),j},O.prototype.toJSON=function(){return this.constructor.toObject(this,K.util.toJSONOptions)},O.DataType=function(){var b={},F=Object.create(b);return F[b[0]="UNDEFINED"]=0,F[b[1]="FLOAT"]=1,F[b[2]="UINT8"]=2,F[b[3]="INT8"]=3,F[b[4]="UINT16"]=4,F[b[5]="INT16"]=5,F[b[6]="INT32"]=6,F[b[7]="INT64"]=7,F[b[8]="STRING"]=8,F[b[9]="BOOL"]=9,F[b[10]="FLOAT16"]=10,F[b[11]="DOUBLE"]=11,F[b[12]="UINT32"]=12,F[b[13]="UINT64"]=13,F[b[14]="COMPLEX64"]=14,F[b[15]="COMPLEX128"]=15,F[b[16]="BFLOAT16"]=16,F}(),O.Segment=function(){function b(F){if(F)for(var j=Object.keys(F),W=0;W<j.length;++W)F[j[W]]!=null&&(this[j[W]]=F[j[W]])}return b.prototype.begin=q.Long?q.Long.fromBits(0,0,!1):0,b.prototype.end=q.Long?q.Long.fromBits(0,0,!1):0,b.create=function(F){return new b(F)},b.encode=function(F,j){return j||(j=Q.create()),F.begin!=null&&F.hasOwnProperty("begin")&&j.uint32(8).int64(F.begin),F.end!=null&&F.hasOwnProperty("end")&&j.uint32(16).int64(F.end),j},b.encodeDelimited=function(F,j){return this.encode(F,j).ldelim()},b.decode=function(F,j){F instanceof X||(F=X.create(F));for(var W=j===void 0?F.len:F.pos+j,J=new G.onnx.TensorProto.Segment;F.pos<W;){var et=F.uint32();switch(et>>>3){case 1:J.begin=F.int64();break;case 2:J.end=F.int64();break;default:F.skipType(7&et)}}return J},b.decodeDelimited=function(F){return F instanceof X||(F=new X(F)),this.decode(F,F.uint32())},b.verify=function(F){return typeof F!="object"||F===null?"object expected":F.begin!=null&&F.hasOwnProperty("begin")&&!(q.isInteger(F.begin)||F.begin&&q.isInteger(F.begin.low)&&q.isInteger(F.begin.high))?"begin: integer|Long expected":F.end!=null&&F.hasOwnProperty("end")&&!(q.isInteger(F.end)||F.end&&q.isInteger(F.end.low)&&q.isInteger(F.end.high))?"end: integer|Long expected":null},b.fromObject=function(F){if(F instanceof G.onnx.TensorProto.Segment)return F;var j=new G.onnx.TensorProto.Segment;return F.begin!=null&&(q.Long?(j.begin=q.Long.fromValue(F.begin)).unsigned=!1:typeof F.begin=="string"?j.begin=parseInt(F.begin,10):typeof F.begin=="number"?j.begin=F.begin:typeof F.begin=="object"&&(j.begin=new q.LongBits(F.begin.low>>>0,F.begin.high>>>0).toNumber())),F.end!=null&&(q.Long?(j.end=q.Long.fromValue(F.end)).unsigned=!1:typeof F.end=="string"?j.end=parseInt(F.end,10):typeof F.end=="number"?j.end=F.end:typeof F.end=="object"&&(j.end=new q.LongBits(F.end.low>>>0,F.end.high>>>0).toNumber())),j},b.toObject=function(F,j){j||(j={});var W={};if(j.defaults){if(q.Long){var J=new q.Long(0,0,!1);W.begin=j.longs===String?J.toString():j.longs===Number?J.toNumber():J}else W.begin=j.longs===String?"0":0;q.Long?(J=new q.Long(0,0,!1),W.end=j.longs===String?J.toString():j.longs===Number?J.toNumber():J):W.end=j.longs===String?"0":0}return F.begin!=null&&F.hasOwnProperty("begin")&&(typeof F.begin=="number"?W.begin=j.longs===String?String(F.begin):F.begin:W.begin=j.longs===String?q.Long.prototype.toString.call(F.begin):j.longs===Number?new q.LongBits(F.begin.low>>>0,F.begin.high>>>0).toNumber():F.begin),F.end!=null&&F.hasOwnProperty("end")&&(typeof F.end=="number"?W.end=j.longs===String?String(F.end):F.end:W.end=j.longs===String?q.Long.prototype.toString.call(F.end):j.longs===Number?new q.LongBits(F.end.low>>>0,F.end.high>>>0).toNumber():F.end),W},b.prototype.toJSON=function(){return this.constructor.toObject(this,K.util.toJSONOptions)},b}(),O.DataLocation=function(){var b={},F=Object.create(b);return F[b[0]="DEFAULT"]=0,F[b[1]="EXTERNAL"]=1,F}(),O}(),nt.TensorShapeProto=function(){function O(b){if(this.dim=[],b)for(var F=Object.keys(b),j=0;j<F.length;++j)b[F[j]]!=null&&(this[F[j]]=b[F[j]])}return O.prototype.dim=q.emptyArray,O.create=function(b){return new O(b)},O.encode=function(b,F){if(F||(F=Q.create()),b.dim!=null&&b.dim.length)for(var j=0;j<b.dim.length;++j)G.onnx.TensorShapeProto.Dimension.encode(b.dim[j],F.uint32(10).fork()).ldelim();return F},O.encodeDelimited=function(b,F){return this.encode(b,F).ldelim()},O.decode=function(b,F){b instanceof X||(b=X.create(b));for(var j=F===void 0?b.len:b.pos+F,W=new G.onnx.TensorShapeProto;b.pos<j;){var J=b.uint32();J>>>3==1?(W.dim&&W.dim.length||(W.dim=[]),W.dim.push(G.onnx.TensorShapeProto.Dimension.decode(b,b.uint32()))):b.skipType(7&J)}return W},O.decodeDelimited=function(b){return b instanceof X||(b=new X(b)),this.decode(b,b.uint32())},O.verify=function(b){if(typeof b!="object"||b===null)return"object expected";if(b.dim!=null&&b.hasOwnProperty("dim")){if(!Array.isArray(b.dim))return"dim: array expected";for(var F=0;F<b.dim.length;++F){var j=G.onnx.TensorShapeProto.Dimension.verify(b.dim[F]);if(j)return"dim."+j}}return null},O.fromObject=function(b){if(b instanceof G.onnx.TensorShapeProto)return b;var F=new G.onnx.TensorShapeProto;if(b.dim){if(!Array.isArray(b.dim))throw TypeError(".onnx.TensorShapeProto.dim: array expected");F.dim=[];for(var j=0;j<b.dim.length;++j){if(typeof b.dim[j]!="object")throw TypeError(".onnx.TensorShapeProto.dim: object expected");F.dim[j]=G.onnx.TensorShapeProto.Dimension.fromObject(b.dim[j])}}return F},O.toObject=function(b,F){F||(F={});var j={};if((F.arrays||F.defaults)&&(j.dim=[]),b.dim&&b.dim.length){j.dim=[];for(var W=0;W<b.dim.length;++W)j.dim[W]=G.onnx.TensorShapeProto.Dimension.toObject(b.dim[W],F)}return j},O.prototype.toJSON=function(){return this.constructor.toObject(this,K.util.toJSONOptions)},O.Dimension=function(){function b(j){if(j)for(var W=Object.keys(j),J=0;J<W.length;++J)j[W[J]]!=null&&(this[W[J]]=j[W[J]])}var F;return b.prototype.dimValue=q.Long?q.Long.fromBits(0,0,!1):0,b.prototype.dimParam="",b.prototype.denotation="",Object.defineProperty(b.prototype,"value",{get:q.oneOfGetter(F=["dimValue","dimParam"]),set:q.oneOfSetter(F)}),b.create=function(j){return new b(j)},b.encode=function(j,W){return W||(W=Q.create()),j.dimValue!=null&&j.hasOwnProperty("dimValue")&&W.uint32(8).int64(j.dimValue),j.dimParam!=null&&j.hasOwnProperty("dimParam")&&W.uint32(18).string(j.dimParam),j.denotation!=null&&j.hasOwnProperty("denotation")&&W.uint32(26).string(j.denotation),W},b.encodeDelimited=function(j,W){return this.encode(j,W).ldelim()},b.decode=function(j,W){j instanceof X||(j=X.create(j));for(var J=W===void 0?j.len:j.pos+W,et=new G.onnx.TensorShapeProto.Dimension;j.pos<J;){var ot=j.uint32();switch(ot>>>3){case 1:et.dimValue=j.int64();break;case 2:et.dimParam=j.string();break;case 3:et.denotation=j.string();break;default:j.skipType(7&ot)}}return et},b.decodeDelimited=function(j){return j instanceof X||(j=new X(j)),this.decode(j,j.uint32())},b.verify=function(j){if(typeof j!="object"||j===null)return"object expected";var W={};if(j.dimValue!=null&&j.hasOwnProperty("dimValue")&&(W.value=1,!(q.isInteger(j.dimValue)||j.dimValue&&q.isInteger(j.dimValue.low)&&q.isInteger(j.dimValue.high))))return"dimValue: integer|Long expected";if(j.dimParam!=null&&j.hasOwnProperty("dimParam")){if(W.value===1)return"value: multiple values";if(W.value=1,!q.isString(j.dimParam))return"dimParam: string expected"}return j.denotation!=null&&j.hasOwnProperty("denotation")&&!q.isString(j.denotation)?"denotation: string expected":null},b.fromObject=function(j){if(j instanceof G.onnx.TensorShapeProto.Dimension)return j;var W=new G.onnx.TensorShapeProto.Dimension;return j.dimValue!=null&&(q.Long?(W.dimValue=q.Long.fromValue(j.dimValue)).unsigned=!1:typeof j.dimValue=="string"?W.dimValue=parseInt(j.dimValue,10):typeof j.dimValue=="number"?W.dimValue=j.dimValue:typeof j.dimValue=="object"&&(W.dimValue=new q.LongBits(j.dimValue.low>>>0,j.dimValue.high>>>0).toNumber())),j.dimParam!=null&&(W.dimParam=String(j.dimParam)),j.denotation!=null&&(W.denotation=String(j.denotation)),W},b.toObject=function(j,W){W||(W={});var J={};return W.defaults&&(J.denotation=""),j.dimValue!=null&&j.hasOwnProperty("dimValue")&&(typeof j.dimValue=="number"?J.dimValue=W.longs===String?String(j.dimValue):j.dimValue:J.dimValue=W.longs===String?q.Long.prototype.toString.call(j.dimValue):W.longs===Number?new q.LongBits(j.dimValue.low>>>0,j.dimValue.high>>>0).toNumber():j.dimValue,W.oneofs&&(J.value="dimValue")),j.dimParam!=null&&j.hasOwnProperty("dimParam")&&(J.dimParam=j.dimParam,W.oneofs&&(J.value="dimParam")),j.denotation!=null&&j.hasOwnProperty("denotation")&&(J.denotation=j.denotation),J},b.prototype.toJSON=function(){return this.constructor.toObject(this,K.util.toJSONOptions)},b}(),O}(),nt.TypeProto=function(){function O(F){if(F)for(var j=Object.keys(F),W=0;W<j.length;++W)F[j[W]]!=null&&(this[j[W]]=F[j[W]])}var b;return O.prototype.tensorType=null,O.prototype.denotation="",Object.defineProperty(O.prototype,"value",{get:q.oneOfGetter(b=["tensorType"]),set:q.oneOfSetter(b)}),O.create=function(F){return new O(F)},O.encode=function(F,j){return j||(j=Q.create()),F.tensorType!=null&&F.hasOwnProperty("tensorType")&&G.onnx.TypeProto.Tensor.encode(F.tensorType,j.uint32(10).fork()).ldelim(),F.denotation!=null&&F.hasOwnProperty("denotation")&&j.uint32(50).string(F.denotation),j},O.encodeDelimited=function(F,j){return this.encode(F,j).ldelim()},O.decode=function(F,j){F instanceof X||(F=X.create(F));for(var W=j===void 0?F.len:F.pos+j,J=new G.onnx.TypeProto;F.pos<W;){var et=F.uint32();switch(et>>>3){case 1:J.tensorType=G.onnx.TypeProto.Tensor.decode(F,F.uint32());break;case 6:J.denotation=F.string();break;default:F.skipType(7&et)}}return J},O.decodeDelimited=function(F){return F instanceof X||(F=new X(F)),this.decode(F,F.uint32())},O.verify=function(F){if(typeof F!="object"||F===null)return"object expected";if(F.tensorType!=null&&F.hasOwnProperty("tensorType")){var j=G.onnx.TypeProto.Tensor.verify(F.tensorType);if(j)return"tensorType."+j}return F.denotation!=null&&F.hasOwnProperty("denotation")&&!q.isString(F.denotation)?"denotation: string expected":null},O.fromObject=function(F){if(F instanceof G.onnx.TypeProto)return F;var j=new G.onnx.TypeProto;if(F.tensorType!=null){if(typeof F.tensorType!="object")throw TypeError(".onnx.TypeProto.tensorType: object expected");j.tensorType=G.onnx.TypeProto.Tensor.fromObject(F.tensorType)}return F.denotation!=null&&(j.denotation=String(F.denotation)),j},O.toObject=function(F,j){j||(j={});var W={};return j.defaults&&(W.denotation=""),F.tensorType!=null&&F.hasOwnProperty("tensorType")&&(W.tensorType=G.onnx.TypeProto.Tensor.toObject(F.tensorType,j),j.oneofs&&(W.value="tensorType")),F.denotation!=null&&F.hasOwnProperty("denotation")&&(W.denotation=F.denotation),W},O.prototype.toJSON=function(){return this.constructor.toObject(this,K.util.toJSONOptions)},O.Tensor=function(){function F(j){if(j)for(var W=Object.keys(j),J=0;J<W.length;++J)j[W[J]]!=null&&(this[W[J]]=j[W[J]])}return F.prototype.elemType=0,F.prototype.shape=null,F.create=function(j){return new F(j)},F.encode=function(j,W){return W||(W=Q.create()),j.elemType!=null&&j.hasOwnProperty("elemType")&&W.uint32(8).int32(j.elemType),j.shape!=null&&j.hasOwnProperty("shape")&&G.onnx.TensorShapeProto.encode(j.shape,W.uint32(18).fork()).ldelim(),W},F.encodeDelimited=function(j,W){return this.encode(j,W).ldelim()},F.decode=function(j,W){j instanceof X||(j=X.create(j));for(var J=W===void 0?j.len:j.pos+W,et=new G.onnx.TypeProto.Tensor;j.pos<J;){var ot=j.uint32();switch(ot>>>3){case 1:et.elemType=j.int32();break;case 2:et.shape=G.onnx.TensorShapeProto.decode(j,j.uint32());break;default:j.skipType(7&ot)}}return et},F.decodeDelimited=function(j){return j instanceof X||(j=new X(j)),this.decode(j,j.uint32())},F.verify=function(j){if(typeof j!="object"||j===null)return"object expected";if(j.elemType!=null&&j.hasOwnProperty("elemType")&&!q.isInteger(j.elemType))return"elemType: integer expected";if(j.shape!=null&&j.hasOwnProperty("shape")){var W=G.onnx.TensorShapeProto.verify(j.shape);if(W)return"shape."+W}return null},F.fromObject=function(j){if(j instanceof G.onnx.TypeProto.Tensor)return j;var W=new G.onnx.TypeProto.Tensor;if(j.elemType!=null&&(W.elemType=0|j.elemType),j.shape!=null){if(typeof j.shape!="object")throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");W.shape=G.onnx.TensorShapeProto.fromObject(j.shape)}return W},F.toObject=function(j,W){W||(W={});var J={};return W.defaults&&(J.elemType=0,J.shape=null),j.elemType!=null&&j.hasOwnProperty("elemType")&&(J.elemType=j.elemType),j.shape!=null&&j.hasOwnProperty("shape")&&(J.shape=G.onnx.TensorShapeProto.toObject(j.shape,W)),J},F.prototype.toJSON=function(){return this.constructor.toObject(this,K.util.toJSONOptions)},F}(),O}(),nt.OperatorSetIdProto=function(){function O(b){if(b)for(var F=Object.keys(b),j=0;j<F.length;++j)b[F[j]]!=null&&(this[F[j]]=b[F[j]])}return O.prototype.domain="",O.prototype.version=q.Long?q.Long.fromBits(0,0,!1):0,O.create=function(b){return new O(b)},O.encode=function(b,F){return F||(F=Q.create()),b.domain!=null&&b.hasOwnProperty("domain")&&F.uint32(10).string(b.domain),b.version!=null&&b.hasOwnProperty("version")&&F.uint32(16).int64(b.version),F},O.encodeDelimited=function(b,F){return this.encode(b,F).ldelim()},O.decode=function(b,F){b instanceof X||(b=X.create(b));for(var j=F===void 0?b.len:b.pos+F,W=new G.onnx.OperatorSetIdProto;b.pos<j;){var J=b.uint32();switch(J>>>3){case 1:W.domain=b.string();break;case 2:W.version=b.int64();break;default:b.skipType(7&J)}}return W},O.decodeDelimited=function(b){return b instanceof X||(b=new X(b)),this.decode(b,b.uint32())},O.verify=function(b){return typeof b!="object"||b===null?"object expected":b.domain!=null&&b.hasOwnProperty("domain")&&!q.isString(b.domain)?"domain: string expected":b.version!=null&&b.hasOwnProperty("version")&&!(q.isInteger(b.version)||b.version&&q.isInteger(b.version.low)&&q.isInteger(b.version.high))?"version: integer|Long expected":null},O.fromObject=function(b){if(b instanceof G.onnx.OperatorSetIdProto)return b;var F=new G.onnx.OperatorSetIdProto;return b.domain!=null&&(F.domain=String(b.domain)),b.version!=null&&(q.Long?(F.version=q.Long.fromValue(b.version)).unsigned=!1:typeof b.version=="string"?F.version=parseInt(b.version,10):typeof b.version=="number"?F.version=b.version:typeof b.version=="object"&&(F.version=new q.LongBits(b.version.low>>>0,b.version.high>>>0).toNumber())),F},O.toObject=function(b,F){F||(F={});var j={};if(F.defaults)if(j.domain="",q.Long){var W=new q.Long(0,0,!1);j.version=F.longs===String?W.toString():F.longs===Number?W.toNumber():W}else j.version=F.longs===String?"0":0;return b.domain!=null&&b.hasOwnProperty("domain")&&(j.domain=b.domain),b.version!=null&&b.hasOwnProperty("version")&&(typeof b.version=="number"?j.version=F.longs===String?String(b.version):b.version:j.version=F.longs===String?q.Long.prototype.toString.call(b.version):F.longs===Number?new q.LongBits(b.version.low>>>0,b.version.high>>>0).toNumber():b.version),j},O.prototype.toJSON=function(){return this.constructor.toObject(this,K.util.toJSONOptions)},O}(),nt),dt.exports=G},2100:(dt,U,rt)=>{dt.exports=rt(9482)},9482:(dt,U,rt)=>{var tt=U;function Y(){tt.util._configure(),tt.Writer._configure(tt.BufferWriter),tt.Reader._configure(tt.BufferReader)}tt.build="minimal",tt.Writer=rt(1173),tt.BufferWriter=rt(3155),tt.Reader=rt(1408),tt.BufferReader=rt(593),tt.util=rt(9693),tt.rpc=rt(5994),tt.roots=rt(5054),tt.configure=Y,Y()},1408:(dt,U,rt)=>{dt.exports=Q;var tt,Y=rt(9693),nt=Y.LongBits,K=Y.utf8;function X(W,J){return RangeError("index out of range: "+W.pos+" + "+(J||1)+" > "+W.len)}function Q(W){this.buf=W,this.pos=0,this.len=W.length}var q,G=typeof Uint8Array<"u"?function(W){if(W instanceof Uint8Array||Array.isArray(W))return new Q(W);throw Error("illegal buffer")}:function(W){if(Array.isArray(W))return new Q(W);throw Error("illegal buffer")},O=function(){return Y.Buffer?function(W){return(Q.create=function(J){return Y.Buffer.isBuffer(J)?new tt(J):G(J)})(W)}:G};function b(){var W=new nt(0,0),J=0;if(!(this.len-this.pos>4)){for(;J<3;++J){if(this.pos>=this.len)throw X(this);if(W.lo=(W.lo|(127&this.buf[this.pos])<<7*J)>>>0,this.buf[this.pos++]<128)return W}return W.lo=(W.lo|(127&this.buf[this.pos++])<<7*J)>>>0,W}for(;J<4;++J)if(W.lo=(W.lo|(127&this.buf[this.pos])<<7*J)>>>0,this.buf[this.pos++]<128)return W;if(W.lo=(W.lo|(127&this.buf[this.pos])<<28)>>>0,W.hi=(W.hi|(127&this.buf[this.pos])>>4)>>>0,this.buf[this.pos++]<128)return W;if(J=0,this.len-this.pos>4){for(;J<5;++J)if(W.hi=(W.hi|(127&this.buf[this.pos])<<7*J+3)>>>0,this.buf[this.pos++]<128)return W}else for(;J<5;++J){if(this.pos>=this.len)throw X(this);if(W.hi=(W.hi|(127&this.buf[this.pos])<<7*J+3)>>>0,this.buf[this.pos++]<128)return W}throw Error("invalid varint encoding")}function F(W,J){return(W[J-4]|W[J-3]<<8|W[J-2]<<16|W[J-1]<<24)>>>0}function j(){if(this.pos+8>this.len)throw X(this,8);return new nt(F(this.buf,this.pos+=4),F(this.buf,this.pos+=4))}Q.create=O(),Q.prototype._slice=Y.Array.prototype.subarray||Y.Array.prototype.slice,Q.prototype.uint32=(q=4294967295,function(){if(q=(127&this.buf[this.pos])>>>0,this.buf[this.pos++]<128||(q=(q|(127&this.buf[this.pos])<<7)>>>0,this.buf[this.pos++]<128)||(q=(q|(127&this.buf[this.pos])<<14)>>>0,this.buf[this.pos++]<128)||(q=(q|(127&this.buf[this.pos])<<21)>>>0,this.buf[this.pos++]<128)||(q=(q|(15&this.buf[this.pos])<<28)>>>0,this.buf[this.pos++]<128))return q;if((this.pos+=5)>this.len)throw this.pos=this.len,X(this,10);return q}),Q.prototype.int32=function(){return 0|this.uint32()},Q.prototype.sint32=function(){var W=this.uint32();return W>>>1^-(1&W)|0},Q.prototype.bool=function(){return this.uint32()!==0},Q.prototype.fixed32=function(){if(this.pos+4>this.len)throw X(this,4);return F(this.buf,this.pos+=4)},Q.prototype.sfixed32=function(){if(this.pos+4>this.len)throw X(this,4);return 0|F(this.buf,this.pos+=4)},Q.prototype.float=function(){if(this.pos+4>this.len)throw X(this,4);var W=Y.float.readFloatLE(this.buf,this.pos);return this.pos+=4,W},Q.prototype.double=function(){if(this.pos+8>this.len)throw X(this,4);var W=Y.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,W},Q.prototype.bytes=function(){var W=this.uint32(),J=this.pos,et=this.pos+W;if(et>this.len)throw X(this,W);return this.pos+=W,Array.isArray(this.buf)?this.buf.slice(J,et):J===et?new this.buf.constructor(0):this._slice.call(this.buf,J,et)},Q.prototype.string=function(){var W=this.bytes();return K.read(W,0,W.length)},Q.prototype.skip=function(W){if(typeof W=="number"){if(this.pos+W>this.len)throw X(this,W);this.pos+=W}else do if(this.pos>=this.len)throw X(this);while(128&this.buf[this.pos++]);return this},Q.prototype.skipType=function(W){switch(W){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(W=7&this.uint32())!=4;)this.skipType(W);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+W+" at offset "+this.pos)}return this},Q._configure=function(W){tt=W,Q.create=O(),tt._configure();var J=Y.Long?"toLong":"toNumber";Y.merge(Q.prototype,{int64:function(){return b.call(this)[J](!1)},uint64:function(){return b.call(this)[J](!0)},sint64:function(){return b.call(this).zzDecode()[J](!1)},fixed64:function(){return j.call(this)[J](!0)},sfixed64:function(){return j.call(this)[J](!1)}})}},593:(dt,U,rt)=>{dt.exports=nt;var tt=rt(1408);(nt.prototype=Object.create(tt.prototype)).constructor=nt;var Y=rt(9693);function nt(K){tt.call(this,K)}nt._configure=function(){Y.Buffer&&(nt.prototype._slice=Y.Buffer.prototype.slice)},nt.prototype.string=function(){var K=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+K,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+K,this.len))},nt._configure()},5054:dt=>{dt.exports={}},5994:(dt,U,rt)=>{U.Service=rt(7948)},7948:(dt,U,rt)=>{dt.exports=Y;var tt=rt(9693);function Y(nt,K,X){if(typeof nt!="function")throw TypeError("rpcImpl must be a function");tt.EventEmitter.call(this),this.rpcImpl=nt,this.requestDelimited=!!K,this.responseDelimited=!!X}(Y.prototype=Object.create(tt.EventEmitter.prototype)).constructor=Y,Y.prototype.rpcCall=function nt(K,X,Q,q,G){if(!q)throw TypeError("request must be specified");var O=this;if(!G)return tt.asPromise(nt,O,K,X,Q,q);if(O.rpcImpl)try{return O.rpcImpl(K,X[O.requestDelimited?"encodeDelimited":"encode"](q).finish(),function(b,F){if(b)return O.emit("error",b,K),G(b);if(F!==null){if(!(F instanceof Q))try{F=Q[O.responseDelimited?"decodeDelimited":"decode"](F)}catch(j){return O.emit("error",j,K),G(j)}return O.emit("data",F,K),G(null,F)}O.end(!0)})}catch(b){return O.emit("error",b,K),void setTimeout(function(){G(b)},0)}else setTimeout(function(){G(Error("already ended"))},0)},Y.prototype.end=function(nt){return this.rpcImpl&&(nt||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this}},1945:(dt,U,rt)=>{dt.exports=Y;var tt=rt(9693);function Y(Q,q){this.lo=Q>>>0,this.hi=q>>>0}var nt=Y.zero=new Y(0,0);nt.toNumber=function(){return 0},nt.zzEncode=nt.zzDecode=function(){return this},nt.length=function(){return 1};var K=Y.zeroHash="\0\0\0\0\0\0\0\0";Y.fromNumber=function(Q){if(Q===0)return nt;var q=Q<0;q&&(Q=-Q);var G=Q>>>0,O=(Q-G)/4294967296>>>0;return q&&(O=~O>>>0,G=~G>>>0,++G>4294967295&&(G=0,++O>4294967295&&(O=0))),new Y(G,O)},Y.from=function(Q){if(typeof Q=="number")return Y.fromNumber(Q);if(tt.isString(Q)){if(!tt.Long)return Y.fromNumber(parseInt(Q,10));Q=tt.Long.fromString(Q)}return Q.low||Q.high?new Y(Q.low>>>0,Q.high>>>0):nt},Y.prototype.toNumber=function(Q){if(!Q&&this.hi>>>31){var q=1+~this.lo>>>0,G=~this.hi>>>0;return q||(G=G+1>>>0),-(q+4294967296*G)}return this.lo+4294967296*this.hi},Y.prototype.toLong=function(Q){return tt.Long?new tt.Long(0|this.lo,0|this.hi,!!Q):{low:0|this.lo,high:0|this.hi,unsigned:!!Q}};var X=String.prototype.charCodeAt;Y.fromHash=function(Q){return Q===K?nt:new Y((X.call(Q,0)|X.call(Q,1)<<8|X.call(Q,2)<<16|X.call(Q,3)<<24)>>>0,(X.call(Q,4)|X.call(Q,5)<<8|X.call(Q,6)<<16|X.call(Q,7)<<24)>>>0)},Y.prototype.toHash=function(){return String.fromCharCode(255&this.lo,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,255&this.hi,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},Y.prototype.zzEncode=function(){var Q=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^Q)>>>0,this.lo=(this.lo<<1^Q)>>>0,this},Y.prototype.zzDecode=function(){var Q=-(1&this.lo);return this.lo=((this.lo>>>1|this.hi<<31)^Q)>>>0,this.hi=(this.hi>>>1^Q)>>>0,this},Y.prototype.length=function(){var Q=this.lo,q=(this.lo>>>28|this.hi<<4)>>>0,G=this.hi>>>24;return G===0?q===0?Q<16384?Q<128?1:2:Q<2097152?3:4:q<16384?q<128?5:6:q<2097152?7:8:G<128?9:10}},9693:function(dt,U,rt){var tt=U;function Y(K,X,Q){for(var q=Object.keys(X),G=0;G<q.length;++G)K[q[G]]!==void 0&&Q||(K[q[G]]=X[q[G]]);return K}function nt(K){function X(Q,q){if(!(this instanceof X))return new X(Q,q);Object.defineProperty(this,"message",{get:function(){return Q}}),Error.captureStackTrace?Error.captureStackTrace(this,X):Object.defineProperty(this,"stack",{value:new Error().stack||""}),q&&Y(this,q)}return(X.prototype=Object.create(Error.prototype)).constructor=X,Object.defineProperty(X.prototype,"name",{get:function(){return K}}),X.prototype.toString=function(){return this.name+": "+this.message},X}tt.asPromise=rt(4537),tt.base64=rt(7419),tt.EventEmitter=rt(9211),tt.float=rt(945),tt.inquire=rt(7199),tt.utf8=rt(4997),tt.pool=rt(6662),tt.LongBits=rt(1945),tt.isNode=!!(rt.g!==void 0&&rt.g&&rt.g.process&&rt.g.process.versions&&rt.g.process.versions.node),tt.global=tt.isNode&&rt.g||typeof window<"u"&&window||typeof self<"u"&&self||this,tt.emptyArray=Object.freeze?Object.freeze([]):[],tt.emptyObject=Object.freeze?Object.freeze({}):{},tt.isInteger=Number.isInteger||function(K){return typeof K=="number"&&isFinite(K)&&Math.floor(K)===K},tt.isString=function(K){return typeof K=="string"||K instanceof String},tt.isObject=function(K){return K&&typeof K=="object"},tt.isset=tt.isSet=function(K,X){var Q=K[X];return!(Q==null||!K.hasOwnProperty(X))&&(typeof Q!="object"||(Array.isArray(Q)?Q.length:Object.keys(Q).length)>0)},tt.Buffer=function(){try{var K=tt.inquire("buffer").Buffer;return K.prototype.utf8Write?K:null}catch{return null}}(),tt._Buffer_from=null,tt._Buffer_allocUnsafe=null,tt.newBuffer=function(K){return typeof K=="number"?tt.Buffer?tt._Buffer_allocUnsafe(K):new tt.Array(K):tt.Buffer?tt._Buffer_from(K):typeof Uint8Array>"u"?K:new Uint8Array(K)},tt.Array=typeof Uint8Array<"u"?Uint8Array:Array,tt.Long=tt.global.dcodeIO&&tt.global.dcodeIO.Long||tt.global.Long||tt.inquire("long"),tt.key2Re=/^true|false|0|1$/,tt.key32Re=/^-?(?:0|[1-9][0-9]*)$/,tt.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,tt.longToHash=function(K){return K?tt.LongBits.from(K).toHash():tt.LongBits.zeroHash},tt.longFromHash=function(K,X){var Q=tt.LongBits.fromHash(K);return tt.Long?tt.Long.fromBits(Q.lo,Q.hi,X):Q.toNumber(!!X)},tt.merge=Y,tt.lcFirst=function(K){return K.charAt(0).toLowerCase()+K.substring(1)},tt.newError=nt,tt.ProtocolError=nt("ProtocolError"),tt.oneOfGetter=function(K){for(var X={},Q=0;Q<K.length;++Q)X[K[Q]]=1;return function(){for(var q=Object.keys(this),G=q.length-1;G>-1;--G)if(X[q[G]]===1&&this[q[G]]!==void 0&&this[q[G]]!==null)return q[G]}},tt.oneOfSetter=function(K){return function(X){for(var Q=0;Q<K.length;++Q)K[Q]!==X&&delete this[K[Q]]}},tt.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},tt._configure=function(){var K=tt.Buffer;K?(tt._Buffer_from=K.from!==Uint8Array.from&&K.from||function(X,Q){return new K(X,Q)},tt._Buffer_allocUnsafe=K.allocUnsafe||function(X){return new K(X)}):tt._Buffer_from=tt._Buffer_allocUnsafe=null}},1173:(dt,U,rt)=>{dt.exports=O;var tt,Y=rt(9693),nt=Y.LongBits,K=Y.base64,X=Y.utf8;function Q(ot,it,at){this.fn=ot,this.len=it,this.next=void 0,this.val=at}function q(){}function G(ot){this.head=ot.head,this.tail=ot.tail,this.len=ot.len,this.next=ot.states}function O(){this.len=0,this.head=new Q(q,0,0),this.tail=this.head,this.states=null}var b=function(){return Y.Buffer?function(){return(O.create=function(){return new tt})()}:function(){return new O}};function F(ot,it,at){it[at]=255&ot}function j(ot,it){this.len=ot,this.next=void 0,this.val=it}function W(ot,it,at){for(;ot.hi;)it[at++]=127&ot.lo|128,ot.lo=(ot.lo>>>7|ot.hi<<25)>>>0,ot.hi>>>=7;for(;ot.lo>127;)it[at++]=127&ot.lo|128,ot.lo=ot.lo>>>7;it[at++]=ot.lo}function J(ot,it,at){it[at]=255&ot,it[at+1]=ot>>>8&255,it[at+2]=ot>>>16&255,it[at+3]=ot>>>24}O.create=b(),O.alloc=function(ot){return new Y.Array(ot)},Y.Array!==Array&&(O.alloc=Y.pool(O.alloc,Y.Array.prototype.subarray)),O.prototype._push=function(ot,it,at){return this.tail=this.tail.next=new Q(ot,it,at),this.len+=it,this},j.prototype=Object.create(Q.prototype),j.prototype.fn=function(ot,it,at){for(;ot>127;)it[at++]=127&ot|128,ot>>>=7;it[at]=ot},O.prototype.uint32=function(ot){return this.len+=(this.tail=this.tail.next=new j((ot>>>=0)<128?1:ot<16384?2:ot<2097152?3:ot<268435456?4:5,ot)).len,this},O.prototype.int32=function(ot){return ot<0?this._push(W,10,nt.fromNumber(ot)):this.uint32(ot)},O.prototype.sint32=function(ot){return this.uint32((ot<<1^ot>>31)>>>0)},O.prototype.uint64=function(ot){var it=nt.from(ot);return this._push(W,it.length(),it)},O.prototype.int64=O.prototype.uint64,O.prototype.sint64=function(ot){var it=nt.from(ot).zzEncode();return this._push(W,it.length(),it)},O.prototype.bool=function(ot){return this._push(F,1,ot?1:0)},O.prototype.fixed32=function(ot){return this._push(J,4,ot>>>0)},O.prototype.sfixed32=O.prototype.fixed32,O.prototype.fixed64=function(ot){var it=nt.from(ot);return this._push(J,4,it.lo)._push(J,4,it.hi)},O.prototype.sfixed64=O.prototype.fixed64,O.prototype.float=function(ot){return this._push(Y.float.writeFloatLE,4,ot)},O.prototype.double=function(ot){return this._push(Y.float.writeDoubleLE,8,ot)};var et=Y.Array.prototype.set?function(ot,it,at){it.set(ot,at)}:function(ot,it,at){for(var st=0;st<ot.length;++st)it[at+st]=ot[st]};O.prototype.bytes=function(ot){var it=ot.length>>>0;if(!it)return this._push(F,1,0);if(Y.isString(ot)){var at=O.alloc(it=K.length(ot));K.decode(ot,at,0),ot=at}return this.uint32(it)._push(et,it,ot)},O.prototype.string=function(ot){var it=X.length(ot);return it?this.uint32(it)._push(X.write,it,ot):this._push(F,1,0)},O.prototype.fork=function(){return this.states=new G(this),this.head=this.tail=new Q(q,0,0),this.len=0,this},O.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new Q(q,0,0),this.len=0),this},O.prototype.ldelim=function(){var ot=this.head,it=this.tail,at=this.len;return this.reset().uint32(at),at&&(this.tail.next=ot.next,this.tail=it,this.len+=at),this},O.prototype.finish=function(){for(var ot=this.head.next,it=this.constructor.alloc(this.len),at=0;ot;)ot.fn(ot.val,it,at),at+=ot.len,ot=ot.next;return it},O._configure=function(ot){tt=ot,O.create=b(),tt._configure()}},3155:(dt,U,rt)=>{dt.exports=nt;var tt=rt(1173);(nt.prototype=Object.create(tt.prototype)).constructor=nt;var Y=rt(9693);function nt(){tt.call(this)}function K(X,Q,q){X.length<40?Y.utf8.write(X,Q,q):Q.utf8Write?Q.utf8Write(X,q):Q.write(X,q)}nt._configure=function(){nt.alloc=Y._Buffer_allocUnsafe,nt.writeBytesBuffer=Y.Buffer&&Y.Buffer.prototype instanceof Uint8Array&&Y.Buffer.prototype.set.name==="set"?function(X,Q,q){Q.set(X,q)}:function(X,Q,q){if(X.copy)X.copy(Q,q,0,X.length);else for(var G=0;G<X.length;)Q[q++]=X[G++]}},nt.prototype.bytes=function(X){Y.isString(X)&&(X=Y._Buffer_from(X,"base64"));var Q=X.length>>>0;return this.uint32(Q),Q&&this._push(nt.writeBytesBuffer,Q,X),this},nt.prototype.string=function(X){var Q=Y.Buffer.byteLength(X);return this.uint32(Q),Q&&this._push(K,Q,X),this},nt._configure()},4154:dt=>{dt.exports=`"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};
`},7067:()=>{},1296:()=>{},760:()=>{},1384:()=>{},3993:()=>{},908:()=>{},6953:()=>{},9925:()=>{},2806:()=>{},6449:()=>{},2850:()=>{},5381:()=>{},5686:(dt,U,rt)=>{rt.r(U),rt.d(U,{flatbuffers:()=>tt});var tt={};tt.Offset,tt.Table,tt.SIZEOF_SHORT=2,tt.SIZEOF_INT=4,tt.FILE_IDENTIFIER_LENGTH=4,tt.SIZE_PREFIX_LENGTH=4,tt.Encoding={UTF8_BYTES:1,UTF16_STRING:2},tt.int32=new Int32Array(2),tt.float32=new Float32Array(tt.int32.buffer),tt.float64=new Float64Array(tt.int32.buffer),tt.isLittleEndian=new Uint16Array(new Uint8Array([1,0]).buffer)[0]===1,tt.Long=function(Y,nt){this.low=0|Y,this.high=0|nt},tt.Long.create=function(Y,nt){return Y==0&&nt==0?tt.Long.ZERO:new tt.Long(Y,nt)},tt.Long.prototype.toFloat64=function(){return(this.low>>>0)+4294967296*this.high},tt.Long.prototype.equals=function(Y){return this.low==Y.low&&this.high==Y.high},tt.Long.ZERO=new tt.Long(0,0),tt.Builder=function(Y){if(Y)nt=Y;else var nt=1024;this.bb=tt.ByteBuffer.allocate(nt),this.space=nt,this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},tt.Builder.prototype.clear=function(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},tt.Builder.prototype.forceDefaults=function(Y){this.force_defaults=Y},tt.Builder.prototype.dataBuffer=function(){return this.bb},tt.Builder.prototype.asUint8Array=function(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())},tt.Builder.prototype.prep=function(Y,nt){Y>this.minalign&&(this.minalign=Y);for(var K=1+~(this.bb.capacity()-this.space+nt)&Y-1;this.space<K+Y+nt;){var X=this.bb.capacity();this.bb=tt.Builder.growByteBuffer(this.bb),this.space+=this.bb.capacity()-X}this.pad(K)},tt.Builder.prototype.pad=function(Y){for(var nt=0;nt<Y;nt++)this.bb.writeInt8(--this.space,0)},tt.Builder.prototype.writeInt8=function(Y){this.bb.writeInt8(this.space-=1,Y)},tt.Builder.prototype.writeInt16=function(Y){this.bb.writeInt16(this.space-=2,Y)},tt.Builder.prototype.writeInt32=function(Y){this.bb.writeInt32(this.space-=4,Y)},tt.Builder.prototype.writeInt64=function(Y){this.bb.writeInt64(this.space-=8,Y)},tt.Builder.prototype.writeFloat32=function(Y){this.bb.writeFloat32(this.space-=4,Y)},tt.Builder.prototype.writeFloat64=function(Y){this.bb.writeFloat64(this.space-=8,Y)},tt.Builder.prototype.addInt8=function(Y){this.prep(1,0),this.writeInt8(Y)},tt.Builder.prototype.addInt16=function(Y){this.prep(2,0),this.writeInt16(Y)},tt.Builder.prototype.addInt32=function(Y){this.prep(4,0),this.writeInt32(Y)},tt.Builder.prototype.addInt64=function(Y){this.prep(8,0),this.writeInt64(Y)},tt.Builder.prototype.addFloat32=function(Y){this.prep(4,0),this.writeFloat32(Y)},tt.Builder.prototype.addFloat64=function(Y){this.prep(8,0),this.writeFloat64(Y)},tt.Builder.prototype.addFieldInt8=function(Y,nt,K){(this.force_defaults||nt!=K)&&(this.addInt8(nt),this.slot(Y))},tt.Builder.prototype.addFieldInt16=function(Y,nt,K){(this.force_defaults||nt!=K)&&(this.addInt16(nt),this.slot(Y))},tt.Builder.prototype.addFieldInt32=function(Y,nt,K){(this.force_defaults||nt!=K)&&(this.addInt32(nt),this.slot(Y))},tt.Builder.prototype.addFieldInt64=function(Y,nt,K){!this.force_defaults&&nt.equals(K)||(this.addInt64(nt),this.slot(Y))},tt.Builder.prototype.addFieldFloat32=function(Y,nt,K){(this.force_defaults||nt!=K)&&(this.addFloat32(nt),this.slot(Y))},tt.Builder.prototype.addFieldFloat64=function(Y,nt,K){(this.force_defaults||nt!=K)&&(this.addFloat64(nt),this.slot(Y))},tt.Builder.prototype.addFieldOffset=function(Y,nt,K){(this.force_defaults||nt!=K)&&(this.addOffset(nt),this.slot(Y))},tt.Builder.prototype.addFieldStruct=function(Y,nt,K){nt!=K&&(this.nested(nt),this.slot(Y))},tt.Builder.prototype.nested=function(Y){if(Y!=this.offset())throw new Error("FlatBuffers: struct must be serialized inline.")},tt.Builder.prototype.notNested=function(){if(this.isNested)throw new Error("FlatBuffers: object serialization must not be nested.")},tt.Builder.prototype.slot=function(Y){this.vtable[Y]=this.offset()},tt.Builder.prototype.offset=function(){return this.bb.capacity()-this.space},tt.Builder.growByteBuffer=function(Y){var nt=Y.capacity();if(3221225472&nt)throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");var K=nt<<1,X=tt.ByteBuffer.allocate(K);return X.setPosition(K-nt),X.bytes().set(Y.bytes(),K-nt),X},tt.Builder.prototype.addOffset=function(Y){this.prep(tt.SIZEOF_INT,0),this.writeInt32(this.offset()-Y+tt.SIZEOF_INT)},tt.Builder.prototype.startObject=function(Y){this.notNested(),this.vtable==null&&(this.vtable=[]),this.vtable_in_use=Y;for(var nt=0;nt<Y;nt++)this.vtable[nt]=0;this.isNested=!0,this.object_start=this.offset()},tt.Builder.prototype.endObject=function(){if(this.vtable==null||!this.isNested)throw new Error("FlatBuffers: endObject called without startObject");this.addInt32(0);for(var Y=this.offset(),nt=this.vtable_in_use-1;nt>=0&&this.vtable[nt]==0;nt--);for(var K=nt+1;nt>=0;nt--)this.addInt16(this.vtable[nt]!=0?Y-this.vtable[nt]:0);this.addInt16(Y-this.object_start);var X=(K+2)*tt.SIZEOF_SHORT;this.addInt16(X);var Q=0,q=this.space;t:for(nt=0;nt<this.vtables.length;nt++){var G=this.bb.capacity()-this.vtables[nt];if(X==this.bb.readInt16(G)){for(var O=tt.SIZEOF_SHORT;O<X;O+=tt.SIZEOF_SHORT)if(this.bb.readInt16(q+O)!=this.bb.readInt16(G+O))continue t;Q=this.vtables[nt];break}}return Q?(this.space=this.bb.capacity()-Y,this.bb.writeInt32(this.space,Q-Y)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-Y,this.offset()-Y)),this.isNested=!1,Y},tt.Builder.prototype.finish=function(Y,nt,K){var X=K?tt.SIZE_PREFIX_LENGTH:0;if(nt){var Q=nt;if(this.prep(this.minalign,tt.SIZEOF_INT+tt.FILE_IDENTIFIER_LENGTH+X),Q.length!=tt.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+tt.FILE_IDENTIFIER_LENGTH);for(var q=tt.FILE_IDENTIFIER_LENGTH-1;q>=0;q--)this.writeInt8(Q.charCodeAt(q))}this.prep(this.minalign,tt.SIZEOF_INT+X),this.addOffset(Y),X&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)},tt.Builder.prototype.finishSizePrefixed=function(Y,nt){this.finish(Y,nt,!0)},tt.Builder.prototype.requiredField=function(Y,nt){var K=this.bb.capacity()-Y,X=K-this.bb.readInt32(K);if(this.bb.readInt16(X+nt)==0)throw new Error("FlatBuffers: field "+nt+" must be set")},tt.Builder.prototype.startVector=function(Y,nt,K){this.notNested(),this.vector_num_elems=nt,this.prep(tt.SIZEOF_INT,Y*nt),this.prep(K,Y*nt)},tt.Builder.prototype.endVector=function(){return this.writeInt32(this.vector_num_elems),this.offset()},tt.Builder.prototype.createString=function(Y){if(Y instanceof Uint8Array)var nt=Y;else{nt=[];for(var K=0;K<Y.length;){var X,Q=Y.charCodeAt(K++);(X=Q<55296||Q>=56320?Q:(Q<<10)+Y.charCodeAt(K++)+-56613888)<128?nt.push(X):(X<2048?nt.push(X>>6&31|192):(X<65536?nt.push(X>>12&15|224):nt.push(X>>18&7|240,X>>12&63|128),nt.push(X>>6&63|128)),nt.push(63&X|128))}}this.addInt8(0),this.startVector(1,nt.length,1),this.bb.setPosition(this.space-=nt.length),K=0;for(var q=this.space,G=this.bb.bytes();K<nt.length;K++)G[q++]=nt[K];return this.endVector()},tt.Builder.prototype.createLong=function(Y,nt){return tt.Long.create(Y,nt)},tt.ByteBuffer=function(Y){this.bytes_=Y,this.position_=0},tt.ByteBuffer.allocate=function(Y){return new tt.ByteBuffer(new Uint8Array(Y))},tt.ByteBuffer.prototype.clear=function(){this.position_=0},tt.ByteBuffer.prototype.bytes=function(){return this.bytes_},tt.ByteBuffer.prototype.position=function(){return this.position_},tt.ByteBuffer.prototype.setPosition=function(Y){this.position_=Y},tt.ByteBuffer.prototype.capacity=function(){return this.bytes_.length},tt.ByteBuffer.prototype.readInt8=function(Y){return this.readUint8(Y)<<24>>24},tt.ByteBuffer.prototype.readUint8=function(Y){return this.bytes_[Y]},tt.ByteBuffer.prototype.readInt16=function(Y){return this.readUint16(Y)<<16>>16},tt.ByteBuffer.prototype.readUint16=function(Y){return this.bytes_[Y]|this.bytes_[Y+1]<<8},tt.ByteBuffer.prototype.readInt32=function(Y){return this.bytes_[Y]|this.bytes_[Y+1]<<8|this.bytes_[Y+2]<<16|this.bytes_[Y+3]<<24},tt.ByteBuffer.prototype.readUint32=function(Y){return this.readInt32(Y)>>>0},tt.ByteBuffer.prototype.readInt64=function(Y){return new tt.Long(this.readInt32(Y),this.readInt32(Y+4))},tt.ByteBuffer.prototype.readUint64=function(Y){return new tt.Long(this.readUint32(Y),this.readUint32(Y+4))},tt.ByteBuffer.prototype.readFloat32=function(Y){return tt.int32[0]=this.readInt32(Y),tt.float32[0]},tt.ByteBuffer.prototype.readFloat64=function(Y){return tt.int32[tt.isLittleEndian?0:1]=this.readInt32(Y),tt.int32[tt.isLittleEndian?1:0]=this.readInt32(Y+4),tt.float64[0]},tt.ByteBuffer.prototype.writeInt8=function(Y,nt){this.bytes_[Y]=nt},tt.ByteBuffer.prototype.writeUint8=function(Y,nt){this.bytes_[Y]=nt},tt.ByteBuffer.prototype.writeInt16=function(Y,nt){this.bytes_[Y]=nt,this.bytes_[Y+1]=nt>>8},tt.ByteBuffer.prototype.writeUint16=function(Y,nt){this.bytes_[Y]=nt,this.bytes_[Y+1]=nt>>8},tt.ByteBuffer.prototype.writeInt32=function(Y,nt){this.bytes_[Y]=nt,this.bytes_[Y+1]=nt>>8,this.bytes_[Y+2]=nt>>16,this.bytes_[Y+3]=nt>>24},tt.ByteBuffer.prototype.writeUint32=function(Y,nt){this.bytes_[Y]=nt,this.bytes_[Y+1]=nt>>8,this.bytes_[Y+2]=nt>>16,this.bytes_[Y+3]=nt>>24},tt.ByteBuffer.prototype.writeInt64=function(Y,nt){this.writeInt32(Y,nt.low),this.writeInt32(Y+4,nt.high)},tt.ByteBuffer.prototype.writeUint64=function(Y,nt){this.writeUint32(Y,nt.low),this.writeUint32(Y+4,nt.high)},tt.ByteBuffer.prototype.writeFloat32=function(Y,nt){tt.float32[0]=nt,this.writeInt32(Y,tt.int32[0])},tt.ByteBuffer.prototype.writeFloat64=function(Y,nt){tt.float64[0]=nt,this.writeInt32(Y,tt.int32[tt.isLittleEndian?0:1]),this.writeInt32(Y+4,tt.int32[tt.isLittleEndian?1:0])},tt.ByteBuffer.prototype.getBufferIdentifier=function(){if(this.bytes_.length<this.position_+tt.SIZEOF_INT+tt.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");for(var Y="",nt=0;nt<tt.FILE_IDENTIFIER_LENGTH;nt++)Y+=String.fromCharCode(this.readInt8(this.position_+tt.SIZEOF_INT+nt));return Y},tt.ByteBuffer.prototype.__offset=function(Y,nt){var K=Y-this.readInt32(Y);return nt<this.readInt16(K)?this.readInt16(K+nt):0},tt.ByteBuffer.prototype.__union=function(Y,nt){return Y.bb_pos=nt+this.readInt32(nt),Y.bb=this,Y},tt.ByteBuffer.prototype.__string=function(Y,nt){Y+=this.readInt32(Y);var K=this.readInt32(Y),X="",Q=0;if(Y+=tt.SIZEOF_INT,nt===tt.Encoding.UTF8_BYTES)return this.bytes_.subarray(Y,Y+K);for(;Q<K;){var q,G=this.readUint8(Y+Q++);if(G<192)q=G;else{var O=this.readUint8(Y+Q++);if(G<224)q=(31&G)<<6|63&O;else{var b=this.readUint8(Y+Q++);q=G<240?(15&G)<<12|(63&O)<<6|63&b:(7&G)<<18|(63&O)<<12|(63&b)<<6|63&this.readUint8(Y+Q++)}}q<65536?X+=String.fromCharCode(q):(q-=65536,X+=String.fromCharCode(55296+(q>>10),56320+(1023&q)))}return X},tt.ByteBuffer.prototype.__indirect=function(Y){return Y+this.readInt32(Y)},tt.ByteBuffer.prototype.__vector=function(Y){return Y+this.readInt32(Y)+tt.SIZEOF_INT},tt.ByteBuffer.prototype.__vector_len=function(Y){return this.readInt32(Y+this.readInt32(Y))},tt.ByteBuffer.prototype.__has_identifier=function(Y){if(Y.length!=tt.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+tt.FILE_IDENTIFIER_LENGTH);for(var nt=0;nt<tt.FILE_IDENTIFIER_LENGTH;nt++)if(Y.charCodeAt(nt)!=this.readInt8(this.position_+tt.SIZEOF_INT+nt))return!1;return!0},tt.ByteBuffer.prototype.createLong=function(Y,nt){return tt.Long.create(Y,nt)}}},__webpack_module_cache__={};function __webpack_require__(dt){var U=__webpack_module_cache__[dt];if(U!==void 0)return U.exports;var rt=__webpack_module_cache__[dt]={exports:{}};return __webpack_modules__[dt].call(rt.exports,rt,rt.exports,__webpack_require__),rt.exports}__webpack_require__.n=dt=>{var U=dt&&dt.__esModule?()=>dt.default:()=>dt;return __webpack_require__.d(U,{a:U}),U},__webpack_require__.d=(dt,U)=>{for(var rt in U)__webpack_require__.o(U,rt)&&!__webpack_require__.o(dt,rt)&&Object.defineProperty(dt,rt,{enumerable:!0,get:U[rt]})},__webpack_require__.g=function(){if(typeof globalThis=="object")return globalThis;try{return this||new Function("return this")()}catch{if(typeof window=="object")return window}}(),__webpack_require__.o=(dt,U)=>Object.prototype.hasOwnProperty.call(dt,U),__webpack_require__.r=dt=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(dt,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(dt,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__(1057);return __webpack_exports__})())})(ort_min);var ort_minExports=ort_min.exports,__defProp$4=Object.defineProperty,__getOwnPropDesc$4=Object.getOwnPropertyDescriptor,__decorateClass$4=(dt,U,rt,tt)=>{for(var Y=tt>1?void 0:tt?__getOwnPropDesc$4(U,rt):U,nt=dt.length-1,K;nt>=0;nt--)(K=dt[nt])&&(Y=(tt?K(U,rt,Y):K(Y))||Y);return tt&&Y&&__defProp$4(U,rt,Y),Y};let OnnxModel=class extends s{constructor(){super(...arguments),this.isRunning=!1}firstUpdated(){const{width:dt}=document.body.getBoundingClientRect();dt<=390?this.scale=dt/this.width:this.scale=390/this.width,ort_minExports.env.wasm.wasmPaths="./"}render(){return x`
            ${this.renderInferenceTime()}
            <div class="media">
                <canvas
                    class=${this.isComputed?"":"hidden"}
                    style="width:${this.width}px; height:${this.height}px;transform: scale(${this.scale})"
                >
                </canvas>
                <slot
                    class=${this.isComputed?"hidden":""}
                    name="media"
                >
                </slot>
            </div>
            <wli-onnx-actions
                mode=${this.mode}
                ?disabled=${!this.isReady}
                @wli-onnx-actions-start=${this.handleStart}
                @wli-onnx-actions-stop=${this.handleStop}
                @wli-onnx-actions-back=${this.handleStop}
                @wli-onnx-actions-record=${this.handleRecord}
                @wli-onnx-actions-upload=${this.handleUpload}
            >
            </wli-onnx-actions>
            <input
                class="hidden"
                type="file"
                accept="image/*"
                @change=${this.imageUpdated}
            />
        `}renderInferenceTime(){return this.isRunning?x`
                <div class="inference">
                    <p>${this.inferenceTime} ms</p>
                </div>
            `:x``}connectedCallback(){super.connectedCallback(),this.addEventListener("wli-webcam-stream",this.handleStream)}disconnectedCallback(){super.disconnectedCallback(),this.removeEventListener("wli-webcam-stream",this.handleStream)}handleStream(dt){this.isComputed=!1,this.stream=dt.detail;const rt=this.stream.getVideoTracks()[0];this.imageCapture=new ImageCapture(rt),this.initInference()}handleStart(){this.isRunning=!0,this.preRunInference()}async preRunInference(){if(this.mode==="stream"&&this.isRunning){const dt=await this.imageCapture.grabFrame();await this.runInference(this.session,dt),setTimeout(()=>this.preRunInference(),20)}else if(this.mode==="image"){this.isComputed=!1;const dt=await createImageBitmap(this.imageElm);await this.runInference(this.session,dt)}this.isComputed=!0}handleStop(){this.isRunning=!1,this.isComputed=!1}handleRecord(){if(this.mode!=="stream"){this.cleanMediaSlot();const dt=document.createElement("wli-webcam");dt.setAttribute("slot","media"),this.append(dt)}this.mode="stream"}handleUpload(){this.mode="image",this.isComputed=!1,this.inputElm.click()}async imageUpdated(){var U,rt;const dt=(rt=(U=this.inputElm)==null?void 0:U.files)==null?void 0:rt[0];if(dt){this.cleanMediaSlot();const tt=document.createElement("img"),Y=URL.createObjectURL(dt);tt.src=Y,tt.setAttribute("slot","media"),this.imageElm=tt,this.append(tt),this.initInference()}}cleanMediaSlot(){this.querySelectorAll("[slot=media]").forEach(U=>U.remove())}async initInference(){if(this.mode==="stream"&&!this.stream){console.warn("[OnnxModel] Stream is undefined!");return}else if(this.mode==="image"&&!this.imageElm){console.warn("[OnnxModel] Image is undefined!");return}const U=await(await fetch(this.path)).arrayBuffer();this.session=await ort_minExports.InferenceSession.create(U,{executionProviders:["wasm"]}),this.isReady=!0}async runInference(dt,U){const rt=new Date;drawCanvas(this.canvasElm,U);const tt=this.canvasElm.getContext("2d"),Y=tt.getImageData(0,0,tt.canvas.width,tt.canvas.height),nt=preProcess(Y),X={images:new ort_minExports.Tensor(Float32Array.from(nt),[1,3,this.height,this.width])},Q=await dt.run(X);console.log("results",Q),this.clearRects();const q=await postProcess(Q.output0,this.height,this.width,this.classes);console.log("boxes",q),drawBoxes(this.canvasElm,q,this.options);const G=new Date;this.inferenceTime=G.getTime()-rt.getTime(),console.log("inferenceTime (ms)",this.inferenceTime)}clearRects(){}};OnnxModel.styles=i$3`
        :host {
            position: relative;
        }

        .inference {
            position: absolute;
            top: 0;
            right: 0;
            width: 90px;
            background: rgba(235, 98, 45, 0.3);
            z-index: 1;
        }

        .inference p {
            margin: 0;
            padding: 4px 8px;
            text-align: right;
            color: white;
        }

        ::slotted(img),
        ::slotted(wli-webcam) {
            max-width: 390px;
            max-height: 100%;
        }

        .rect {
            position: absolute;
            border: solid 1px red;
        }

        .media {
            height: calc(100dvh - 146px);
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #020d29;
            background-image:
                radial-gradient(white, rgba(255,255,255,.2) 2px, transparent 40px),
                radial-gradient(white, rgba(255,255,255,.15) 1px, transparent 30px),
                radial-gradient(white, rgba(255,255,255,.1) 2px, transparent 40px),
                radial-gradient(rgba(255,255,255,.4), rgba(255,255,255,.1) 2px, transparent 30px);
            background-size: 550px 550px, 350px 350px, 250px 250px, 150px 150px;
            background-position: 0 0, 40px 60px, 130px 270px, 70px 100px;
        }

        .hidden {
            display: none;
        }
    `;__decorateClass$4([n$1({type:String,attribute:!0})],OnnxModel.prototype,"name",2);__decorateClass$4([n$1({type:String,attribute:!0})],OnnxModel.prototype,"path",2);__decorateClass$4([n$1({type:Array})],OnnxModel.prototype,"classes",2);__decorateClass$4([n$1({type:Number,attribute:!0})],OnnxModel.prototype,"width",2);__decorateClass$4([n$1({type:Number,attribute:!0})],OnnxModel.prototype,"height",2);__decorateClass$4([n$1({type:Object})],OnnxModel.prototype,"options",2);__decorateClass$4([i("canvas")],OnnxModel.prototype,"canvasElm",2);__decorateClass$4([i("input")],OnnxModel.prototype,"inputElm",2);__decorateClass$4([i(".wrapper")],OnnxModel.prototype,"wrapperElm",2);__decorateClass$4([t()],OnnxModel.prototype,"inferenceTime",2);__decorateClass$4([t()],OnnxModel.prototype,"mode",2);__decorateClass$4([t()],OnnxModel.prototype,"isReady",2);__decorateClass$4([t()],OnnxModel.prototype,"isComputed",2);OnnxModel=__decorateClass$4([e$1("wli-onnx-model")],OnnxModel);var __defProp$3=Object.defineProperty,__getOwnPropDesc$3=Object.getOwnPropertyDescriptor,__decorateClass$3=(dt,U,rt,tt)=>{for(var Y=tt>1?void 0:tt?__getOwnPropDesc$3(U,rt):U,nt=dt.length-1,K;nt>=0;nt--)(K=dt[nt])&&(Y=(tt?K(U,rt,Y):K(Y))||Y);return tt&&Y&&__defProp$3(U,rt,Y),Y};let Route=class extends s{constructor(){super(...arguments),this.active=!1}render(){return x`
            <slot></slot>
        `}};Route.styles=i$3`
        :host {
        }
    `;__decorateClass$3([n$1()],Route.prototype,"path",2);__decorateClass$3([n$1()],Route.prototype,"propss",2);__decorateClass$3([n$1({type:Boolean,attribute:!0})],Route.prototype,"active",2);Route=__decorateClass$3([e$1("wli-route")],Route);var __defProp$2=Object.defineProperty,__getOwnPropDesc$2=Object.getOwnPropertyDescriptor,__decorateClass$2=(dt,U,rt,tt)=>{for(var Y=tt>1?void 0:tt?__getOwnPropDesc$2(U,rt):U,nt=dt.length-1,K;nt>=0;nt--)(K=dt[nt])&&(Y=(tt?K(U,rt,Y):K(Y))||Y);return tt&&Y&&__defProp$2(U,rt,Y),Y};let Router=class extends s{render(){return x`
            <slot></slot>
        `}willUpdate(){const dt=this.querySelector(`:scope > wli-route[path="${this.path}"]`),U=this.querySelector(":scope > wli-route[active]");if(U&&(U.removeAttribute("active"),U.innerHTML=""),dt){const rt=dt.getAttribute("component"),tt=dt.props;if(rt){const Y=document.createElement(rt);dt.setAttribute("active","");for(const nt in tt)Y[nt]=tt[nt];dt.append(Y)}}}};Router.styles=i$3`
        :host {
        }
    `;__decorateClass$2([n$1()],Router.prototype,"path",2);Router=__decorateClass$2([e$1("wli-router")],Router);var __defProp$1=Object.defineProperty,__getOwnPropDesc$1=Object.getOwnPropertyDescriptor,__decorateClass$1=(dt,U,rt,tt)=>{for(var Y=tt>1?void 0:tt?__getOwnPropDesc$1(U,rt):U,nt=dt.length-1,K;nt>=0;nt--)(K=dt[nt])&&(Y=(tt?K(U,rt,Y):K(Y))||Y);return tt&&Y&&__defProp$1(U,rt,Y),Y};let Webcam=class extends s{render(){return x`
            <video autoplay laysinline muted></video>
            <slot />
        `}async firstUpdated(){const dt={audio:!1,video:{facingMode:"environment"}};try{this.stream=await navigator.mediaDevices.getUserMedia(dt),this.videoElm.srcObject=this.stream;const U=new CustomEvent("wli-webcam-stream",{detail:this.stream,bubbles:!0});this.dispatchEvent(U)}catch(U){console.warn(U),alert("Error - Cannot access webcam")}}disconnectedCallback(){this.stream.getTracks().forEach(U=>U.stop())}};Webcam.styles=i$3`
        :host {
            display: block;
        }

        video {
            width: 100%;
        }
    `;__decorateClass$1([i("video")],Webcam.prototype,"videoElm",2);__decorateClass$1([t()],Webcam.prototype,"stream",2);Webcam=__decorateClass$1([e$1("wli-webcam")],Webcam);var __defProp=Object.defineProperty,__getOwnPropDesc=Object.getOwnPropertyDescriptor,__decorateClass=(dt,U,rt,tt)=>{for(var Y=tt>1?void 0:tt?__getOwnPropDesc(U,rt):U,nt=dt.length-1,K;nt>=0;nt--)(K=dt[nt])&&(Y=(tt?K(U,rt,Y):K(Y))||Y);return tt&&Y&&__defProp(U,rt,Y),Y};let App=class extends s{constructor(){super(...arguments),this.path="/login"}handleLogin(){this.path="/home"}handleRun(dt){this.path="/capture",this.model=dt.detail}handleBackHome(){this.path="/home"}render(){return x`
            <wli-main-layout>
                <wli-header></wli-header>
                <wli-router path="${this.path}">
                    <wli-route
                        path="/"
                        redirect=${()=>"/login"}
                    >
                    </wli-route>
                    <wli-route
                        path="/login"
                        component="wli-login"
                        @wli-login=${this.handleLogin}
                    >
                    </wli-route>
                    <wli-route
                        path="/home"
                        component="wli-home"
                        @wli-home-run=${this.handleRun}
                    >
                    </wli-route>
                    <wli-route
                        path="/capture"
                        component="wli-capture"
                        .props=${this.model}
                        @wli-onnx-actions-back=${this.handleBackHome}
                    >
                    </wli-route>
                </wli-router>
            </wli-main-layout>
        `}};App.styles=i$3`
        :host {
        }
    `;__decorateClass([t()],App.prototype,"path",2);__decorateClass([t()],App.prototype,"model",2);App=__decorateClass([e$1("wli-app")],App);
